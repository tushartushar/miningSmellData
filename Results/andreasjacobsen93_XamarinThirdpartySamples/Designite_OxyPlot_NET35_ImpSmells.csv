Implementation smell,Namespace,Class,File,Method,Description
Long Method,OxyPlot,CohenSutherlandClipping,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CohenSutherlandClipping.cs,ClipLine,The method has 133 lines of code.
Long Method,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method has 3357 lines of code.
Long Method,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The method has 232 lines of code.
Long Method,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The method has 105 lines of code.
Long Method,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The method has 105 lines of code.
Long Method,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderOrMeasureLegends,The method has 118 lines of code.
Long Method,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The method has 100 lines of code.
Long Method,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The method has 131 lines of code.
Complex Method,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,Cyclomatic complexity of the method is 23
Complex Method,OxyPlot.Annotations,LineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\LineAnnotation.cs,GetScreenPoints,Cyclomatic complexity of the method is 17
Complex Method,OxyPlot.Annotations,FunctionAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\FunctionAnnotation.cs,GetScreenPoints,Cyclomatic complexity of the method is 12
Complex Method,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,Render,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,GetPoint,Cyclomatic complexity of the method is 18
Complex Method,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,GetVector,Cyclomatic complexity of the method is 23
Complex Method,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,Cyclomatic complexity of the method is 16
Complex Method,OxyPlot,CodeGenerator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,AddArray,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,CodeGenerator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,SetProperties,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot,CodeGeneratorStringExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGeneratorStringExtensions.cs,ToCode,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,Cyclomatic complexity of the method is 11
Complex Method,OxyPlot,Decimator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\Decimator.cs,AddVerticalPoints,Cyclomatic complexity of the method is 11
Complex Method,OxyPlot,SutherlandHodgmanClipping,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\SutherlandHodgmanClipping.cs,LineIntercept,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot,CohenSutherlandClipping,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CohenSutherlandClipping.cs,ClipLine,Cyclomatic complexity of the method is 25
Complex Method,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,Cyclomatic complexity of the method is 32
Complex Method,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,Cyclomatic complexity of the method is 11
Complex Method,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,Cyclomatic complexity of the method is 14
Complex Method,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,Cyclomatic complexity of the method is 15
Complex Method,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedLine,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMarkers,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,Cyclomatic complexity of the method is 15
Complex Method,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,ClipRect,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,PdfWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfWriter.cs,WriteCore,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,GetFont,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot,ListFiller,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ListFiller.cs,Fill,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,Cyclomatic complexity of the method is 66
Complex Method,OxyPlot,OxyImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\OxyImage.cs,GetEncoder,Cyclomatic complexity of the method is 14
Complex Method,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,Cyclomatic complexity of the method is 20
Complex Method,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,Cyclomatic complexity of the method is 12
Complex Method,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,Cyclomatic complexity of the method is 12
Complex Method,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteText,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,EnsureLegendProperties,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,Cyclomatic complexity of the method is 86
Complex Method,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,Cyclomatic complexity of the method is 15
Complex Method,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderOrMeasureLegends,Cyclomatic complexity of the method is 17
Complex Method,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,GetNearestPoint,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,Render,Cyclomatic complexity of the method is 12
Complex Method,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,InternalUpdateMaxMinValue,Cyclomatic complexity of the method is 23
Complex Method,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,UpdateItemsSourcePoints,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,ErrorColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,UpdateMaxMin,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,InternalUpdateMaxMin,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,Cyclomatic complexity of the method is 16
Complex Method,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,Cyclomatic complexity of the method is 16
Complex Method,OxyPlot.Series,DataPointSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\DataPointSeries.cs,UpdateItemsSourcePoints,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,GetNearestPoint,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,XYAxisSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\XYAxisSeries.cs,InternalUpdateMaxMin,Cyclomatic complexity of the method is 21
Complex Method,OxyPlot.Series,XYAxisSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\XYAxisSeries.cs,InternalUpdateMaxMin,Cyclomatic complexity of the method is 17
Complex Method,OxyPlot.Series,XYAxisSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\XYAxisSeries.cs,InternalUpdateMaxMin,Cyclomatic complexity of the method is 17
Complex Method,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,Render,Cyclomatic complexity of the method is 26
Complex Method,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,Cyclomatic complexity of the method is 17
Complex Method,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,Render,Cyclomatic complexity of the method is 19
Complex Method,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,Cyclomatic complexity of the method is 25
Complex Method,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,Cyclomatic complexity of the method is 42
Complex Method,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,Cyclomatic complexity of the method is 30
Complex Method,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CreateDateTickValues,Cyclomatic complexity of the method is 23
Complex Method,OxyPlot.Axes,AxisRendererBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AxisRendererBase.cs,GetTickPositions,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,Render,Cyclomatic complexity of the method is 21
Complex Method,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetAxisTitlePositionAndAlignment,Cyclomatic complexity of the method is 14
Complex Method,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,Cyclomatic complexity of the method is 37
Complex Method,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderMinorItems,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot.Reporting,HtmlReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\HtmlReportWriter.cs,WriteRows,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,Cyclomatic complexity of the method is 9
Long Parameter List,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The method has 6 parameters.
Long Parameter List,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,ImageAnnotation,The method has 5 parameters.
Long Parameter List,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,GetPointAtRelativeDistance,The method has 5 parameters.
Long Parameter List,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The method has 5 parameters.
Long Parameter List,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The method has 5 parameters.
Long Parameter List,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The method has 87 parameters.
Long Parameter List,OxyPlot,ControllerExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Graphics\ControllerExtensions.cs,BindMouseDown,The method has 5 parameters.
Long Parameter List,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The method has 6 parameters.
Long Parameter List,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The method has 5 parameters.
Long Parameter List,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,Segment,The method has 8 parameters.
Long Parameter List,OxyPlot,Decimator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\Decimator.cs,AddVerticalPoints,The method has 6 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The method has 12 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The method has 11 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,MeasureMathText,The method has 5 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The method has 14 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawLineSegments,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawPolygons,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawImage,The method has 11 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedLine,The method has 11 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedLineSegments,The method has 8 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawImage,The method has 8 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedImage,The method has 9 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedPolygon,The method has 10 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedRectangle,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedRectangleAsPolygon,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedEllipse,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedText,The method has 12 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedMathText,The method has 12 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMultilineText,The method has 8 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawLine,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMarker,The method has 9 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMarkers,The method has 11 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMarkers,The method has 11 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawRectangleAsPolygon,The method has 5 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawRectangleAsPolygon,The method has 5 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The method has 9 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\IRenderContext.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\IRenderContext.cs,DrawLineSegments,The method has 6 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\IRenderContext.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\IRenderContext.cs,DrawPolygons,The method has 7 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\IRenderContext.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\IRenderContext.cs,DrawImage,The method has 11 parameters.
Long Parameter List,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,DrawImage,The method has 11 parameters.
Long Parameter List,OxyPlot,PortableDocumentImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentImage.cs,PortableDocumentImage,The method has 7 parameters.
Long Parameter List,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawImage,The method has 11 parameters.
Long Parameter List,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AppendCubicBezier,The method has 6 parameters.
Long Parameter List,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Transform,The method has 6 parameters.
Long Parameter List,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,DrawRectangle,The method has 5 parameters.
Long Parameter List,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,SetClippingRectangle,The method has 5 parameters.
Long Parameter List,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,DrawEllipse,The method has 5 parameters.
Long Parameter List,OxyPlot,StringHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\StringHelper.cs,Format,The method has 5 parameters.
Long Parameter List,OxyPlot,FractionHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\FractionHelper.cs,ConvertToFractionString,The method has 6 parameters.
Long Parameter List,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The method has 9 parameters.
Long Parameter List,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapInfoHeader,The method has 8 parameters.
Long Parameter List,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapV4Header,The method has 7 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,SvgRenderContext,The method has 6 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawImage,The method has 11 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The method has 5 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The method has 5 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteImage,The method has 9 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteImage,The method has 5 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteRectangle,The method has 5 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteText,The method has 9 parameters.
Long Parameter List,OxyPlot,SvgExporter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgExporter.cs,Export,The method has 6 parameters.
Long Parameter List,OxyPlot,SvgExporter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgExporter.cs,ExportToString,The method has 5 parameters.
Long Parameter List,OxyPlot,TrackerHitResult,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerHitResult.cs,TrackerHitResult,The method has 6 parameters.
Long Parameter List,OxyPlot.Series,ScatterErrorPoint,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorPoint.cs,ScatterErrorPoint,The method has 7 parameters.
Long Parameter List,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,DefineDataFields,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,AddScatterPoints,The method has 17 parameters.
Long Parameter List,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,DefineDataFields,The method has 11 parameters.
Long Parameter List,OxyPlot.Series,ErrorColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,UpdateMaxMin,The method has 6 parameters.
Long Parameter List,OxyPlot.Series,ErrorColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,RenderItem,The method has 7 parameters.
Long Parameter List,OxyPlot.Series,BoxPlotItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotItem.cs,BoxPlotItem,The method has 8 parameters.
Long Parameter List,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,HighLowItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HighLowItem.cs,HighLowItem,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,HighLowSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HighLowSeries.cs,GetNearestPoint,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,HighLowSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HighLowSeries.cs,UpdateData,The method has 10 parameters.
Long Parameter List,OxyPlot.Series,ScatterPoint,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterPoint.cs,ScatterPoint,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,XYAxisSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\XYAxisSeries.cs,InternalUpdateMaxMin,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,UpdateData,The method has 8 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 6 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 6 parameters.
Long Parameter List,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,UpdateMaxMin,The method has 8 parameters.
Long Parameter List,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,Render,The method has 7 parameters.
Long Parameter List,OxyPlot.Axes,AngleAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\AngleAxis.cs,AngleAxis,The method has 5 parameters.
Long Parameter List,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The method has 12 parameters.
Long Parameter List,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,Render,The method has 7 parameters.
Long Parameter List,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The method has 7 parameters.
Long Parameter List,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,DateTimeAxis,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,LinearAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearAxis.cs,LinearAxis,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,MagnitudeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\MagnitudeAxis.cs,MagnitudeAxis,The method has 5 parameters.
Long Parameter List,OxyPlot.Axes,TimeSpanAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\TimeSpanAxis.cs,TimeSpanAxis,The method has 5 parameters.
Long Parameter List,OxyPlot.Axes,AxisRendererBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AxisRendererBase.cs,GetTickPositions,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetAxisTitlePositionAndAlignment,The method has 5 parameters.
Long Parameter List,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The method has 5 parameters.
Long Identifier,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,UpdateItemsSourcePoints,The length of the parameter sourceAsEnumerableScatterPoints is 31.
Long Identifier,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,ExtractNextContiguousLineSegment,The length of the parameter previousContiguousLineSegmentEndPoint is 37.
Long Statement,OxyPlot.Annotations,PointAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PointAnnotation.cs,Render,The length of the statement  "	rc.DrawMarker (clippingRectangle' this.screenPosition' this.Shape' null' this.Size' this.Fill' this.Stroke' this.StrokeThickness); " is 130.
Long Statement,OxyPlot.Annotations,PointAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PointAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 224.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double x0 = double.IsNaN (this.MinimumX) || this.MinimumX.Equals (double.MinValue) ? this.XAxis.ActualMinimum : this.MinimumX; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double x1 = double.IsNaN (this.MaximumX) || this.MaximumX.Equals (double.MaxValue) ? this.XAxis.ActualMaximum : this.MaximumX; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double y0 = double.IsNaN (this.MinimumY) || this.MinimumY.Equals (double.MinValue) ? this.YAxis.ActualMinimum : this.MinimumY; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double y1 = double.IsNaN (this.MaximumY) || this.MaximumY.Equals (double.MaxValue) ? this.YAxis.ActualMaximum : this.MaximumY; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedRectangle (clippingRectangle' this.screenRectangle' this.GetSelectableFillColor (this.Fill)' this.GetSelectableColor (this.Stroke)' this.StrokeThickness); " is 168.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 220.
Long Statement,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,Render,The length of the statement  "	this.actualBounds = GetTextBounds (position' textSize' this.Padding' this.TextRotation' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 146.
Long Statement,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,Render,The length of the statement  "	rc.DrawMathText (position' this.Text' this.GetSelectableFillColor (this.ActualTextColor)' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 228.
Long Statement,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,HitTestOverride,The length of the statement  "	return ScreenPointHelper.IsPointInPolygon (args.Point' this.actualBounds) ? new HitTestResult (this' args.Point) : null; " is 120.
Long Statement,OxyPlot.Annotations,PolygonAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PolygonAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedPolygon (clippingRectangle' this.screenPoints' MinimumSegmentLength * MinimumSegmentLength' this.GetSelectableFillColor (this.Fill)' this.GetSelectableColor (this.Stroke)' this.StrokeThickness' this.LineStyle' this.LineJoin); " is 239.
Long Statement,OxyPlot.Annotations,PolygonAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PolygonAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 224.
Long Statement,OxyPlot.Annotations,PolygonAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PolygonAnnotation.cs,HitTestOverride,The length of the statement  "	return ScreenPointHelper.IsPointInPolygon (args.Point' this.screenPoints) ? new HitTestResult (this' args.Point) : null; " is 120.
Long Statement,OxyPlot.Annotations,ArrowAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ArrowAnnotation.cs,Render,The length of the statement  "	}' MinimumSegmentLength * MinimumSegmentLength' this.GetSelectableColor (this.Color)' this.StrokeThickness' dashArray' this.LineJoin' false); " is 141.
Long Statement,OxyPlot.Annotations,ArrowAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ArrowAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clippingRectangle' textPoint' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' ha' va); " is 171.
Long Statement,OxyPlot.Annotations,EllipseAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The length of the statement  "	this.screenRectangle = new OxyRect (this.Transform (this.X - (this.Width / 2)' this.Y - (this.Height / 2))' this.Transform (this.X + (this.Width / 2)' this.Y + (this.Height / 2))); " is 180.
Long Statement,OxyPlot.Annotations,EllipseAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedEllipse (clippingRectangle' this.screenRectangle' this.GetSelectableFillColor (this.Fill)' this.GetSelectableColor (this.Stroke)' this.StrokeThickness); " is 166.
Long Statement,OxyPlot.Annotations,EllipseAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 224.
Long Statement,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The length of the statement  "	var clippingRectangle = OxyRect.Create (this.ClipByXAxis ? this.XAxis.ScreenMin.X : PlotModel.PlotArea.Left' this.ClipByYAxis ? this.YAxis.ScreenMin.Y : PlotModel.PlotArea.Top' this.ClipByXAxis ? this.XAxis.ScreenMax.X : PlotModel.PlotArea.Right' this.ClipByYAxis ? this.YAxis.ScreenMax.Y : PlotModel.PlotArea.Bottom); " is 318.
Long Statement,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedLine (clippingRectangle' this.screenPoints' MinimumSegmentLength * MinimumSegmentLength' this.GetSelectableColor (this.Color)' this.StrokeThickness' dashArray' this.LineJoin' this.aliased' null' clippedPoints.AddRange); " is 233.
Long Statement,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The length of the statement  "		position += new ScreenVector (f * this.TextPadding * Math.Cos (angleInRadians)' f * this.TextPadding * Math.Sin (angleInRadians)); " is 130.
Long Statement,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The length of the statement  "					rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 212.
Long Statement,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The length of the statement  "				rc.DrawText (textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 186.
Long Statement,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The length of the statement  "	rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColor.FromAColor (200' OxyColors.White)' OxyColors.Undefined); " is 191.
Long Statement,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The length of the statement  "	rc.DrawText (p' this.CopyrightNotice' OxyColors.Black' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Bottom); " is 172.
Long Statement,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hot,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White); " is 177.
Long Statement,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hue,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.Red' OxyColors.Yellow' OxyColors.Green' OxyColors.Cyan' OxyColors.Blue' OxyColors.Magenta' OxyColors.Red); " is 163.
Long Statement,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,HueDistinct,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.Magenta' OxyColors.Blue' OxyColors.Cyan' OxyColors.Green' OxyColors.Yellow' OxyColors.Red); " is 148.
Long Statement,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Jet,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.DarkBlue' OxyColors.Cyan' OxyColors.Yellow' OxyColors.Orange' OxyColors.DarkRed); " is 138.
Long Statement,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Rainbow,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.Violet' OxyColors.Indigo' OxyColors.Blue' OxyColors.Green' OxyColors.Yellow' OxyColors.Orange' OxyColors.Red); " is 167.
Long Statement,OxyPlot,ScreenPointHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\ScreenPointHelper.cs,IsPointInPolygon,The length of the statement  "		if (((pts [i].Y > p.Y) != (pts [j].Y > p.Y)) && (p.X < ((pts [j].X - pts [i].X) * ((p.Y - pts [i].Y) / (pts [j].Y - pts [i].Y))) + pts [i].X)) { " is 144.
Long Statement,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The length of the statement  "				Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance); " is 120.
Long Statement,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,Segment,The length of the statement  "		var pt = new ScreenPoint ((ax * t * t * t) + (bx * t * t) + (cx * t) + dx' (ay * t * t * t) + (by * t * t) + (cy * t) + dy); " is 124.
Long Statement,OxyPlot,OxyThickness,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyThickness.cs,ToCode,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "new OxyThickness({0}'{1}'{2}'{3})"' this.Left' this.Top' this.Right' this.Bottom); " is 135.
Long Statement,OxyPlot,OxyThickness,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyThickness.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3})"' this.left' this.top' this.right' this.bottom); " is 122.
Long Statement,OxyPlot,OxyRect,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyRect.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3})"' this.left' this.top' this.width' this.height); " is 122.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedLine,The length of the statement  "			if (sc0.X != points [lastPointIndex].X || sc0.Y != points [lastPointIndex].Y || outputBuffer.Count == 0)// ReSharper restore disable CompareOfFloatsByEqualityOperator " is 166.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedImage,The length of the statement  "	if (x > clippingRectangle.Right || x + w < clippingRectangle.Left || y > clippingRectangle.Bottom || y + h < clippingRectangle.Top) { " is 133.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedMathText,The length of the statement  "		rc.DrawMathText (p' text' fill' fontFamily' fontSize' fontWeight' rotate' horizontalAlignment' verticalAlignment' maxSize); " is 123.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedMathText,The length of the statement  "		rc.DrawMathText (p' text' fill' fontFamily' fontSize' fontWeight' rotate' horizontalAlignment' verticalAlignment' maxSize); " is 123.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMultilineText,The length of the statement  "		rc.DrawText (new ScreenPoint (point.X' point.Y + (i * dy))' lines [i]' color' fontWeight: fontWeight' fontSize: fontSize); " is 122.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawRectangleAsPolygon,The length of the statement  "	if (thickness.Left.Equals (thickness.Right) && thickness.Left.Equals (thickness.Top) && thickness.Left.Equals (thickness.Bottom)) { " is 131.
Long Statement,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,DrawText,The length of the statement  "	this.rc.DrawText (p' text' fill' this.GetFontFamily (fontFamily)' fontSize' fontWeight' rotate' halign' valign' maxSize); " is 121.
Long Statement,OxyPlot,OxyMouseDownGesture,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Input\Gestures\OxyMouseDownGesture.cs,Equals,The length of the statement  "	return mg != null && mg.Modifiers == this.Modifiers && mg.MouseButton == this.MouseButton && mg.ClickCount == this.ClickCount; " is 126.
Long Statement,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,DrawText,The length of the statement  "	// Move to the start of the next line' offset from the start of the current line by (tx ' ty ). tx and ty are numbers expressed in unscaled text space units. " is 157.
Long Statement,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The length of the statement  "	if (signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A) { " is 203.
Long Statement,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The length of the statement  "			p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height); " is 125.
Long Statement,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The length of the statement  "			p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height); " is 126.
Long Statement,OxyPlot,TrackerHitResult,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerHitResult.cs,ToString,The length of the statement  "	return StringHelper.Format (this.PlotModel.ActualCulture' formatString' this.Item' this.Series.Title' xaxisTitle' xvalue' yaxisTitle' yvalue' this.Item).Trim (); " is 161.
Long Statement,OxyPlot,TrackerManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerManipulator.cs,Delta,The length of the statement  "		this.currentSeries = this.PlotView.ActualModel != null ? this.PlotView.ActualModel.GetSeriesFromPoint (e.Position' 20) : null; " is 126.
Long Statement,OxyPlot,TrackerManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerManipulator.cs,Started,The length of the statement  "	this.currentSeries = this.PlotView.ActualModel != null ? this.PlotView.ActualModel.GetSeriesFromPoint (e.Position) : null; " is 122.
Long Statement,OxyPlot,ControllerBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Graphics\ControllerBase.cs,Unbind,The length of the statement  "	foreach (var icb in this.InputCommandBindings.Where (icb => object.ReferenceEquals (icb.Command' command)).ToArray ()) { " is 120.
Long Statement,OxyPlot,Selection,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Graphics\Selection.cs,Unselect,The length of the statement  "		throw new InvalidOperationException ("Item " + index + " and feature " + feature + " is not selected. Cannot unselect."); " is 121.
Long Statement,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The length of the statement  "	var textSize = rc.DrawMathText (new ScreenPoint (x' y)' s.Title' this.LegendTextColor.GetActualColor (this.TextColor)' this.LegendFont ?? this.DefaultFont' this.LegendFontSize' this.LegendFontWeight' 0' this.LegendItemAlignment' VerticalAlignment.Top' maxsize' true); " is 267.
Long Statement,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The length of the statement  "	var symbolRect = new OxyRect (this.LegendSymbolPlacement == LegendSymbolPlacement.Right ? x0 + textSize.Width + this.LegendSymbolMargin : x0 - this.LegendSymbolMargin - this.LegendSymbolLength' rect.Top' this.LegendSymbolLength' textSize.Height); " is 246.
Long Statement,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderOrMeasureLegends,The length of the statement  "			titleSize = rc.MeasureMathText (this.LegendTitle' this.LegendTitleFont ?? this.DefaultFont' this.LegendTitleFontSize' this.LegendTitleFontWeight); " is 146.
Long Statement,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderOrMeasureLegends,The length of the statement  "			titleSize = rc.DrawMathText (new ScreenPoint (rect.Left + x' rect.Top + top)' this.LegendTitle' this.LegendTitleColor.GetActualColor (this.TextColor)' this.LegendTitleFont ?? this.DefaultFont' this.LegendTitleFontSize' this.LegendTitleFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Top' null' true); " is 311.
Long Statement,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderOrMeasureLegends,The length of the statement  "		var textSize = rc.MeasureMathText (s.Title' this.LegendFont ?? this.DefaultFont' this.LegendFontSize' this.LegendFontWeight); " is 125.
Long Statement,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The length of the statement  "	rc.DrawClippedLineSegments (clippingRectangle' segments' this.GetSelectableColor (this.ErrorBarColor)' this.ErrorBarStrokeThickness' null' OxyPenLineJoin.Bevel' true); " is 167.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,GetNearestPoint,The length of the statement  "		if (p.X < this.XAxis.ActualMinimum || p.X > this.XAxis.ActualMaximum || p.Y < this.YAxis.ActualMinimum || p.Y > this.YAxis.ActualMaximum) { " is 139.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,GetNearestPoint,The length of the statement  "			var text = this.Format (formatString' item' this.Title' xaxisTitle' xvalue' yaxisTitle' yvalue' colorAxisTitle' zvalue); " is 120.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,Render,The length of the statement  "		var markerIsStrokedOnly = this.MarkerType == MarkerType.Plus || this.MarkerType == MarkerType.Star || this.MarkerType == MarkerType.Cross; " is 138.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,Render,The length of the statement  "			rc.DrawMarkers (clippingRect' group.Value' this.MarkerType' this.MarkerOutline' groupSizes [group.Key]' color' markerIsStrokedOnly ? color : this.MarkerStroke' this.MarkerStrokeThickness' this.BinSize' binOffset); " is 213.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,Render,The length of the statement  "	rc.DrawMarkers (clippingRect' allPoints' this.MarkerType' this.MarkerOutline' allMarkerSizes' this.ActualMarkerFillColor' this.MarkerStroke' this.MarkerStrokeThickness' this.BinSize' binOffset); " is 194.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,Render,The length of the statement  "	rc.DrawMarkers (clippingRect' selectedPoints' this.MarkerType' this.MarkerOutline' selectedMarkerSizes' this.PlotModel.SelectionColor' this.PlotModel.SelectionColor' this.MarkerStrokeThickness' this.BinSize' binOffset); " is 219.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,RenderLegend,The length of the statement  "	rc.DrawMarker (legendBox' midpt' this.MarkerType' this.MarkerOutline' this.MarkerSize' this.IsSelected () ? this.PlotModel.SelectionColor : this.ActualMarkerFillColor' this.IsSelected () ? this.PlotModel.SelectionColor : this.MarkerStroke' this.MarkerStrokeThickness); " is 268.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,EnsureAxes,The length of the statement  "	this.ColorAxis = this.PlotModel.GetAxisOrDefault (this.ColorAxisKey' (Axis)this.PlotModel.DefaultColorAxis) as IColorAxis; " is 122.
Long Statement,OxyPlot.Series,BarItemBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarItemBase.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}"' this.Value' this.CategoryIndex' this.Color.ToCode ()); " is 126.
Long Statement,OxyPlot.Series,ErrorColumnItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ErrorColumnItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}"' this.Value' this.Error' this.CategoryIndex' this.Color.ToCode ()); " is 142.
Long Statement,OxyPlot.Series,BoxPlotItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotItem.cs,ToString,The length of the statement  "	return string.Format ("{0} {1} {2} {3} {4} {5} "' this.X' this.LowerWhisker' this.BoxBottom' this.Median' this.BoxTop' this.UpperWhisker); " is 138.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,The length of the statement  "				result.Text = this.Format (this.OutlierTrackerFormatString' item' this.Title' this.XAxis.GetValue (result.DataPoint.X)' outlier); " is 129.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,The length of the statement  "			result.Text = this.Format (this.TrackerFormatString' item' this.Title' this.XAxis.GetValue (result.DataPoint.X)' item.UpperWhisker' item.BoxTop' item.Median' item.BoxBottom' item.LowerWhisker); " is 193.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,The length of the statement  "			result.Text = this.Format (this.TrackerFormatString' item' this.Title' this.XAxis.GetValue (result.DataPoint.X)' item.UpperWhisker' item.BoxTop' item.Median' item.BoxBottom' item.LowerWhisker); " is 193.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,IsValidPoint,The length of the statement  "	return !double.IsNaN (item.X) && !double.IsInfinity (item.X) && !item.Values.Any (double.IsNaN) && !item.Values.Any (double.IsInfinity) && (xaxis != null && xaxis.IsValidValue (item.X)) && (yaxis != null && item.Values.All (yaxis.IsValidValue)); " is 245.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The length of the statement  "				var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2); " is 141.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The length of the statement  "	rc.DrawMarkers (clippingRect' outlierScreenPoints' this.OutlierType' null' markerSizes' fillColor' strokeColor' this.StrokeThickness); " is 134.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The length of the statement  "		rc.DrawRectangleAsPolygon (new OxyRect (xmid - halfBoxWidth' ytop' 2 * halfBoxWidth' ybottom - ytop)' fillColor' strokeColor' LegendStrokeThickness); " is 149.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The length of the statement  "		}' strokeColor' LegendStrokeThickness * this.MedianThickness' LineStyle.Solid.GetDashArray ()' OxyPenLineJoin.Miter' true); " is 123.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The length of the statement  "		var ellipseRect = new OxyRect (xmid - this.MedianPointSize' ymid - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2); " is 141.
Long Statement,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,EnsureAxes,The length of the statement  "	this.ColorAxis = this.PlotModel.GetAxisOrDefault (this.ColorAxisKey' (Axis)this.PlotModel.DefaultColorAxis) as IColorAxis; " is 122.
Long Statement,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The length of the statement  "			rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 140.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The length of the statement  "	rc.DrawClippedLine (clippingRect' pts0' minDistSquared' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' dashArray' this.LineJoin' false); " is 155.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The length of the statement  "	rc.DrawClippedLine (clippingRect' pts1' minDistSquared' this.GetSelectableColor (this.ActualColor2)' this.StrokeThickness' dashArray' this.LineJoin' false); " is 156.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The length of the statement  "	rc.DrawClippedPolygon (clippingRect' pts' minDistSquared' this.GetSelectableFillColor (this.ActualFill)' OxyColors.Undefined); " is 126.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The length of the statement  "	rc.DrawMarkers (clippingRect' pts0' this.MarkerType' null' markerSizes' this.MarkerFill' this.MarkerStroke' this.MarkerStrokeThickness' 1); " is 139.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The length of the statement  "	rc.DrawMarkers (clippingRect' pts1' this.MarkerType' null' markerSizes' this.MarkerFill' this.MarkerStroke' this.MarkerStrokeThickness' 1); " is 139.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,RenderLegend,The length of the statement  "	rc.DrawLine (pts0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle.GetDashArray ()); " is 123.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,RenderLegend,The length of the statement  "	rc.DrawLine (pts1' this.GetSelectableColor (this.ActualColor2)' this.StrokeThickness' this.ActualLineStyle.GetDashArray ()); " is 124.
Long Statement,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The length of the statement  "				var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill); " is 143.
Long Statement,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (this.CandleWidth * 0.5)' yclose' this.CandleWidth' yopen - yclose)' this.GetSelectableFillColor (this.ActualIncreasingFill)' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness); " is 239.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The length of the statement  "	Conrec.RendererDelegate renderer = (startX' startY' endX' endY' contourLevel) => this.segments.Add (new ContourSegment (new DataPoint (startX' startY)' new DataPoint (endX' endY)' contourLevel)); " is 195.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,GetNearestPoint,The length of the statement  "		var r = interpolate ? this.GetNearestInterpolatedPointInternal (c.Points' point) : this.GetNearestPointInternal (c.Points' point); " is 130.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,GetNearestPoint,The length of the statement  "				result.Text = this.Format (this.TrackerFormatString' null' this.Title' xaxisTitle' r.DataPoint.X' yaxisTitle' r.DataPoint.Y' zaxisTitle' c.ContourLevel); " is 153.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,The length of the statement  "			rc.DrawClippedLine (clippingRect' transformedPoints' 4' this.GetSelectableColor (strokeColor)' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' false); " is 157.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The length of the statement  "			segment2 = this.FindConnectedSegment (contourPoints [contourPointsCount - 1]' firstSegment.ContourLevel' eps' out reverse); " is 123.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,RenderLabel,The length of the statement  "		rc.DrawText (cl.Position' cl.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' cl.Angle' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 182.
Long Statement,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,GetCategoryAxis,The length of the statement  "		throw new Exception ("A ColumnSeries requires a CategoryAxis on the x-axis. Use a BarSeries if you want horizontal bars."); " is 123.
Long Statement,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The length of the statement  "	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' va); " is 159.
Long Statement,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,GetCategoryAxis,The length of the statement  "		throw new Exception ("A BarSeries requires a CategoryAxis on the y-axis. Use a ColumnSeries if you want vertical bars."); " is 121.
Long Statement,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The length of the statement  "	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' ha' VerticalAlignment.Middle); " is 157.
Long Statement,OxyPlot.Series,IntervalBarItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}"' this.Start' this.End' this.Title' this.Color.ToCode ()); " is 132.
Long Statement,OxyPlot.Series,RectangleBarItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}'{4}'{5}"' this.X0' this.Y0' this.X1' this.Y1' this.Title' this.Color.ToCode ()); " is 154.
Long Statement,OxyPlot.Series,RectangleBarItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}'{4}"' this.X0' this.Y0' this.X1' this.Y1' this.Title); " is 128.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,GetNearestPoint,The length of the statement  "			var text = this.Format (this.TrackerFormatString' item' this.Items [i].X0' this.Items [i].X1' this.Items [i].Y0' this.Items [i].Y1' this.Items [i].Title); " is 154.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (clippingRect' rectangle' this.GetSelectableFillColor (item.Color.GetActualColor (this.ActualFillColor))' this.StrokeColor' this.StrokeThickness); " is 179.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 181.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness); " is 193.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,GetNearestPoint,The length of the statement  "			var text = this.Format (this.TrackerFormatString' item' this.Items [i].Start' this.Items [i].End' this.Items [i].Title); " is 120.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (clippingRect' rectangle' this.GetSelectableFillColor (item.Color.GetActualColor (this.ActualFillColor))' this.StrokeColor' this.StrokeThickness); " is 179.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 181.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness); " is 193.
Long Statement,OxyPlot.Series,TornadoBarItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}'{4}"' this.Minimum' this.Maximum' this.BaseValue' this.MinimumColor.ToCode ()' this.MaximumColor.ToCode ()); " is 182.
Long Statement,OxyPlot.Series,TornadoBarItem,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}"' this.Minimum' this.Maximum' this.BaseValue' this.MinimumColor.ToCode ()); " is 149.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (clippingRect' minimumRectangle' item.MinimumColor.GetActualColor (this.ActualMinimumFillColor)' this.StrokeColor' this.StrokeThickness); " is 170.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (clippingRect' maximumRectangle' item.MaximumColor.GetActualColor (this.ActualMaximumFillColor)' this.StrokeColor' this.StrokeThickness); " is 170.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2); " is 122.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle); " is 180.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2); " is 123.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle); " is 179.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness); " is 176.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness); " is 160.
Long Statement,OxyPlot.Series,HighLowSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HighLowSeries.cs,GetNearestPoint,The length of the statement  "				result.Text = this.Format (this.TrackerFormatString' item' this.Title' this.XAxis.GetValue (p.X)' item.High' item.Low' item.Open' item.Close); " is 142.
Long Statement,OxyPlot.Series,HighLowSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HighLowSeries.cs,IsValidItem,The length of the statement  "	return !double.IsNaN (pt.X) && !double.IsInfinity (pt.X) && !double.IsNaN (pt.High) && !double.IsInfinity (pt.High) && !double.IsNaN (pt.Low) && !double.IsInfinity (pt.Low); " is 173.
Long Statement,OxyPlot.Series,StemSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StemSeries.cs,Render,The length of the statement  "			rc.DrawClippedLine (clippingRect' points' minDistSquared' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false); " is 126.
Long Statement,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The length of the statement  "	var verticalStrokeThickness = double.IsNaN (this.VerticalStrokeThickness) ? this.StrokeThickness : this.VerticalStrokeThickness; " is 128.
Long Statement,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The length of the statement  "				rc.DrawClippedLineSegments (clippingRect' vlpts' actualColor' verticalStrokeThickness' verticalLineDashArray' this.LineJoin' false); " is 132.
Long Statement,OxyPlot.Series,TwoColorLineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\TwoColorLineSeries.cs,RenderLine,The length of the statement  "	rc.DrawClippedLine (clippingRect' pointsToRender' this.MinimumSegmentLength * this.MinimumSegmentLength' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' dashArray' this.LineJoin' false); " is 204.
Long Statement,OxyPlot.Series,TwoColorLineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\TwoColorLineSeries.cs,RenderLine,The length of the statement  "	rc.DrawClippedLine (clippingRect' pointsToRender' this.MinimumSegmentLength * this.MinimumSegmentLength' this.GetSelectableColor (this.ActualColor2)' this.StrokeThickness' dashArray2' this.LineJoin' false); " is 206.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "	var midPoint = new ScreenPoint ((model.PlotArea.Left + model.PlotArea.Right) * 0.5' (model.PlotArea.Top + model.PlotArea.Bottom) * 0.5); " is 136.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "		var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians))); " is 146.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians))); " is 173.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians))); " is 151.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle); " is 212.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 185.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegend,The length of the statement  "	rc.DrawLine (pts' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle.GetDashArray ()); " is 122.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegend,The length of the statement  "	rc.DrawMarker (legendBox' midpt' this.MarkerType' this.MarkerOutline' this.MarkerSize' this.ActualMarkerFill' this.MarkerStroke' this.MarkerStrokeThickness); " is 157.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderPoints,The length of the statement  "	while (pointEnumerator.MoveNext () && this.ExtractNextContiguousLineSegment (pointEnumerator' ref lastValidPoint' broken' this.contiguousScreenPointsBuffer)) { " is 159.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderPoints,The length of the statement  "				rc.DrawClippedLineSegments (clippingRect' broken' this.BrokenLineColor' this.BrokenLineThickness' dashArray' this.LineJoin' false); " is 131.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderPointLabels,The length of the statement  "		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Bottom); " is 181.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The length of the statement  "	rc.DrawClippedText (clippingRect' pt' this.Title' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' ha' VerticalAlignment.Middle); " is 166.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLine,The length of the statement  "	rc.DrawClippedLine (clippingRect' pointsToRender' this.MinimumSegmentLength * this.MinimumSegmentLength' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' dashArray' this.LineJoin' false' this.outputBuffer); " is 223.
Long Statement,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,Render,The length of the statement  "			rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined); " is 162.
Long Statement,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,IsValidValue,The length of the statement  "	return value == value && value != 1.0 / 0.0 && value != -1.0 / 0.0 && value < this.FilterMaxValue && value > this.FilterMinValue && (this.FilterFunction == null || this.FilterFunction (value)); " is 193.
Long Statement,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,ToString,The length of the statement  "	return string.Format (this.ActualCulture' "{0}({1}' {2}' {3}' {4})"' this.GetType ().Name' this.Position' this.ActualMinimum' this.ActualMaximum' this.ActualMajorStep); " is 168.
Long Statement,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,UpdateIntervals,The length of the statement  "	this.ActualMajorStep = !double.IsNaN (this.MajorStep) ? this.MajorStep : this.CalculateActualInterval (length' labelSize); " is 122.
Long Statement,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,UpdateIntervals,The length of the statement  "	this.ActualMinorStep = !double.IsNaN (this.MinorStep) ? this.MinorStep : this.CalculateMinorInterval (this.ActualMajorStep); " is 124.
Long Statement,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The length of the statement  "	// double maxIntervals = Orientation == AxisOrientation.x ? MaximumAxisIntervalsPer200Pixels * 0.8 : MaximumAxisIntervalsPer200Pixels; " is 134.
Long Statement,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateMinorInterval,The length of the statement  "	// The following obsolete code divided major intervals into 4 minor intervals' unless the major interval's mantissa was 5. " is 122.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,GetCurrentBaseValue,The length of the statement  "	return negativeValue ? this.currentNegativeBaseValues [stackIndex' categoryIndex] : this.currentPositiveBaseValues [stackIndex' categoryIndex]; " is 143.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "		var maxBarWidth = stackedSeries.Where (s => s.StackGroup == stackIndices [j]).Select (s => ((CategorizedSeries)s).GetBarWidth ()).Concat (new[] { " is 145.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "			if (stackedSeries.SelectMany (s => ((CategorizedSeries)s).GetItems ()).Any (item => item.GetCategoryIndex (k++) == i)) { " is 120.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "	var unstackedBarSeries = categorizedSeries.Where (s => !(s is IStackableSeries) || !((IStackableSeries)s).IsStacked).ToList (); " is 127.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "			if (stackedSeries.SelectMany (s => ((CategorizedSeries)s).GetItems ()).All (item => item.GetCategoryIndex (k++) != i)) { " is 120.
Long Statement,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,Render,The length of the statement  "			rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined); " is 162.
Long Statement,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,GetHighValue,The length of the statement  "	double highValue = paletteIndex >= this.Palette.Colors.Count - 1 ? this.ActualMaximum : (majorLabelValues [paletteIndex] + majorLabelValues [paletteIndex + 1]) / 2; " is 164.
Long Statement,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,GetLowValue,The length of the statement  "	double lowValue = paletteIndex == 0 ? this.ActualMinimum : (majorLabelValues [paletteIndex - 1] + majorLabelValues [paletteIndex]) / 2; " is 135.
Long Statement,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,GetPaletteIndex,The length of the statement  "	int index = 1 + (int)((value - this.ActualMinimum) / (this.ActualMaximum - this.ActualMinimum) * this.Palette.Colors.Count); " is 124.
Long Statement,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The length of the statement  "				rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined); " is 162.
Long Statement,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,GetLowValue,The length of the statement  "	return ((double)paletteIndex / this.Palette.Colors.Count * (this.ActualMaximum - this.ActualMinimum)) + this.ActualMinimum; " is 123.
Long Statement,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,GetTickValues,The length of the statement  "	minorTickValues = this.CreateDateTimeTickValues (this.ActualMinimum' this.ActualMaximum' this.ActualMinorStep' this.actualMinorIntervalType); " is 141.
Long Statement,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,GetTickValues,The length of the statement  "	majorTickValues = this.CreateDateTimeTickValues (this.ActualMinimum' this.ActualMaximum' this.ActualMajorStep' this.actualIntervalType); " is 136.
Long Statement,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CreateDateTimeTickValues,The length of the statement  "	// If the step size is more than 7 days (e.g. months or years) we use a specialized tick generation method that adds tick values with uneven spacing... " is 151.
Long Statement,OxyPlot.Axes,LinearAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearAxis.cs,FormatValueOverride,The length of the statement  "		return FractionHelper.ConvertToFractionString (x' this.FractionUnit' this.FractionUnitSymbol' 1e-6' this.ActualCulture' this.StringFormat); " is 139.
Long Statement,OxyPlot.Axes,MagnitudeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\MagnitudeAxis.cs,Transform,The length of the statement  "	return new ScreenPoint (this.MidPoint.x + (r * Math.Cos (theta / 180 * Math.PI))' this.MidPoint.y - (r * Math.Sin (theta / 180 * Math.PI))); " is 140.
Long Statement,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The length of the statement  "		var screenPoints = this.MinorTickValues.Where (x => x > Math.Min (scaledStartAngle' scaledEndAngle) - eps && x < Math.Max (scaledStartAngle' scaledEndAngle) + eps && !this.MajorTickValues.Contains (x)).Take (tickCount + 1).Select (x => magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' x' axis)); " is 300.
Long Statement,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The length of the statement  "			this.RenderContext.DrawLine (magnitudeAxis.MidPoint.x' magnitudeAxis.MidPoint.y' screenPoint.x' screenPoint.y' this.MinorPen' false); " is 133.
Long Statement,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The length of the statement  "	var isFullCircle = Math.Abs (Math.Abs (Math.Max (angleAxis.EndAngle' angleAxis.StartAngle) - Math.Min (angleAxis.StartAngle' angleAxis.EndAngle)) - 360) < 1e-3; " is 160.
Long Statement,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The length of the statement  "		var screenPoints = this.MajorTickValues.Where (x => x > Math.Min (scaledStartAngle' scaledEndAngle) - eps && x < Math.Max (scaledStartAngle' scaledEndAngle) + eps).Take (majorTickCount).Select (x => magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' x' axis)).ToArray (); " is 274.
Long Statement,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The length of the statement  "			this.RenderContext.DrawLine (magnitudeAxis.MidPoint.x' magnitudeAxis.MidPoint.y' point.x' point.y' this.MajorPen' false); " is 121.
Long Statement,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The length of the statement  "		this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va); " is 141.
Long Statement,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,Render,The length of the statement  "		var minorTicks = MinorTickValues.Where (x => x >= axis.ActualMinimum && x <= axis.ActualMaximum && !majorTicks.Contains (x)).ToArray (); " is 136.
Long Statement,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,RenderTickText,The length of the statement  "	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' axis.Angle' ha' va); " is 146.
Long Statement,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetAxisTitlePositionAndAlignment,The length of the statement  "	double middle = axis.IsHorizontal () ? Lerp (axis.ScreenMin.X' axis.ScreenMax.X' axis.TitlePosition) : Lerp (axis.ScreenMax.Y' axis.ScreenMin.Y' axis.TitlePosition); " is 165.
Long Statement,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderAxisTitle,The length of the statement  "		double screenLength = isHorizontal ? Math.Abs (axis.ScreenMax.X - axis.ScreenMin.X) : Math.Abs (axis.ScreenMax.Y - axis.ScreenMin.Y); " is 133.
Long Statement,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderAxisTitle,The length of the statement  "	this.RenderContext.DrawMathText (lpt' axis.ActualTitle' axis.ActualTitleColor' axis.ActualTitleFont' axis.ActualTitleFontSize' axis.ActualTitleFontWeight' angle' halign' valign' maxSize); " is 187.
Long Statement,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The length of the statement  "		this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' axis.Angle' ha' va); " is 146.
Long Statement,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The length of the statement  "		this.RenderContext.DrawLine (axis.Transform (actualMinimum)' axisPosition' axis.Transform (actualMaximum)' axisPosition' this.AxislinePen); " is 139.
Long Statement,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The length of the statement  "		this.RenderContext.DrawLine (axisPosition' axis.Transform (actualMinimum)' axisPosition' axis.Transform (actualMaximum)' this.AxislinePen); " is 139.
Complex Conditional,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedImage,The conditional expression  "x > clippingRectangle.Right || x + w < clippingRectangle.Left || y > clippingRectangle.Bottom || y + h < clippingRectangle.Top"  is complex.
Complex Conditional,OxyPlot,OxyImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\OxyImage.cs,GetImageFormat,The conditional expression  "bytes.Length >= 4 && bytes [0] == 0x89 && bytes [1] == 0x50 && bytes [2] == 0x4E && bytes [3] == 0x47"  is complex.
Complex Conditional,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The conditional expression  "signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A"  is complex.
Complex Conditional,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,GetNearestPoint,The conditional expression  "p.X < this.XAxis.ActualMinimum || p.X > this.XAxis.ActualMaximum || p.Y < this.YAxis.ActualMinimum || p.Y > this.YAxis.ActualMaximum"  is complex.
Complex Conditional,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The conditional expression  "!this.IsValid (item.X0) || !this.IsValid (item.X1) || !this.IsValid (item.Y0) || !this.IsValid (item.Y1)"  is complex.
Magic Number,OxyPlot.Annotations,PointAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PointAnnotation.cs,PointAnnotation,The following statement contains a magic number: this.Size = 4;  
Magic Number,OxyPlot.Annotations,PointAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PointAnnotation.cs,PointAnnotation,The following statement contains a magic number: this.TextMargin = 2;  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,TextAnnotation,The following statement contains a magic number: this.Padding = new OxyThickness (4);  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,Render,The following statement contains a magic number: if ((this.TextRotation % 90).Equals (0)) {  	var actualRect = new OxyRect (this.actualBounds [0]' this.actualBounds [2]);  	rc.DrawRectangle (actualRect' this.Background' this.Stroke' this.StrokeThickness);  }  else {  	rc.DrawPolygon (this.actualBounds' this.Background' this.Stroke' this.StrokeThickness);  }  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,Render,The following statement contains a magic number: if ((this.TextRotation % 90).Equals (0)) {  	var actualRect = new OxyRect (this.actualBounds [0]' this.actualBounds [2]);  	rc.DrawRectangle (actualRect' this.Background' this.Stroke' this.StrokeThickness);  }  else {  	rc.DrawPolygon (this.actualBounds' this.Background' this.Stroke' this.StrokeThickness);  }  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: switch (horizontalAlignment) {  case HorizontalAlignment.Center:  	left = -size.Width * 0.5;  	right = -left;  	break;  case HorizontalAlignment.Right:  	left = -size.Width;  	right = 0;  	break;  default:  	left = 0;  	right = size.Width;  	break;  }  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: left = -size.Width * 0.5;  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: switch (verticalAlignment) {  case VerticalAlignment.Middle:  	top = -size.Height * 0.5;  	bottom = -top;  	break;  case VerticalAlignment.Bottom:  	top = -size.Height;  	bottom = 0;  	break;  default:  	top = 0;  	bottom = size.Height;  	break;  }  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: top = -size.Height * 0.5;  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: polygon [2] = position + (u * (right + padding.Right)) + (v * (bottom + padding.Bottom));  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: polygon [3] = position + (u * (left - padding.Left)) + (v * (bottom + padding.Bottom));  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\LineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: if (!isCurvedLine) {  	// we only need to calculate two points if it is a straight line  	if (fx != null) {  		points.Add (new DataPoint (this.ActualMinimumX' fx (this.ActualMinimumX)));  		points.Add (new DataPoint (this.ActualMaximumX' fx (this.ActualMaximumX)));  	}  	else {  		points.Add (new DataPoint (fy (this.ActualMinimumY)' this.ActualMinimumY));  		points.Add (new DataPoint (fy (this.ActualMaximumY)' this.ActualMaximumY));  	}  	if (this.Type == LineAnnotationType.Horizontal || this.Type == LineAnnotationType.Vertical) {  		// use aliased line drawing for horizontal and vertical lines  		this.Aliased = true;  	}  }  else {  	if (fx != null) {  		double x = this.ActualMinimumX;  		// todo: the step size should be adaptive  		double dx = (this.ActualMaximumX - this.ActualMinimumX) / 100;  		while (true) {  			points.Add (new DataPoint (x' fx (x)));  			if (x > this.ActualMaximumX) {  				break;  			}  			x += dx;  		}  	}  	else {  		double y = this.ActualMinimumY;  		// todo: the step size should be adaptive  		double dy = (this.ActualMaximumY - this.ActualMinimumY) / 100;  		while (true) {  			points.Add (new DataPoint (fy (y)' y));  			if (y > this.ActualMaximumY) {  				break;  			}  			y += dy;  		}  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\LineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: if (!isCurvedLine) {  	// we only need to calculate two points if it is a straight line  	if (fx != null) {  		points.Add (new DataPoint (this.ActualMinimumX' fx (this.ActualMinimumX)));  		points.Add (new DataPoint (this.ActualMaximumX' fx (this.ActualMaximumX)));  	}  	else {  		points.Add (new DataPoint (fy (this.ActualMinimumY)' this.ActualMinimumY));  		points.Add (new DataPoint (fy (this.ActualMaximumY)' this.ActualMaximumY));  	}  	if (this.Type == LineAnnotationType.Horizontal || this.Type == LineAnnotationType.Vertical) {  		// use aliased line drawing for horizontal and vertical lines  		this.Aliased = true;  	}  }  else {  	if (fx != null) {  		double x = this.ActualMinimumX;  		// todo: the step size should be adaptive  		double dx = (this.ActualMaximumX - this.ActualMinimumX) / 100;  		while (true) {  			points.Add (new DataPoint (x' fx (x)));  			if (x > this.ActualMaximumX) {  				break;  			}  			x += dx;  		}  	}  	else {  		double y = this.ActualMinimumY;  		// todo: the step size should be adaptive  		double dy = (this.ActualMaximumY - this.ActualMinimumY) / 100;  		while (true) {  			points.Add (new DataPoint (fy (y)' y));  			if (y > this.ActualMaximumY) {  				break;  			}  			y += dy;  		}  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\LineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: if (fx != null) {  	double x = this.ActualMinimumX;  	// todo: the step size should be adaptive  	double dx = (this.ActualMaximumX - this.ActualMinimumX) / 100;  	while (true) {  		points.Add (new DataPoint (x' fx (x)));  		if (x > this.ActualMaximumX) {  			break;  		}  		x += dx;  	}  }  else {  	double y = this.ActualMinimumY;  	// todo: the step size should be adaptive  	double dy = (this.ActualMaximumY - this.ActualMinimumY) / 100;  	while (true) {  		points.Add (new DataPoint (fy (y)' y));  		if (y > this.ActualMaximumY) {  			break;  		}  		y += dy;  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\LineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: if (fx != null) {  	double x = this.ActualMinimumX;  	// todo: the step size should be adaptive  	double dx = (this.ActualMaximumX - this.ActualMinimumX) / 100;  	while (true) {  		points.Add (new DataPoint (x' fx (x)));  		if (x > this.ActualMaximumX) {  			break;  		}  		x += dx;  	}  }  else {  	double y = this.ActualMinimumY;  	// todo: the step size should be adaptive  	double dy = (this.ActualMaximumY - this.ActualMinimumY) / 100;  	while (true) {  		points.Add (new DataPoint (fy (y)' y));  		if (y > this.ActualMaximumY) {  			break;  		}  		y += dy;  	}  }  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ArrowAnnotation.cs,ArrowAnnotation,The following statement contains a magic number: this.HeadLength = 10;  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ArrowAnnotation.cs,ArrowAnnotation,The following statement contains a magic number: this.HeadWidth = 3;  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ArrowAnnotation.cs,ArrowAnnotation,The following statement contains a magic number: this.StrokeThickness = 2;  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ArrowAnnotation.cs,HitTestOverride,The following statement contains a magic number: if ((args.Point - this.screenEndPoint).Length < args.Tolerance) {  	return new HitTestResult (this' this.screenEndPoint' null' 2);  }  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ArrowAnnotation.cs,HitTestOverride,The following statement contains a magic number: return new HitTestResult (this' this.screenEndPoint' null' 2);  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = new OxyRect (this.Transform (this.X - (this.Width / 2)' this.Y - (this.Height / 2))' this.Transform (this.X + (this.Width / 2)' this.Y + (this.Height / 2)));  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = new OxyRect (this.Transform (this.X - (this.Width / 2)' this.Y - (this.Height / 2))' this.Transform (this.X + (this.Width / 2)' this.Y + (this.Height / 2)));  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = new OxyRect (this.Transform (this.X - (this.Width / 2)' this.Y - (this.Height / 2))' this.Transform (this.X + (this.Width / 2)' this.Y + (this.Height / 2)));  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = new OxyRect (this.Transform (this.X - (this.Width / 2)' this.Y - (this.Height / 2))' this.Transform (this.X + (this.Width / 2)' this.Y + (this.Height / 2)));  
Magic Number,OxyPlot.Annotations,FunctionAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\FunctionAnnotation.cs,FunctionAnnotation,The following statement contains a magic number: this.Resolution = 400;  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,ImageAnnotation,The following statement contains a magic number: this.X = new PlotLength (0.5' PlotLengthUnit.RelativeToPlotArea);  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,ImageAnnotation,The following statement contains a magic number: this.Y = new PlotLength (0.5' PlotLengthUnit.RelativeToPlotArea);  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: if (this.HorizontalAlignment == HorizontalAlignment.Center) {  	x -= width * 0.5;  }  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: x -= width * 0.5;  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: if (this.VerticalAlignment == VerticalAlignment.Middle) {  	y -= height * 0.5;  }  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: y -= height * 0.5;  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,PathAnnotation,The following statement contains a magic number: this.TextMargin = 12;  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  	margin = 0;  }  else {  	margin *= this.TextLinePosition < 0.5 ? 1 : -1;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: margin *= this.TextLinePosition < 0.5 ? 1 : -1;  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (GetPointAtRelativeDistance (clippedPoints' this.TextLinePosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position += new ScreenVector (f * this.TextPadding * Math.Cos (angleInRadians)' f * this.TextPadding * Math.Sin (angleInRadians));  	if (!string.IsNullOrEmpty (this.Text)) {  		var textPosition = this.GetActualTextPosition (() => position);  		if (this.TextPosition.IsDefined ()) {  			angle = this.TextRotation;  		}  		if (this.ClipText) {  			var cs = new CohenSutherlandClipping (clippingRectangle);  			if (cs.IsInside (position)) {  				rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  			}  		}  		else {  			rc.DrawText (textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  		}  	}  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (GetPointAtRelativeDistance (clippedPoints' this.TextLinePosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position += new ScreenVector (f * this.TextPadding * Math.Cos (angleInRadians)' f * this.TextPadding * Math.Sin (angleInRadians));  	if (!string.IsNullOrEmpty (this.Text)) {  		var textPosition = this.GetActualTextPosition (() => position);  		if (this.TextPosition.IsDefined ()) {  			angle = this.TextRotation;  		}  		if (this.ClipText) {  			var cs = new CohenSutherlandClipping (clippingRectangle);  			if (cs.IsInside (position)) {  				rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  			}  		}  		else {  			rc.DrawText (textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  		}  	}  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (GetPointAtRelativeDistance (clippedPoints' this.TextLinePosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position += new ScreenVector (f * this.TextPadding * Math.Cos (angleInRadians)' f * this.TextPadding * Math.Sin (angleInRadians));  	if (!string.IsNullOrEmpty (this.Text)) {  		var textPosition = this.GetActualTextPosition (() => position);  		if (this.TextPosition.IsDefined ()) {  			angle = this.TextRotation;  		}  		if (this.ClipText) {  			var cs = new CohenSutherlandClipping (clippingRectangle);  			if (cs.IsInside (position)) {  				rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  			}  		}  		else {  			rc.DrawText (textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  		}  	}  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (GetPointAtRelativeDistance (clippedPoints' this.TextLinePosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position += new ScreenVector (f * this.TextPadding * Math.Cos (angleInRadians)' f * this.TextPadding * Math.Sin (angleInRadians));  	if (!string.IsNullOrEmpty (this.Text)) {  		var textPosition = this.GetActualTextPosition (() => position);  		if (this.TextPosition.IsDefined ()) {  			angle = this.TextRotation;  		}  		if (this.ClipText) {  			var cs = new CohenSutherlandClipping (clippingRectangle);  			if (cs.IsInside (position)) {  				rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  			}  		}  		else {  			rc.DrawText (textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  		}  	}  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (GetPointAtRelativeDistance (clippedPoints' this.TextLinePosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position += new ScreenVector (f * this.TextPadding * Math.Cos (angleInRadians)' f * this.TextPadding * Math.Sin (angleInRadians));  	if (!string.IsNullOrEmpty (this.Text)) {  		var textPosition = this.GetActualTextPosition (() => position);  		if (this.TextPosition.IsDefined ()) {  			angle = this.TextRotation;  		}  		if (this.ClipText) {  			var cs = new CohenSutherlandClipping (clippingRectangle);  			if (cs.IsInside (position)) {  				rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  			}  		}  		else {  			rc.DrawText (textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  		}  	}  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (GetPointAtRelativeDistance (clippedPoints' this.TextLinePosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position += new ScreenVector (f * this.TextPadding * Math.Cos (angleInRadians)' f * this.TextPadding * Math.Sin (angleInRadians));  	if (!string.IsNullOrEmpty (this.Text)) {  		var textPosition = this.GetActualTextPosition (() => position);  		if (this.TextPosition.IsDefined ()) {  			angle = this.TextRotation;  		}  		if (this.ClipText) {  			var cs = new CohenSutherlandClipping (clippingRectangle);  			if (cs.IsInside (position)) {  				rc.DrawClippedText (clippingRectangle' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  			}  		}  		else {  			rc.DrawText (textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  		}  	}  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: angle += 180;  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: angle -= 180;  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: switch (this.TextOrientation) {  case AnnotationTextOrientation.Horizontal:  	angle = 0;  	break;  case AnnotationTextOrientation.Vertical:  	angle = -90;  	break;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following statement contains a magic number: angle = -90;  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,GetPointAtRelativeDistance,The following statement contains a magic number: for (int i = 1; i < pts.Count; i++) {  	double dl = (pts [i] - pts [i - 1]).Length;  	if (l >= length - eps && l <= length + dl + eps) {  		double f = (l - length) / dl;  		double x = (pts [i].X * f) + (pts [i - 1].X * (1 - f));  		double y = (pts [i].Y * f) + (pts [i - 1].Y * (1 - f));  		position = new ScreenPoint (x' y);  		double dx = pts [i].X - pts [i - 1].X;  		double dy = pts [i].Y - pts [i - 1].Y;  		angle = Math.Atan2 (dy' dx) / Math.PI * 180;  		return true;  	}  	length += dl;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,GetPointAtRelativeDistance,The following statement contains a magic number: if (l >= length - eps && l <= length + dl + eps) {  	double f = (l - length) / dl;  	double x = (pts [i].X * f) + (pts [i - 1].X * (1 - f));  	double y = (pts [i].Y * f) + (pts [i - 1].Y * (1 - f));  	position = new ScreenPoint (x' y);  	double dx = pts [i].X - pts [i - 1].X;  	double dy = pts [i].Y - pts [i - 1].Y;  	angle = Math.Atan2 (dy' dx) / Math.PI * 180;  	return true;  }  
Magic Number,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,GetPointAtRelativeDistance,The following statement contains a magic number: angle = Math.Atan2 (dy' dx) / Math.PI * 180;  
Magic Number,OxyPlot.Annotations,PolylineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PolylineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: if (this.Smooth) {  	var resampledPoints = ScreenPointHelper.ResamplePoints (screenPoints' this.MinimumSegmentLength);  	return CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Annotations,PolylineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PolylineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: if (this.Smooth) {  	var resampledPoints = ScreenPointHelper.ResamplePoints (screenPoints' this.MinimumSegmentLength);  	return CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Annotations,PolylineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PolylineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: return CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Annotations,PolylineAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PolylineAnnotation.cs,GetScreenPoints,The following statement contains a magic number: return CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,TileMapAnnotation,The following statement contains a magic number: this.TileSize = 256;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,TileMapAnnotation,The following statement contains a magic number: this.MaxZoomLevel = 20;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,TileMapAnnotation,The following statement contains a magic number: this.MaxNumberOfDownloads = 8;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColor.FromAColor (200' OxyColors.White)' OxyColors.Undefined);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColor.FromAColor (200' OxyColors.White)' OxyColors.Undefined);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColor.FromAColor (200' OxyColors.White)' OxyColors.Undefined);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColor.FromAColor (200' OxyColors.White)' OxyColors.Undefined);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColor.FromAColor (200' OxyColors.White)' OxyColors.Undefined);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The following statement contains a magic number: x = (longitude + 180.0) / 360.0 * n;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The following statement contains a magic number: x = (longitude + 180.0) / 360.0 * n;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The following statement contains a magic number: y = (1.0 - (Math.Log (Math.Tan (lat) + (1.0 / Math.Cos (lat))) / Math.PI)) / 2.0 * n;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The following statement contains a magic number: longitude = (x / n * 360.0) - 180.0;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The following statement contains a magic number: longitude = (x / n * 360.0) - 180.0;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The following statement contains a magic number: latitude = lat * 180.0 / Math.PI;  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (currentTouches.Length > 1 && currentTouches.Length == previousTouches.Length) {  	var currentDistance = (currentTouches [1] - currentTouches [0]).Length;  	var previousDistance = (previousTouches [1] - previousTouches [0]).Length;  	scale = currentDistance / previousDistance;  	if (scale < 0.5) {  		scale = 0.5;  	}  	if (scale > 2) {  		scale = 2;  	}  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (currentTouches.Length > 1 && currentTouches.Length == previousTouches.Length) {  	var currentDistance = (currentTouches [1] - currentTouches [0]).Length;  	var previousDistance = (previousTouches [1] - previousTouches [0]).Length;  	scale = currentDistance / previousDistance;  	if (scale < 0.5) {  		scale = 0.5;  	}  	if (scale > 2) {  		scale = 2;  	}  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (currentTouches.Length > 1 && currentTouches.Length == previousTouches.Length) {  	var currentDistance = (currentTouches [1] - currentTouches [0]).Length;  	var previousDistance = (previousTouches [1] - previousTouches [0]).Length;  	scale = currentDistance / previousDistance;  	if (scale < 0.5) {  		scale = 0.5;  	}  	if (scale > 2) {  		scale = 2;  	}  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (currentTouches.Length > 1 && currentTouches.Length == previousTouches.Length) {  	var currentDistance = (currentTouches [1] - currentTouches [0]).Length;  	var previousDistance = (previousTouches [1] - previousTouches [0]).Length;  	scale = currentDistance / previousDistance;  	if (scale < 0.5) {  		scale = 0.5;  	}  	if (scale > 2) {  		scale = 2;  	}  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (scale < 0.5) {  	scale = 0.5;  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (scale < 0.5) {  	scale = 0.5;  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: scale = 0.5;  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (scale > 2) {  	scale = 2;  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: if (scale > 2) {  	scale = 2;  }  
Magic Number,OxyPlot,OxyTouchEventArgs,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\EventArgs\OxyTouchEventArgs.cs,OxyTouchEventArgs,The following statement contains a magic number: scale = 2;  
Magic Number,OxyPlot,PlotController,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotController.cs,PlotController,The following statement contains a magic number: this.BindMouseDown (OxyMouseButton.Middle' OxyModifierKeys.None' 2' PlotCommands.ResetAt);  
Magic Number,OxyPlot,PlotController,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotController.cs,PlotController,The following statement contains a magic number: this.BindMouseDown (OxyMouseButton.Right' OxyModifierKeys.Control' 2' PlotCommands.ResetAt);  
Magic Number,OxyPlot,PlotController,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotController.cs,PlotController,The following statement contains a magic number: this.BindMouseDown (OxyMouseButton.Left' OxyModifierKeys.Control | OxyModifierKeys.Alt' 2' PlotCommands.ResetAt);  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: ZoomWheelFine = new DelegatePlotCommand<OxyMouseWheelEventArgs> ((view' controller' args) => HandleZoomByWheel (view' args' 0.1));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: ZoomInAt = new DelegatePlotCommand<OxyMouseEventArgs> ((view' controller' args) => HandleZoomAt (view' args' 0.05));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: ZoomOutAt = new DelegatePlotCommand<OxyMouseEventArgs> ((view' controller' args) => HandleZoomAt (view' args' -0.05));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanLeft = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' -0.1' 0));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanRight = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' 0.1' 0));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanUp = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' 0' -0.1));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanDown = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' 0' 0.1));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanLeftFine = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' -0.01' 0));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanRightFine = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' 0.01' 0));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanUpFine = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' 0' -0.01));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: PanDownFine = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandlePan (view' 0' 0.01));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: ZoomInFine = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandleZoomCenter (view' 0.1));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,PlotCommands,The following statement contains a magic number: ZoomOutFine = new DelegatePlotCommand<OxyKeyEventArgs> ((view' controller' args) => HandleZoomCenter (view' -0.1));  
Magic Number,OxyPlot,PlotCommands,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\PlotCommands.cs,HandleZoomCenter,The following statement contains a magic number: view.ActualModel.ZoomAllAxes (1 + (delta * 0.12));  
Magic Number,OxyPlot,CodeGenerator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,CodeGenerator,The following statement contains a magic number: this.Indents = 8;  
Magic Number,OxyPlot,CodeGenerator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,CodeGenerator,The following statement contains a magic number: this.Indents += 4;  
Magic Number,OxyPlot,CodeGenerator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,CodeGenerator,The following statement contains a magic number: this.Indents -= 4;  
Magic Number,OxyPlot,CodeGenerator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,AddArray,The following statement contains a magic number: if (array.Rank == 2) {  	this.AppendLine ("{0} = new {1}[{2}' {3}];"' name' elementType.Name' array.GetLength (0)' array.GetLength (1));  	for (int i = 0; i < array.GetLength (0); i++) {  		for (int j = 0; j < array.GetLength (1); j++) {  			var code = array.GetValue (i' j).ToCode ();  			if (code == null) {  				continue;  			}  			this.AppendLine ("{0}[{1}' {2}] = {3};"' name' i' j' code);  		}  	}  }  
Magic Number,OxyPlot,CodeGenerator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,AddArray,The following statement contains a magic number: if (array.Rank > 2) {  	throw new NotImplementedException ();  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ChangeIntensity,The following statement contains a magic number: hsv [2] *= factor;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ChangeIntensity,The following statement contains a magic number: if (hsv [2] > 1.0) {  	hsv [2] = 1.0;  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ChangeIntensity,The following statement contains a magic number: if (hsv [2] > 1.0) {  	hsv [2] = 1.0;  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ChangeIntensity,The following statement contains a magic number: hsv [2] = 1.0;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,Complementary,The following statement contains a magic number: return OxyColor.FromHsv (newHue' hsv [1]' hsv [2]);  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (r == v) {  	h = (g - b) / delta;  }  else if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (r == v) {  	h = (g - b) / delta;  }  else if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: h = 2 + ((b - r) / delta);  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: h = 4 + ((r - g) / delta);  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: h *= 60;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: if (h < 0.0) {  	h += 360;  }  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: h += 360;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: hsv [0] = h / 360.0;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: hsv [2] = v / 255.0;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToHsv,The following statement contains a magic number: hsv [2] = v / 255.0;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToUint,The following statement contains a magic number: u += (uint)color.R << 16;  
Magic Number,OxyPlot,OxyColorExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColorExtensions.cs,ToUint,The following statement contains a magic number: u += (uint)color.G << 8;  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,OxyPalettes,The following statement contains a magic number: BlueWhiteRed31 = BlueWhiteRed (31);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,OxyPalettes,The following statement contains a magic number: Hot64 = Hot (64);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,OxyPalettes,The following statement contains a magic number: Hue64 = Hue (64);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\ScreenPointHelper.cs,FindPositionOnLine,The following statement contains a magic number: if (u2 < 1e-6) {  	return double.NaN;  }  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\ScreenPointHelper.cs,GetCentroid,The following statement contains a magic number: a *= 0.5;  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\ScreenPointHelper.cs,GetCentroid,The following statement contains a magic number: cx /= 6 * a;  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\ScreenPointHelper.cs,GetCentroid,The following statement contains a magic number: cy /= 6 * a;  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n < 2) {  	result.AddRange (points);  	return result;  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	}  	else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	}  	else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	}  	else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	}  	else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	}  	else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	}  	else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	}  	else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	}  	else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	}  	else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  }  else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  }  else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  }  else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	value = value.Trim ('#');  	var u = uint.Parse (value' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	if (value.Length < 8) {  		// alpha value was not specified  		u += 0xFF000000;  	}  	return FromUInt32 (u);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,Parse,The following statement contains a magic number: if (value.Length < 8) {  	// alpha value was not specified  	u += 0xFF000000;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,Parse,The following statement contains a magic number: if (values.Length < 3 || values.Length > 4) {  	throw new FormatException ("Invalid format.");  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,Parse,The following statement contains a magic number: if (values.Length < 3 || values.Length > 4) {  	throw new FormatException ("Invalid format.");  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,Parse,The following statement contains a magic number: if (values.Length > 3) {  	alpha = byte.Parse (values [i++]' CultureInfo.InvariantCulture);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: if (hsv.Length != 3) {  	throw new InvalidOperationException ("Wrong length of hsv array.");  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromHsv (hsv [0]' hsv [1]' hsv [2]);  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	var i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	var i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	var i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	var i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	var i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: hue *= 6.0;  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,HueDifference,The following statement contains a magic number: if (dh > 0.5) {  	dh -= 1.0;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,HueDifference,The following statement contains a magic number: if (dh < -0.5) {  	dh += 1.0;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromRgb,The following statement contains a magic number: return new OxyColor {  	A = 255'  	R = r'  	G = g'  	B = b  };  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.A.GetHashCode ();  	result = (result * 397) ^ this.R.GetHashCode ();  	result = (result * 397) ^ this.G.GetHashCode ();  	result = (result * 397) ^ this.B.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.A.GetHashCode ();  	result = (result * 397) ^ this.R.GetHashCode ();  	result = (result * 397) ^ this.G.GetHashCode ();  	result = (result * 397) ^ this.B.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.A.GetHashCode ();  	result = (result * 397) ^ this.R.GetHashCode ();  	result = (result * 397) ^ this.G.GetHashCode ();  	result = (result * 397) ^ this.B.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.R.GetHashCode ();  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.G.GetHashCode ();  
Magic Number,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.B.GetHashCode ();  
Magic Number,OxyPlot,OxyPen,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPen.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.Color.GetHashCode ();  	result = (result * 397) ^ this.Thickness.GetHashCode ();  	result = (result * 397) ^ this.LineStyle.GetHashCode ();  	result = (result * 397) ^ this.LineJoin.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyPen,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPen.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.Color.GetHashCode ();  	result = (result * 397) ^ this.Thickness.GetHashCode ();  	result = (result * 397) ^ this.LineStyle.GetHashCode ();  	result = (result * 397) ^ this.LineJoin.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyPen,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPen.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.Color.GetHashCode ();  	result = (result * 397) ^ this.Thickness.GetHashCode ();  	result = (result * 397) ^ this.LineStyle.GetHashCode ();  	result = (result * 397) ^ this.LineJoin.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyPen,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPen.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.Thickness.GetHashCode ();  
Magic Number,OxyPlot,OxyPen,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPen.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.LineStyle.GetHashCode ();  
Magic Number,OxyPlot,OxyPen,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyPen.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.LineJoin.GetHashCode ();  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	10'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	10'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	10'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,MathRenderingExtensions,The following statement contains a magic number: SubAlignment = 0.6;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,MathRenderingExtensions,The following statement contains a magic number: SubSize = 0.62;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,MathRenderingExtensions,The following statement contains a magic number: SuperSize = 0.62;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: if (text.Contains ("^{") || text.Contains ("_{")) {  	double x = pt.X;  	double y = pt.Y;  	// Measure  	var size = InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' true' angle);  	switch (ha) {  	case HorizontalAlignment.Right:  		x -= size.Width;  		break;  	case HorizontalAlignment.Center:  		x -= size.Width * 0.5;  		break;  	}  	switch (va) {  	case VerticalAlignment.Bottom:  		y -= size.Height;  		break;  	case VerticalAlignment.Middle:  		y -= size.Height * 0.5;  		break;  	}  	InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' false' angle);  	return measure ? size : OxySize.Empty;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: if (text.Contains ("^{") || text.Contains ("_{")) {  	double x = pt.X;  	double y = pt.Y;  	// Measure  	var size = InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' true' angle);  	switch (ha) {  	case HorizontalAlignment.Right:  		x -= size.Width;  		break;  	case HorizontalAlignment.Center:  		x -= size.Width * 0.5;  		break;  	}  	switch (va) {  	case VerticalAlignment.Bottom:  		y -= size.Height;  		break;  	case VerticalAlignment.Middle:  		y -= size.Height * 0.5;  		break;  	}  	InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' false' angle);  	return measure ? size : OxySize.Empty;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: switch (ha) {  case HorizontalAlignment.Right:  	x -= size.Width;  	break;  case HorizontalAlignment.Center:  	x -= size.Width * 0.5;  	break;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: x -= size.Width * 0.5;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: switch (va) {  case VerticalAlignment.Bottom:  	y -= size.Height;  	break;  case VerticalAlignment.Middle:  	y -= size.Height * 0.5;  	break;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: y -= size.Height * 0.5;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX + superScriptXDisplacement;  			double sy = currentY + superScriptYDisplacement;  			var size = drawText (sx' sy' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			if (currentX + size.Width < minimumX) {  				minimumX = currentX + size.Width;  			}  			if (currentY + size.Height > maximumY) {  				maximumY = currentY + size.Height;  			}  			if (currentY + size.Height < minimumY) {  				minimumY = currentY + size.Height;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			double sx = currentX - subscriptXDisplacement;  			double sy = currentY + subscriptYDisplacement;  			var size = drawText (sx' sy' subString' subscriptFontSize);  			if (currentX + (size.Width * cosAngle) > maximumX) {  				maximumX = currentX + (size.Width * cosAngle);  			}  			if (currentX + (size.Width * cosAngle) < minimumX) {  				minimumX = currentX + (size.Width * cosAngle);  			}  			if (currentY + (size.Height * sinAngle) > maximumY) {  				maximumY = currentY + (size.Height * sinAngle);  			}  			if (currentY + (size.Height * sinAngle) < minimumY) {  				minimumY = currentY + (size.Height * sinAngle);  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + (2 * cosAngle);  	currentY = maximumY + (2 * sinAngle);  	var size2 = drawText (currentX' currentY' regularString' fontSize);  	currentX += (size2.Width + 2) * cosAngle;  	currentY += (size2.Height + 2) * sinAngle;  	maximumX = Math.Max (currentX' maximumX);  	maximumY = Math.Max (currentY' maximumY);  	minimumX = Math.Min (currentX' minimumX);  	minimumY = Math.Min (currentY' minimumY);  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string supString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		double sx = currentX + superScriptXDisplacement;  		double sy = currentY + superScriptYDisplacement;  		var size = drawText (sx' sy' supString' superscriptFontSize);  		if (currentX + size.Width > maximumX) {  			maximumX = currentX + size.Width;  		}  		if (currentX + size.Width < minimumX) {  			minimumX = currentX + size.Width;  		}  		if (currentY + size.Height > maximumY) {  			maximumY = currentY + size.Height;  		}  		if (currentY + size.Height < minimumY) {  			minimumY = currentY + size.Height;  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string supString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		double sx = currentX + superScriptXDisplacement;  		double sy = currentY + superScriptYDisplacement;  		var size = drawText (sx' sy' supString' superscriptFontSize);  		if (currentX + size.Width > maximumX) {  			maximumX = currentX + size.Width;  		}  		if (currentX + size.Width < minimumX) {  			minimumX = currentX + size.Width;  		}  		if (currentY + size.Height > maximumY) {  			maximumY = currentY + size.Height;  		}  		if (currentY + size.Height < minimumY) {  			minimumY = currentY + size.Height;  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string supString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	double sx = currentX + superScriptXDisplacement;  	double sy = currentY + superScriptYDisplacement;  	var size = drawText (sx' sy' supString' superscriptFontSize);  	if (currentX + size.Width > maximumX) {  		maximumX = currentX + size.Width;  	}  	if (currentX + size.Width < minimumX) {  		minimumX = currentX + size.Width;  	}  	if (currentY + size.Height > maximumY) {  		maximumY = currentY + size.Height;  	}  	if (currentY + size.Height < minimumY) {  		minimumY = currentY + size.Height;  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string supString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	double sx = currentX + superScriptXDisplacement;  	double sy = currentY + superScriptYDisplacement;  	var size = drawText (sx' sy' supString' superscriptFontSize);  	if (currentX + size.Width > maximumX) {  		maximumX = currentX + size.Width;  	}  	if (currentX + size.Width < minimumX) {  		minimumX = currentX + size.Width;  	}  	if (currentY + size.Height > maximumY) {  		maximumY = currentY + size.Height;  	}  	if (currentY + size.Height < minimumY) {  		minimumY = currentY + size.Height;  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string subString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		double sx = currentX - subscriptXDisplacement;  		double sy = currentY + subscriptYDisplacement;  		var size = drawText (sx' sy' subString' subscriptFontSize);  		if (currentX + (size.Width * cosAngle) > maximumX) {  			maximumX = currentX + (size.Width * cosAngle);  		}  		if (currentX + (size.Width * cosAngle) < minimumX) {  			minimumX = currentX + (size.Width * cosAngle);  		}  		if (currentY + (size.Height * sinAngle) > maximumY) {  			maximumY = currentY + (size.Height * sinAngle);  		}  		if (currentY + (size.Height * sinAngle) < minimumY) {  			minimumY = currentY + (size.Height * sinAngle);  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string subString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		double sx = currentX - subscriptXDisplacement;  		double sy = currentY + subscriptYDisplacement;  		var size = drawText (sx' sy' subString' subscriptFontSize);  		if (currentX + (size.Width * cosAngle) > maximumX) {  			maximumX = currentX + (size.Width * cosAngle);  		}  		if (currentX + (size.Width * cosAngle) < minimumX) {  			minimumX = currentX + (size.Width * cosAngle);  		}  		if (currentY + (size.Height * sinAngle) > maximumY) {  			maximumY = currentY + (size.Height * sinAngle);  		}  		if (currentY + (size.Height * sinAngle) < minimumY) {  			minimumY = currentY + (size.Height * sinAngle);  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string subString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	double sx = currentX - subscriptXDisplacement;  	double sy = currentY + subscriptYDisplacement;  	var size = drawText (sx' sy' subString' subscriptFontSize);  	if (currentX + (size.Width * cosAngle) > maximumX) {  		maximumX = currentX + (size.Width * cosAngle);  	}  	if (currentX + (size.Width * cosAngle) < minimumX) {  		minimumX = currentX + (size.Width * cosAngle);  	}  	if (currentY + (size.Height * sinAngle) > maximumY) {  		maximumY = currentY + (size.Height * sinAngle);  	}  	if (currentY + (size.Height * sinAngle) < minimumY) {  		minimumY = currentY + (size.Height * sinAngle);  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string subString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	double sx = currentX - subscriptXDisplacement;  	double sy = currentY + subscriptYDisplacement;  	var size = drawText (sx' sy' subString' subscriptFontSize);  	if (currentX + (size.Width * cosAngle) > maximumX) {  		maximumX = currentX + (size.Width * cosAngle);  	}  	if (currentX + (size.Width * cosAngle) < minimumX) {  		minimumX = currentX + (size.Width * cosAngle);  	}  	if (currentY + (size.Height * sinAngle) > maximumY) {  		maximumY = currentY + (size.Height * sinAngle);  	}  	if (currentY + (size.Height * sinAngle) < minimumY) {  		minimumY = currentY + (size.Height * sinAngle);  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: currentX = maximumX + (2 * cosAngle);  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: currentY = maximumY + (2 * sinAngle);  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: currentX += (size2.Width + 2) * cosAngle;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: currentY += (size2.Height + 2) * sinAngle;  
Magic Number,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawLineSegments,The following statement contains a magic number: for (int i = 0; i + 1 < points.Count; i += 2) {  	this.DrawLine (new[] {  		points [i]'  		points [i + 1]  	}' stroke' thickness' dashArray' lineJoin' aliased);  }  
Magic Number,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,DrawLineSegments,The following statement contains a magic number: i += 2
Magic Number,OxyPlot,RenderContextBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderContextBase.cs,CreateEllipse,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t = Math.PI * 2 * i / n;  	points [i] = new ScreenPoint (cx + (Math.Cos (t) * dx)' cy + (Math.Sin (t) * dy));  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedLineSegments,The following statement contains a magic number: for (int i = 0; i + 1 < points.Count; i += 2) {  	var s0 = points [i];  	var s1 = points [i + 1];  	if (clipping.ClipLine (ref s0' ref s1)) {  		clippedPoints.Add (s0);  		clippedPoints.Add (s1);  	}  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedLineSegments,The following statement contains a magic number: i += 2
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedEllipse,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double a = Math.PI * 2 * i / (n - 1);  	points [i] = new ScreenPoint (cx + (rx * Math.Cos (a))' cy + (ry * Math.Sin (a)));  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawClippedEllipse,The following statement contains a magic number: rc.DrawClippedPolygon (clippingRectangle' points' 4' fill' stroke' thickness);  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMarkers,The following statement contains a magic number: foreach (var p in markerPoints) {  	if (resolution > 1) {  		var x = (int)((p.X - binOffset.X) / resolution);  		var y = (int)((p.Y - binOffset.Y) / resolution);  		uint hash = (uint)(x << 16) + (uint)y;  		if (hashset.ContainsKey (hash)) {  			i++;  			continue;  		}  		hashset.Add (hash' true);  	}  	bool outside = p.x < minx || p.x > maxx || p.y < miny || p.y > maxy;  	if (!outside) {  		int j = i < markerSize.Count ? i : 0;  		AddMarkerGeometry (p' markerType' markerOutline' markerSize [j]' ellipses' rects' polygons' lines);  	}  	i++;  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,DrawMarkers,The following statement contains a magic number: if (resolution > 1) {  	var x = (int)((p.X - binOffset.X) / resolution);  	var y = (int)((p.Y - binOffset.Y) / resolution);  	uint hash = (uint)(x << 16) + (uint)y;  	if (hashset.ContainsKey (hash)) {  		i++;  		continue;  	}  	hashset.Add (hash' true);  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,EnsureNonEmptyLineIsVisible,The following statement contains a magic number: if (pts.Count == 2) {  	if (pts [0].DistanceTo (pts [1]) < 1) {  		// Modify to a small horizontal line to make sure it is being rendered  		pts [1] = new ScreenPoint (pts [0].X + 1' pts [0].Y);  		pts [0] = new ScreenPoint (pts [0].X - 1' pts [0].Y);  	}  }  
Magic Number,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,XkcdRenderingDecorator,The following statement contains a magic number: this.DistortionFactor = 7;  
Magic Number,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,XkcdRenderingDecorator,The following statement contains a magic number: this.InterpolationDistance = 10;  
Magic Number,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,XkcdRenderingDecorator,The following statement contains a magic number: this.ThicknessScale = 2;  
Magic Number,OxyPlot,XkcdRenderingDecorator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\XkcdRenderingDecorator.cs,Distort,The following statement contains a magic number: randomNumbers = this.ApplyMovingAverage (randomNumbers' 5);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetColor,The following statement contains a magic number: doc.SetColor (c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetColor,The following statement contains a magic number: doc.SetColor (c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetColor,The following statement contains a magic number: doc.SetColor (c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetColor,The following statement contains a magic number: doc.SetStrokeAlpha (c.A / 255.0);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetFillColor,The following statement contains a magic number: doc.SetFillColor (c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetFillColor,The following statement contains a magic number: doc.SetFillColor (c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetFillColor,The following statement contains a magic number: doc.SetFillColor (c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,OxyPlot,PortableDocumentExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentExtensions.cs,SetFillColor,The following statement contains a magic number: doc.SetFillAlpha (c.A / 255.0);  
Magic Number,OxyPlot,PortableDocumentFont,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentFont.cs,Measure,The following statement contains a magic number: width = w * fontSize / 1000;  
Magic Number,OxyPlot,PortableDocumentFont,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentFont.cs,Measure,The following statement contains a magic number: height = (this.Ascent - this.Descent) * fontSize / 1000;  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: this.doc.SetFont (fontFamily' fontSize / 96 * 72' fontWeight > 500);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: this.doc.SetFont (fontFamily' fontSize / 96 * 72' fontWeight > 500);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: this.doc.SetFont (fontFamily' fontSize / 96 * 72' fontWeight > 500);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: if (halign == HorizontalAlignment.Center) {  	dx = -width / 2;  }  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: dx = -width / 2;  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Middle) {  	dy = -height / 2;  }  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: dy = -height / 2;  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,DrawText,The following statement contains a magic number: if (Math.Abs (rotate) > 1e-6) {  	this.doc.Rotate (-rotate);  }  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,MeasureText,The following statement contains a magic number: this.doc.SetFont (fontFamily' fontSize / 96 * 72' fontWeight > 500);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,MeasureText,The following statement contains a magic number: this.doc.SetFont (fontFamily' fontSize / 96 * 72' fontWeight > 500);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,MeasureText,The following statement contains a magic number: this.doc.SetFont (fontFamily' fontSize / 96 * 72' fontWeight > 500);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,SetLineWidth,The following statement contains a magic number: this.doc.SetLineWidth (thickness / 96 * 72);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,SetLineWidth,The following statement contains a magic number: this.doc.SetLineWidth (thickness / 96 * 72);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,SetLineDashPattern,The following statement contains a magic number: this.doc.SetLineDashPattern (dashArray.Select (d => d / 96 * 72).ToArray ()' dashPhase / 96 * 72);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,SetLineDashPattern,The following statement contains a magic number: this.doc.SetLineDashPattern (dashArray.Select (d => d / 96 * 72).ToArray ()' dashPhase / 96 * 72);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,SetLineDashPattern,The following statement contains a magic number: this.doc.SetLineDashPattern (dashArray.Select (d => d / 96 * 72).ToArray ()' dashPhase / 96 * 72);  
Magic Number,OxyPlot,PdfRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PdfRenderContext.cs,SetLineDashPattern,The following statement contains a magic number: this.doc.SetLineDashPattern (dashArray.Select (d => d / 96 * 72).ToArray ()' dashPhase / 96 * 72);  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,PortableDocument,The following statement contains a magic number: this.currentFontSize = 12;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,DrawCircle,The following statement contains a magic number: this.DrawEllipse (x - r' y - r' r * 2' r * 2' fill);  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,DrawCircle,The following statement contains a magic number: this.DrawEllipse (x - r' y - r' r * 2' r * 2' fill);  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,FillCircle,The following statement contains a magic number: this.FillEllipse (x - r' y - r' r * 2' r * 2);  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,FillCircle,The following statement contains a magic number: this.FillEllipse (x - r' y - r' r * 2' r * 2);  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,DrawText,The following statement contains a magic number: y = y - (this.currentFont.Descent * this.currentFontSize / 1000);  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: switch (pageSize) {  case PageSize.A4:  	shortLength = 595;  	longLength = 842;  	break;  case PageSize.A3:  	shortLength = 842;  	longLength = 1190;  	break;  case PageSize.Letter:  	shortLength = 612;  	longLength = 792;  	break;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: switch (pageSize) {  case PageSize.A4:  	shortLength = 595;  	longLength = 842;  	break;  case PageSize.A3:  	shortLength = 842;  	longLength = 1190;  	break;  case PageSize.Letter:  	shortLength = 612;  	longLength = 792;  	break;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: switch (pageSize) {  case PageSize.A4:  	shortLength = 595;  	longLength = 842;  	break;  case PageSize.A3:  	shortLength = 842;  	longLength = 1190;  	break;  case PageSize.Letter:  	shortLength = 612;  	longLength = 792;  	break;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: switch (pageSize) {  case PageSize.A4:  	shortLength = 595;  	longLength = 842;  	break;  case PageSize.A3:  	shortLength = 842;  	longLength = 1190;  	break;  case PageSize.Letter:  	shortLength = 612;  	longLength = 792;  	break;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: switch (pageSize) {  case PageSize.A4:  	shortLength = 595;  	longLength = 842;  	break;  case PageSize.A3:  	shortLength = 842;  	longLength = 1190;  	break;  case PageSize.Letter:  	shortLength = 612;  	longLength = 792;  	break;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: switch (pageSize) {  case PageSize.A4:  	shortLength = 595;  	longLength = 842;  	break;  case PageSize.A3:  	shortLength = 842;  	longLength = 1190;  	break;  case PageSize.Letter:  	shortLength = 612;  	longLength = 792;  	break;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: shortLength = 595;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: longLength = 842;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: shortLength = 842;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: longLength = 1190;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: shortLength = 612;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following statement contains a magic number: longLength = 792;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: for (var i = encodedBlock.Length - 1; i >= 0; i--) {  	encodedBlock [i] = (byte)((t % 85) + AsciiOffset);  	t /= 85;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: for (var i = encodedBlock.Length - 1; i >= 0; i--) {  	encodedBlock [i] = (byte)((t % 85) + AsciiOffset);  	t /= 85;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: encodedBlock [i] = (byte)((t % 85) + AsciiOffset);  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: t /= 85;  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: foreach (byte b in ba) {  	if (count >= 4 - 1) {  		tuple |= b;  		if (tuple == 0) {  			sb.Append ('z');  		}  		else {  			encodeBlock (encodedBlock.Length' tuple);  		}  		tuple = 0;  		count = 0;  	}  	else {  		tuple |= (uint)(b << (24 - (count * 8)));  		count++;  	}  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: foreach (byte b in ba) {  	if (count >= 4 - 1) {  		tuple |= b;  		if (tuple == 0) {  			sb.Append ('z');  		}  		else {  			encodeBlock (encodedBlock.Length' tuple);  		}  		tuple = 0;  		count = 0;  	}  	else {  		tuple |= (uint)(b << (24 - (count * 8)));  		count++;  	}  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: foreach (byte b in ba) {  	if (count >= 4 - 1) {  		tuple |= b;  		if (tuple == 0) {  			sb.Append ('z');  		}  		else {  			encodeBlock (encodedBlock.Length' tuple);  		}  		tuple = 0;  		count = 0;  	}  	else {  		tuple |= (uint)(b << (24 - (count * 8)));  		count++;  	}  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: if (count >= 4 - 1) {  	tuple |= b;  	if (tuple == 0) {  		sb.Append ('z');  	}  	else {  		encodeBlock (encodedBlock.Length' tuple);  	}  	tuple = 0;  	count = 0;  }  else {  	tuple |= (uint)(b << (24 - (count * 8)));  	count++;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: if (count >= 4 - 1) {  	tuple |= b;  	if (tuple == 0) {  		sb.Append ('z');  	}  	else {  		encodeBlock (encodedBlock.Length' tuple);  	}  	tuple = 0;  	count = 0;  }  else {  	tuple |= (uint)(b << (24 - (count * 8)));  	count++;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: if (count >= 4 - 1) {  	tuple |= b;  	if (tuple == 0) {  		sb.Append ('z');  	}  	else {  		encodeBlock (encodedBlock.Length' tuple);  	}  	tuple = 0;  	count = 0;  }  else {  	tuple |= (uint)(b << (24 - (count * 8)));  	count++;  }  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: tuple |= (uint)(b << (24 - (count * 8)));  
Magic Number,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,Ascii85Encode,The following statement contains a magic number: tuple |= (uint)(b << (24 - (count * 8)));  
Magic Number,OxyPlot,PortableDocumentImageUtilities,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocumentImageUtilities.cs,Convert,The following statement contains a magic number: return new PortableDocumentImage (image.Width' image.Height' 8' bits' maskBits' interpolate);  
Magic Number,OxyPlot,AxisUtilities,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\AxisUtilities.cs,CreateTickValues,The following statement contains a magic number: while (value <= to + epsilon && i < maxTicks) {  	i++;  	// try to get rid of numerical noise  	var v = Math.Round (value / step' 14) * step;  	values.Add (v);  	value += step;  }  
Magic Number,OxyPlot,StringHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\StringHelper.cs,CreateValidFileName,The following statement contains a magic number: if (validFileName.Length > 160) {  	// safe value threshold is 260  	validFileName = validFileName.Remove (156) + "...";  }  
Magic Number,OxyPlot,StringHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\StringHelper.cs,CreateValidFileName,The following statement contains a magic number: if (validFileName.Length > 160) {  	// safe value threshold is 260  	validFileName = validFileName.Remove (156) + "...";  }  
Magic Number,OxyPlot,StringHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\StringHelper.cs,CreateValidFileName,The following statement contains a magic number: validFileName = validFileName.Remove (156) + "...";  
Magic Number,OxyPlot,FractionHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\FractionHelper.cs,ConvertToFractionString,The following statement contains a magic number: for (int d = 1; d <= 64; d++) {  	double n = value * d;  	var ni = (int)Math.Round (n);  	if (Math.Abs (n - ni) < eps) {  		string nis = unitSymbol == null || ni != 1 ? ni.ToString (CultureInfo.InvariantCulture) : string.Empty;  		if (d == 1) {  			return string.Format ("{0}{1}"' nis' unitSymbol);  		}  		return string.Format ("{0}{1}/{2}"' nis' unitSymbol' d);  	}  }  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,CreateVector,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	result [i] = Math.Round (x0 + ((x1 - x0) * i / (n - 1))' 8);  }  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,CreateVector,The following statement contains a magic number: result [i] = Math.Round (x0 + ((x1 - x0) * i / (n - 1))' 8);  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,CreateVector,The following statement contains a magic number: for (int i = 0; i <= n; i++) {  	result [i] = Math.Round (x0 + (i * dx)' 8);  }  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,CreateVector,The following statement contains a magic number: result [i] = Math.Round (x0 + (i * dx)' 8);  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return items.Where (item => item != null).Aggregate (17' (current' item) => (current * 23) + item.GetHashCode ());  }  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return items.Where (item => item != null).Aggregate (17' (current' item) => (current * 23) + item.GetHashCode ());  }  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,GetHashCode,The following statement contains a magic number: return items.Where (item => item != null).Aggregate (17' (current' item) => (current * 23) + item.GetHashCode ());  
Magic Number,OxyPlot,ArrayHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\ArrayHelper.cs,GetHashCode,The following statement contains a magic number: return items.Where (item => item != null).Aggregate (17' (current' item) => (current * 23) + item.GetHashCode ());  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: m = 4
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: xh [0] = 0.5 * (x [i] + x [i + 1]);  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: yh [0] = 0.5 * (y [j] + y [j + 1]);  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (m != 4) {  	m3 = m + 1;  }  else {  	m3 = 1;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,OxyImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\OxyImage.cs,GetImageFormat,The following statement contains a magic number: if (bytes.Length >= 2 && bytes [0] == 0xFF && bytes [1] == 0xD8) {  	return ImageFormat.Jpeg;  }  
Magic Number,OxyPlot,OxyImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\OxyImage.cs,GetImageFormat,The following statement contains a magic number: if (bytes.Length >= 2 && bytes [0] == 0x42 && bytes [1] == 0x4D) {  	return ImageFormat.Bmp;  }  
Magic Number,OxyPlot,OxyImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\OxyImage.cs,GetImageFormat,The following statement contains a magic number: if (bytes.Length >= 4 && bytes [0] == 0x89 && bytes [1] == 0x50 && bytes [2] == 0x4E && bytes [3] == 0x47) {  	return ImageFormat.Png;  }  
Magic Number,OxyPlot,OxyImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\OxyImage.cs,GetImageFormat,The following statement contains a magic number: if (bytes.Length >= 4 && bytes [0] == 0x89 && bytes [1] == 0x50 && bytes [2] == 0x4E && bytes [3] == 0x47) {  	return ImageFormat.Png;  }  
Magic Number,OxyPlot,OxyImage,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\OxyImage.cs,GetImageFormat,The following statement contains a magic number: if (bytes.Length >= 4 && bytes [0] == 0x89 && bytes [1] == 0x50 && bytes [2] == 0x4E && bytes [3] == 0x47) {  	return ImageFormat.Png;  }  
Magic Number,OxyPlot,ImageEncoderOptions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\ImageEncoderOptions.cs,ImageEncoderOptions,The following statement contains a magic number: this.DpiX = 96;  
Magic Number,OxyPlot,ImageEncoderOptions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\ImageEncoderOptions.cs,ImageEncoderOptions,The following statement contains a magic number: this.DpiY = 96;  
Magic Number,OxyPlot,BmpDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpDecoder.cs,GetImageInfo,The following statement contains a magic number: r.ReadBytes (2);  
Magic Number,OxyPlot,BmpDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpDecoder.cs,GetImageInfo,The following statement contains a magic number: r.ReadBytes (4);  
Magic Number,OxyPlot,BmpDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpDecoder.cs,GetImageInfo,The following statement contains a magic number: return new OxyImageInfo {  	Width = width'  	Height = height'  	DpiX = horizontalResolution * 0.0254'  	DpiY = verticalResolution * 0.0254'  	BitsPerPixel = bitsPerPixel  };  
Magic Number,OxyPlot,BmpDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpDecoder.cs,GetImageInfo,The following statement contains a magic number: return new OxyImageInfo {  	Width = width'  	Height = height'  	DpiX = horizontalResolution * 0.0254'  	DpiY = verticalResolution * 0.0254'  	BitsPerPixel = bitsPerPixel  };  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,Encode,The following statement contains a magic number: WriteBitmapInfoHeader (w' width' height' 32' bytes.Length' this.options.DpiX' this.options.DpiY);  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,Encode,The following statement contains a magic number: if (palette.Length > 256) {  	throw new ArgumentException ("Too many colors in the palette."' "palette");  }  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,Encode,The following statement contains a magic number: WriteBitmapInfoHeader (w' width' height' 8' length' this.options.DpiX' this.options.DpiY' palette.Length);  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapInfoHeader,The following statement contains a magic number: w.Write ((uint)40);  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapInfoHeader,The following statement contains a magic number: w.Write ((uint)(dpix / 0.0254));  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapInfoHeader,The following statement contains a magic number: w.Write ((uint)(dpiy / 0.0254));  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write ((uint)108);  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write ((uint)3);  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write (new byte[3 * 3 * 4]);  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write (new byte[3 * 3 * 4]);  
Magic Number,OxyPlot,BmpEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Bmp\BmpEncoder.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write (new byte[3 * 3 * 4]);  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: inputReader.ReadBytes (8);  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: inputReader.ReadString (4);  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: while (true) {  	var length = (int)inputReader.ReadBigEndianUInt32 ();  	var type = inputReader.ReadString (4);  	if (type == "IEND") {  		break;  	}  	switch (type) {  	case "pHYs": {  		if (length != 9) {  			throw new FormatException ("Wrong length of pHYs chunk.");  		}  		var ppux = inputReader.ReadBigEndianUInt32 ();  		var ppuy = inputReader.ReadBigEndianUInt32 ();  		inputReader.ReadByte ();  		// unit  		dpix = ppux * 0.0254;  		dpiy = ppuy * 0.0254;  		break;  	}  	default: {  		ms.Position += length;  		break;  	}  	}  	// Read CRC  	inputReader.ReadBigEndianUInt32 ();  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: while (true) {  	var length = (int)inputReader.ReadBigEndianUInt32 ();  	var type = inputReader.ReadString (4);  	if (type == "IEND") {  		break;  	}  	switch (type) {  	case "pHYs": {  		if (length != 9) {  			throw new FormatException ("Wrong length of pHYs chunk.");  		}  		var ppux = inputReader.ReadBigEndianUInt32 ();  		var ppuy = inputReader.ReadBigEndianUInt32 ();  		inputReader.ReadByte ();  		// unit  		dpix = ppux * 0.0254;  		dpiy = ppuy * 0.0254;  		break;  	}  	default: {  		ms.Position += length;  		break;  	}  	}  	// Read CRC  	inputReader.ReadBigEndianUInt32 ();  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: while (true) {  	var length = (int)inputReader.ReadBigEndianUInt32 ();  	var type = inputReader.ReadString (4);  	if (type == "IEND") {  		break;  	}  	switch (type) {  	case "pHYs": {  		if (length != 9) {  			throw new FormatException ("Wrong length of pHYs chunk.");  		}  		var ppux = inputReader.ReadBigEndianUInt32 ();  		var ppuy = inputReader.ReadBigEndianUInt32 ();  		inputReader.ReadByte ();  		// unit  		dpix = ppux * 0.0254;  		dpiy = ppuy * 0.0254;  		break;  	}  	default: {  		ms.Position += length;  		break;  	}  	}  	// Read CRC  	inputReader.ReadBigEndianUInt32 ();  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: while (true) {  	var length = (int)inputReader.ReadBigEndianUInt32 ();  	var type = inputReader.ReadString (4);  	if (type == "IEND") {  		break;  	}  	switch (type) {  	case "pHYs": {  		if (length != 9) {  			throw new FormatException ("Wrong length of pHYs chunk.");  		}  		var ppux = inputReader.ReadBigEndianUInt32 ();  		var ppuy = inputReader.ReadBigEndianUInt32 ();  		inputReader.ReadByte ();  		// unit  		dpix = ppux * 0.0254;  		dpiy = ppuy * 0.0254;  		break;  	}  	default: {  		ms.Position += length;  		break;  	}  	}  	// Read CRC  	inputReader.ReadBigEndianUInt32 ();  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: switch (type) {  case "pHYs": {  	if (length != 9) {  		throw new FormatException ("Wrong length of pHYs chunk.");  	}  	var ppux = inputReader.ReadBigEndianUInt32 ();  	var ppuy = inputReader.ReadBigEndianUInt32 ();  	inputReader.ReadByte ();  	// unit  	dpix = ppux * 0.0254;  	dpiy = ppuy * 0.0254;  	break;  }  default: {  	ms.Position += length;  	break;  }  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: switch (type) {  case "pHYs": {  	if (length != 9) {  		throw new FormatException ("Wrong length of pHYs chunk.");  	}  	var ppux = inputReader.ReadBigEndianUInt32 ();  	var ppuy = inputReader.ReadBigEndianUInt32 ();  	inputReader.ReadByte ();  	// unit  	dpix = ppux * 0.0254;  	dpiy = ppuy * 0.0254;  	break;  }  default: {  	ms.Position += length;  	break;  }  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: switch (type) {  case "pHYs": {  	if (length != 9) {  		throw new FormatException ("Wrong length of pHYs chunk.");  	}  	var ppux = inputReader.ReadBigEndianUInt32 ();  	var ppuy = inputReader.ReadBigEndianUInt32 ();  	inputReader.ReadByte ();  	// unit  	dpix = ppux * 0.0254;  	dpiy = ppuy * 0.0254;  	break;  }  default: {  	ms.Position += length;  	break;  }  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: if (length != 9) {  	throw new FormatException ("Wrong length of pHYs chunk.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: dpix = ppux * 0.0254;  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,GetImageInfo,The following statement contains a magic number: dpiy = ppuy * 0.0254;  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A) {  	throw new FormatException ("Invalid signature.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A) {  	throw new FormatException ("Invalid signature.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A) {  	throw new FormatException ("Invalid signature.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A) {  	throw new FormatException ("Invalid signature.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A) {  	throw new FormatException ("Invalid signature.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (signature [0] != 0x89 || signature [1] != 0x50 || signature [2] != 0x4E || signature [3] != 0x47 || signature [4] != 0x0D || signature [5] != 0x0A || signature [6] != 0x1A || signature [7] != 0x0A) {  	throw new FormatException ("Invalid signature.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (headerLength != 13) {  	throw new FormatException ("Header not supported.");  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: if (bitDepth != 8) {  	throw new NotImplementedException ();  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: while (true) {  	var length = (int)inputReader.ReadBigEndianUInt32 ();  	var type = inputReader.ReadString (4);  	if (type == "IEND") {  		break;  	}  	switch (type) {  	case "PLTE":  		throw new NotImplementedException ();  	case "IDAT": {  		inputReader.ReadByte ();  		// method  		inputReader.ReadByte ();  		// check  		var chunkBytes = inputReader.ReadBytes (length - 6);  		var expectedCheckSum = inputReader.ReadBigEndianUInt32 ();  		var deflatedBytes = Deflate (chunkBytes);  		var actualCheckSum = PngEncoder.Adler32 (deflatedBytes);  		if (actualCheckSum != expectedCheckSum) {  			throw new FormatException ("Invalid checksum.");  		}  		ms.Write (deflatedBytes' 0' deflatedBytes.Length);  		break;  	}  	default: {  		inputReader.ReadBytes (length);  		break;  	}  	}  	inputReader.ReadBigEndianUInt32 ();  	// crc  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: while (true) {  	var length = (int)inputReader.ReadBigEndianUInt32 ();  	var type = inputReader.ReadString (4);  	if (type == "IEND") {  		break;  	}  	switch (type) {  	case "PLTE":  		throw new NotImplementedException ();  	case "IDAT": {  		inputReader.ReadByte ();  		// method  		inputReader.ReadByte ();  		// check  		var chunkBytes = inputReader.ReadBytes (length - 6);  		var expectedCheckSum = inputReader.ReadBigEndianUInt32 ();  		var deflatedBytes = Deflate (chunkBytes);  		var actualCheckSum = PngEncoder.Adler32 (deflatedBytes);  		if (actualCheckSum != expectedCheckSum) {  			throw new FormatException ("Invalid checksum.");  		}  		ms.Write (deflatedBytes' 0' deflatedBytes.Length);  		break;  	}  	default: {  		inputReader.ReadBytes (length);  		break;  	}  	}  	inputReader.ReadBigEndianUInt32 ();  	// crc  }  
Magic Number,OxyPlot,PngDecoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngDecoder.cs,Decode,The following statement contains a magic number: switch (type) {  case "PLTE":  	throw new NotImplementedException ();  case "IDAT": {  	inputReader.ReadByte ();  	// method  	inputReader.ReadByte ();  	// check  	var chunkBytes = inputReader.ReadBytes (length - 6);  	var expectedCheckSum = inputReader.ReadBigEndianUInt32 ();  	var deflatedBytes = Deflate (chunkBytes);  	var actualCheckSum = PngEncoder.Adler32 (deflatedBytes);  	if (actualCheckSum != expectedCheckSum) {  		throw new FormatException ("Invalid checksum.");  	}  	ms.Write (deflatedBytes' 0' deflatedBytes.Length);  	break;  }  default: {  	inputReader.ReadBytes (length);  	break;  }  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,PngEncoder,The following statement contains a magic number: CrcTable = new ulong[256];  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,PngEncoder,The following statement contains a magic number: for (int n = 0; n < 256; n++) {  	var c = (ulong)n;  	for (int k = 0; k < 8; k++) {  		if ((c & 1) != 0) {  			c = 0xedb88320L ^ (c >> 1);  		}  		else {  			c = c >> 1;  		}  	}  	CrcTable [n] = c;  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,PngEncoder,The following statement contains a magic number: for (int n = 0; n < 256; n++) {  	var c = (ulong)n;  	for (int k = 0; k < 8; k++) {  		if ((c & 1) != 0) {  			c = 0xedb88320L ^ (c >> 1);  		}  		else {  			c = c >> 1;  		}  	}  	CrcTable [n] = c;  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,PngEncoder,The following statement contains a magic number: for (int k = 0; k < 8; k++) {  	if ((c & 1) != 0) {  		c = 0xedb88320L ^ (c >> 1);  	}  	else {  		c = c >> 1;  	}  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,Adler32,The following statement contains a magic number: return (b << 16) | a;  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,CreateHeaderData,The following statement contains a magic number: w.Write ((byte)8);  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,CreateHeaderData,The following statement contains a magic number: w.Write ((byte)6);  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i += MaxDeflate) {  	var n = (ushort)Math.Min (bytes.Length - i' MaxDeflate);  	var last = (byte)(i + n < bytes.Length ? 0 : 1);  	w.Write (last);  	w.Write ((byte)(n & 0xFF));  	w.Write ((byte)((n >> 8) & 0xFF));  	var n2 = ~n;  	w.Write ((byte)(n2 & 0xFF));  	w.Write ((byte)((n2 >> 8) & 0xFF));  	w.Write (bytes' i' n);  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i += MaxDeflate) {  	var n = (ushort)Math.Min (bytes.Length - i' MaxDeflate);  	var last = (byte)(i + n < bytes.Length ? 0 : 1);  	w.Write (last);  	w.Write ((byte)(n & 0xFF));  	w.Write ((byte)((n >> 8) & 0xFF));  	var n2 = ~n;  	w.Write ((byte)(n2 & 0xFF));  	w.Write ((byte)((n2 >> 8) & 0xFF));  	w.Write (bytes' i' n);  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: w.Write ((byte)((n >> 8) & 0xFF));  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: w.Write ((byte)((n2 >> 8) & 0xFF));  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,UpdateCrc,The following statement contains a magic number: return data.Aggregate (crc' (current' x) => CrcTable [(current ^ x) & 0xff] ^ (current >> 8));  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [3]);  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [2]);  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [3]);  
Magic Number,OxyPlot,PngEncoder,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Png\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [2]);  
Magic Number,OxyPlot,ByteBitReader,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\ByteBitReader.cs,ByteBitReader,The following statement contains a magic number: this.bitPosition = 8;  
Magic Number,OxyPlot,ByteBitReader,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\ByteBitReader.cs,Read,The following statement contains a magic number: if (this.bitPosition == 8) {  	this.nextBits = this.input.ReadByte ();  	if (this.nextBits == -1) {  		this.isEndOfStream = true;  		return -1;  	}  	this.bitPosition = 0;  }  
Magic Number,OxyPlot,ByteBitReader,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\ByteBitReader.cs,GetBitPosition,The following statement contains a magic number: return this.bitPosition % 8;  
Magic Number,OxyPlot,ByteBitReader,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\ByteBitReader.cs,ReadByte,The following statement contains a magic number: this.bitPosition = 8;  
Magic Number,OxyPlot,CanonicalCode,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\CanonicalCode.cs,ToCodeTree,The following statement contains a magic number: for (int i = this.codeLengths.Max (); i >= 1; i--) {  	// Descend through positive code lengths  	var newNodes = new List<Node> ();  	// Add leaves for symbols with code length i  	for (int j = 0; j < this.codeLengths.Length; j++) {  		if (this.codeLengths [j] == i) {  			newNodes.Add (new Leaf (j));  		}  	}  	// Merge nodes from the previous deeper layer  	for (int j = 0; j < nodes.Count; j += 2) {  		newNodes.Add (new InternalNode (nodes [j]' nodes [j + 1]));  	}  	nodes = newNodes;  	if (nodes.Count % 2 != 0) {  		throw new Exception ("This canonical code does not represent a Huffman code tree");  	}  }  
Magic Number,OxyPlot,CanonicalCode,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\CanonicalCode.cs,ToCodeTree,The following statement contains a magic number: for (int i = this.codeLengths.Max (); i >= 1; i--) {  	// Descend through positive code lengths  	var newNodes = new List<Node> ();  	// Add leaves for symbols with code length i  	for (int j = 0; j < this.codeLengths.Length; j++) {  		if (this.codeLengths [j] == i) {  			newNodes.Add (new Leaf (j));  		}  	}  	// Merge nodes from the previous deeper layer  	for (int j = 0; j < nodes.Count; j += 2) {  		newNodes.Add (new InternalNode (nodes [j]' nodes [j + 1]));  	}  	nodes = newNodes;  	if (nodes.Count % 2 != 0) {  		throw new Exception ("This canonical code does not represent a Huffman code tree");  	}  }  
Magic Number,OxyPlot,CanonicalCode,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\CanonicalCode.cs,ToCodeTree,The following statement contains a magic number: for (int j = 0; j < nodes.Count; j += 2) {  	newNodes.Add (new InternalNode (nodes [j]' nodes [j + 1]));  }  
Magic Number,OxyPlot,CanonicalCode,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\CanonicalCode.cs,ToCodeTree,The following statement contains a magic number: j += 2
Magic Number,OxyPlot,CanonicalCode,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\CanonicalCode.cs,ToCodeTree,The following statement contains a magic number: if (nodes.Count % 2 != 0) {  	throw new Exception ("This canonical code does not represent a Huffman code tree");  }  
Magic Number,OxyPlot,CanonicalCode,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\CanonicalCode.cs,ToCodeTree,The following statement contains a magic number: if (nodes.Count != 2) {  	throw new Exception ("This canonical code does not represent a Huffman code tree");  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 0' 144' 8);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 0' 144' 8);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 144' 256' 9);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 144' 256' 9);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 144' 256' 9);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 256' 280' 7);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 256' 280' 7);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 256' 280' 7);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 280' 288' 8);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 280' 288' 8);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (llcodelens' 280' 288' 8);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (distcodelens' 0' 32' 5);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: Arrays.Fill (distcodelens' 0' 32' 5);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: this.dictionary = new CircularDictionary (32 * 1024);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: this.dictionary = new CircularDictionary (32 * 1024);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: while (true) {  	// Block header  	var isFinal = this.input.ReadNoEof () != -1;  	// bfinal  	var type = this.ReadInt (2);  	// btype  	// Decompress by type  	if (type == 0) {  		this.DecompressUncompressedBlock ();  	}  	else if (type == 1 || type == 2) {  		CodeTree litLenCode' distCode;  		if (type == 1) {  			litLenCode = FixedLiteralLengthCode;  			distCode = FixedDistanceCode;  		}  		else {  			var temp = this.DecodeHuffmanCodes ();  			litLenCode = temp [0];  			distCode = temp [1];  		}  		this.DecompressHuffmanBlock (litLenCode' distCode);  	}  	else if (type == 3) {  		throw new FormatException ("Invalid block type");  	}  	else {  		throw new NotImplementedException ();  	}  	if (isFinal) {  		break;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: while (true) {  	// Block header  	var isFinal = this.input.ReadNoEof () != -1;  	// bfinal  	var type = this.ReadInt (2);  	// btype  	// Decompress by type  	if (type == 0) {  		this.DecompressUncompressedBlock ();  	}  	else if (type == 1 || type == 2) {  		CodeTree litLenCode' distCode;  		if (type == 1) {  			litLenCode = FixedLiteralLengthCode;  			distCode = FixedDistanceCode;  		}  		else {  			var temp = this.DecodeHuffmanCodes ();  			litLenCode = temp [0];  			distCode = temp [1];  		}  		this.DecompressHuffmanBlock (litLenCode' distCode);  	}  	else if (type == 3) {  		throw new FormatException ("Invalid block type");  	}  	else {  		throw new NotImplementedException ();  	}  	if (isFinal) {  		break;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: while (true) {  	// Block header  	var isFinal = this.input.ReadNoEof () != -1;  	// bfinal  	var type = this.ReadInt (2);  	// btype  	// Decompress by type  	if (type == 0) {  		this.DecompressUncompressedBlock ();  	}  	else if (type == 1 || type == 2) {  		CodeTree litLenCode' distCode;  		if (type == 1) {  			litLenCode = FixedLiteralLengthCode;  			distCode = FixedDistanceCode;  		}  		else {  			var temp = this.DecodeHuffmanCodes ();  			litLenCode = temp [0];  			distCode = temp [1];  		}  		this.DecompressHuffmanBlock (litLenCode' distCode);  	}  	else if (type == 3) {  		throw new FormatException ("Invalid block type");  	}  	else {  		throw new NotImplementedException ();  	}  	if (isFinal) {  		break;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: if (type == 0) {  	this.DecompressUncompressedBlock ();  }  else if (type == 1 || type == 2) {  	CodeTree litLenCode' distCode;  	if (type == 1) {  		litLenCode = FixedLiteralLengthCode;  		distCode = FixedDistanceCode;  	}  	else {  		var temp = this.DecodeHuffmanCodes ();  		litLenCode = temp [0];  		distCode = temp [1];  	}  	this.DecompressHuffmanBlock (litLenCode' distCode);  }  else if (type == 3) {  	throw new FormatException ("Invalid block type");  }  else {  	throw new NotImplementedException ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: if (type == 0) {  	this.DecompressUncompressedBlock ();  }  else if (type == 1 || type == 2) {  	CodeTree litLenCode' distCode;  	if (type == 1) {  		litLenCode = FixedLiteralLengthCode;  		distCode = FixedDistanceCode;  	}  	else {  		var temp = this.DecodeHuffmanCodes ();  		litLenCode = temp [0];  		distCode = temp [1];  	}  	this.DecompressHuffmanBlock (litLenCode' distCode);  }  else if (type == 3) {  	throw new FormatException ("Invalid block type");  }  else {  	throw new NotImplementedException ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: if (type == 1 || type == 2) {  	CodeTree litLenCode' distCode;  	if (type == 1) {  		litLenCode = FixedLiteralLengthCode;  		distCode = FixedDistanceCode;  	}  	else {  		var temp = this.DecodeHuffmanCodes ();  		litLenCode = temp [0];  		distCode = temp [1];  	}  	this.DecompressHuffmanBlock (litLenCode' distCode);  }  else if (type == 3) {  	throw new FormatException ("Invalid block type");  }  else {  	throw new NotImplementedException ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: if (type == 1 || type == 2) {  	CodeTree litLenCode' distCode;  	if (type == 1) {  		litLenCode = FixedLiteralLengthCode;  		distCode = FixedDistanceCode;  	}  	else {  		var temp = this.DecodeHuffmanCodes ();  		litLenCode = temp [0];  		distCode = temp [1];  	}  	this.DecompressHuffmanBlock (litLenCode' distCode);  }  else if (type == 3) {  	throw new FormatException ("Invalid block type");  }  else {  	throw new NotImplementedException ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,Deflate,The following statement contains a magic number: if (type == 3) {  	throw new FormatException ("Invalid block type");  }  else {  	throw new NotImplementedException ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [16] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [16] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [17] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [17] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [18] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [18] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [0] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < numCodeLenCodes - 4; i++) {  	if (i % 2 == 0) {  		codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  	}  	else {  		codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (i % 2 == 0) {  	codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  }  else {  	codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (i % 2 == 0) {  	codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  }  else {  	codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (i % 2 == 0) {  	codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  }  else {  	codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (i % 2 == 0) {  	codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  }  else {  	codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (i % 2 == 0) {  	codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  }  else {  	codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (i % 2 == 0) {  	codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  }  else {  	codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (i % 2 == 0) {  	codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  }  else {  	codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [8 + (i / 2)] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: codeLenCodeLen [7 - (i / 2)] = this.ReadInt (3);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: for (var i = 0; i < codeLens.Length; i++) {  	if (runLen > 0) {  		codeLens [i] = runVal;  		runLen--;  	}  	else {  		var sym = this.DecodeSymbol (codeLenCode);  		if (sym < 16) {  			codeLens [i] = sym;  			runVal = sym;  		}  		else {  			if (sym == 16) {  				if (runVal == -1) {  					throw new FormatException ("No code length value to copy");  				}  				runLen = this.ReadInt (2) + 3;  			}  			else if (sym == 17) {  				runVal = 0;  				runLen = this.ReadInt (3) + 3;  			}  			else if (sym == 18) {  				runVal = 0;  				runLen = this.ReadInt (7) + 11;  			}  			else {  				throw new Exception ();  			}  			i--;  		}  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (runLen > 0) {  	codeLens [i] = runVal;  	runLen--;  }  else {  	var sym = this.DecodeSymbol (codeLenCode);  	if (sym < 16) {  		codeLens [i] = sym;  		runVal = sym;  	}  	else {  		if (sym == 16) {  			if (runVal == -1) {  				throw new FormatException ("No code length value to copy");  			}  			runLen = this.ReadInt (2) + 3;  		}  		else if (sym == 17) {  			runVal = 0;  			runLen = this.ReadInt (3) + 3;  		}  		else if (sym == 18) {  			runVal = 0;  			runLen = this.ReadInt (7) + 11;  		}  		else {  			throw new Exception ();  		}  		i--;  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym < 16) {  	codeLens [i] = sym;  	runVal = sym;  }  else {  	if (sym == 16) {  		if (runVal == -1) {  			throw new FormatException ("No code length value to copy");  		}  		runLen = this.ReadInt (2) + 3;  	}  	else if (sym == 17) {  		runVal = 0;  		runLen = this.ReadInt (3) + 3;  	}  	else if (sym == 18) {  		runVal = 0;  		runLen = this.ReadInt (7) + 11;  	}  	else {  		throw new Exception ();  	}  	i--;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 16) {  	if (runVal == -1) {  		throw new FormatException ("No code length value to copy");  	}  	runLen = this.ReadInt (2) + 3;  }  else if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: runLen = this.ReadInt (2) + 3;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: runLen = this.ReadInt (2) + 3;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 17) {  	runVal = 0;  	runLen = this.ReadInt (3) + 3;  }  else if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: runLen = this.ReadInt (3) + 3;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: runLen = this.ReadInt (3) + 3;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: if (sym == 18) {  	runVal = 0;  	runLen = this.ReadInt (7) + 11;  }  else {  	throw new Exception ();  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: runLen = this.ReadInt (7) + 11;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeHuffmanCodes,The following statement contains a magic number: runLen = this.ReadInt (7) + 11;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecompressHuffmanBlock,The following statement contains a magic number: while (true) {  	var sym = this.DecodeSymbol (litLenCode);  	if (sym == 256) {  		// End of block  		break;  	}  	if (sym < 256) {  		// Literal byte  		this.output.Write ((byte)sym);  		this.dictionary.Append (sym);  	}  	else {  		// Length and distance for copying  		var len = this.DecodeRunLength (sym);  		if (distCode == null) {  			throw new FormatException ("Length symbol encountered with empty distance code");  		}  		var distSym = this.DecodeSymbol (distCode);  		var dist = this.DecodeDistance (distSym);  		this.dictionary.Copy (dist' len' this.output);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecompressHuffmanBlock,The following statement contains a magic number: while (true) {  	var sym = this.DecodeSymbol (litLenCode);  	if (sym == 256) {  		// End of block  		break;  	}  	if (sym < 256) {  		// Literal byte  		this.output.Write ((byte)sym);  		this.dictionary.Append (sym);  	}  	else {  		// Length and distance for copying  		var len = this.DecodeRunLength (sym);  		if (distCode == null) {  			throw new FormatException ("Length symbol encountered with empty distance code");  		}  		var distSym = this.DecodeSymbol (distCode);  		var dist = this.DecodeDistance (distSym);  		this.dictionary.Copy (dist' len' this.output);  	}  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecompressHuffmanBlock,The following statement contains a magic number: if (sym == 256) {  	// End of block  	break;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecompressHuffmanBlock,The following statement contains a magic number: if (sym < 256) {  	// Literal byte  	this.output.Write ((byte)sym);  	this.dictionary.Append (sym);  }  else {  	// Length and distance for copying  	var len = this.DecodeRunLength (sym);  	if (distCode == null) {  		throw new FormatException ("Length symbol encountered with empty distance code");  	}  	var distSym = this.DecodeSymbol (distCode);  	var dist = this.DecodeDistance (distSym);  	this.dictionary.Copy (dist' len' this.output);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym < 257 || sym > 285) {  	throw new FormatException ("Invalid run length symbol: " + sym);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym < 257 || sym > 285) {  	throw new FormatException ("Invalid run length symbol: " + sym);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 264) {  	return sym - 254;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 264) {  	return sym - 254;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: return sym - 254;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 284) {  	var i = (sym - 261) / 4;  	// Number of extra bits to read  	return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 284) {  	var i = (sym - 261) / 4;  	// Number of extra bits to read  	return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 284) {  	var i = (sym - 261) / 4;  	// Number of extra bits to read  	return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 284) {  	var i = (sym - 261) / 4;  	// Number of extra bits to read  	return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 284) {  	var i = (sym - 261) / 4;  	// Number of extra bits to read  	return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 284) {  	var i = (sym - 261) / 4;  	// Number of extra bits to read  	return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: if (sym <= 284) {  	var i = (sym - 261) / 4;  	// Number of extra bits to read  	return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: return ((((sym - 265) % 4) + 4) << i) + 3 + this.ReadInt (i);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeRunLength,The following statement contains a magic number: return 258;  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeDistance,The following statement contains a magic number: if (sym <= 3) {  	return sym + 1;  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeDistance,The following statement contains a magic number: if (sym <= 29) {  	var i = (sym / 2) - 1;  	// Number of extra bits to read  	return (((sym % 2) + 2) << i) + 1 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeDistance,The following statement contains a magic number: if (sym <= 29) {  	var i = (sym / 2) - 1;  	// Number of extra bits to read  	return (((sym % 2) + 2) << i) + 1 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeDistance,The following statement contains a magic number: if (sym <= 29) {  	var i = (sym / 2) - 1;  	// Number of extra bits to read  	return (((sym % 2) + 2) << i) + 1 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeDistance,The following statement contains a magic number: if (sym <= 29) {  	var i = (sym / 2) - 1;  	// Number of extra bits to read  	return (((sym % 2) + 2) << i) + 1 + this.ReadInt (i);  }  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeDistance,The following statement contains a magic number: return (((sym % 2) + 2) << i) + 1 + this.ReadInt (i);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,DecodeDistance,The following statement contains a magic number: return (((sym % 2) + 2) << i) + 1 + this.ReadInt (i);  
Magic Number,OxyPlot,Deflate,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Imaging\Deflate\Deflate.cs,ReadInt,The following statement contains a magic number: if (numBits < 0 || numBits >= 32) {  	throw new ArgumentException ();  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: for (var i = lines.Length - 1; i >= 0; i--) {  	var line = lines [i];  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: for (var i = lines.Length - 1; i >= 0; i--) {  	var line = lines [i];  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p += new ScreenVector (Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: foreach (var line in lines) {  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: foreach (var line in lines) {  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p += new ScreenVector (-Math.Sin (rotate / 180.0 * Math.PI) * size.Height' Math.Cos (rotate / 180.0 * Math.PI) * size.Height);  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (fill.IsInvisible ()) {  	style.AppendFormat ("fill:none;");  }  else {  	style.AppendFormat ("fill:{0};"' this.ColorToString (fill));  	if (fill.A != 0xFF) {  		style.AppendFormat (CultureInfo.InvariantCulture' "fill-opacity:{0};"' fill.A / 255.0);  	}  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (fill.A != 0xFF) {  	style.AppendFormat (CultureInfo.InvariantCulture' "fill-opacity:{0};"' fill.A / 255.0);  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: style.AppendFormat (CultureInfo.InvariantCulture' "fill-opacity:{0};"' fill.A / 255.0);  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (stroke.IsInvisible ()) {  	style.AppendFormat ("stroke:none;");  }  else {  	string formatString = "stroke:{0};stroke-width:{1:" + this.NumberFormat + "}";  	style.AppendFormat (CultureInfo.InvariantCulture' formatString' this.ColorToString (stroke)' thickness);  	switch (lineJoin) {  	case OxyPenLineJoin.Round:  		style.AppendFormat (";stroke-linejoin:round");  		break;  	case OxyPenLineJoin.Bevel:  		style.AppendFormat (";stroke-linejoin:bevel");  		break;  	}  	if (stroke.A != 0xFF) {  		style.AppendFormat (CultureInfo.InvariantCulture' ";stroke-opacity:{0}"' stroke.A / 255.0);  	}  	if (dashArray != null && dashArray.Length > 0) {  		style.Append (";stroke-dasharray:");  		for (int i = 0; i < dashArray.Length; i++) {  			style.AppendFormat (CultureInfo.InvariantCulture' "{0}{1}"' i > 0 ? "'" : string.Empty' dashArray [i]);  		}  	}  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (stroke.A != 0xFF) {  	style.AppendFormat (CultureInfo.InvariantCulture' ";stroke-opacity:{0}"' stroke.A / 255.0);  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: style.AppendFormat (CultureInfo.InvariantCulture' ";stroke-opacity:{0}"' stroke.A / 255.0);  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("cx"' x + (width / 2));  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("cy"' y + (height / 2));  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("rx"' width / 2);  
Magic Number,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("ry"' height / 2);  
Magic Number,OxyPlot,SvgExporter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgExporter.cs,SvgExporter,The following statement contains a magic number: this.Width = 600;  
Magic Number,OxyPlot,SvgExporter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgExporter.cs,SvgExporter,The following statement contains a magic number: this.Height = 400;  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerManipulator.cs,Delta,The following statement contains a magic number: if (this.currentSeries == null || !this.LockToInitialSeries) {  	// get the nearest  	this.currentSeries = this.PlotView.ActualModel != null ? this.PlotView.ActualModel.GetSeriesFromPoint (e.Position' 20) : null;  }  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerManipulator.cs,Delta,The following statement contains a magic number: this.currentSeries = this.PlotView.ActualModel != null ? this.PlotView.ActualModel.GetSeriesFromPoint (e.Position' 20) : null;  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerManipulator.cs,GetNearestHit,The following statement contains a magic number: if (snap || pointsOnly) {  	var result = s.GetNearestPoint (point' false);  	if (result != null) {  		if (result.Position.DistanceTo (point) < 20) {  			return result;  		}  	}  }  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerManipulator.cs,GetNearestHit,The following statement contains a magic number: if (result != null) {  	if (result.Position.DistanceTo (point) < 20) {  		return result;  	}  }  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\TrackerManipulator.cs,GetNearestHit,The following statement contains a magic number: if (result.Position.DistanceTo (point) < 20) {  	return result;  }  
Magic Number,OxyPlot,ZoomRectangleManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\ZoomRectangleManipulator.cs,Completed,The following statement contains a magic number: if (this.zoomRectangle.Width > 10 && this.zoomRectangle.Height > 10) {  	var p0 = this.InverseTransform (this.zoomRectangle.Left' this.zoomRectangle.Top);  	var p1 = this.InverseTransform (this.zoomRectangle.Right' this.zoomRectangle.Bottom);  	if (this.XAxis != null) {  		this.XAxis.Zoom (p0.X' p1.X);  	}  	if (this.YAxis != null) {  		this.YAxis.Zoom (p0.Y' p1.Y);  	}  	this.PlotView.InvalidatePlot ();  }  
Magic Number,OxyPlot,ZoomRectangleManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\ZoomRectangleManipulator.cs,Completed,The following statement contains a magic number: if (this.zoomRectangle.Width > 10 && this.zoomRectangle.Height > 10) {  	var p0 = this.InverseTransform (this.zoomRectangle.Left' this.zoomRectangle.Top);  	var p1 = this.InverseTransform (this.zoomRectangle.Right' this.zoomRectangle.Bottom);  	if (this.XAxis != null) {  		this.XAxis.Zoom (p0.X' p1.X);  	}  	if (this.YAxis != null) {  		this.YAxis.Zoom (p0.Y' p1.Y);  	}  	this.PlotView.InvalidatePlot ();  }  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: if (this.FineControl) {  	scale *= 3;  }  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: scale *= 3;  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: if (scale < 0.1) {  	scale = 0.1;  }  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: if (scale < 0.1) {  	scale = 0.1;  }  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotController\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: scale = 0.1;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: if (this.LegendPlacement == LegendPlacement.Outside) {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotAndAxisArea.Left - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotAndAxisArea.Right + this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotAndAxisArea.Top - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotAndAxisArea.Bottom + this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  else {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: if (this.LegendPlacement == LegendPlacement.Outside) {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotAndAxisArea.Left - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotAndAxisArea.Right + this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotAndAxisArea.Top - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotAndAxisArea.Bottom + this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  else {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: if (this.LegendPlacement == LegendPlacement.Outside) {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotAndAxisArea.Left - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotAndAxisArea.Right + this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotAndAxisArea.Top - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotAndAxisArea.Bottom + this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  else {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: if (this.LegendPlacement == LegendPlacement.Outside) {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotAndAxisArea.Left - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotAndAxisArea.Right + this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotAndAxisArea.Top - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotAndAxisArea.Bottom + this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  else {  	switch (this.LegendPosition) {  	case LegendPosition.LeftTop:  	case LegendPosition.LeftMiddle:  	case LegendPosition.LeftBottom:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.RightTop:  	case LegendPosition.RightMiddle:  	case LegendPosition.RightBottom:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.TopLeft:  	case LegendPosition.TopCenter:  	case LegendPosition.TopRight:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.BottomLeft:  	case LegendPosition.BottomCenter:  	case LegendPosition.BottomRight:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	}  	switch (this.LegendPosition) {  	case LegendPosition.TopLeft:  	case LegendPosition.BottomLeft:  		left = this.PlotArea.Left + this.LegendMargin;  		break;  	case LegendPosition.TopRight:  	case LegendPosition.BottomRight:  		left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  		break;  	case LegendPosition.LeftTop:  	case LegendPosition.RightTop:  		top = this.PlotArea.Top + this.LegendMargin;  		break;  	case LegendPosition.LeftBottom:  	case LegendPosition.RightBottom:  		top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  		break;  	case LegendPosition.LeftMiddle:  	case LegendPosition.RightMiddle:  		top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  		break;  	case LegendPosition.TopCenter:  	case LegendPosition.BottomCenter:  		left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  		break;  	}  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: switch (this.LegendPosition) {  case LegendPosition.TopLeft:  case LegendPosition.BottomLeft:  	left = this.PlotArea.Left;  	break;  case LegendPosition.TopRight:  case LegendPosition.BottomRight:  	left = this.PlotArea.Right - legendSize.Width;  	break;  case LegendPosition.LeftTop:  case LegendPosition.RightTop:  	top = this.PlotArea.Top;  	break;  case LegendPosition.LeftBottom:  case LegendPosition.RightBottom:  	top = this.PlotArea.Bottom - legendSize.Height;  	break;  case LegendPosition.LeftMiddle:  case LegendPosition.RightMiddle:  	top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  	break;  case LegendPosition.TopCenter:  case LegendPosition.BottomCenter:  	left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: switch (this.LegendPosition) {  case LegendPosition.TopLeft:  case LegendPosition.BottomLeft:  	left = this.PlotArea.Left;  	break;  case LegendPosition.TopRight:  case LegendPosition.BottomRight:  	left = this.PlotArea.Right - legendSize.Width;  	break;  case LegendPosition.LeftTop:  case LegendPosition.RightTop:  	top = this.PlotArea.Top;  	break;  case LegendPosition.LeftBottom:  case LegendPosition.RightBottom:  	top = this.PlotArea.Bottom - legendSize.Height;  	break;  case LegendPosition.LeftMiddle:  case LegendPosition.RightMiddle:  	top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  	break;  case LegendPosition.TopCenter:  case LegendPosition.BottomCenter:  	left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: switch (this.LegendPosition) {  case LegendPosition.TopLeft:  case LegendPosition.BottomLeft:  	left = this.PlotArea.Left + this.LegendMargin;  	break;  case LegendPosition.TopRight:  case LegendPosition.BottomRight:  	left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  	break;  case LegendPosition.LeftTop:  case LegendPosition.RightTop:  	top = this.PlotArea.Top + this.LegendMargin;  	break;  case LegendPosition.LeftBottom:  case LegendPosition.RightBottom:  	top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  	break;  case LegendPosition.LeftMiddle:  case LegendPosition.RightMiddle:  	top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  	break;  case LegendPosition.TopCenter:  case LegendPosition.BottomCenter:  	left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: switch (this.LegendPosition) {  case LegendPosition.TopLeft:  case LegendPosition.BottomLeft:  	left = this.PlotArea.Left + this.LegendMargin;  	break;  case LegendPosition.TopRight:  case LegendPosition.BottomRight:  	left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  	break;  case LegendPosition.LeftTop:  case LegendPosition.RightTop:  	top = this.PlotArea.Top + this.LegendMargin;  	break;  case LegendPosition.LeftBottom:  case LegendPosition.RightBottom:  	top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  	break;  case LegendPosition.LeftMiddle:  case LegendPosition.RightMiddle:  	top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  	break;  case LegendPosition.TopCenter:  case LegendPosition.BottomCenter:  	left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following statement contains a magic number: left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: switch (this.LegendItemAlignment) {  case HorizontalAlignment.Center:  	x = (rect.Left + rect.Right) / 2;  	if (this.LegendSymbolPlacement == LegendSymbolPlacement.Left) {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	else {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	break;  case HorizontalAlignment.Right:  	x = rect.Right;  	// if (LegendSymbolPlacement == LegendSymbolPlacement.Right)  	x -= this.LegendSymbolLength + this.LegendSymbolMargin;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: switch (this.LegendItemAlignment) {  case HorizontalAlignment.Center:  	x = (rect.Left + rect.Right) / 2;  	if (this.LegendSymbolPlacement == LegendSymbolPlacement.Left) {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	else {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	break;  case HorizontalAlignment.Right:  	x = rect.Right;  	// if (LegendSymbolPlacement == LegendSymbolPlacement.Right)  	x -= this.LegendSymbolLength + this.LegendSymbolMargin;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: switch (this.LegendItemAlignment) {  case HorizontalAlignment.Center:  	x = (rect.Left + rect.Right) / 2;  	if (this.LegendSymbolPlacement == LegendSymbolPlacement.Left) {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	else {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	break;  case HorizontalAlignment.Right:  	x = rect.Right;  	// if (LegendSymbolPlacement == LegendSymbolPlacement.Right)  	x -= this.LegendSymbolLength + this.LegendSymbolMargin;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: x = (rect.Left + rect.Right) / 2;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: if (this.LegendSymbolPlacement == LegendSymbolPlacement.Left) {  	x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  }  else {  	x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: if (this.LegendSymbolPlacement == LegendSymbolPlacement.Left) {  	x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  }  else {  	x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: switch (this.LegendItemAlignment) {  case HorizontalAlignment.Center:  	x0 = x - (textSize.Width * 0.5);  	break;  case HorizontalAlignment.Right:  	x0 = x - textSize.Width;  	break;  }  
Magic Number,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following statement contains a magic number: x0 = x - (textSize.Width * 0.5);  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,ScatterErrorSeries,The following statement contains a magic number: this.ErrorBarStopWidth = 4.0;  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: foreach (var point in this.ActualPointsList) {  	if (point == null) {  		continue;  	}  	if (point.ErrorX > 0.0) {  		var leftErrorPoint = this.XAxis.Transform (point.X - (point.ErrorX * 0.5)' point.Y' this.YAxis);  		var rightErrorPoint = this.XAxis.Transform (point.X + (point.ErrorX * 0.5)' point.Y' this.YAxis);  		if (Math.Abs (rightErrorPoint.X - leftErrorPoint.X) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (leftErrorPoint);  			segments.Add (rightErrorPoint);  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y + this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y + this.ErrorBarStopWidth));  		}  	}  	if (point.ErrorY > 0.0) {  		var topErrorPoint = this.XAxis.Transform (point.X' point.Y - (point.ErrorY * 0.5)' this.YAxis);  		var bottomErrorPoint = this.XAxis.Transform (point.X' point.Y + (point.ErrorY * 0.5)' this.YAxis);  		if (Math.Abs (topErrorPoint.Y - bottomErrorPoint.Y) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (topErrorPoint);  			segments.Add (bottomErrorPoint);  			segments.Add (new ScreenPoint (topErrorPoint.X - this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (topErrorPoint.X + this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X - this.ErrorBarStopWidth' bottomErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X + this.ErrorBarStopWidth' bottomErrorPoint.Y));  		}  	}  }  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: foreach (var point in this.ActualPointsList) {  	if (point == null) {  		continue;  	}  	if (point.ErrorX > 0.0) {  		var leftErrorPoint = this.XAxis.Transform (point.X - (point.ErrorX * 0.5)' point.Y' this.YAxis);  		var rightErrorPoint = this.XAxis.Transform (point.X + (point.ErrorX * 0.5)' point.Y' this.YAxis);  		if (Math.Abs (rightErrorPoint.X - leftErrorPoint.X) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (leftErrorPoint);  			segments.Add (rightErrorPoint);  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y + this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y + this.ErrorBarStopWidth));  		}  	}  	if (point.ErrorY > 0.0) {  		var topErrorPoint = this.XAxis.Transform (point.X' point.Y - (point.ErrorY * 0.5)' this.YAxis);  		var bottomErrorPoint = this.XAxis.Transform (point.X' point.Y + (point.ErrorY * 0.5)' this.YAxis);  		if (Math.Abs (topErrorPoint.Y - bottomErrorPoint.Y) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (topErrorPoint);  			segments.Add (bottomErrorPoint);  			segments.Add (new ScreenPoint (topErrorPoint.X - this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (topErrorPoint.X + this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X - this.ErrorBarStopWidth' bottomErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X + this.ErrorBarStopWidth' bottomErrorPoint.Y));  		}  	}  }  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: foreach (var point in this.ActualPointsList) {  	if (point == null) {  		continue;  	}  	if (point.ErrorX > 0.0) {  		var leftErrorPoint = this.XAxis.Transform (point.X - (point.ErrorX * 0.5)' point.Y' this.YAxis);  		var rightErrorPoint = this.XAxis.Transform (point.X + (point.ErrorX * 0.5)' point.Y' this.YAxis);  		if (Math.Abs (rightErrorPoint.X - leftErrorPoint.X) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (leftErrorPoint);  			segments.Add (rightErrorPoint);  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y + this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y + this.ErrorBarStopWidth));  		}  	}  	if (point.ErrorY > 0.0) {  		var topErrorPoint = this.XAxis.Transform (point.X' point.Y - (point.ErrorY * 0.5)' this.YAxis);  		var bottomErrorPoint = this.XAxis.Transform (point.X' point.Y + (point.ErrorY * 0.5)' this.YAxis);  		if (Math.Abs (topErrorPoint.Y - bottomErrorPoint.Y) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (topErrorPoint);  			segments.Add (bottomErrorPoint);  			segments.Add (new ScreenPoint (topErrorPoint.X - this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (topErrorPoint.X + this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X - this.ErrorBarStopWidth' bottomErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X + this.ErrorBarStopWidth' bottomErrorPoint.Y));  		}  	}  }  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: foreach (var point in this.ActualPointsList) {  	if (point == null) {  		continue;  	}  	if (point.ErrorX > 0.0) {  		var leftErrorPoint = this.XAxis.Transform (point.X - (point.ErrorX * 0.5)' point.Y' this.YAxis);  		var rightErrorPoint = this.XAxis.Transform (point.X + (point.ErrorX * 0.5)' point.Y' this.YAxis);  		if (Math.Abs (rightErrorPoint.X - leftErrorPoint.X) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (leftErrorPoint);  			segments.Add (rightErrorPoint);  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y + this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y - this.ErrorBarStopWidth));  			segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y + this.ErrorBarStopWidth));  		}  	}  	if (point.ErrorY > 0.0) {  		var topErrorPoint = this.XAxis.Transform (point.X' point.Y - (point.ErrorY * 0.5)' this.YAxis);  		var bottomErrorPoint = this.XAxis.Transform (point.X' point.Y + (point.ErrorY * 0.5)' this.YAxis);  		if (Math.Abs (topErrorPoint.Y - bottomErrorPoint.Y) > this.MarkerSize * this.MinimumErrorSize) {  			segments.Add (topErrorPoint);  			segments.Add (bottomErrorPoint);  			segments.Add (new ScreenPoint (topErrorPoint.X - this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (topErrorPoint.X + this.ErrorBarStopWidth' topErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X - this.ErrorBarStopWidth' bottomErrorPoint.Y));  			segments.Add (new ScreenPoint (bottomErrorPoint.X + this.ErrorBarStopWidth' bottomErrorPoint.Y));  		}  	}  }  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: if (point.ErrorX > 0.0) {  	var leftErrorPoint = this.XAxis.Transform (point.X - (point.ErrorX * 0.5)' point.Y' this.YAxis);  	var rightErrorPoint = this.XAxis.Transform (point.X + (point.ErrorX * 0.5)' point.Y' this.YAxis);  	if (Math.Abs (rightErrorPoint.X - leftErrorPoint.X) > this.MarkerSize * this.MinimumErrorSize) {  		segments.Add (leftErrorPoint);  		segments.Add (rightErrorPoint);  		segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y - this.ErrorBarStopWidth));  		segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y + this.ErrorBarStopWidth));  		segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y - this.ErrorBarStopWidth));  		segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y + this.ErrorBarStopWidth));  	}  }  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: if (point.ErrorX > 0.0) {  	var leftErrorPoint = this.XAxis.Transform (point.X - (point.ErrorX * 0.5)' point.Y' this.YAxis);  	var rightErrorPoint = this.XAxis.Transform (point.X + (point.ErrorX * 0.5)' point.Y' this.YAxis);  	if (Math.Abs (rightErrorPoint.X - leftErrorPoint.X) > this.MarkerSize * this.MinimumErrorSize) {  		segments.Add (leftErrorPoint);  		segments.Add (rightErrorPoint);  		segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y - this.ErrorBarStopWidth));  		segments.Add (new ScreenPoint (leftErrorPoint.X' leftErrorPoint.Y + this.ErrorBarStopWidth));  		segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y - this.ErrorBarStopWidth));  		segments.Add (new ScreenPoint (rightErrorPoint.X' rightErrorPoint.Y + this.ErrorBarStopWidth));  	}  }  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: if (point.ErrorY > 0.0) {  	var topErrorPoint = this.XAxis.Transform (point.X' point.Y - (point.ErrorY * 0.5)' this.YAxis);  	var bottomErrorPoint = this.XAxis.Transform (point.X' point.Y + (point.ErrorY * 0.5)' this.YAxis);  	if (Math.Abs (topErrorPoint.Y - bottomErrorPoint.Y) > this.MarkerSize * this.MinimumErrorSize) {  		segments.Add (topErrorPoint);  		segments.Add (bottomErrorPoint);  		segments.Add (new ScreenPoint (topErrorPoint.X - this.ErrorBarStopWidth' topErrorPoint.Y));  		segments.Add (new ScreenPoint (topErrorPoint.X + this.ErrorBarStopWidth' topErrorPoint.Y));  		segments.Add (new ScreenPoint (bottomErrorPoint.X - this.ErrorBarStopWidth' bottomErrorPoint.Y));  		segments.Add (new ScreenPoint (bottomErrorPoint.X + this.ErrorBarStopWidth' bottomErrorPoint.Y));  	}  }  
Magic Number,OxyPlot.Series,ScatterErrorSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterErrorSeries.cs,Render,The following statement contains a magic number: if (point.ErrorY > 0.0) {  	var topErrorPoint = this.XAxis.Transform (point.X' point.Y - (point.ErrorY * 0.5)' this.YAxis);  	var bottomErrorPoint = this.XAxis.Transform (point.X' point.Y + (point.ErrorY * 0.5)' this.YAxis);  	if (Math.Abs (topErrorPoint.Y - bottomErrorPoint.Y) > this.MarkerSize * this.MinimumErrorSize) {  		segments.Add (topErrorPoint);  		segments.Add (bottomErrorPoint);  		segments.Add (new ScreenPoint (topErrorPoint.X - this.ErrorBarStopWidth' topErrorPoint.Y));  		segments.Add (new ScreenPoint (topErrorPoint.X + this.ErrorBarStopWidth' topErrorPoint.Y));  		segments.Add (new ScreenPoint (bottomErrorPoint.X - this.ErrorBarStopWidth' bottomErrorPoint.Y));  		segments.Add (new ScreenPoint (bottomErrorPoint.X + this.ErrorBarStopWidth' bottomErrorPoint.Y));  	}  }  
Magic Number,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,ScatterSeries,The following statement contains a magic number: this.MarkerSize = 5;  
Magic Number,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,InternalUpdateMaxMinValue,The following statement contains a magic number: foreach (var pt in pts) {  	double x = pt.X;  	double y = pt.Y;  	// Check if the point is defined (the code below is faster than double.IsNaN)  	#pragma  	// ReSharper disable EqualExpressionComparison  	// ReSharper disable CompareOfFloatsByEqualityOperator  	if (x != x || y != y)// ReSharper restore CompareOfFloatsByEqualityOperator  	// ReSharper restore EqualExpressionComparison  	#pragma  	 {  		continue;  	}  	double value = pt.value;  	if (x < minx) {  		minx = x;  	}  	if (x > maxx) {  		maxx = x;  	}  	if (y < miny) {  		miny = y;  	}  	if (y > maxy) {  		maxy = y;  	}  	if (value < minvalue) {  		minvalue = value;  	}  	if (value > maxvalue) {  		maxvalue = value;  	}  }  
Magic Number,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,InternalUpdateMaxMinValue,The following statement contains a magic number: foreach (var pt in pts) {  	double x = pt.X;  	double y = pt.Y;  	// Check if the point is defined (the code below is faster than double.IsNaN)  	#pragma  	// ReSharper disable EqualExpressionComparison  	// ReSharper disable CompareOfFloatsByEqualityOperator  	if (x != x || y != y)// ReSharper restore CompareOfFloatsByEqualityOperator  	// ReSharper restore EqualExpressionComparison  	#pragma  	 {  		continue;  	}  	double value = pt.value;  	if (x < minx) {  		minx = x;  	}  	if (x > maxx) {  		maxx = x;  	}  	if (y < miny) {  		miny = y;  	}  	if (y > maxy) {  		maxy = y;  	}  	if (value < minvalue) {  		minvalue = value;  	}  	if (value > maxvalue) {  		maxvalue = value;  	}  }  
Magic Number,OxyPlot.Series,ScatterSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ScatterSeries{T}.cs,InternalUpdateMaxMinValue,The following statement contains a magic number: if (x != x || y != y)// ReSharper restore CompareOfFloatsByEqualityOperator  // ReSharper restore EqualExpressionComparison  #pragma   {  	continue;  }  
Magic Number,OxyPlot.Series,ErrorColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,ErrorColumnSeries,The following statement contains a magic number: this.ErrorWidth = 0.4;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.BoxWidth = 0.3;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.MedianThickness = 2;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.OutlierSize = 2;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.MedianPointSize = 2;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.WhiskerWidth = 0.5;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	// Add the outlier points  	outlierScreenPoints.AddRange (item.Outliers.Select (outlier => this.Transform (item.X' outlier)));  	var topWhiskerTop = this.Transform (item.X' item.UpperWhisker);  	var topWhiskerBottom = this.Transform (item.X' item.BoxTop);  	var bottomWhiskerTop = this.Transform (item.X' item.BoxBottom);  	var bottomWhiskerBottom = this.Transform (item.X' item.LowerWhisker);  	rc.DrawClippedLine (clippingRect' new[] {  		topWhiskerTop'  		topWhiskerBottom  	}' 0' strokeColor' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' true);  	rc.DrawClippedLine (clippingRect' new[] {  		bottomWhiskerTop'  		bottomWhiskerBottom  	}' 0' strokeColor' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' true);  	// Draw the whiskers  	if (this.WhiskerWidth > 0) {  		var topWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.UpperWhisker);  		var topWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.UpperWhisker);  		var bottomWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.LowerWhisker);  		var bottomWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.LowerWhisker);  		rc.DrawClippedLine (clippingRect' new[] {  			topWhiskerLine1'  			topWhiskerLine2  		}' 0' strokeColor' this.StrokeThickness' null' OxyPenLineJoin.Miter' true);  		rc.DrawClippedLine (clippingRect' new[] {  			bottomWhiskerLine1'  			bottomWhiskerLine2  		}' 0' strokeColor' this.StrokeThickness' null' OxyPenLineJoin.Miter' true);  	}  	if (this.ShowBox) {  		// Draw the box  		var rect = this.GetBoxRect (item);  		rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' strokeColor' this.StrokeThickness);  	}  	if (!this.ShowMedianAsDot) {  		// Draw the median line  		var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  		var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  		rc.DrawClippedLine (clippingRect' new[] {  			medianLeft'  			medianRight  		}' 0' strokeColor' this.StrokeThickness * this.MedianThickness' null' OxyPenLineJoin.Miter' true);  	}  	else {  		var mc = this.Transform (item.X' item.Median);  		if (clippingRect.Contains (mc)) {  			var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  			rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined' 0);  		}  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	// Add the outlier points  	outlierScreenPoints.AddRange (item.Outliers.Select (outlier => this.Transform (item.X' outlier)));  	var topWhiskerTop = this.Transform (item.X' item.UpperWhisker);  	var topWhiskerBottom = this.Transform (item.X' item.BoxTop);  	var bottomWhiskerTop = this.Transform (item.X' item.BoxBottom);  	var bottomWhiskerBottom = this.Transform (item.X' item.LowerWhisker);  	rc.DrawClippedLine (clippingRect' new[] {  		topWhiskerTop'  		topWhiskerBottom  	}' 0' strokeColor' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' true);  	rc.DrawClippedLine (clippingRect' new[] {  		bottomWhiskerTop'  		bottomWhiskerBottom  	}' 0' strokeColor' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' true);  	// Draw the whiskers  	if (this.WhiskerWidth > 0) {  		var topWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.UpperWhisker);  		var topWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.UpperWhisker);  		var bottomWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.LowerWhisker);  		var bottomWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.LowerWhisker);  		rc.DrawClippedLine (clippingRect' new[] {  			topWhiskerLine1'  			topWhiskerLine2  		}' 0' strokeColor' this.StrokeThickness' null' OxyPenLineJoin.Miter' true);  		rc.DrawClippedLine (clippingRect' new[] {  			bottomWhiskerLine1'  			bottomWhiskerLine2  		}' 0' strokeColor' this.StrokeThickness' null' OxyPenLineJoin.Miter' true);  	}  	if (this.ShowBox) {  		// Draw the box  		var rect = this.GetBoxRect (item);  		rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' strokeColor' this.StrokeThickness);  	}  	if (!this.ShowMedianAsDot) {  		// Draw the median line  		var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  		var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  		rc.DrawClippedLine (clippingRect' new[] {  			medianLeft'  			medianRight  		}' 0' strokeColor' this.StrokeThickness * this.MedianThickness' null' OxyPenLineJoin.Miter' true);  	}  	else {  		var mc = this.Transform (item.X' item.Median);  		if (clippingRect.Contains (mc)) {  			var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  			rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined' 0);  		}  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	// Draw the median line  	var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  	var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  	rc.DrawClippedLine (clippingRect' new[] {  		medianLeft'  		medianRight  	}' 0' strokeColor' this.StrokeThickness * this.MedianThickness' null' OxyPenLineJoin.Miter' true);  }  else {  	var mc = this.Transform (item.X' item.Median);  	if (clippingRect.Contains (mc)) {  		var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  		rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined' 0);  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	// Draw the median line  	var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  	var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  	rc.DrawClippedLine (clippingRect' new[] {  		medianLeft'  		medianRight  	}' 0' strokeColor' this.StrokeThickness * this.MedianThickness' null' OxyPenLineJoin.Miter' true);  }  else {  	var mc = this.Transform (item.X' item.Median);  	if (clippingRect.Contains (mc)) {  		var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  		rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined' 0);  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (clippingRect.Contains (mc)) {  	var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined' 0);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (clippingRect.Contains (mc)) {  	var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined' 0);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: if (this.ShowBox) {  	// box  	rc.DrawRectangleAsPolygon (new OxyRect (xmid - halfBoxWidth' ytop' 2 * halfBoxWidth' ybottom - ytop)' fillColor' strokeColor' LegendStrokeThickness);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - halfBoxWidth' ytop' 2 * halfBoxWidth' ybottom - ytop)' fillColor' strokeColor' LegendStrokeThickness);  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	rc.DrawLine (new[] {  		new ScreenPoint (xmid - halfBoxWidth' ymid)'  		new ScreenPoint (xmid + halfBoxWidth' ymid)  	}' strokeColor' LegendStrokeThickness * this.MedianThickness' LineStyle.Solid.GetDashArray ()' OxyPenLineJoin.Miter' true);  }  else {  	var ellipseRect = new OxyRect (xmid - this.MedianPointSize' ymid - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	rc.DrawLine (new[] {  		new ScreenPoint (xmid - halfBoxWidth' ymid)'  		new ScreenPoint (xmid + halfBoxWidth' ymid)  	}' strokeColor' LegendStrokeThickness * this.MedianThickness' LineStyle.Solid.GetDashArray ()' OxyPenLineJoin.Miter' true);  }  else {  	var ellipseRect = new OxyRect (xmid - this.MedianPointSize' ymid - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' OxyColors.Undefined);  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: left -= dx / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: right += dx / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: bottom -= dy / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,Render,The following statement contains a magic number: top += dy / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = Math.Abs (this.X1 - this.X0) / (m - 1);  	double dy = Math.Abs (this.Y1 - this.Y0) / (n - 1);  	this.MinX -= dx / 2;  	this.MaxX += dx / 2;  	this.MinY -= dy / 2;  	this.MaxY += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = Math.Abs (this.X1 - this.X0) / (m - 1);  	double dy = Math.Abs (this.Y1 - this.Y0) / (n - 1);  	this.MinX -= dx / 2;  	this.MaxX += dx / 2;  	this.MinY -= dy / 2;  	this.MaxY += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = Math.Abs (this.X1 - this.X0) / (m - 1);  	double dy = Math.Abs (this.Y1 - this.Y0) / (n - 1);  	this.MinX -= dx / 2;  	this.MaxX += dx / 2;  	this.MinY -= dy / 2;  	this.MaxY += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = Math.Abs (this.X1 - this.X0) / (m - 1);  	double dy = Math.Abs (this.Y1 - this.Y0) / (n - 1);  	this.MinX -= dx / 2;  	this.MaxX += dx / 2;  	this.MinY -= dy / 2;  	this.MaxY += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: this.MinX -= dx / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: this.MaxX += dx / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: this.MinY -= dy / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,UpdateMaxMin,The following statement contains a magic number: this.MaxY += dy / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < n; j++) {  		var p = new DataPoint ((i * dx) + this.X0' (j * dy) + this.Y0);  		var point = this.Transform (p);  		var v = GetValue (this.Data' i' j);  		var color = this.ColorAxis.GetColor (v);  		var hsv = color.ToHsv ();  		var textColor = hsv [2] > 0.6 ? OxyColors.Black : OxyColors.White;  		var label = this.GetLabel (v' i' j);  		rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < n; j++) {  		var p = new DataPoint ((i * dx) + this.X0' (j * dy) + this.Y0);  		var point = this.Transform (p);  		var v = GetValue (this.Data' i' j);  		var color = this.ColorAxis.GetColor (v);  		var hsv = color.ToHsv ();  		var textColor = hsv [2] > 0.6 ? OxyColors.Black : OxyColors.White;  		var label = this.GetLabel (v' i' j);  		rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < n; j++) {  		var p = new DataPoint ((i * dx) + this.X0' (j * dy) + this.Y0);  		var point = this.Transform (p);  		var v = GetValue (this.Data' i' j);  		var color = this.ColorAxis.GetColor (v);  		var hsv = color.ToHsv ();  		var textColor = hsv [2] > 0.6 ? OxyColors.Black : OxyColors.White;  		var label = this.GetLabel (v' i' j);  		rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	var p = new DataPoint ((i * dx) + this.X0' (j * dy) + this.Y0);  	var point = this.Transform (p);  	var v = GetValue (this.Data' i' j);  	var color = this.ColorAxis.GetColor (v);  	var hsv = color.ToHsv ();  	var textColor = hsv [2] > 0.6 ? OxyColors.Black : OxyColors.White;  	var label = this.GetLabel (v' i' j);  	rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	var p = new DataPoint ((i * dx) + this.X0' (j * dy) + this.Y0);  	var point = this.Transform (p);  	var v = GetValue (this.Data' i' j);  	var color = this.ColorAxis.GetColor (v);  	var hsv = color.ToHsv ();  	var textColor = hsv [2] > 0.6 ? OxyColors.Black : OxyColors.White;  	var label = this.GetLabel (v' i' j);  	rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	var p = new DataPoint ((i * dx) + this.X0' (j * dy) + this.Y0);  	var point = this.Transform (p);  	var v = GetValue (this.Data' i' j);  	var color = this.ColorAxis.GetColor (v);  	var hsv = color.ToHsv ();  	var textColor = hsv [2] > 0.6 ? OxyColors.Black : OxyColors.White;  	var label = this.GetLabel (v' i' j);  	rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,RenderLabels,The following statement contains a magic number: rc.DrawClippedText (clip' point' label' textColor' this.ActualFont' fontSize' 500' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = (this.X1 - this.X0) / (this.Data.GetLength (0) - 1);  	double dy = (this.Y1 - this.Y0) / (this.Data.GetLength (1) - 1);  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = (this.X1 - this.X0) / (this.Data.GetLength (0) - 1);  	double dy = (this.Y1 - this.Y0) / (this.Data.GetLength (1) - 1);  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = (this.X1 - this.X0) / (this.Data.GetLength (0) - 1);  	double dy = (this.Y1 - this.Y0) / (this.Data.GetLength (1) - 1);  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: if (this.CoordinateDefinition == HeatMapCoordinateDefinition.Center) {  	double dx = (this.X1 - this.X0) / (this.Data.GetLength (0) - 1);  	double dy = (this.Y1 - this.Y0) / (this.Data.GetLength (1) - 1);  	left -= dx / 2;  	right += dx / 2;  	bottom -= dy / 2;  	top += dy / 2;  }  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: left -= dx / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: right += dx / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: bottom -= dy / 2;  
Magic Number,OxyPlot.Series,HeatMapSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HeatMapSeries.cs,IsPointInRange,The following statement contains a magic number: top += dy / 2;  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,CandleStickSeries,The following statement contains a magic number: this.CandleWidth = 10;  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: foreach (var v in this.Items) {  	if (!this.IsValidItem (v' this.XAxis' this.YAxis)) {  		continue;  	}  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var high = this.Transform (v.X' v.High);  		var low = this.Transform (v.X' v.Low);  		if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  			rc.DrawClippedLine (clippingRect' new[] {  				low'  				high  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		}  		else {  			var open = this.Transform (v.X' v.Open);  			var close = this.Transform (v.X' v.Close);  			var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  			var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  			// Upper shadow  			rc.DrawClippedLine (clippingRect' new[] {  				high'  				min  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Lower shadow  			rc.DrawClippedLine (clippingRect' new[] {  				max'  				low  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Shadow ends  			if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  				var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  				var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					highLeft'  					highRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  				var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  				var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					lowLeft'  					lowRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			}  			// Body  			var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  			var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  			var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  			rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  		}  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: foreach (var v in this.Items) {  	if (!this.IsValidItem (v' this.XAxis' this.YAxis)) {  		continue;  	}  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var high = this.Transform (v.X' v.High);  		var low = this.Transform (v.X' v.Low);  		if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  			rc.DrawClippedLine (clippingRect' new[] {  				low'  				high  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		}  		else {  			var open = this.Transform (v.X' v.Open);  			var close = this.Transform (v.X' v.Close);  			var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  			var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  			// Upper shadow  			rc.DrawClippedLine (clippingRect' new[] {  				high'  				min  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Lower shadow  			rc.DrawClippedLine (clippingRect' new[] {  				max'  				low  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Shadow ends  			if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  				var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  				var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					highLeft'  					highRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  				var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  				var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					lowLeft'  					lowRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			}  			// Body  			var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  			var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  			var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  			rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  		}  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: foreach (var v in this.Items) {  	if (!this.IsValidItem (v' this.XAxis' this.YAxis)) {  		continue;  	}  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var high = this.Transform (v.X' v.High);  		var low = this.Transform (v.X' v.Low);  		if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  			rc.DrawClippedLine (clippingRect' new[] {  				low'  				high  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		}  		else {  			var open = this.Transform (v.X' v.Open);  			var close = this.Transform (v.X' v.Close);  			var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  			var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  			// Upper shadow  			rc.DrawClippedLine (clippingRect' new[] {  				high'  				min  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Lower shadow  			rc.DrawClippedLine (clippingRect' new[] {  				max'  				low  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Shadow ends  			if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  				var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  				var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					highLeft'  					highRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  				var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  				var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					lowLeft'  					lowRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			}  			// Body  			var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  			var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  			var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  			rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  		}  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: foreach (var v in this.Items) {  	if (!this.IsValidItem (v' this.XAxis' this.YAxis)) {  		continue;  	}  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var high = this.Transform (v.X' v.High);  		var low = this.Transform (v.X' v.Low);  		if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  			rc.DrawClippedLine (clippingRect' new[] {  				low'  				high  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		}  		else {  			var open = this.Transform (v.X' v.Open);  			var close = this.Transform (v.X' v.Close);  			var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  			var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  			// Upper shadow  			rc.DrawClippedLine (clippingRect' new[] {  				high'  				min  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Lower shadow  			rc.DrawClippedLine (clippingRect' new[] {  				max'  				low  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Shadow ends  			if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  				var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  				var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					highLeft'  					highRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  				var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  				var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					lowLeft'  					lowRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			}  			// Body  			var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  			var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  			var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  			rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  		}  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: foreach (var v in this.Items) {  	if (!this.IsValidItem (v' this.XAxis' this.YAxis)) {  		continue;  	}  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var high = this.Transform (v.X' v.High);  		var low = this.Transform (v.X' v.Low);  		if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  			rc.DrawClippedLine (clippingRect' new[] {  				low'  				high  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		}  		else {  			var open = this.Transform (v.X' v.Open);  			var close = this.Transform (v.X' v.Close);  			var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  			var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  			// Upper shadow  			rc.DrawClippedLine (clippingRect' new[] {  				high'  				min  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Lower shadow  			rc.DrawClippedLine (clippingRect' new[] {  				max'  				low  			}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			// Shadow ends  			if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  				var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  				var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					highLeft'  					highRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  				var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  				var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  				rc.DrawClippedLine (clippingRect' new[] {  					lowLeft'  					lowRight  				}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			}  			// Body  			var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  			var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  			var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  			rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  		}  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var high = this.Transform (v.X' v.High);  	var low = this.Transform (v.X' v.Low);  	if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  		rc.DrawClippedLine (clippingRect' new[] {  			low'  			high  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  	else {  		var open = this.Transform (v.X' v.Open);  		var close = this.Transform (v.X' v.Close);  		var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  		var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  		// Upper shadow  		rc.DrawClippedLine (clippingRect' new[] {  			high'  			min  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Lower shadow  		rc.DrawClippedLine (clippingRect' new[] {  			max'  			low  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Shadow ends  		if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  			var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  			var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				highLeft'  				highRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  			var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				lowLeft'  				lowRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		}  		// Body  		var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  		var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  		var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  		rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var high = this.Transform (v.X' v.High);  	var low = this.Transform (v.X' v.Low);  	if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  		rc.DrawClippedLine (clippingRect' new[] {  			low'  			high  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  	else {  		var open = this.Transform (v.X' v.Open);  		var close = this.Transform (v.X' v.Close);  		var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  		var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  		// Upper shadow  		rc.DrawClippedLine (clippingRect' new[] {  			high'  			min  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Lower shadow  		rc.DrawClippedLine (clippingRect' new[] {  			max'  			low  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Shadow ends  		if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  			var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  			var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				highLeft'  				highRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  			var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				lowLeft'  				lowRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		}  		// Body  		var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  		var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  		var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  		rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var high = this.Transform (v.X' v.High);  	var low = this.Transform (v.X' v.Low);  	if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  		rc.DrawClippedLine (clippingRect' new[] {  			low'  			high  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  	else {  		var open = this.Transform (v.X' v.Open);  		var close = this.Transform (v.X' v.Close);  		var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  		var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  		// Upper shadow  		rc.DrawClippedLine (clippingRect' new[] {  			high'  			min  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Lower shadow  		rc.DrawClippedLine (clippingRect' new[] {  			max'  			low  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Shadow ends  		if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  			var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  			var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				highLeft'  				highRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  			var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				lowLeft'  				lowRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		}  		// Body  		var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  		var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  		var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  		rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var high = this.Transform (v.X' v.High);  	var low = this.Transform (v.X' v.Low);  	if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  		rc.DrawClippedLine (clippingRect' new[] {  			low'  			high  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  	else {  		var open = this.Transform (v.X' v.Open);  		var close = this.Transform (v.X' v.Close);  		var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  		var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  		// Upper shadow  		rc.DrawClippedLine (clippingRect' new[] {  			high'  			min  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Lower shadow  		rc.DrawClippedLine (clippingRect' new[] {  			max'  			low  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Shadow ends  		if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  			var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  			var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				highLeft'  				highRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  			var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				lowLeft'  				lowRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		}  		// Body  		var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  		var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  		var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  		rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var high = this.Transform (v.X' v.High);  	var low = this.Transform (v.X' v.Low);  	if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  		rc.DrawClippedLine (clippingRect' new[] {  			low'  			high  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  	else {  		var open = this.Transform (v.X' v.Open);  		var close = this.Transform (v.X' v.Close);  		var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  		var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  		// Upper shadow  		rc.DrawClippedLine (clippingRect' new[] {  			high'  			min  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Lower shadow  		rc.DrawClippedLine (clippingRect' new[] {  			max'  			low  		}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		// Shadow ends  		if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  			var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  			var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				highLeft'  				highRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  			var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  			var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  			rc.DrawClippedLine (clippingRect' new[] {  				lowLeft'  				lowRight  			}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		}  		// Body  		var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  		var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  		var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  		rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  	rc.DrawClippedLine (clippingRect' new[] {  		low'  		high  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  else {  	var open = this.Transform (v.X' v.Open);  	var close = this.Transform (v.X' v.Close);  	var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  	var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  	// Upper shadow  	rc.DrawClippedLine (clippingRect' new[] {  		high'  		min  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Lower shadow  	rc.DrawClippedLine (clippingRect' new[] {  		max'  		low  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Shadow ends  	if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  		var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  		var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			highLeft'  			highRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  		var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			lowLeft'  			lowRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	}  	// Body  	var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  	var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  	var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  	rc.DrawClippedLine (clippingRect' new[] {  		low'  		high  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  else {  	var open = this.Transform (v.X' v.Open);  	var close = this.Transform (v.X' v.Close);  	var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  	var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  	// Upper shadow  	rc.DrawClippedLine (clippingRect' new[] {  		high'  		min  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Lower shadow  	rc.DrawClippedLine (clippingRect' new[] {  		max'  		low  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Shadow ends  	if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  		var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  		var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			highLeft'  			highRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  		var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			lowLeft'  			lowRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	}  	// Body  	var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  	var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  	var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  	rc.DrawClippedLine (clippingRect' new[] {  		low'  		high  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  else {  	var open = this.Transform (v.X' v.Open);  	var close = this.Transform (v.X' v.Close);  	var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  	var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  	// Upper shadow  	rc.DrawClippedLine (clippingRect' new[] {  		high'  		min  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Lower shadow  	rc.DrawClippedLine (clippingRect' new[] {  		max'  		low  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Shadow ends  	if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  		var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  		var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			highLeft'  			highRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  		var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			lowLeft'  			lowRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	}  	// Body  	var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  	var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  	var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  	rc.DrawClippedLine (clippingRect' new[] {  		low'  		high  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  else {  	var open = this.Transform (v.X' v.Open);  	var close = this.Transform (v.X' v.Close);  	var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  	var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  	// Upper shadow  	rc.DrawClippedLine (clippingRect' new[] {  		high'  		min  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Lower shadow  	rc.DrawClippedLine (clippingRect' new[] {  		max'  		low  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Shadow ends  	if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  		var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  		var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			highLeft'  			highRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  		var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			lowLeft'  			lowRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	}  	// Body  	var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  	var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  	var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  	rc.DrawClippedLine (clippingRect' new[] {  		low'  		high  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  else {  	var open = this.Transform (v.X' v.Open);  	var close = this.Transform (v.X' v.Close);  	var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  	var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  	// Upper shadow  	rc.DrawClippedLine (clippingRect' new[] {  		high'  		min  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Lower shadow  	rc.DrawClippedLine (clippingRect' new[] {  		max'  		low  	}' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	// Shadow ends  	if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  		var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  		var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			highLeft'  			highRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  		var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  		var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  		rc.DrawClippedLine (clippingRect' new[] {  			lowLeft'  			lowRight  		}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	}  	// Body  	var openLeft = open + new ScreenVector (-this.CandleWidth * 0.5' 0);  	var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  	var fillColor = v.Close > v.Open ? this.GetSelectableFillColor (this.ActualIncreasingFill) : this.GetSelectableFillColor (this.DecreasingFill);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rect' fillColor' actualColor' this.StrokeThickness);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  	var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		highLeft'  		highRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  	var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		lowLeft'  		lowRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  	var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		highLeft'  		highRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  	var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		lowLeft'  		lowRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  	var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		highLeft'  		highRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  	var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		lowLeft'  		lowRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (high.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' high.Y);  	var highRight = new ScreenPoint (high.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' high.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		highLeft'  		highRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (low.X - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' low.Y);  	var lowRight = new ScreenPoint (low.X + (this.CandleWidth * 0.5 * this.ShadowEndLength)' low.Y);  	rc.DrawClippedLine (clippingRect' new[] {  		lowLeft'  		lowRight  	}' 0' shadowEndColor' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Top);  	var highRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Top);  	rc.DrawLine (new[] {  		highLeft'  		highRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Bottom);  	var lowRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Bottom);  	rc.DrawLine (new[] {  		lowLeft'  		lowRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Top);  	var highRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Top);  	rc.DrawLine (new[] {  		highLeft'  		highRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Bottom);  	var lowRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Bottom);  	rc.DrawLine (new[] {  		lowLeft'  		lowRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Top);  	var highRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Top);  	rc.DrawLine (new[] {  		highLeft'  		highRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Bottom);  	var lowRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Bottom);  	rc.DrawLine (new[] {  		lowLeft'  		lowRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The following statement contains a magic number: if (this.ShadowEndColor.IsVisible () && this.ShadowEndLength > 0) {  	var highLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Top);  	var highRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Top);  	rc.DrawLine (new[] {  		highLeft'  		highRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  	var lowLeft = new ScreenPoint (xmid - (this.CandleWidth * 0.5 * this.ShadowEndLength) - 1' legendBox.Bottom);  	var lowRight = new ScreenPoint (xmid + (this.CandleWidth * 0.5 * this.ShadowEndLength)' legendBox.Bottom);  	rc.DrawLine (new[] {  		lowLeft'  		lowRight  	}' this.GetSelectableColor (this.ShadowEndColor)' this.StrokeThickness' dashArray' this.LineJoin' true);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (this.CandleWidth * 0.5)' yclose' this.CandleWidth' yopen - yclose)' this.GetSelectableFillColor (this.ActualIncreasingFill)' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,ContourSeries,The following statement contains a magic number: this.LabelBackground = OxyColor.FromAColor (220' OxyColors.White);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (actualContourLevels == null) {  	double max = this.Data [0' 0];  	double min = this.Data [0' 0];  	for (int i = 0; i < this.Data.GetUpperBound (0); i++) {  		for (int j = 0; j < this.Data.GetUpperBound (1); j++) {  			max = Math.Max (max' this.Data [i' j]);  			min = Math.Min (min' this.Data [i' j]);  		}  	}  	double actualStep = this.ContourLevelStep;  	if (double.IsNaN (actualStep)) {  		double range = max - min;  		double step = range / 20;  		double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  		actualStep = Math.Pow (10' Math.Floor (stepExp));  	}  	max = Math.Round (actualStep * (int)Math.Ceiling (max / actualStep)' 14);  	min = Math.Round (actualStep * (int)Math.Floor (min / actualStep)' 14);  	actualContourLevels = ArrayHelper.CreateVector (min' max' actualStep);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (actualContourLevels == null) {  	double max = this.Data [0' 0];  	double min = this.Data [0' 0];  	for (int i = 0; i < this.Data.GetUpperBound (0); i++) {  		for (int j = 0; j < this.Data.GetUpperBound (1); j++) {  			max = Math.Max (max' this.Data [i' j]);  			min = Math.Min (min' this.Data [i' j]);  		}  	}  	double actualStep = this.ContourLevelStep;  	if (double.IsNaN (actualStep)) {  		double range = max - min;  		double step = range / 20;  		double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  		actualStep = Math.Pow (10' Math.Floor (stepExp));  	}  	max = Math.Round (actualStep * (int)Math.Ceiling (max / actualStep)' 14);  	min = Math.Round (actualStep * (int)Math.Floor (min / actualStep)' 14);  	actualContourLevels = ArrayHelper.CreateVector (min' max' actualStep);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (actualContourLevels == null) {  	double max = this.Data [0' 0];  	double min = this.Data [0' 0];  	for (int i = 0; i < this.Data.GetUpperBound (0); i++) {  		for (int j = 0; j < this.Data.GetUpperBound (1); j++) {  			max = Math.Max (max' this.Data [i' j]);  			min = Math.Min (min' this.Data [i' j]);  		}  	}  	double actualStep = this.ContourLevelStep;  	if (double.IsNaN (actualStep)) {  		double range = max - min;  		double step = range / 20;  		double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  		actualStep = Math.Pow (10' Math.Floor (stepExp));  	}  	max = Math.Round (actualStep * (int)Math.Ceiling (max / actualStep)' 14);  	min = Math.Round (actualStep * (int)Math.Floor (min / actualStep)' 14);  	actualContourLevels = ArrayHelper.CreateVector (min' max' actualStep);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (actualContourLevels == null) {  	double max = this.Data [0' 0];  	double min = this.Data [0' 0];  	for (int i = 0; i < this.Data.GetUpperBound (0); i++) {  		for (int j = 0; j < this.Data.GetUpperBound (1); j++) {  			max = Math.Max (max' this.Data [i' j]);  			min = Math.Min (min' this.Data [i' j]);  		}  	}  	double actualStep = this.ContourLevelStep;  	if (double.IsNaN (actualStep)) {  		double range = max - min;  		double step = range / 20;  		double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  		actualStep = Math.Pow (10' Math.Floor (stepExp));  	}  	max = Math.Round (actualStep * (int)Math.Ceiling (max / actualStep)' 14);  	min = Math.Round (actualStep * (int)Math.Floor (min / actualStep)' 14);  	actualContourLevels = ArrayHelper.CreateVector (min' max' actualStep);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (actualContourLevels == null) {  	double max = this.Data [0' 0];  	double min = this.Data [0' 0];  	for (int i = 0; i < this.Data.GetUpperBound (0); i++) {  		for (int j = 0; j < this.Data.GetUpperBound (1); j++) {  			max = Math.Max (max' this.Data [i' j]);  			min = Math.Min (min' this.Data [i' j]);  		}  	}  	double actualStep = this.ContourLevelStep;  	if (double.IsNaN (actualStep)) {  		double range = max - min;  		double step = range / 20;  		double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  		actualStep = Math.Pow (10' Math.Floor (stepExp));  	}  	max = Math.Round (actualStep * (int)Math.Ceiling (max / actualStep)' 14);  	min = Math.Round (actualStep * (int)Math.Floor (min / actualStep)' 14);  	actualContourLevels = ArrayHelper.CreateVector (min' max' actualStep);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (double.IsNaN (actualStep)) {  	double range = max - min;  	double step = range / 20;  	double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  	actualStep = Math.Pow (10' Math.Floor (stepExp));  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (double.IsNaN (actualStep)) {  	double range = max - min;  	double step = range / 20;  	double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  	actualStep = Math.Pow (10' Math.Floor (stepExp));  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (double.IsNaN (actualStep)) {  	double range = max - min;  	double step = range / 20;  	double stepExp = Math.Round (Math.Log (Math.Abs (step)' 10));  	actualStep = Math.Pow (10' Math.Floor (stepExp));  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: actualStep = Math.Pow (10' Math.Floor (stepExp));  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: max = Math.Round (actualStep * (int)Math.Ceiling (max / actualStep)' 14);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: min = Math.Round (actualStep * (int)Math.Floor (min / actualStep)' 14);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: foreach (var contour in this.contours) {  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var transformedPoints = contour.Points.Select (this.Transform).ToArray ();  		var strokeColor = contour.Color.GetActualColor (this.ActualColor);  		rc.DrawClippedLine (clippingRect' transformedPoints' 4' this.GetSelectableColor (strokeColor)' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' false);  		// rc.DrawClippedPolygon(transformedPoints' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  		if (transformedPoints.Length > 10) {  			this.AddContourLabels (contour' transformedPoints' clippingRect' contourLabels);  		}  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: foreach (var contour in this.contours) {  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var transformedPoints = contour.Points.Select (this.Transform).ToArray ();  		var strokeColor = contour.Color.GetActualColor (this.ActualColor);  		rc.DrawClippedLine (clippingRect' transformedPoints' 4' this.GetSelectableColor (strokeColor)' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' false);  		// rc.DrawClippedPolygon(transformedPoints' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  		if (transformedPoints.Length > 10) {  			this.AddContourLabels (contour' transformedPoints' clippingRect' contourLabels);  		}  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var transformedPoints = contour.Points.Select (this.Transform).ToArray ();  	var strokeColor = contour.Color.GetActualColor (this.ActualColor);  	rc.DrawClippedLine (clippingRect' transformedPoints' 4' this.GetSelectableColor (strokeColor)' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' false);  	// rc.DrawClippedPolygon(transformedPoints' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  	if (transformedPoints.Length > 10) {  		this.AddContourLabels (contour' transformedPoints' clippingRect' contourLabels);  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var transformedPoints = contour.Points.Select (this.Transform).ToArray ();  	var strokeColor = contour.Color.GetActualColor (this.ActualColor);  	rc.DrawClippedLine (clippingRect' transformedPoints' 4' this.GetSelectableColor (strokeColor)' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' false);  	// rc.DrawClippedPolygon(transformedPoints' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  	if (transformedPoints.Length > 10) {  		this.AddContourLabels (contour' transformedPoints' clippingRect' contourLabels);  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: rc.DrawClippedLine (clippingRect' transformedPoints' 4' this.GetSelectableColor (strokeColor)' this.StrokeThickness' dashArray' OxyPenLineJoin.Miter' false);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: if (transformedPoints.Length > 10) {  	this.AddContourLabels (contour' transformedPoints' clippingRect' contourLabels);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (pts.Length < 2) {  	return;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: angle -= 180;  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: angle += 180;  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: while (segmentCount > 0) {  	ContourSegment segment1 = null' segment2 = null;  	if (firstSegment != null) {  		bool reverse;  		// Find a segment that is connected to the head of the contour  		segment1 = this.FindConnectedSegment (contourPoints [0]' firstSegment.ContourLevel' eps' out reverse);  		if (segment1 != null) {  			contourPoints.Insert (0' reverse ? segment1.StartPoint : segment1.EndPoint);  			contourPointsCount++;  			this.segments.Remove (segment1);  			segmentCount--;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = this.FindConnectedSegment (contourPoints [contourPointsCount - 1]' firstSegment.ContourLevel' eps' out reverse);  		if (segment2 != null) {  			contourPoints.Add (reverse ? segment2.StartPoint : segment2.EndPoint);  			contourPointsCount++;  			this.segments.Remove (segment2);  			segmentCount--;  		}  	}  	if ((segment1 == null && segment2 == null) || segmentCount == 0) {  		if (contourPointsCount > 0 && firstSegment != null) {  			this.contours.Add (new Contour (contourPoints' firstSegment.ContourLevel));  			contourPoints = new List<DataPoint> ();  			contourPointsCount = 0;  		}  		if (segmentCount > 0) {  			firstSegment = this.segments.First ();  			contourPoints.Add (firstSegment.StartPoint);  			contourPoints.Add (firstSegment.EndPoint);  			contourPointsCount += 2;  			this.segments.Remove (firstSegment);  			segmentCount--;  		}  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: if ((segment1 == null && segment2 == null) || segmentCount == 0) {  	if (contourPointsCount > 0 && firstSegment != null) {  		this.contours.Add (new Contour (contourPoints' firstSegment.ContourLevel));  		contourPoints = new List<DataPoint> ();  		contourPointsCount = 0;  	}  	if (segmentCount > 0) {  		firstSegment = this.segments.First ();  		contourPoints.Add (firstSegment.StartPoint);  		contourPoints.Add (firstSegment.EndPoint);  		contourPointsCount += 2;  		this.segments.Remove (firstSegment);  		segmentCount--;  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: if (segmentCount > 0) {  	firstSegment = this.segments.First ();  	contourPoints.Add (firstSegment.StartPoint);  	contourPoints.Add (firstSegment.EndPoint);  	contourPointsCount += 2;  	this.segments.Remove (firstSegment);  	segmentCount--;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: contourPointsCount += 2;  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,GetNearestPoint,The following statement contains a magic number: for (int i = 0; i < this.ActualBarRectangles.Count; i++) {  	var r = this.ActualBarRectangles [i];  	if (r.Contains (point)) {  		double value = (this.Items [i].Y0 + this.Items [i].Y1) / 2;  		var sp = point;  		var dp = new DataPoint (i' value);  		var item = this.GetItem (i);  		var text = this.Format (this.TrackerFormatString' item' this.Items [i].X0' this.Items [i].X1' this.Items [i].Y0' this.Items [i].Y1' this.Items [i].Title);  		return new TrackerHitResult (this' dp' sp' item' i' text);  	}  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,GetNearestPoint,The following statement contains a magic number: if (r.Contains (point)) {  	double value = (this.Items [i].Y0 + this.Items [i].Y1) / 2;  	var sp = point;  	var dp = new DataPoint (i' value);  	var item = this.GetItem (i);  	var text = this.Format (this.TrackerFormatString' item' this.Items [i].X0' this.Items [i].X1' this.Items [i].Y0' this.Items [i].Y1' this.Items [i].Title);  	return new TrackerHitResult (this' dp' sp' item' i' text);  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	if (!this.IsValid (item.X0) || !this.IsValid (item.X1) || !this.IsValid (item.Y0) || !this.IsValid (item.Y1)) {  		continue;  	}  	var p0 = this.Transform (item.X0' item.Y0);  	var p1 = this.Transform (item.X1' item.Y1);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rectangle' this.GetSelectableFillColor (item.Color.GetActualColor (this.ActualFillColor))' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  	i++;  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	if (!this.IsValid (item.X0) || !this.IsValid (item.X1) || !this.IsValid (item.Y0) || !this.IsValid (item.Y1)) {  		continue;  	}  	var p0 = this.Transform (item.X0' item.Y0);  	var p1 = this.Transform (item.X1' item.Y1);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rectangle' this.GetSelectableFillColor (item.Color.GetActualColor (this.ActualFillColor))' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  	i++;  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,IntervalBarSeries,The following statement contains a magic number: this.LabelMargin = 4;  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,GetNearestPoint,The following statement contains a magic number: for (int i = 0; i < this.ActualBarRectangles.Count; i++) {  	var r = this.ActualBarRectangles [i];  	if (r.Contains (point)) {  		var item = (IntervalBarItem)this.GetItem (this.ValidItemsIndexInversion [i]);  		var categoryIndex = item.GetCategoryIndex (i);  		double value = (this.ValidItems [i].Start + this.ValidItems [i].End) / 2;  		var dp = new DataPoint (categoryIndex' value);  		var text = this.Format (this.TrackerFormatString' item' this.Items [i].Start' this.Items [i].End' this.Items [i].Title);  		return new TrackerHitResult (this' dp' point' item' i' text);  	}  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,GetNearestPoint,The following statement contains a magic number: if (r.Contains (point)) {  	var item = (IntervalBarItem)this.GetItem (this.ValidItemsIndexInversion [i]);  	var categoryIndex = item.GetCategoryIndex (i);  	double value = (this.ValidItems [i].Start + this.ValidItems [i].End) / 2;  	var dp = new DataPoint (categoryIndex' value);  	var text = this.Format (this.TrackerFormatString' item' this.Items [i].Start' this.Items [i].End' this.Items [i].Title);  	return new TrackerHitResult (this' dp' point' item' i' text);  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	double categoryValue = categoryAxis.GetCategoryValue (categoryIndex' stackIndex' actualBarWidth);  	var p0 = this.Transform (item.Start' categoryValue);  	var p1 = this.Transform (item.End' categoryValue + actualBarWidth);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rectangle' this.GetSelectableFillColor (item.Color.GetActualColor (this.ActualFillColor))' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	double categoryValue = categoryAxis.GetCategoryValue (categoryIndex' stackIndex' actualBarWidth);  	var p0 = this.Transform (item.Start' categoryValue);  	var p1 = this.Transform (item.End' categoryValue + actualBarWidth);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' rectangle' this.GetSelectableFillColor (item.Color.GetActualColor (this.ActualFillColor))' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = this.Format (this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MaximumFillColor = OxyColor.FromRgb (216' 82' 85);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MaximumFillColor = OxyColor.FromRgb (216' 82' 85);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MaximumFillColor = OxyColor.FromRgb (216' 82' 85);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MinimumFillColor = OxyColor.FromRgb (84' 138' 209);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MinimumFillColor = OxyColor.FromRgb (84' 138' 209);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MinimumFillColor = OxyColor.FromRgb (84' 138' 209);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.LabelMargin = 4;  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var barOffset = categoryAxis.GetCurrentBarOffset (categoryIndex);  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + barOffset);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + barOffset + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + barOffset);  	p2 = new ScreenPoint ((int)p2.X' p2.Y);  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' minimumRectangle' item.MinimumColor.GetActualColor (this.ActualMinimumFillColor)' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (clippingRect' maximumRectangle' item.MaximumColor.GetActualColor (this.ActualMaximumFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = this.Format (this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = this.Format (this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var barOffset = categoryAxis.GetCurrentBarOffset (categoryIndex);  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + barOffset);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + barOffset + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + barOffset);  	p2 = new ScreenPoint ((int)p2.X' p2.Y);  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' minimumRectangle' item.MinimumColor.GetActualColor (this.ActualMinimumFillColor)' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (clippingRect' maximumRectangle' item.MaximumColor.GetActualColor (this.ActualMaximumFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = this.Format (this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = this.Format (this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var barOffset = categoryAxis.GetCurrentBarOffset (categoryIndex);  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + barOffset);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + barOffset + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + barOffset);  	p2 = new ScreenPoint ((int)p2.X' p2.Y);  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' minimumRectangle' item.MinimumColor.GetActualColor (this.ActualMinimumFillColor)' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (clippingRect' maximumRectangle' item.MaximumColor.GetActualColor (this.ActualMaximumFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = this.Format (this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = this.Format (this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var barOffset = categoryAxis.GetCurrentBarOffset (categoryIndex);  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + barOffset);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + barOffset + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + barOffset);  	p2 = new ScreenPoint ((int)p2.X' p2.Y);  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' minimumRectangle' item.MinimumColor.GetActualColor (this.ActualMinimumFillColor)' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (clippingRect' maximumRectangle' item.MaximumColor.GetActualColor (this.ActualMaximumFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = this.Format (this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = this.Format (this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var barOffset = categoryAxis.GetCurrentBarOffset (categoryIndex);  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + barOffset);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + barOffset + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + barOffset);  	p2 = new ScreenPoint ((int)p2.X' p2.Y);  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (clippingRect' minimumRectangle' item.MinimumColor.GetActualColor (this.ActualMinimumFillColor)' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (clippingRect' maximumRectangle' item.MaximumColor.GetActualColor (this.ActualMaximumFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = this.Format (this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = this.Format (this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: if (this.MinimumLabelFormatString != null) {  	var s = this.Format (this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  	var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: if (this.MaximumLabelFormatString != null) {  	var s = this.Format (this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  	var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,HighLowSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\HighLowSeries.cs,HighLowSeries,The following statement contains a magic number: this.TickLength = 4;  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,GetNearestPoint,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	var p1 = this.ActualPoints [i];  	var p2 = this.ActualPoints [i + 1 < n ? i + 1 : i];  	var sp1 = this.Transform (p1.X' p1.Y);  	var sp2 = this.Transform (p2.X' p1.Y);  	double spdx = sp2.x - sp1.x;  	double spdy = sp2.y - sp1.y;  	double u1 = ((point.x - sp1.x) * spdx) + ((point.y - sp1.y) * spdy);  	double u2 = (spdx * spdx) + (spdy * spdy);  	double ds = (spdx * spdx) + (spdy * spdy);  	if (ds < 4) {  		// if the points are very close' we can get numerical problems' just use the first point...  		u1 = 0;  		u2 = 1;  	}  	if (Math.Abs (u2) < double.Epsilon) {  		continue;  		// P1 && P2 coincident  	}  	double u = u1 / u2;  	if (u < 0 || u > 1) {  		continue;  		// outside line  	}  	double sx = sp1.x + (u * spdx);  	double sy = sp1.y + (u * spdy);  	double dx = point.x - sx;  	double dy = point.y - sy;  	double distanceSquared = (dx * dx) + (dy * dy);  	if (distanceSquared < minimumDistanceSquared) {  		double px = p1.X + (u * (p2.X - p1.X));  		double py = p1.Y;  		result = new TrackerHitResult (this' new DataPoint (px' py)' new ScreenPoint (sx' sy)' this.GetItem (i)' i);  		minimumDistanceSquared = distanceSquared;  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,GetNearestPoint,The following statement contains a magic number: if (ds < 4) {  	// if the points are very close' we can get numerical problems' just use the first point...  	u1 = 0;  	u2 = 1;  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && lineStyle != LineStyle.None) {  	if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  		// TODO: change to array  		var hlpts = new List<ScreenPoint> ();  		var vlpts = new List<ScreenPoint> ();  		for (int i = 0; i + 2 < lpts.Count; i += 2) {  			hlpts.Add (lpts [i]);  			hlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 2]);  		}  		rc.DrawClippedLineSegments (clippingRect' hlpts' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		rc.DrawClippedLineSegments (clippingRect' vlpts' actualColor' verticalStrokeThickness' verticalLineDashArray' this.LineJoin' false);  	}  	else {  		rc.DrawClippedLine (clippingRect' lpts' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && lineStyle != LineStyle.None) {  	if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  		// TODO: change to array  		var hlpts = new List<ScreenPoint> ();  		var vlpts = new List<ScreenPoint> ();  		for (int i = 0; i + 2 < lpts.Count; i += 2) {  			hlpts.Add (lpts [i]);  			hlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 2]);  		}  		rc.DrawClippedLineSegments (clippingRect' hlpts' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		rc.DrawClippedLineSegments (clippingRect' vlpts' actualColor' verticalStrokeThickness' verticalLineDashArray' this.LineJoin' false);  	}  	else {  		rc.DrawClippedLine (clippingRect' lpts' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && lineStyle != LineStyle.None) {  	if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  		// TODO: change to array  		var hlpts = new List<ScreenPoint> ();  		var vlpts = new List<ScreenPoint> ();  		for (int i = 0; i + 2 < lpts.Count; i += 2) {  			hlpts.Add (lpts [i]);  			hlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 2]);  		}  		rc.DrawClippedLineSegments (clippingRect' hlpts' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  		rc.DrawClippedLineSegments (clippingRect' vlpts' actualColor' verticalStrokeThickness' verticalLineDashArray' this.LineJoin' false);  	}  	else {  		rc.DrawClippedLine (clippingRect' lpts' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  	// TODO: change to array  	var hlpts = new List<ScreenPoint> ();  	var vlpts = new List<ScreenPoint> ();  	for (int i = 0; i + 2 < lpts.Count; i += 2) {  		hlpts.Add (lpts [i]);  		hlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 2]);  	}  	rc.DrawClippedLineSegments (clippingRect' hlpts' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	rc.DrawClippedLineSegments (clippingRect' vlpts' actualColor' verticalStrokeThickness' verticalLineDashArray' this.LineJoin' false);  }  else {  	rc.DrawClippedLine (clippingRect' lpts' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  	// TODO: change to array  	var hlpts = new List<ScreenPoint> ();  	var vlpts = new List<ScreenPoint> ();  	for (int i = 0; i + 2 < lpts.Count; i += 2) {  		hlpts.Add (lpts [i]);  		hlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 2]);  	}  	rc.DrawClippedLineSegments (clippingRect' hlpts' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	rc.DrawClippedLineSegments (clippingRect' vlpts' actualColor' verticalStrokeThickness' verticalLineDashArray' this.LineJoin' false);  }  else {  	rc.DrawClippedLine (clippingRect' lpts' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  	// TODO: change to array  	var hlpts = new List<ScreenPoint> ();  	var vlpts = new List<ScreenPoint> ();  	for (int i = 0; i + 2 < lpts.Count; i += 2) {  		hlpts.Add (lpts [i]);  		hlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 2]);  	}  	rc.DrawClippedLineSegments (clippingRect' hlpts' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  	rc.DrawClippedLineSegments (clippingRect' vlpts' actualColor' verticalStrokeThickness' verticalLineDashArray' this.LineJoin' false);  }  else {  	rc.DrawClippedLine (clippingRect' lpts' 0' actualColor' this.StrokeThickness' dashArray' this.LineJoin' false);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: for (int i = 0; i + 2 < lpts.Count; i += 2) {  	hlpts.Add (lpts [i]);  	hlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 2]);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: for (int i = 0; i + 2 < lpts.Count; i += 2) {  	hlpts.Add (lpts [i]);  	hlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 2]);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: for (int i = 0; i + 2 < lpts.Count; i += 2) {  	hlpts.Add (lpts [i]);  	hlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 2]);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: i += 2
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: vlpts.Add (lpts [i + 2]);  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.AngleSpan = 360.0;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.TickRadialLength = 6;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.TickHorizontalLength = 8;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.TickLabelDistance = 4;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.InsideLabelPosition = 0.5;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.FontSize = 12;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		// draw the tick line with the same color as the text  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.ActualTextColor' 1' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render a label inside the slice  	if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  		rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		// draw the tick line with the same color as the text  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.ActualTextColor' 1' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render a label inside the slice  	if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  		rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		// draw the tick line with the same color as the text  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.ActualTextColor' 1' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render a label inside the slice  	if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  		rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		// draw the tick line with the same color as the text  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.ActualTextColor' 1' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render a label inside the slice  	if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  		rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		// draw the tick line with the same color as the text  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.ActualTextColor' 1' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render a label inside the slice  	if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  		rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		// draw the tick line with the same color as the text  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.ActualTextColor' 1' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render a label inside the slice  	if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  		rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: while (true) {  	bool stop = false;  	if (angle >= endAngle) {  		angle = endAngle;  		stop = true;  	}  	double a = angle * Math.PI / 180;  	var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  	outerPoints.Add (op);  	var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  	if (innerRadius + explodedRadius > 0) {  		innerPoints.Add (ip);  	}  	if (stop) {  		break;  	}  	angle += this.AngleIncrement;  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.OutsideLabelFormat != null) {  	string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  	int sign = Math.Sign (Math.Cos (midAngleRadians));  	// tick points  	var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  	var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  	var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  	// draw the tick line with the same color as the text  	rc.DrawLine (new[] {  		tp0'  		tp1'  		tp2  	}' this.ActualTextColor' 1' null' OxyPenLineJoin.Bevel);  	// label  	var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  	rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  	string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  	double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  	var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  	double textAngle = 0;  	if (this.AreInsideLabelsAngled) {  		textAngle = midAngle;  		if (Math.Cos (midAngleRadians) < 0) {  			textAngle += 180;  		}  	}  	var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  	rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.InsideLabelFormat != null && !this.InsideLabelColor.IsUndefined ()) {  	string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  	double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  	var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  	double textAngle = 0;  	if (this.AreInsideLabelsAngled) {  		textAngle = midAngle;  		if (Math.Cos (midAngleRadians) < 0) {  			textAngle += 180;  		}  	}  	var actualInsideLabelColor = this.InsideLabelColor.IsAutomatic () ? this.ActualTextColor : this.InsideLabelColor;  	rc.DrawText (labelPosition' label' actualInsideLabelColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.AreInsideLabelsAngled) {  	textAngle = midAngle;  	if (Math.Cos (midAngleRadians) < 0) {  		textAngle += 180;  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (Math.Cos (midAngleRadians) < 0) {  	textAngle += 180;  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: textAngle += 180;  
Magic Number,OxyPlot.Series,FunctionSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The following statement contains a magic number: for (double x = x0; x <= x1 + (dx * 0.5); x += dx) {  	this.Points.Add (new DataPoint (x' f (x)));  }  
Magic Number,OxyPlot.Series,FunctionSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The following statement contains a magic number: for (double t = t0; t <= t1 + (dt * 0.5); t += dt) {  	this.Points.Add (new DataPoint (fx (t)' fy (t)));  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.MinimumSegmentLength = 2;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.StrokeThickness = 2;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.MarkerSize = 3;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.LabelMargin = 6;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: switch (this.LineLegendPosition) {  case LineLegendPosition.Start:  	// start position  	point = this.ActualPoints [0];  	ha = HorizontalAlignment.Right;  	dx = -4;  	break;  default:  	// end position  	point = this.ActualPoints [this.ActualPoints.Count - 1];  	dx = 4;  	break;  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: switch (this.LineLegendPosition) {  case LineLegendPosition.Start:  	// start position  	point = this.ActualPoints [0];  	ha = HorizontalAlignment.Right;  	dx = -4;  	break;  default:  	// end position  	point = this.ActualPoints [this.ActualPoints.Count - 1];  	dx = 4;  	break;  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: dx = -4;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: dx = 4;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLineAndMarkers,The following statement contains a magic number: if (this.Smooth) {  	// spline smoothing (should only be used on small datasets)  	var resampledPoints = ScreenPointHelper.ResamplePoints (pointsToRender' this.MinimumSegmentLength);  	screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLineAndMarkers,The following statement contains a magic number: if (this.Smooth) {  	// spline smoothing (should only be used on small datasets)  	var resampledPoints = ScreenPointHelper.ResamplePoints (pointsToRender' this.MinimumSegmentLength);  	screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLineAndMarkers,The following statement contains a magic number: screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,RenderLineAndMarkers,The following statement contains a magic number: screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Series\LineSeries.cs,ResetSmoothedPoints,The following statement contains a magic number: this.smoothedPoints = CanonicalSplineHelper.CreateSpline (this.ActualPoints' 0.5' null' false' tolerance);  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,LogarithmicAxis,The following statement contains a magic number: this.Base = 10;  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (this.ActualMaximum <= this.ActualMinimum) {  	this.ActualMaximum = this.ActualMinimum * 100;  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMaximum = this.ActualMinimum * 100;  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,The following statement contains a magic number: if (this.ActualMinimum <= 0) {  	this.ActualMinimum = 0.1;  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,The following statement contains a magic number: this.ActualMinimum = 0.1;  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,The following statement contains a magic number: if (majorTickValues.Count < 2) {  	base.GetTickValues (out majorLabelValues' out majorTickValues' out minorTickValues);  }  else {  	majorLabelValues = majorTickValues;  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (this.PowerPadding) {  	double logBase = Math.Log (this.Base);  	var e0 = (int)Math.Floor (Math.Log (this.ActualMinimum) / logBase);  	var e1 = (int)Math.Ceiling (Math.Log (this.ActualMaximum) / logBase);  	if (!double.IsNaN (this.ActualMinimum)) {  		this.ActualMinimum = Math.Round (Math.Exp (e0 * logBase)' 14);  	}  	if (!double.IsNaN (this.ActualMaximum)) {  		this.ActualMaximum = Math.Round (Math.Exp (e1 * logBase)' 14);  	}  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (this.PowerPadding) {  	double logBase = Math.Log (this.Base);  	var e0 = (int)Math.Floor (Math.Log (this.ActualMinimum) / logBase);  	var e1 = (int)Math.Ceiling (Math.Log (this.ActualMaximum) / logBase);  	if (!double.IsNaN (this.ActualMinimum)) {  		this.ActualMinimum = Math.Round (Math.Exp (e0 * logBase)' 14);  	}  	if (!double.IsNaN (this.ActualMaximum)) {  		this.ActualMaximum = Math.Round (Math.Exp (e1 * logBase)' 14);  	}  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (!double.IsNaN (this.ActualMinimum)) {  	this.ActualMinimum = Math.Round (Math.Exp (e0 * logBase)' 14);  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.ActualMinimum = Math.Round (Math.Exp (e0 * logBase)' 14);  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (!double.IsNaN (this.ActualMaximum)) {  	this.ActualMaximum = Math.Round (Math.Exp (e1 * logBase)' 14);  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LogarithmicAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.ActualMaximum = Math.Round (Math.Exp (e1 * logBase)' 14);  
Magic Number,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,RangeColorAxis,The following statement contains a magic number: this.AxisDistance = 20;  
Magic Number,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double distance = this.AxisDistance;  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	const int TierShift = 0;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - TierShift - width - distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + TierShift + distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - TierShift - height - distance;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + TierShift + distance;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  	};  	foreach (ColorRange range in this.ranges) {  		double ylow = this.Transform (range.LowerBound);  		double yhigh = this.Transform (range.UpperBound);  		double ymax = this.Transform (ActualMaximum);  		double ymin = this.Transform (ActualMinimum);  		if (ylow < ymax) {  			continue;  		}  		if (yhigh > ymin) {  			continue;  		}  		if (ylow > ymin) {  			ylow = ymin;  		}  		if (yhigh < ymax) {  			yhigh = ymax;  		}  		drawColorRect (ylow' yhigh' range.Color);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (!this.LowColor.IsUndefined ()) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (!this.HighColor.IsUndefined ()) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double distance = this.AxisDistance;  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	const int TierShift = 0;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - TierShift - width - distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + TierShift + distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - TierShift - height - distance;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + TierShift + distance;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  	};  	foreach (ColorRange range in this.ranges) {  		double ylow = this.Transform (range.LowerBound);  		double yhigh = this.Transform (range.UpperBound);  		double ymax = this.Transform (ActualMaximum);  		double ymin = this.Transform (ActualMinimum);  		if (ylow < ymax) {  			continue;  		}  		if (yhigh > ymin) {  			continue;  		}  		if (ylow > ymin) {  			ylow = ymin;  		}  		if (yhigh < ymax) {  			yhigh = ymax;  		}  		drawColorRect (ylow' yhigh' range.Color);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (!this.LowColor.IsUndefined ()) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (!this.HighColor.IsUndefined ()) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double distance = this.AxisDistance;  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	const int TierShift = 0;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - TierShift - width - distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + TierShift + distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - TierShift - height - distance;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + TierShift + distance;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  	};  	foreach (ColorRange range in this.ranges) {  		double ylow = this.Transform (range.LowerBound);  		double yhigh = this.Transform (range.UpperBound);  		double ymax = this.Transform (ActualMaximum);  		double ymin = this.Transform (ActualMinimum);  		if (ylow < ymax) {  			continue;  		}  		if (yhigh > ymin) {  			continue;  		}  		if (ylow > ymin) {  			ylow = ymin;  		}  		if (yhigh < ymax) {  			yhigh = ymax;  		}  		drawColorRect (ylow' yhigh' range.Color);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (!this.LowColor.IsUndefined ()) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (!this.HighColor.IsUndefined ()) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,AngleAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\AngleAxis.cs,AngleAxis,The following statement contains a magic number: this.EndAngle = 360;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MinimumPadding = 0.01;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MaximumPadding = 0.01;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MinorTickSize = 4;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MajorTickSize = 7;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.TitlePosition = 0.5;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.TitleClippingLength = 0.9;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.IntervalLength = 60;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.AxisTitleDistance = 4;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.AxisTickToLabelDistance = 4;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (double.IsNaN (this.ActualMaximum) || double.IsInfinity (this.ActualMaximum)) {  	this.ActualMaximum = 100;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMaximum = 100;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (this.ActualMaximum <= this.ActualMinimum) {  	this.ActualMaximum = this.ActualMinimum + 100;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMaximum = this.ActualMinimum + 100;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (range < this.MinimumRange) {  	var average = (this.ActualMaximum + this.ActualMinimum) * 0.5;  	var delta = this.MinimumRange / 2;  	this.ActualMinimum = average - delta;  	this.ActualMaximum = average + delta;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (range < this.MinimumRange) {  	var average = (this.ActualMaximum + this.ActualMinimum) * 0.5;  	var delta = this.MinimumRange / 2;  	this.ActualMinimum = average - delta;  	this.ActualMaximum = average + delta;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: if (this.IsVertical ()) {  	switch (this.TickStyle) {  	case TickStyle.Outside:  		width += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		width += this.MajorTickSize * 0.75;  		break;  	}  	width += this.AxisDistance;  	width += this.AxisTickToLabelDistance;  	width += maximumTextSize.Width;  	if (labelTextSize.Height > 0) {  		width += this.AxisTitleDistance;  		width += labelTextSize.Height;  	}  }  else {  	// caution: this includes AngleAxis because Position=None  	switch (this.TickStyle) {  	case TickStyle.Outside:  		height += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		height += this.MajorTickSize * 0.75;  		break;  	}  	height += this.AxisDistance;  	height += this.AxisTickToLabelDistance;  	height += maximumTextSize.Height;  	if (labelTextSize.Height > 0) {  		height += this.AxisTitleDistance;  		height += labelTextSize.Height;  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: if (this.IsVertical ()) {  	switch (this.TickStyle) {  	case TickStyle.Outside:  		width += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		width += this.MajorTickSize * 0.75;  		break;  	}  	width += this.AxisDistance;  	width += this.AxisTickToLabelDistance;  	width += maximumTextSize.Width;  	if (labelTextSize.Height > 0) {  		width += this.AxisTitleDistance;  		width += labelTextSize.Height;  	}  }  else {  	// caution: this includes AngleAxis because Position=None  	switch (this.TickStyle) {  	case TickStyle.Outside:  		height += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		height += this.MajorTickSize * 0.75;  		break;  	}  	height += this.AxisDistance;  	height += this.AxisTickToLabelDistance;  	height += maximumTextSize.Height;  	if (labelTextSize.Height > 0) {  		height += this.AxisTitleDistance;  		height += labelTextSize.Height;  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: switch (this.TickStyle) {  case TickStyle.Outside:  	width += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	width += this.MajorTickSize * 0.75;  	break;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: width += this.MajorTickSize * 0.75;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: switch (this.TickStyle) {  case TickStyle.Outside:  	height += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	height += this.MajorTickSize * 0.75;  	break;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: height += this.MajorTickSize * 0.75;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: if (double.IsNaN (this.ActualMinorStep)) {  	this.ActualMinorStep = 2;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMinorStep = 2;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: if (double.IsNaN (this.ActualMajorStep)) {  	this.ActualMajorStep = 10;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMajorStep = 10;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,FormatValueOverride,The following statement contains a magic number: if (this.UseSuperExponentialFormat && !x.Equals (0)) {  	double exp = Exponent (x);  	double mantissa = Mantissa (x);  	string fmt;  	if (this.StringFormat == null) {  		fmt = Math.Abs (mantissa - 1.0) < 1e-6 ? "10^{{{1:0}}}" : "{0}10^{{{1:0}}}";  	}  	else {  		fmt = "{0:" + this.StringFormat + "}10^{{{1:0}}}";  	}  	return string.Format (this.ActualCulture' fmt' mantissa' exp);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,FormatValueOverride,The following statement contains a magic number: if (this.StringFormat == null) {  	fmt = Math.Abs (mantissa - 1.0) < 1e-6 ? "10^{{{1:0}}}" : "{0}10^{{{1:0}}}";  }  else {  	fmt = "{0:" + this.StringFormat + "}10^{{{1:0}}}";  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,FormatValueOverride,The following statement contains a magic number: fmt = Math.Abs (mantissa - 1.0) < 1e-6 ? "10^{{{1:0}}}" : "{0}10^{{{1:0}}}";  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualMaximum,The following statement contains a magic number: if (range < double.Epsilon) {  	double zeroRange = this.DataMaximum > 0 ? this.DataMaximum : 1;  	actualMaximum += zeroRange * 0.5;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualMaximum,The following statement contains a magic number: actualMaximum += zeroRange * 0.5;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualMinimum,The following statement contains a magic number: if (range < double.Epsilon) {  	double zeroRange = this.DataMaximum > 0 ? this.DataMaximum : 1;  	actualMinimum -= zeroRange * 0.5;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualMinimum,The following statement contains a magic number: actualMinimum -= zeroRange * 0.5;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (intervalCandidate);  	if (m == 5) {  		// reduce 5 to 2  		intervalCandidate = removeNoise (intervalCandidate / 2.5);  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	else {  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	if (range / intervalCandidate > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (intervalCandidate) || double.IsInfinity (intervalCandidate)) {  		break;  	}  	interval = intervalCandidate;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (intervalCandidate);  	if (m == 5) {  		// reduce 5 to 2  		intervalCandidate = removeNoise (intervalCandidate / 2.5);  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	else {  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	if (range / intervalCandidate > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (intervalCandidate) || double.IsInfinity (intervalCandidate)) {  		break;  	}  	interval = intervalCandidate;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (intervalCandidate);  	if (m == 5) {  		// reduce 5 to 2  		intervalCandidate = removeNoise (intervalCandidate / 2.5);  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	else {  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	if (range / intervalCandidate > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (intervalCandidate) || double.IsInfinity (intervalCandidate)) {  		break;  	}  	interval = intervalCandidate;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (intervalCandidate);  	if (m == 5) {  		// reduce 5 to 2  		intervalCandidate = removeNoise (intervalCandidate / 2.5);  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	else {  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	if (range / intervalCandidate > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (intervalCandidate) || double.IsInfinity (intervalCandidate)) {  		break;  	}  	interval = intervalCandidate;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (intervalCandidate);  	if (m == 5) {  		// reduce 5 to 2  		intervalCandidate = removeNoise (intervalCandidate / 2.5);  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	else {  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	if (range / intervalCandidate > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (intervalCandidate) || double.IsInfinity (intervalCandidate)) {  		break;  	}  	interval = intervalCandidate;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (intervalCandidate);  	if (m == 5) {  		// reduce 5 to 2  		intervalCandidate = removeNoise (intervalCandidate / 2.5);  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	else {  		intervalCandidate = removeNoise (intervalCandidate / 2.0);  	}  	if (range / intervalCandidate > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (intervalCandidate) || double.IsInfinity (intervalCandidate)) {  		break;  	}  	interval = intervalCandidate;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	intervalCandidate = removeNoise (intervalCandidate / 2.5);  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	intervalCandidate = removeNoise (intervalCandidate / 2.5);  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	intervalCandidate = removeNoise (intervalCandidate / 2.5);  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	intervalCandidate = removeNoise (intervalCandidate / 2.5);  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	intervalCandidate = removeNoise (intervalCandidate / 2.5);  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	intervalCandidate = removeNoise (intervalCandidate / 2.5);  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: intervalCandidate = removeNoise (intervalCandidate / 2.5);  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  else {  	intervalCandidate = removeNoise (intervalCandidate / 2.0);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: intervalCandidate = removeNoise (intervalCandidate / 2.0);  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: intervalCandidate = removeNoise (intervalCandidate / 2.0);  
Magic Number,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,CalculateMinorInterval,The following statement contains a magic number: return majorInterval / 5;  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,GetCategoryValue,The following statement contains a magic number: return categoryIndex - 0.5 + ((offsetEnd + offsetBegin - actualBarWidth) * 0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,GetCategoryValue,The following statement contains a magic number: return categoryIndex - 0.5 + ((offsetEnd + offsetBegin - actualBarWidth) * 0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,GetCategoryValue,The following statement contains a magic number: return categoryIndex - 0.5 + this.BarOffset [categoryIndex];  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,GetTickValues,The following statement contains a magic number: if (!this.IsTickCentered) {  	// Subtract 0.5 from the label values to get the tick values.  	// Add one extra tick at the end.  	var mv = new List<double> (majorLabelValues.Count);  	mv.AddRange (majorLabelValues.Select (v => v - 0.5));  	if (mv.Count > 0) {  		mv.Add (mv [mv.Count - 1] + 1);  	}  	majorTickValues = mv;  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,GetTickValues,The following statement contains a magic number: mv.AddRange (majorLabelValues.Select (v => v - 0.5));  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.Include (-0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (actualLabels.Count > 0) {  	this.Include ((actualLabels.Count - 1) + 0.5);  }  else {  	this.Include (0.5);  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (actualLabels.Count > 0) {  	this.Include ((actualLabels.Count - 1) + 0.5);  }  else {  	this.Include (0.5);  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.Include ((actualLabels.Count - 1) + 0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.Include (0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The following statement contains a magic number: for (var i = 0; i < actualLabels.Count; i++) {  	this.BarOffset [i] = 0.5 - (this.TotalWidthPerCategory [i] * factor);  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The following statement contains a magic number: this.BarOffset [i] = 0.5 - (this.TotalWidthPerCategory [i] * factor);  
Magic Number,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  	};  	IList<double> majorLabelValues;  	IList<double> majorTickValues;  	IList<double> minorTickValues;  	this.GetTickValues (out majorLabelValues' out majorTickValues' out minorTickValues);  	int n = this.Palette.Colors.Count;  	for (int i = 0; i < n; i++) {  		double low = this.Transform (this.GetLowValue (i' majorLabelValues));  		double high = this.Transform (this.GetHighValue (i' majorLabelValues));  		drawColorRect (low' high' this.Palette.Colors [i]);  	}  }  
Magic Number,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  	};  	IList<double> majorLabelValues;  	IList<double> majorTickValues;  	IList<double> minorTickValues;  	this.GetTickValues (out majorLabelValues' out majorTickValues' out minorTickValues);  	int n = this.Palette.Colors.Count;  	for (int i = 0; i < n; i++) {  		double low = this.Transform (this.GetLowValue (i' majorLabelValues));  		double high = this.Transform (this.GetHighValue (i' majorLabelValues));  		drawColorRect (low' high' this.Palette.Colors [i]);  	}  }  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,LinearColorAxis,The following statement contains a magic number: this.AxisDistance = 20;  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,LinearColorAxis,The following statement contains a magic number: this.Palette = OxyPalettes.Jet (200);  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double distance = this.AxisDistance;  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width - distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift + distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height - distance;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift + distance;  		break;  	}  	if (this.RenderAsImage) {  		var axisLength = this.Transform (this.ActualMaximum) - this.Transform (this.ActualMinimum);  		bool reverse = axisLength > 0;  		axisLength = Math.Abs (axisLength);  		if (this.IsHorizontal ()) {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' axisLength' height' 1' true);  		}  		else {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' width' axisLength' 1' true);  		}  	}  	else {  		Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  			double ymin = Math.Min (ylow' yhigh);  			double ymax = Math.Max (ylow' yhigh) + 0.5;  			rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  		};  		int n = this.Palette.Colors.Count;  		for (int i = 0; i < n; i++) {  			double ylow = this.Transform (this.GetLowValue (i));  			double yhigh = this.Transform (this.GetHighValue (i));  			drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  		}  		double highLowLength = 10;  		if (this.IsHorizontal ()) {  			highLowLength *= -1;  		}  		if (!this.LowColor.IsUndefined ()) {  			double ylow = this.Transform (this.ActualMinimum);  			drawColorRect (ylow' ylow + highLowLength' this.LowColor);  		}  		if (!this.HighColor.IsUndefined ()) {  			double yhigh = this.Transform (this.ActualMaximum);  			drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  		}  	}  }  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double distance = this.AxisDistance;  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width - distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift + distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height - distance;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift + distance;  		break;  	}  	if (this.RenderAsImage) {  		var axisLength = this.Transform (this.ActualMaximum) - this.Transform (this.ActualMinimum);  		bool reverse = axisLength > 0;  		axisLength = Math.Abs (axisLength);  		if (this.IsHorizontal ()) {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' axisLength' height' 1' true);  		}  		else {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' width' axisLength' 1' true);  		}  	}  	else {  		Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  			double ymin = Math.Min (ylow' yhigh);  			double ymax = Math.Max (ylow' yhigh) + 0.5;  			rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  		};  		int n = this.Palette.Colors.Count;  		for (int i = 0; i < n; i++) {  			double ylow = this.Transform (this.GetLowValue (i));  			double yhigh = this.Transform (this.GetHighValue (i));  			drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  		}  		double highLowLength = 10;  		if (this.IsHorizontal ()) {  			highLowLength *= -1;  		}  		if (!this.LowColor.IsUndefined ()) {  			double ylow = this.Transform (this.ActualMinimum);  			drawColorRect (ylow' ylow + highLowLength' this.LowColor);  		}  		if (!this.HighColor.IsUndefined ()) {  			double yhigh = this.Transform (this.ActualMaximum);  			drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  		}  	}  }  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double distance = this.AxisDistance;  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width - distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift + distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height - distance;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift + distance;  		break;  	}  	if (this.RenderAsImage) {  		var axisLength = this.Transform (this.ActualMaximum) - this.Transform (this.ActualMinimum);  		bool reverse = axisLength > 0;  		axisLength = Math.Abs (axisLength);  		if (this.IsHorizontal ()) {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' axisLength' height' 1' true);  		}  		else {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' width' axisLength' 1' true);  		}  	}  	else {  		Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  			double ymin = Math.Min (ylow' yhigh);  			double ymax = Math.Max (ylow' yhigh) + 0.5;  			rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  		};  		int n = this.Palette.Colors.Count;  		for (int i = 0; i < n; i++) {  			double ylow = this.Transform (this.GetLowValue (i));  			double yhigh = this.Transform (this.GetHighValue (i));  			drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  		}  		double highLowLength = 10;  		if (this.IsHorizontal ()) {  			highLowLength *= -1;  		}  		if (!this.LowColor.IsUndefined ()) {  			double ylow = this.Transform (this.ActualMinimum);  			drawColorRect (ylow' ylow + highLowLength' this.LowColor);  		}  		if (!this.HighColor.IsUndefined ()) {  			double yhigh = this.Transform (this.ActualMaximum);  			drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  		}  	}  }  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double distance = this.AxisDistance;  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width - distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift + distance;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height - distance;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift + distance;  		break;  	}  	if (this.RenderAsImage) {  		var axisLength = this.Transform (this.ActualMaximum) - this.Transform (this.ActualMinimum);  		bool reverse = axisLength > 0;  		axisLength = Math.Abs (axisLength);  		if (this.IsHorizontal ()) {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' axisLength' height' 1' true);  		}  		else {  			var colorAxisImage = this.GenerateColorAxisImage (reverse);  			rc.DrawImage (colorAxisImage' left' top' width' axisLength' 1' true);  		}  	}  	else {  		Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  			double ymin = Math.Min (ylow' yhigh);  			double ymax = Math.Max (ylow' yhigh) + 0.5;  			rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  		};  		int n = this.Palette.Colors.Count;  		for (int i = 0; i < n; i++) {  			double ylow = this.Transform (this.GetLowValue (i));  			double yhigh = this.Transform (this.GetHighValue (i));  			drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  		}  		double highLowLength = 10;  		if (this.IsHorizontal ()) {  			highLowLength *= -1;  		}  		if (!this.LowColor.IsUndefined ()) {  			double ylow = this.Transform (this.ActualMinimum);  			drawColorRect (ylow' ylow + highLowLength' this.LowColor);  		}  		if (!this.HighColor.IsUndefined ()) {  			double yhigh = this.Transform (this.ActualMaximum);  			drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  		}  	}  }  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The following statement contains a magic number: if (this.RenderAsImage) {  	var axisLength = this.Transform (this.ActualMaximum) - this.Transform (this.ActualMinimum);  	bool reverse = axisLength > 0;  	axisLength = Math.Abs (axisLength);  	if (this.IsHorizontal ()) {  		var colorAxisImage = this.GenerateColorAxisImage (reverse);  		rc.DrawImage (colorAxisImage' left' top' axisLength' height' 1' true);  	}  	else {  		var colorAxisImage = this.GenerateColorAxisImage (reverse);  		rc.DrawImage (colorAxisImage' left' top' width' axisLength' 1' true);  	}  }  else {  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh) + 0.5;  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  	};  	int n = this.Palette.Colors.Count;  	for (int i = 0; i < n; i++) {  		double ylow = this.Transform (this.GetLowValue (i));  		double yhigh = this.Transform (this.GetHighValue (i));  		drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (!this.LowColor.IsUndefined ()) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (!this.HighColor.IsUndefined ()) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The following statement contains a magic number: if (this.RenderAsImage) {  	var axisLength = this.Transform (this.ActualMaximum) - this.Transform (this.ActualMinimum);  	bool reverse = axisLength > 0;  	axisLength = Math.Abs (axisLength);  	if (this.IsHorizontal ()) {  		var colorAxisImage = this.GenerateColorAxisImage (reverse);  		rc.DrawImage (colorAxisImage' left' top' axisLength' height' 1' true);  	}  	else {  		var colorAxisImage = this.GenerateColorAxisImage (reverse);  		rc.DrawImage (colorAxisImage' left' top' width' axisLength' 1' true);  	}  }  else {  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh) + 0.5;  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' OxyColors.Undefined);  	};  	int n = this.Palette.Colors.Count;  	for (int i = 0; i < n; i++) {  		double ylow = this.Transform (this.GetLowValue (i));  		double yhigh = this.Transform (this.GetHighValue (i));  		drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (!this.LowColor.IsUndefined ()) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (!this.HighColor.IsUndefined ()) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: switch (this.actualIntervalType) {  case DateTimeIntervalType.Years:  	this.ActualMinorStep = 31;  	this.actualMinorIntervalType = DateTimeIntervalType.Years;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy";  	}  	break;  case DateTimeIntervalType.Months:  	this.actualMinorIntervalType = DateTimeIntervalType.Months;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Weeks:  	this.actualMinorIntervalType = DateTimeIntervalType.Days;  	this.ActualMajorStep = 7;  	this.ActualMinorStep = 1;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy/ww";  	}  	break;  case DateTimeIntervalType.Days:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Hours:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Minutes:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Seconds:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm:ss";  	}  	break;  case DateTimeIntervalType.Manual:  	break;  case DateTimeIntervalType.Auto:  	break;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: switch (this.actualIntervalType) {  case DateTimeIntervalType.Years:  	this.ActualMinorStep = 31;  	this.actualMinorIntervalType = DateTimeIntervalType.Years;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy";  	}  	break;  case DateTimeIntervalType.Months:  	this.actualMinorIntervalType = DateTimeIntervalType.Months;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Weeks:  	this.actualMinorIntervalType = DateTimeIntervalType.Days;  	this.ActualMajorStep = 7;  	this.ActualMinorStep = 1;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy/ww";  	}  	break;  case DateTimeIntervalType.Days:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Hours:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Minutes:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Seconds:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm:ss";  	}  	break;  case DateTimeIntervalType.Manual:  	break;  case DateTimeIntervalType.Auto:  	break;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMinorStep = 31;  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMajorStep = 7;  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	if (range / interval < maxNumberOfIntervals) {  		break;  	}  	double nextInterval = goodIntervals.FirstOrDefault (i => i > interval);  	if (Math.Abs (nextInterval) < double.Epsilon) {  		nextInterval = interval * 2;  	}  	interval = nextInterval;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (Math.Abs (nextInterval) < double.Epsilon) {  	nextInterval = interval * 2;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: nextInterval = interval * 2;  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 1.0 / 24 / 60) {  	this.actualIntervalType = DateTimeIntervalType.Minutes;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 1.0 / 24 / 60) {  	this.actualIntervalType = DateTimeIntervalType.Minutes;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 1.0 / 24) {  	this.actualIntervalType = DateTimeIntervalType.Hours;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 30) {  	this.actualIntervalType = DateTimeIntervalType.Months;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (range >= 365.25) {  	this.actualIntervalType = DateTimeIntervalType.Years;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.actualIntervalType == DateTimeIntervalType.Months) {  	double monthsRange = range / 30.5;  	interval = this.CalculateActualInterval (availableSize' maxIntervalSize' monthsRange);  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.actualIntervalType == DateTimeIntervalType.Years) {  	double yearsRange = range / 365.25;  	interval = this.CalculateActualInterval (availableSize' maxIntervalSize' yearsRange);  }  
Magic Number,OxyPlot.Axes,LinearAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearAxis.cs,FormatValueOverride,The following statement contains a magic number: if (this.FormatAsFractions) {  	return FractionHelper.ConvertToFractionString (x' this.FractionUnit' this.FractionUnitSymbol' 1e-6' this.ActualCulture' this.StringFormat);  }  
Magic Number,OxyPlot.Axes,LinearAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearAxis.cs,FormatValueOverride,The following statement contains a magic number: return FractionHelper.ConvertToFractionString (x' this.FractionUnit' this.FractionUnitSymbol' 1e-6' this.ActualCulture' this.StringFormat);  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\MagnitudeAxis.cs,Transform,The following statement contains a magic number: return new ScreenPoint (this.MidPoint.x + (r * Math.Cos (theta / 180 * Math.PI))' this.MidPoint.y - (r * Math.Sin (theta / 180 * Math.PI)));  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\MagnitudeAxis.cs,Transform,The following statement contains a magic number: return new ScreenPoint (this.MidPoint.x + (r * Math.Cos (theta / 180 * Math.PI))' this.MidPoint.y - (r * Math.Sin (theta / 180 * Math.PI)));  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\MagnitudeAxis.cs,UpdateTransform,The following statement contains a magic number: this.MidPoint = new ScreenPoint ((x0 + x1) / 2' (y0 + y1) / 2);  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\MagnitudeAxis.cs,UpdateTransform,The following statement contains a magic number: this.MidPoint = new ScreenPoint ((x0 + x1) / 2' (y0 + y1) / 2);  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\MagnitudeAxis.cs,UpdateTransform,The following statement contains a magic number: this.SetTransform (0.5 * r / (this.ActualMaximum - this.ActualMinimum)' this.ActualMinimum);  
Magic Number,OxyPlot.Axes,TimeSpanAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\TimeSpanAxis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	if (range / interval < maxNumberOfIntervals) {  		return interval;  	}  	double nextInterval = goodIntervals.FirstOrDefault (i => i > interval);  	if (Math.Abs (nextInterval) < double.Epsilon) {  		nextInterval = interval * 2;  	}  	interval = nextInterval;  }  
Magic Number,OxyPlot.Axes,TimeSpanAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\TimeSpanAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (Math.Abs (nextInterval) < double.Epsilon) {  	nextInterval = interval * 2;  }  
Magic Number,OxyPlot.Axes,TimeSpanAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\TimeSpanAxis.cs,CalculateActualInterval,The following statement contains a magic number: nextInterval = interval * 2;  
Magic Number,OxyPlot.Axes,AxisRendererBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: switch (tickStyle) {  case TickStyle.Crossing:  	x0 = -tickSize * sign * 0.75;  	x1 = tickSize * sign * 0.75;  	break;  case TickStyle.Inside:  	x0 = -tickSize * sign;  	break;  case TickStyle.Outside:  	x1 = tickSize * sign;  	break;  }  
Magic Number,OxyPlot.Axes,AxisRendererBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: switch (tickStyle) {  case TickStyle.Crossing:  	x0 = -tickSize * sign * 0.75;  	x1 = tickSize * sign * 0.75;  	break;  case TickStyle.Inside:  	x0 = -tickSize * sign;  	break;  case TickStyle.Outside:  	x1 = tickSize * sign;  	break;  }  
Magic Number,OxyPlot.Axes,AxisRendererBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: x0 = -tickSize * sign * 0.75;  
Magic Number,OxyPlot.Axes,AxisRendererBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: x1 = tickSize * sign * 0.75;  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (var value in this.MajorLabelValues.Take (majorTickCount)) {  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	var angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	var text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (var value in this.MajorLabelValues.Take (majorTickCount)) {  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	var angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	var text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (var value in this.MajorLabelValues.Take (majorTickCount)) {  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	var angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	var text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (var value in this.MajorLabelValues.Take (majorTickCount)) {  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	var angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	var text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (var value in this.MajorLabelValues.Take (majorTickCount)) {  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	var angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	var text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (var value in this.MajorLabelValues.Take (majorTickCount)) {  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	var angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	var text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (var value in this.MajorLabelValues.Take (majorTickCount)) {  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	var angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	var text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.RenderContext.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: angle *= 180 / Math.PI;  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: va = angle >= 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot.Axes,AngleAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AngleAxisRenderer.cs,Render,The following statement contains a magic number: angle -= 180;  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle > 3 * Math.PI / 4 || actualAngle < -3 * Math.PI / 4) {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Top;  }  else if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle > 3 * Math.PI / 4 || actualAngle < -3 * Math.PI / 4) {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Top;  }  else if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle > 3 * Math.PI / 4 || actualAngle < -3 * Math.PI / 4) {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Top;  }  else if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle > 3 * Math.PI / 4 || actualAngle < -3 * Math.PI / 4) {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Top;  }  else if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle > 3 * Math.PI / 4 || actualAngle < -3 * Math.PI / 4) {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Top;  }  else if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle > 3 * Math.PI / 4 || actualAngle < -3 * Math.PI / 4) {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Top;  }  else if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle < -Math.PI / 4) {  	ha = HorizontalAlignment.Right;  	va = VerticalAlignment.Middle;  }  else if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,MagnitudeAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\MagnitudeAxisRenderer.cs,GetTickTextAligment,The following statement contains a magic number: if (actualAngle > Math.PI / 4) {  	ha = HorizontalAlignment.Left;  	va = VerticalAlignment.Middle;  }  else {  	ha = HorizontalAlignment.Center;  	va = VerticalAlignment.Bottom;  }  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: Debug.Assert (angle <= 180 && angle >= -180' "Axis angle should be in the interval [-180'180] degrees.");  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: Debug.Assert (angle <= 180 && angle >= -180' "Axis angle should be in the interval [-180'180] degrees.");  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > -45 && angle < 45) {  	return;  }  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > -45 && angle < 45) {  	return;  }  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > 135 || angle < -135) {  	ha = (HorizontalAlignment)(-(int)defaultHorizontalAlignment);  	va = (VerticalAlignment)(-(int)defaultVerticalAlignment);  	return;  }  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > 135 || angle < -135) {  	ha = (HorizontalAlignment)(-(int)defaultHorizontalAlignment);  	va = (VerticalAlignment)(-(int)defaultVerticalAlignment);  	return;  }  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > 45) {  	ha = (HorizontalAlignment)((int)defaultVerticalAlignment);  	va = (VerticalAlignment)(-(int)defaultHorizontalAlignment);  	return;  }  
Magic Number,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle < -45) {  	ha = (HorizontalAlignment)(-(int)defaultVerticalAlignment);  	va = (VerticalAlignment)((int)defaultHorizontalAlignment);  }  
Magic Number,OxyPlot.Reporting,WikiReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,WikiReportWriter,The following statement contains a magic number: this.MaxLineLength = 60;  
Magic Number,OxyPlot.Reporting,WikiReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,PadString,The following statement contains a magic number: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
Magic Number,OxyPlot.Reporting,WikiReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,PadString,The following statement contains a magic number: text = text.PadRight ((text.Length + width) / 2);  
Magic Number,OxyPlot.Reporting,TextReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,TextReportWriter,The following statement contains a magic number: this.MaxLineLength = 60;  
Magic Number,OxyPlot.Reporting,TextReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,PadString,The following statement contains a magic number: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
Magic Number,OxyPlot.Reporting,TextReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,PadString,The following statement contains a magic number: text = text.PadRight ((text.Length + width) / 2);  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.DefaultStyle = new ParagraphStyle {  	FontFamily = bodyTextFontFamily'  	FontSize = 11'  	SpacingAfter = 10  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.DefaultStyle = new ParagraphStyle {  	FontFamily = bodyTextFontFamily'  	FontSize = 11'  	SpacingAfter = 10  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles = new ParagraphStyle[5];  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [0] = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = titleFontFamily'  	SpacingBefore = 12'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [0] = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = titleFontFamily'  	SpacingBefore = 12'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [0].FontSize = 16;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [1].FontSize = 14;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [2].FontSize = 13;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [2].FontSize = 13;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [3].FontSize = 12;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [3].FontSize = 12;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [4].FontSize = 11;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [4].FontSize = 11;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableTextStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = tableTextFontFamily'  	SpacingAfter = 0'  	LeftIndentation = 3'  	RightIndentation = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableTextStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = tableTextFontFamily'  	SpacingAfter = 0'  	LeftIndentation = 3'  	RightIndentation = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableCaptionStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	Italic = true'  	SpacingBefore = 10'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableCaptionStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	Italic = true'  	SpacingBefore = 10'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.Margins = new OxyThickness (25);  
Magic Number,OxyPlot.Reporting,HeaderHelper,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\HeaderHelper.cs,GetHeader,The following statement contains a magic number: for (int i = level + 1; i < 10; i++) {  	this.headerLevel [i] = 0;  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (this.Width < 0) {  	this.ActualWidth = 150 * (-this.Width);  }  else {  	this.ActualWidth = this.Width;  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: this.ActualWidth = 150 * (-this.Width);  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: foreach (var c in this.Columns) {  	if (double.IsNaN (c.Width)) {  		// todo: find auto width  		c.ActualWidth = 40;  		totalWidth += c.ActualWidth;  	}  	if (c.Width < 0) {  		totalWeight += -c.Width;  	}  	if (c.Width >= 0) {  		totalWidth += c.Width;  		c.ActualWidth = c.Width;  	}  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (double.IsNaN (c.Width)) {  	// todo: find auto width  	c.ActualWidth = 40;  	totalWidth += c.ActualWidth;  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: c.ActualWidth = 40;  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (double.IsNaN (this.ActualWidth)) {  	this.ActualWidth = Math.Max (150' totalWidth + 100);  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (double.IsNaN (this.ActualWidth)) {  	this.ActualWidth = Math.Max (150' totalWidth + 100);  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: this.ActualWidth = Math.Max (150' totalWidth + 100);  
Magic Number,OxyPlot.Reporting,Table,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: this.ActualWidth = Math.Max (150' totalWidth + 100);  
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((20' 280)' (298' 558)' (576' 836)' (854' 1114))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((20' 55)' (576' 611)' (854' 889)' (298' 333))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((23' 42)' (24' 43)' (25' 44)' (26' 45)' (27' 46)' (28' 47)' (29' 48)' (30' 49)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (301' 320)' (302' 321)' (303' 322)' (304' 323)' (305' 324)' (306' 325)' (307' 326)' (308' 327)' (309' 328)' (310' 329)' (311' 330)' (312' 331)' (313' 332)' (579' 598)' (580' 599)' (581' 600)' (582' 601)' (583' 602)' (584' 603)' (585' 604)' (586' 605)' (587' 606)' (588' 607)' (589' 608)' (590' 609)' (591' 610)' (857' 876)' (858' 877)' (859' 878)' (860' 879)' (861' 880)' (862' 881)' (863' 882)' (864' 883)' (865' 884)' (866' 885)' (867' 886)' (868' 887)' (869' 888))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((23' 53)' (24' 54)' (301' 331)' (302' 332)' (579' 609)' (580' 610)' (857' 887)' (858' 888))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((23' 42)' (25' 44)' (26' 45)' (27' 46)' (28' 47)' (29' 48)' (30' 49)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (301' 320)' (303' 322)' (304' 323)' (305' 324)' (306' 325)' (307' 326)' (308' 327)' (309' 328)' (310' 329)' (311' 330)' (312' 331)' (313' 332)' (579' 598)' (581' 600)' (582' 601)' (583' 602)' (584' 603)' (585' 604)' (586' 605)' (587' 606)' (588' 607)' (589' 608)' (590' 609)' (591' 610)' (857' 876)' (859' 878)' (860' 879)' (861' 880)' (862' 881)' (863' 882)' (864' 883)' (865' 884)' (866' 885)' (867' 886)' (868' 887)' (869' 888))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((221' 253)' (777' 809)' (1055' 1087)' (499' 531))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1138' 1174)' (1416' 1452)' (1694' 1730))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1138' 1173)' (1972' 2007)' (1416' 1451)' (1694' 1729))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1141' 1160)' (1142' 1161)' (1143' 1162)' (1144' 1163)' (1145' 1164)' (1146' 1165)' (1147' 1166)' (1148' 1167)' (1149' 1168)' (1150' 1169)' (1151' 1170)' (1152' 1171)' (1153' 1172)' (1419' 1438)' (1420' 1439)' (1421' 1440)' (1422' 1441)' (1423' 1442)' (1424' 1443)' (1425' 1444)' (1426' 1445)' (1427' 1446)' (1428' 1447)' (1429' 1448)' (1430' 1449)' (1431' 1450)' (1697' 1716)' (1698' 1717)' (1699' 1718)' (1700' 1719)' (1701' 1720)' (1702' 1721)' (1703' 1722)' (1704' 1723)' (1705' 1724)' (1706' 1725)' (1707' 1726)' (1708' 1727)' (1709' 1728)' (1975' 1994)' (1976' 1995)' (1977' 1996)' (1978' 1997)' (1979' 1998)' (1980' 1999)' (1981' 2000)' (1982' 2001)' (1983' 2002)' (1984' 2003)' (1985' 2004)' (1986' 2005)' (1987' 2006))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1141' 1171)' (1142' 1172)' (1419' 1449)' (1420' 1450)' (1697' 1727)' (1698' 1728)' (1975' 2005)' (1976' 2006))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1141' 1160)' (1143' 1162)' (1144' 1163)' (1145' 1164)' (1146' 1165)' (1147' 1166)' (1148' 1167)' (1149' 1168)' (1150' 1169)' (1151' 1170)' (1152' 1171)' (1153' 1172)' (1419' 1438)' (1421' 1440)' (1422' 1441)' (1423' 1442)' (1424' 1443)' (1425' 1444)' (1426' 1445)' (1427' 1446)' (1428' 1447)' (1429' 1448)' (1430' 1449)' (1431' 1450)' (1697' 1716)' (1699' 1718)' (1700' 1719)' (1701' 1720)' (1702' 1721)' (1703' 1722)' (1704' 1723)' (1705' 1724)' (1706' 1725)' (1707' 1726)' (1708' 1727)' (1709' 1728)' (1975' 1994)' (1977' 1996)' (1978' 1997)' (1979' 1998)' (1980' 1999)' (1981' 2000)' (1982' 2001)' (1983' 2002)' (1984' 2003)' (1985' 2004)' (1986' 2005)' (1987' 2006))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1371' 1393)' (1649' 1671))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1736' 1760)' (2014' 2038))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1921' 1949)' (2199' 2227))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((2256' 2516)' (2534' 2794)' (2812' 3072)' (3090' 3350))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((2259' 2278)' (2260' 2279)' (2261' 2280)' (2262' 2281)' (2263' 2282)' (2264' 2283)' (2265' 2284)' (2266' 2285)' (2267' 2286)' (2268' 2287)' (2269' 2288)' (2270' 2289)' (2271' 2290)' (2272' 2291)' (2273' 2292)' (2274' 2293)' (2275' 2294)' (2276' 2295)' (2277' 2296)' (2278' 2297)' (2279' 2298)' (2280' 2299)' (2281' 2300)' (2282' 2301)' (2283' 2302)' (2284' 2303)' (2285' 2304)' (2286' 2305)' (2287' 2306)' (2288' 2307)' (2289' 2308)' (2290' 2309)' (2291' 2310)' (2292' 2311)' (2293' 2312)' (2294' 2313)' (2295' 2314)' (2296' 2315)' (2297' 2316)' (2298' 2317)' (2299' 2318)' (2300' 2319)' (2301' 2320)' (2302' 2321)' (2303' 2322)' (2304' 2323)' (2305' 2324)' (2306' 2325)' (2307' 2326)' (2308' 2327)' (2309' 2328)' (2310' 2329)' (2311' 2330)' (2312' 2331)' (2313' 2332)' (2314' 2333)' (2315' 2334)' (2316' 2335)' (2317' 2336)' (2318' 2337)' (2319' 2338)' (2320' 2339)' (2321' 2340)' (2322' 2341)' (2323' 2342)' (2324' 2343)' (2325' 2344)' (2326' 2345)' (2327' 2346)' (2328' 2347)' (2329' 2348)' (2330' 2349)' (2331' 2350)' (2332' 2351)' (2333' 2352)' (2334' 2353)' (2335' 2354)' (2336' 2355)' (2337' 2356)' (2338' 2357)' (2339' 2358)' (2340' 2359)' (2341' 2360)' (2342' 2361)' (2343' 2362)' (2344' 2363)' (2345' 2364)' (2346' 2365)' (2347' 2366)' (2348' 2367)' (2349' 2368)' (2350' 2369)' (2351' 2370)' (2352' 2371)' (2353' 2372)' (2354' 2373)' (2355' 2374)' (2356' 2375)' (2357' 2376)' (2358' 2377)' (2359' 2378)' (2360' 2379)' (2361' 2380)' (2362' 2381)' (2363' 2382)' (2364' 2383)' (2365' 2384)' (2366' 2385)' (2367' 2386)' (2368' 2387)' (2369' 2388)' (2370' 2389)' (2371' 2390)' (2372' 2391)' (2373' 2392)' (2374' 2393)' (2375' 2394)' (2376' 2395)' (2377' 2396)' (2378' 2397)' (2379' 2398)' (2380' 2399)' (2381' 2400)' (2382' 2401)' (2383' 2402)' (2384' 2403)' (2385' 2404)' (2386' 2405)' (2387' 2406)' (2388' 2407)' (2389' 2408)' (2390' 2409)' (2391' 2410)' (2392' 2411)' (2393' 2412)' (2394' 2413)' (2395' 2414)' (2396' 2415)' (2397' 2416)' (2398' 2417)' (2399' 2418)' (2400' 2419)' (2401' 2420)' (2402' 2421)' (2403' 2422)' (2404' 2423)' (2405' 2424)' (2406' 2425)' (2407' 2426)' (2408' 2427)' (2409' 2428)' (2410' 2429)' (2411' 2430)' (2412' 2431)' (2413' 2432)' (2414' 2433)' (2415' 2434)' (2416' 2435)' (2417' 2436)' (2418' 2437)' (2419' 2438)' (2420' 2439)' (2421' 2440)' (2422' 2441)' (2423' 2442)' (2424' 2443)' (2425' 2444)' (2426' 2445)' (2427' 2446)' (2428' 2447)' (2429' 2448)' (2430' 2449)' (2431' 2450)' (2432' 2451)' (2433' 2452)' (2434' 2453)' (2435' 2454)' (2436' 2455)' (2437' 2456)' (2438' 2457)' (2439' 2458)' (2440' 2459)' (2441' 2460)' (2442' 2461)' (2443' 2462)' (2444' 2463)' (2445' 2464)' (2446' 2465)' (2447' 2466)' (2448' 2467)' (2449' 2468)' (2450' 2469)' (2451' 2470)' (2452' 2471)' (2453' 2472)' (2454' 2473)' (2455' 2474)' (2456' 2475)' (2457' 2476)' (2458' 2477)' (2459' 2478)' (2460' 2479)' (2461' 2480)' (2462' 2481)' (2463' 2482)' (2464' 2483)' (2465' 2484)' (2466' 2485)' (2467' 2486)' (2468' 2487)' (2469' 2488)' (2470' 2489)' (2471' 2490)' (2472' 2491)' (2473' 2492)' (2474' 2493)' (2475' 2494)' (2476' 2495)' (2477' 2496)' (2478' 2497)' (2479' 2498)' (2480' 2499)' (2481' 2500)' (2482' 2501)' (2483' 2502)' (2484' 2503)' (2485' 2504)' (2486' 2505)' (2487' 2506)' (2488' 2507)' (2489' 2508)' (2490' 2509)' (2491' 2510)' (2492' 2511)' (2493' 2512)' (2494' 2513)' (2537' 2556)' (2538' 2557)' (2539' 2558)' (2540' 2559)' (2541' 2560)' (2542' 2561)' (2543' 2562)' (2544' 2563)' (2545' 2564)' (2546' 2565)' (2547' 2566)' (2548' 2567)' (2549' 2568)' (2550' 2569)' (2551' 2570)' (2552' 2571)' (2553' 2572)' (2554' 2573)' (2555' 2574)' (2556' 2575)' (2557' 2576)' (2558' 2577)' (2559' 2578)' (2560' 2579)' (2561' 2580)' (2562' 2581)' (2563' 2582)' (2564' 2583)' (2565' 2584)' (2566' 2585)' (2567' 2586)' (2568' 2587)' (2569' 2588)' (2570' 2589)' (2571' 2590)' (2572' 2591)' (2573' 2592)' (2574' 2593)' (2575' 2594)' (2576' 2595)' (2577' 2596)' (2578' 2597)' (2579' 2598)' (2580' 2599)' (2581' 2600)' (2582' 2601)' (2583' 2602)' (2584' 2603)' (2585' 2604)' (2586' 2605)' (2587' 2606)' (2588' 2607)' (2589' 2608)' (2590' 2609)' (2591' 2610)' (2592' 2611)' (2593' 2612)' (2594' 2613)' (2595' 2614)' (2596' 2615)' (2597' 2616)' (2598' 2617)' (2599' 2618)' (2600' 2619)' (2601' 2620)' (2602' 2621)' (2603' 2622)' (2604' 2623)' (2605' 2624)' (2606' 2625)' (2607' 2626)' (2608' 2627)' (2609' 2628)' (2610' 2629)' (2611' 2630)' (2612' 2631)' (2613' 2632)' (2614' 2633)' (2615' 2634)' (2616' 2635)' (2617' 2636)' (2618' 2637)' (2619' 2638)' (2620' 2639)' (2621' 2640)' (2622' 2641)' (2623' 2642)' (2624' 2643)' (2625' 2644)' (2626' 2645)' (2627' 2646)' (2628' 2647)' (2629' 2648)' (2630' 2649)' (2631' 2650)' (2632' 2651)' (2633' 2652)' (2634' 2653)' (2635' 2654)' (2636' 2655)' (2637' 2656)' (2638' 2657)' (2639' 2658)' (2640' 2659)' (2641' 2660)' (2642' 2661)' (2643' 2662)' (2644' 2663)' (2645' 2664)' (2646' 2665)' (2647' 2666)' (2648' 2667)' (2649' 2668)' (2650' 2669)' (2651' 2670)' (2652' 2671)' (2653' 2672)' (2654' 2673)' (2655' 2674)' (2656' 2675)' (2657' 2676)' (2658' 2677)' (2659' 2678)' (2660' 2679)' (2661' 2680)' (2662' 2681)' (2663' 2682)' (2664' 2683)' (2665' 2684)' (2666' 2685)' (2667' 2686)' (2668' 2687)' (2669' 2688)' (2670' 2689)' (2671' 2690)' (2672' 2691)' (2673' 2692)' (2674' 2693)' (2675' 2694)' (2676' 2695)' (2677' 2696)' (2678' 2697)' (2679' 2698)' (2680' 2699)' (2681' 2700)' (2682' 2701)' (2683' 2702)' (2684' 2703)' (2685' 2704)' (2686' 2705)' (2687' 2706)' (2688' 2707)' (2689' 2708)' (2690' 2709)' (2691' 2710)' (2692' 2711)' (2693' 2712)' (2694' 2713)' (2695' 2714)' (2696' 2715)' (2697' 2716)' (2698' 2717)' (2699' 2718)' (2700' 2719)' (2701' 2720)' (2702' 2721)' (2703' 2722)' (2704' 2723)' (2705' 2724)' (2706' 2725)' (2707' 2726)' (2708' 2727)' (2709' 2728)' (2710' 2729)' (2711' 2730)' (2712' 2731)' (2713' 2732)' (2714' 2733)' (2715' 2734)' (2716' 2735)' (2717' 2736)' (2718' 2737)' (2719' 2738)' (2720' 2739)' (2721' 2740)' (2722' 2741)' (2723' 2742)' (2724' 2743)' (2725' 2744)' (2726' 2745)' (2727' 2746)' (2728' 2747)' (2729' 2748)' (2730' 2749)' (2731' 2750)' (2732' 2751)' (2733' 2752)' (2734' 2753)' (2735' 2754)' (2736' 2755)' (2737' 2756)' (2738' 2757)' (2739' 2758)' (2740' 2759)' (2741' 2760)' (2742' 2761)' (2743' 2762)' (2744' 2763)' (2745' 2764)' (2746' 2765)' (2747' 2766)' (2748' 2767)' (2749' 2768)' (2750' 2769)' (2751' 2770)' (2752' 2771)' (2753' 2772)' (2754' 2773)' (2755' 2774)' (2756' 2775)' (2757' 2776)' (2758' 2777)' (2759' 2778)' (2760' 2779)' (2761' 2780)' (2762' 2781)' (2763' 2782)' (2764' 2783)' (2765' 2784)' (2766' 2785)' (2767' 2786)' (2768' 2787)' (2769' 2788)' (2770' 2789)' (2771' 2790)' (2772' 2791)' (2815' 2834)' (2816' 2835)' (2817' 2836)' (2818' 2837)' (2819' 2838)' (2820' 2839)' (2821' 2840)' (2822' 2841)' (2823' 2842)' (2824' 2843)' (2825' 2844)' (2826' 2845)' (2827' 2846)' (2828' 2847)' (2829' 2848)' (2830' 2849)' (2831' 2850)' (2832' 2851)' (2833' 2852)' (2834' 2853)' (2835' 2854)' (2836' 2855)' (2837' 2856)' (2838' 2857)' (2839' 2858)' (2840' 2859)' (2841' 2860)' (2842' 2861)' (2843' 2862)' (2844' 2863)' (2845' 2864)' (2846' 2865)' (2847' 2866)' (2848' 2867)' (2849' 2868)' (2850' 2869)' (2851' 2870)' (2852' 2871)' (2853' 2872)' (2854' 2873)' (2855' 2874)' (2856' 2875)' (2857' 2876)' (2858' 2877)' (2859' 2878)' (2860' 2879)' (2861' 2880)' (2862' 2881)' (2863' 2882)' (2864' 2883)' (2865' 2884)' (2866' 2885)' (2867' 2886)' (2868' 2887)' (2869' 2888)' (2870' 2889)' (2871' 2890)' (2872' 2891)' (2873' 2892)' (2874' 2893)' (2875' 2894)' (2876' 2895)' (2877' 2896)' (2878' 2897)' (2879' 2898)' (2880' 2899)' (2881' 2900)' (2882' 2901)' (2883' 2902)' (2884' 2903)' (2885' 2904)' (2886' 2905)' (2887' 2906)' (2888' 2907)' (2889' 2908)' (2890' 2909)' (2891' 2910)' (2892' 2911)' (2893' 2912)' (2894' 2913)' (2895' 2914)' (2896' 2915)' (2897' 2916)' (2898' 2917)' (2899' 2918)' (2900' 2919)' (2901' 2920)' (2902' 2921)' (2903' 2922)' (2904' 2923)' (2905' 2924)' (2906' 2925)' (2907' 2926)' (2908' 2927)' (2909' 2928)' (2910' 2929)' (2911' 2930)' (2912' 2931)' (2913' 2932)' (2914' 2933)' (2915' 2934)' (2916' 2935)' (2917' 2936)' (2918' 2937)' (2919' 2938)' (2920' 2939)' (2921' 2940)' (2922' 2941)' (2923' 2942)' (2924' 2943)' (2925' 2944)' (2926' 2945)' (2927' 2946)' (2928' 2947)' (2929' 2948)' (2930' 2949)' (2931' 2950)' (2932' 2951)' (2933' 2952)' (2934' 2953)' (2935' 2954)' (2936' 2955)' (2937' 2956)' (2938' 2957)' (2939' 2958)' (2940' 2959)' (2941' 2960)' (2942' 2961)' (2943' 2962)' (2944' 2963)' (2945' 2964)' (2946' 2965)' (2947' 2966)' (2948' 2967)' (2949' 2968)' (2950' 2969)' (2951' 2970)' (2952' 2971)' (2953' 2972)' (2954' 2973)' (2955' 2974)' (2956' 2975)' (2957' 2976)' (2958' 2977)' (2959' 2978)' (2960' 2979)' (2961' 2980)' (2962' 2981)' (2963' 2982)' (2964' 2983)' (2965' 2984)' (2966' 2985)' (2967' 2986)' (2968' 2987)' (2969' 2988)' (2970' 2989)' (2971' 2990)' (2972' 2991)' (2973' 2992)' (2974' 2993)' (2975' 2994)' (2976' 2995)' (2977' 2996)' (2978' 2997)' (2979' 2998)' (2980' 2999)' (2981' 3000)' (2982' 3001)' (2983' 3002)' (2984' 3003)' (2985' 3004)' (2986' 3005)' (2987' 3006)' (2988' 3007)' (2989' 3008)' (2990' 3009)' (2991' 3010)' (2992' 3011)' (2993' 3012)' (2994' 3013)' (2995' 3014)' (2996' 3015)' (2997' 3016)' (2998' 3017)' (2999' 3018)' (3000' 3019)' (3001' 3020)' (3002' 3021)' (3003' 3022)' (3004' 3023)' (3005' 3024)' (3006' 3025)' (3007' 3026)' (3008' 3027)' (3009' 3028)' (3010' 3029)' (3011' 3030)' (3012' 3031)' (3013' 3032)' (3014' 3033)' (3015' 3034)' (3016' 3035)' (3017' 3036)' (3018' 3037)' (3019' 3038)' (3020' 3039)' (3021' 3040)' (3022' 3041)' (3023' 3042)' (3024' 3043)' (3025' 3044)' (3026' 3045)' (3027' 3046)' (3028' 3047)' (3029' 3048)' (3030' 3049)' (3031' 3050)' (3032' 3051)' (3033' 3052)' (3034' 3053)' (3035' 3054)' (3036' 3055)' (3037' 3056)' (3038' 3057)' (3039' 3058)' (3040' 3059)' (3041' 3060)' (3042' 3061)' (3043' 3062)' (3044' 3063)' (3045' 3064)' (3046' 3065)' (3047' 3066)' (3048' 3067)' (3049' 3068)' (3050' 3069)' (3093' 3112)' (3094' 3113)' (3095' 3114)' (3096' 3115)' (3097' 3116)' (3098' 3117)' (3099' 3118)' (3100' 3119)' (3101' 3120)' (3102' 3121)' (3103' 3122)' (3104' 3123)' (3105' 3124)' (3106' 3125)' (3107' 3126)' (3108' 3127)' (3109' 3128)' (3110' 3129)' (3111' 3130)' (3112' 3131)' (3113' 3132)' (3114' 3133)' (3115' 3134)' (3116' 3135)' (3117' 3136)' (3118' 3137)' (3119' 3138)' (3120' 3139)' (3121' 3140)' (3122' 3141)' (3123' 3142)' (3124' 3143)' (3125' 3144)' (3126' 3145)' (3127' 3146)' (3128' 3147)' (3129' 3148)' (3130' 3149)' (3131' 3150)' (3132' 3151)' (3133' 3152)' (3134' 3153)' (3135' 3154)' (3136' 3155)' (3137' 3156)' (3138' 3157)' (3139' 3158)' (3140' 3159)' (3141' 3160)' (3142' 3161)' (3143' 3162)' (3144' 3163)' (3145' 3164)' (3146' 3165)' (3147' 3166)' (3148' 3167)' (3149' 3168)' (3150' 3169)' (3151' 3170)' (3152' 3171)' (3153' 3172)' (3154' 3173)' (3155' 3174)' (3156' 3175)' (3157' 3176)' (3158' 3177)' (3159' 3178)' (3160' 3179)' (3161' 3180)' (3162' 3181)' (3163' 3182)' (3164' 3183)' (3165' 3184)' (3166' 3185)' (3167' 3186)' (3168' 3187)' (3169' 3188)' (3170' 3189)' (3171' 3190)' (3172' 3191)' (3173' 3192)' (3174' 3193)' (3175' 3194)' (3176' 3195)' (3177' 3196)' (3178' 3197)' (3179' 3198)' (3180' 3199)' (3181' 3200)' (3182' 3201)' (3183' 3202)' (3184' 3203)' (3185' 3204)' (3186' 3205)' (3187' 3206)' (3188' 3207)' (3189' 3208)' (3190' 3209)' (3191' 3210)' (3192' 3211)' (3193' 3212)' (3194' 3213)' (3195' 3214)' (3196' 3215)' (3197' 3216)' (3198' 3217)' (3199' 3218)' (3200' 3219)' (3201' 3220)' (3202' 3221)' (3203' 3222)' (3204' 3223)' (3205' 3224)' (3206' 3225)' (3207' 3226)' (3208' 3227)' (3209' 3228)' (3210' 3229)' (3211' 3230)' (3212' 3231)' (3213' 3232)' (3214' 3233)' (3215' 3234)' (3216' 3235)' (3217' 3236)' (3218' 3237)' (3219' 3238)' (3220' 3239)' (3221' 3240)' (3222' 3241)' (3223' 3242)' (3224' 3243)' (3225' 3244)' (3226' 3245)' (3227' 3246)' (3228' 3247)' (3229' 3248)' (3230' 3249)' (3231' 3250)' (3232' 3251)' (3233' 3252)' (3234' 3253)' (3235' 3254)' (3236' 3255)' (3237' 3256)' (3238' 3257)' (3239' 3258)' (3240' 3259)' (3241' 3260)' (3242' 3261)' (3243' 3262)' (3244' 3263)' (3245' 3264)' (3246' 3265)' (3247' 3266)' (3248' 3267)' (3249' 3268)' (3250' 3269)' (3251' 3270)' (3252' 3271)' (3253' 3272)' (3254' 3273)' (3255' 3274)' (3256' 3275)' (3257' 3276)' (3258' 3277)' (3259' 3278)' (3260' 3279)' (3261' 3280)' (3262' 3281)' (3263' 3282)' (3264' 3283)' (3265' 3284)' (3266' 3285)' (3267' 3286)' (3268' 3287)' (3269' 3288)' (3270' 3289)' (3271' 3290)' (3272' 3291)' (3273' 3292)' (3274' 3293)' (3275' 3294)' (3276' 3295)' (3277' 3296)' (3278' 3297)' (3279' 3298)' (3280' 3299)' (3281' 3300)' (3282' 3301)' (3283' 3302)' (3284' 3303)' (3285' 3304)' (3286' 3305)' (3287' 3306)' (3288' 3307)' (3289' 3308)' (3290' 3309)' (3291' 3310)' (3292' 3311)' (3293' 3312)' (3294' 3313)' (3295' 3314)' (3296' 3315)' (3297' 3316)' (3298' 3317)' (3299' 3318)' (3300' 3319)' (3301' 3320)' (3302' 3321)' (3303' 3322)' (3304' 3323)' (3305' 3324)' (3306' 3325)' (3307' 3326)' (3308' 3327)' (3309' 3328)' (3310' 3329)' (3311' 3330)' (3312' 3331)' (3313' 3332)' (3314' 3333)' (3315' 3334)' (3316' 3335)' (3317' 3336)' (3318' 3337)' (3319' 3338)' (3320' 3339)' (3321' 3340)' (3322' 3341)' (3323' 3342)' (3324' 3343)' (3325' 3344)' (3326' 3345)' (3327' 3346)' (3328' 3347))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((2259' 2512)' (2260' 2513)' (2537' 2790)' (2538' 2791)' (2815' 3068)' (2816' 3069)' (3093' 3346)' (3094' 3347))
Duplicate Code,OxyPlot,StandardFonts,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\StandardFonts.cs,StandardFonts,The method contains a code clone-set at the following line numbers (starting from the method definition): ((2259' 2278)' (2261' 2280)' (2262' 2281)' (2263' 2282)' (2264' 2283)' (2265' 2284)' (2266' 2285)' (2267' 2286)' (2268' 2287)' (2269' 2288)' (2270' 2289)' (2271' 2290)' (2272' 2291)' (2273' 2292)' (2274' 2293)' (2275' 2294)' (2276' 2295)' (2277' 2296)' (2278' 2297)' (2279' 2298)' (2280' 2299)' (2281' 2300)' (2282' 2301)' (2283' 2302)' (2284' 2303)' (2285' 2304)' (2286' 2305)' (2287' 2306)' (2288' 2307)' (2289' 2308)' (2290' 2309)' (2291' 2310)' (2292' 2311)' (2293' 2312)' (2294' 2313)' (2295' 2314)' (2296' 2315)' (2297' 2316)' (2298' 2317)' (2299' 2318)' (2300' 2319)' (2301' 2320)' (2302' 2321)' (2303' 2322)' (2304' 2323)' (2305' 2324)' (2306' 2325)' (2307' 2326)' (2308' 2327)' (2309' 2328)' (2310' 2329)' (2311' 2330)' (2312' 2331)' (2313' 2332)' (2314' 2333)' (2315' 2334)' (2316' 2335)' (2317' 2336)' (2318' 2337)' (2319' 2338)' (2320' 2339)' (2321' 2340)' (2322' 2341)' (2323' 2342)' (2324' 2343)' (2325' 2344)' (2326' 2345)' (2327' 2346)' (2328' 2347)' (2329' 2348)' (2330' 2349)' (2331' 2350)' (2332' 2351)' (2333' 2352)' (2334' 2353)' (2335' 2354)' (2336' 2355)' (2337' 2356)' (2338' 2357)' (2339' 2358)' (2340' 2359)' (2341' 2360)' (2342' 2361)' (2343' 2362)' (2344' 2363)' (2345' 2364)' (2346' 2365)' (2347' 2366)' (2348' 2367)' (2349' 2368)' (2350' 2369)' (2351' 2370)' (2352' 2371)' (2353' 2372)' (2354' 2373)' (2355' 2374)' (2356' 2375)' (2357' 2376)' (2358' 2377)' (2359' 2378)' (2360' 2379)' (2361' 2380)' (2362' 2381)' (2363' 2382)' (2364' 2383)' (2365' 2384)' (2366' 2385)' (2367' 2386)' (2368' 2387)' (2369' 2388)' (2370' 2389)' (2371' 2390)' (2372' 2391)' (2373' 2392)' (2374' 2393)' (2375' 2394)' (2376' 2395)' (2377' 2396)' (2378' 2397)' (2379' 2398)' (2380' 2399)' (2381' 2400)' (2382' 2401)' (2383' 2402)' (2384' 2403)' (2385' 2404)' (2386' 2405)' (2387' 2406)' (2388' 2407)' (2389' 2408)' (2390' 2409)' (2391' 2410)' (2392' 2411)' (2393' 2412)' (2394' 2413)' (2395' 2414)' (2396' 2415)' (2397' 2416)' (2398' 2417)' (2399' 2418)' (2400' 2419)' (2401' 2420)' (2402' 2421)' (2403' 2422)' (2404' 2423)' (2405' 2424)' (2406' 2425)' (2407' 2426)' (2408' 2427)' (2409' 2428)' (2410' 2429)' (2411' 2430)' (2412' 2431)' (2413' 2432)' (2414' 2433)' (2415' 2434)' (2416' 2435)' (2417' 2436)' (2418' 2437)' (2419' 2438)' (2420' 2439)' (2421' 2440)' (2422' 2441)' (2423' 2442)' (2424' 2443)' (2425' 2444)' (2426' 2445)' (2427' 2446)' (2428' 2447)' (2429' 2448)' (2430' 2449)' (2431' 2450)' (2432' 2451)' (2433' 2452)' (2434' 2453)' (2435' 2454)' (2436' 2455)' (2437' 2456)' (2438' 2457)' (2439' 2458)' (2440' 2459)' (2441' 2460)' (2442' 2461)' (2443' 2462)' (2444' 2463)' (2445' 2464)' (2446' 2465)' (2447' 2466)' (2448' 2467)' (2449' 2468)' (2450' 2469)' (2451' 2470)' (2452' 2471)' (2453' 2472)' (2454' 2473)' (2455' 2474)' (2456' 2475)' (2457' 2476)' (2458' 2477)' (2459' 2478)' (2460' 2479)' (2461' 2480)' (2462' 2481)' (2463' 2482)' (2464' 2483)' (2465' 2484)' (2466' 2485)' (2467' 2486)' (2468' 2487)' (2469' 2488)' (2470' 2489)' (2471' 2490)' (2472' 2491)' (2473' 2492)' (2474' 2493)' (2475' 2494)' (2476' 2495)' (2477' 2496)' (2478' 2497)' (2479' 2498)' (2480' 2499)' (2481' 2500)' (2482' 2501)' (2483' 2502)' (2484' 2503)' (2485' 2504)' (2486' 2505)' (2487' 2506)' (2488' 2507)' (2489' 2508)' (2490' 2509)' (2491' 2510)' (2492' 2511)' (2493' 2512)' (2494' 2513)' (2537' 2556)' (2539' 2558)' (2540' 2559)' (2541' 2560)' (2542' 2561)' (2543' 2562)' (2544' 2563)' (2545' 2564)' (2546' 2565)' (2547' 2566)' (2548' 2567)' (2549' 2568)' (2550' 2569)' (2551' 2570)' (2552' 2571)' (2553' 2572)' (2554' 2573)' (2555' 2574)' (2556' 2575)' (2557' 2576)' (2558' 2577)' (2559' 2578)' (2560' 2579)' (2561' 2580)' (2562' 2581)' (2563' 2582)' (2564' 2583)' (2565' 2584)' (2566' 2585)' (2567' 2586)' (2568' 2587)' (2569' 2588)' (2570' 2589)' (2571' 2590)' (2572' 2591)' (2573' 2592)' (2574' 2593)' (2575' 2594)' (2576' 2595)' (2577' 2596)' (2578' 2597)' (2579' 2598)' (2580' 2599)' (2581' 2600)' (2582' 2601)' (2583' 2602)' (2584' 2603)' (2585' 2604)' (2586' 2605)' (2587' 2606)' (2588' 2607)' (2589' 2608)' (2590' 2609)' (2591' 2610)' (2592' 2611)' (2593' 2612)' (2594' 2613)' (2595' 2614)' (2596' 2615)' (2597' 2616)' (2598' 2617)' (2599' 2618)' (2600' 2619)' (2601' 2620)' (2602' 2621)' (2603' 2622)' (2604' 2623)' (2605' 2624)' (2606' 2625)' (2607' 2626)' (2608' 2627)' (2609' 2628)' (2610' 2629)' (2611' 2630)' (2612' 2631)' (2613' 2632)' (2614' 2633)' (2615' 2634)' (2616' 2635)' (2617' 2636)' (2618' 2637)' (2619' 2638)' (2620' 2639)' (2621' 2640)' (2622' 2641)' (2623' 2642)' (2624' 2643)' (2625' 2644)' (2626' 2645)' (2627' 2646)' (2628' 2647)' (2629' 2648)' (2630' 2649)' (2631' 2650)' (2632' 2651)' (2633' 2652)' (2634' 2653)' (2635' 2654)' (2636' 2655)' (2637' 2656)' (2638' 2657)' (2639' 2658)' (2640' 2659)' (2641' 2660)' (2642' 2661)' (2643' 2662)' (2644' 2663)' (2645' 2664)' (2646' 2665)' (2647' 2666)' (2648' 2667)' (2649' 2668)' (2650' 2669)' (2651' 2670)' (2652' 2671)' (2653' 2672)' (2654' 2673)' (2655' 2674)' (2656' 2675)' (2657' 2676)' (2658' 2677)' (2659' 2678)' (2660' 2679)' (2661' 2680)' (2662' 2681)' (2663' 2682)' (2664' 2683)' (2665' 2684)' (2666' 2685)' (2667' 2686)' (2668' 2687)' (2669' 2688)' (2670' 2689)' (2671' 2690)' (2672' 2691)' (2673' 2692)' (2674' 2693)' (2675' 2694)' (2676' 2695)' (2677' 2696)' (2678' 2697)' (2679' 2698)' (2680' 2699)' (2681' 2700)' (2682' 2701)' (2683' 2702)' (2684' 2703)' (2685' 2704)' (2686' 2705)' (2687' 2706)' (2688' 2707)' (2689' 2708)' (2690' 2709)' (2691' 2710)' (2692' 2711)' (2693' 2712)' (2694' 2713)' (2695' 2714)' (2696' 2715)' (2697' 2716)' (2698' 2717)' (2699' 2718)' (2700' 2719)' (2701' 2720)' (2702' 2721)' (2703' 2722)' (2704' 2723)' (2705' 2724)' (2706' 2725)' (2707' 2726)' (2708' 2727)' (2709' 2728)' (2710' 2729)' (2711' 2730)' (2712' 2731)' (2713' 2732)' (2714' 2733)' (2715' 2734)' (2716' 2735)' (2717' 2736)' (2718' 2737)' (2719' 2738)' (2720' 2739)' (2721' 2740)' (2722' 2741)' (2723' 2742)' (2724' 2743)' (2725' 2744)' (2726' 2745)' (2727' 2746)' (2728' 2747)' (2729' 2748)' (2730' 2749)' (2731' 2750)' (2732' 2751)' (2733' 2752)' (2734' 2753)' (2735' 2754)' (2736' 2755)' (2737' 2756)' (2738' 2757)' (2739' 2758)' (2740' 2759)' (2741' 2760)' (2742' 2761)' (2743' 2762)' (2744' 2763)' (2745' 2764)' (2746' 2765)' (2747' 2766)' (2748' 2767)' (2749' 2768)' (2750' 2769)' (2751' 2770)' (2752' 2771)' (2753' 2772)' (2754' 2773)' (2755' 2774)' (2756' 2775)' (2757' 2776)' (2758' 2777)' (2759' 2778)' (2760' 2779)' (2761' 2780)' (2762' 2781)' (2763' 2782)' (2764' 2783)' (2765' 2784)' (2766' 2785)' (2767' 2786)' (2768' 2787)' (2769' 2788)' (2770' 2789)' (2771' 2790)' (2772' 2791)' (2815' 2834)' (2817' 2836)' (2818' 2837)' (2819' 2838)' (2820' 2839)' (2821' 2840)' (2822' 2841)' (2823' 2842)' (2824' 2843)' (2825' 2844)' (2826' 2845)' (2827' 2846)' (2828' 2847)' (2829' 2848)' (2830' 2849)' (2831' 2850)' (2832' 2851)' (2833' 2852)' (2834' 2853)' (2835' 2854)' (2836' 2855)' (2837' 2856)' (2838' 2857)' (2839' 2858)' (2840' 2859)' (2841' 2860)' (2842' 2861)' (2843' 2862)' (2844' 2863)' (2845' 2864)' (2846' 2865)' (2847' 2866)' (2848' 2867)' (2849' 2868)' (2850' 2869)' (2851' 2870)' (2852' 2871)' (2853' 2872)' (2854' 2873)' (2855' 2874)' (2856' 2875)' (2857' 2876)' (2858' 2877)' (2859' 2878)' (2860' 2879)' (2861' 2880)' (2862' 2881)' (2863' 2882)' (2864' 2883)' (2865' 2884)' (2866' 2885)' (2867' 2886)' (2868' 2887)' (2869' 2888)' (2870' 2889)' (2871' 2890)' (2872' 2891)' (2873' 2892)' (2874' 2893)' (2875' 2894)' (2876' 2895)' (2877' 2896)' (2878' 2897)' (2879' 2898)' (2880' 2899)' (2881' 2900)' (2882' 2901)' (2883' 2902)' (2884' 2903)' (2885' 2904)' (2886' 2905)' (2887' 2906)' (2888' 2907)' (2889' 2908)' (2890' 2909)' (2891' 2910)' (2892' 2911)' (2893' 2912)' (2894' 2913)' (2895' 2914)' (2896' 2915)' (2897' 2916)' (2898' 2917)' (2899' 2918)' (2900' 2919)' (2901' 2920)' (2902' 2921)' (2903' 2922)' (2904' 2923)' (2905' 2924)' (2906' 2925)' (2907' 2926)' (2908' 2927)' (2909' 2928)' (2910' 2929)' (2911' 2930)' (2912' 2931)' (2913' 2932)' (2914' 2933)' (2915' 2934)' (2916' 2935)' (2917' 2936)' (2918' 2937)' (2919' 2938)' (2920' 2939)' (2921' 2940)' (2922' 2941)' (2923' 2942)' (2924' 2943)' (2925' 2944)' (2926' 2945)' (2927' 2946)' (2928' 2947)' (2929' 2948)' (2930' 2949)' (2931' 2950)' (2932' 2951)' (2933' 2952)' (2934' 2953)' (2935' 2954)' (2936' 2955)' (2937' 2956)' (2938' 2957)' (2939' 2958)' (2940' 2959)' (2941' 2960)' (2942' 2961)' (2943' 2962)' (2944' 2963)' (2945' 2964)' (2946' 2965)' (2947' 2966)' (2948' 2967)' (2949' 2968)' (2950' 2969)' (2951' 2970)' (2952' 2971)' (2953' 2972)' (2954' 2973)' (2955' 2974)' (2956' 2975)' (2957' 2976)' (2958' 2977)' (2959' 2978)' (2960' 2979)' (2961' 2980)' (2962' 2981)' (2963' 2982)' (2964' 2983)' (2965' 2984)' (2966' 2985)' (2967' 2986)' (2968' 2987)' (2969' 2988)' (2970' 2989)' (2971' 2990)' (2972' 2991)' (2973' 2992)' (2974' 2993)' (2975' 2994)' (2976' 2995)' (2977' 2996)' (2978' 2997)' (2979' 2998)' (2980' 2999)' (2981' 3000)' (2982' 3001)' (2983' 3002)' (2984' 3003)' (2985' 3004)' (2986' 3005)' (2987' 3006)' (2988' 3007)' (2989' 3008)' (2990' 3009)' (2991' 3010)' (2992' 3011)' (2993' 3012)' (2994' 3013)' (2995' 3014)' (2996' 3015)' (2997' 3016)' (2998' 3017)' (2999' 3018)' (3000' 3019)' (3001' 3020)' (3002' 3021)' (3003' 3022)' (3004' 3023)' (3005' 3024)' (3006' 3025)' (3007' 3026)' (3008' 3027)' (3009' 3028)' (3010' 3029)' (3011' 3030)' (3012' 3031)' (3013' 3032)' (3014' 3033)' (3015' 3034)' (3016' 3035)' (3017' 3036)' (3018' 3037)' (3019' 3038)' (3020' 3039)' (3021' 3040)' (3022' 3041)' (3023' 3042)' (3024' 3043)' (3025' 3044)' (3026' 3045)' (3027' 3046)' (3028' 3047)' (3029' 3048)' (3030' 3049)' (3031' 3050)' (3032' 3051)' (3033' 3052)' (3034' 3053)' (3035' 3054)' (3036' 3055)' (3037' 3056)' (3038' 3057)' (3039' 3058)' (3040' 3059)' (3041' 3060)' (3042' 3061)' (3043' 3062)' (3044' 3063)' (3045' 3064)' (3046' 3065)' (3047' 3066)' (3048' 3067)' (3049' 3068)' (3050' 3069)' (3093' 3112)' (3095' 3114)' (3096' 3115)' (3097' 3116)' (3098' 3117)' (3099' 3118)' (3100' 3119)' (3101' 3120)' (3102' 3121)' (3103' 3122)' (3104' 3123)' (3105' 3124)' (3106' 3125)' (3107' 3126)' (3108' 3127)' (3109' 3128)' (3110' 3129)' (3111' 3130)' (3112' 3131)' (3113' 3132)' (3114' 3133)' (3115' 3134)' (3116' 3135)' (3117' 3136)' (3118' 3137)' (3119' 3138)' (3120' 3139)' (3121' 3140)' (3122' 3141)' (3123' 3142)' (3124' 3143)' (3125' 3144)' (3126' 3145)' (3127' 3146)' (3128' 3147)' (3129' 3148)' (3130' 3149)' (3131' 3150)' (3132' 3151)' (3133' 3152)' (3134' 3153)' (3135' 3154)' (3136' 3155)' (3137' 3156)' (3138' 3157)' (3139' 3158)' (3140' 3159)' (3141' 3160)' (3142' 3161)' (3143' 3162)' (3144' 3163)' (3145' 3164)' (3146' 3165)' (3147' 3166)' (3148' 3167)' (3149' 3168)' (3150' 3169)' (3151' 3170)' (3152' 3171)' (3153' 3172)' (3154' 3173)' (3155' 3174)' (3156' 3175)' (3157' 3176)' (3158' 3177)' (3159' 3178)' (3160' 3179)' (3161' 3180)' (3162' 3181)' (3163' 3182)' (3164' 3183)' (3165' 3184)' (3166' 3185)' (3167' 3186)' (3168' 3187)' (3169' 3188)' (3170' 3189)' (3171' 3190)' (3172' 3191)' (3173' 3192)' (3174' 3193)' (3175' 3194)' (3176' 3195)' (3177' 3196)' (3178' 3197)' (3179' 3198)' (3180' 3199)' (3181' 3200)' (3182' 3201)' (3183' 3202)' (3184' 3203)' (3185' 3204)' (3186' 3205)' (3187' 3206)' (3188' 3207)' (3189' 3208)' (3190' 3209)' (3191' 3210)' (3192' 3211)' (3193' 3212)' (3194' 3213)' (3195' 3214)' (3196' 3215)' (3197' 3216)' (3198' 3217)' (3199' 3218)' (3200' 3219)' (3201' 3220)' (3202' 3221)' (3203' 3222)' (3204' 3223)' (3205' 3224)' (3206' 3225)' (3207' 3226)' (3208' 3227)' (3209' 3228)' (3210' 3229)' (3211' 3230)' (3212' 3231)' (3213' 3232)' (3214' 3233)' (3215' 3234)' (3216' 3235)' (3217' 3236)' (3218' 3237)' (3219' 3238)' (3220' 3239)' (3221' 3240)' (3222' 3241)' (3223' 3242)' (3224' 3243)' (3225' 3244)' (3226' 3245)' (3227' 3246)' (3228' 3247)' (3229' 3248)' (3230' 3249)' (3231' 3250)' (3232' 3251)' (3233' 3252)' (3234' 3253)' (3235' 3254)' (3236' 3255)' (3237' 3256)' (3238' 3257)' (3239' 3258)' (3240' 3259)' (3241' 3260)' (3242' 3261)' (3243' 3262)' (3244' 3263)' (3245' 3264)' (3246' 3265)' (3247' 3266)' (3248' 3267)' (3249' 3268)' (3250' 3269)' (3251' 3270)' (3252' 3271)' (3253' 3272)' (3254' 3273)' (3255' 3274)' (3256' 3275)' (3257' 3276)' (3258' 3277)' (3259' 3278)' (3260' 3279)' (3261' 3280)' (3262' 3281)' (3263' 3282)' (3264' 3283)' (3265' 3284)' (3266' 3285)' (3267' 3286)' (3268' 3287)' (3269' 3288)' (3270' 3289)' (3271' 3290)' (3272' 3291)' (3273' 3292)' (3274' 3293)' (3275' 3294)' (3276' 3295)' (3277' 3296)' (3278' 3297)' (3279' 3298)' (3280' 3299)' (3281' 3300)' (3282' 3301)' (3283' 3302)' (3284' 3303)' (3285' 3304)' (3286' 3305)' (3287' 3306)' (3288' 3307)' (3289' 3308)' (3290' 3309)' (3291' 3310)' (3292' 3311)' (3293' 3312)' (3294' 3313)' (3295' 3314)' (3296' 3315)' (3297' 3316)' (3298' 3317)' (3299' 3318)' (3300' 3319)' (3301' 3320)' (3302' 3321)' (3303' 3322)' (3304' 3323)' (3305' 3324)' (3306' 3325)' (3307' 3326)' (3308' 3327)' (3309' 3328)' (3310' 3329)' (3311' 3330)' (3312' 3331)' (3313' 3332)' (3314' 3333)' (3315' 3334)' (3316' 3335)' (3317' 3336)' (3318' 3337)' (3319' 3338)' (3320' 3339)' (3321' 3340)' (3322' 3341)' (3323' 3342)' (3324' 3343)' (3325' 3344)' (3326' 3345)' (3327' 3346)' (3328' 3347))
Missing Default,OxyPlot.Annotations,FunctionAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\FunctionAnnotation.cs,GetScreenPoints,The following switch statement is missing a default case: switch (this.Type) {  case FunctionAnnotationType.EquationX:  	fx = this.Equation;  	break;  case FunctionAnnotationType.EquationY:  	fy = this.Equation;  	break;  }  
Missing Default,OxyPlot.Annotations,PathAnnotation,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Annotations\PathAnnotation.cs,Render,The following switch statement is missing a default case: switch (this.TextOrientation) {  case AnnotationTextOrientation.Horizontal:  	angle = 0;  	break;  case AnnotationTextOrientation.Vertical:  	angle = -90;  	break;  }  
Missing Default,OxyPlot,SutherlandHodgmanClipping,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\Utilities\SutherlandHodgmanClipping.cs,LineIntercept,The following switch statement is missing a default case: switch (edge) {  case RectangleEdge.Bottom:  	if (b.Y.Equals (a.Y)) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (a.X + (((b.X - a.X) * (bounds.Bottom - a.Y)) / (b.Y - a.Y))' bounds.Bottom);  case RectangleEdge.Left:  	if (b.X.Equals (a.X)) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (bounds.Left' a.Y + (((b.Y - a.Y) * (bounds.Left - a.X)) / (b.X - a.X)));  case RectangleEdge.Right:  	if (b.X.Equals (a.X)) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (bounds.Right' a.Y + (((b.Y - a.Y) * (bounds.Right - a.X)) / (b.X - a.X)));  case RectangleEdge.Top:  	if (b.Y.Equals (a.Y)) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (a.X + (((b.X - a.X) * (bounds.Top - a.Y)) / (b.Y - a.Y))' bounds.Top);  }  
Missing Default,OxyPlot,OxyColor,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\OxyColor.cs,FromHsv,The following switch statement is missing a default case: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Missing Default,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following switch statement is missing a default case: switch (ha) {  case HorizontalAlignment.Right:  	x -= size.Width;  	break;  case HorizontalAlignment.Center:  	x -= size.Width * 0.5;  	break;  }  
Missing Default,OxyPlot,MathRenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\MathRenderingExtensions.cs,DrawMathText,The following switch statement is missing a default case: switch (va) {  case VerticalAlignment.Bottom:  	y -= size.Height;  	break;  case VerticalAlignment.Middle:  	y -= size.Height * 0.5;  	break;  }  
Missing Default,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following switch statement is missing a default case: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Missing Default,OxyPlot,RenderingExtensions,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Rendering\RenderContext\RenderingExtensions.cs,AddMarkerGeometry,The following switch statement is missing a default case: switch (type) {  case MarkerType.Cross:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - (size * M3)' p.y - (size * M3)));  	lines.Add (new ScreenPoint (p.x + (size * M3)' p.y + (size * M3)));  	lines.Add (new ScreenPoint (p.x - (size * M3)' p.y + (size * M3)));  	lines.Add (new ScreenPoint (p.x + (size * M3)' p.y - (size * M3)));  	break;  }  }  
Missing Default,OxyPlot,PortableDocument,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Pdf\PortableDocument.cs,AddPage,The following switch statement is missing a default case: switch (pageSize) {  case PageSize.A4:  	shortLength = 595;  	longLength = 842;  	break;  case PageSize.A3:  	shortLength = 842;  	longLength = 1190;  	break;  case PageSize.Letter:  	shortLength = 612;  	longLength = 792;  	break;  }  
Missing Default,OxyPlot,Conrec,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Utilities\Conrec.cs,Contour,The following switch statement is missing a default case: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Missing Default,OxyPlot,SvgWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following switch statement is missing a default case: switch (lineJoin) {  case OxyPenLineJoin.Round:  	style.AppendFormat (";stroke-linejoin:round");  	break;  case OxyPenLineJoin.Bevel:  	style.AppendFormat (";stroke-linejoin:bevel");  	break;  }  
Missing Default,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,EnsureLegendProperties,The following switch statement is missing a default case: switch (this.LegendPosition) {  case LegendPosition.LeftTop:  case LegendPosition.LeftMiddle:  case LegendPosition.LeftBottom:  case LegendPosition.RightTop:  case LegendPosition.RightMiddle:  case LegendPosition.RightBottom:  	if (this.LegendOrientation == LegendOrientation.Horizontal) {  		this.LegendOrientation = LegendOrientation.Vertical;  	}  	break;  }  
Missing Default,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following switch statement is missing a default case: switch (this.LegendPosition) {  case LegendPosition.LeftTop:  case LegendPosition.LeftMiddle:  case LegendPosition.LeftBottom:  	left = this.PlotAndAxisArea.Left - legendSize.Width - this.LegendMargin;  	break;  case LegendPosition.RightTop:  case LegendPosition.RightMiddle:  case LegendPosition.RightBottom:  	left = this.PlotAndAxisArea.Right + this.LegendMargin;  	break;  case LegendPosition.TopLeft:  case LegendPosition.TopCenter:  case LegendPosition.TopRight:  	top = this.PlotAndAxisArea.Top - legendSize.Height - this.LegendMargin;  	break;  case LegendPosition.BottomLeft:  case LegendPosition.BottomCenter:  case LegendPosition.BottomRight:  	top = this.PlotAndAxisArea.Bottom + this.LegendMargin;  	break;  }  
Missing Default,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following switch statement is missing a default case: switch (this.LegendPosition) {  case LegendPosition.TopLeft:  case LegendPosition.BottomLeft:  	left = this.PlotArea.Left;  	break;  case LegendPosition.TopRight:  case LegendPosition.BottomRight:  	left = this.PlotArea.Right - legendSize.Width;  	break;  case LegendPosition.LeftTop:  case LegendPosition.RightTop:  	top = this.PlotArea.Top;  	break;  case LegendPosition.LeftBottom:  case LegendPosition.RightBottom:  	top = this.PlotArea.Bottom - legendSize.Height;  	break;  case LegendPosition.LeftMiddle:  case LegendPosition.RightMiddle:  	top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  	break;  case LegendPosition.TopCenter:  case LegendPosition.BottomCenter:  	left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  	break;  }  
Missing Default,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following switch statement is missing a default case: switch (this.LegendPosition) {  case LegendPosition.LeftTop:  case LegendPosition.LeftMiddle:  case LegendPosition.LeftBottom:  	left = this.PlotArea.Left + this.LegendMargin;  	break;  case LegendPosition.RightTop:  case LegendPosition.RightMiddle:  case LegendPosition.RightBottom:  	left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  	break;  case LegendPosition.TopLeft:  case LegendPosition.TopCenter:  case LegendPosition.TopRight:  	top = this.PlotArea.Top + this.LegendMargin;  	break;  case LegendPosition.BottomLeft:  case LegendPosition.BottomCenter:  case LegendPosition.BottomRight:  	top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  	break;  }  
Missing Default,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,GetLegendRectangle,The following switch statement is missing a default case: switch (this.LegendPosition) {  case LegendPosition.TopLeft:  case LegendPosition.BottomLeft:  	left = this.PlotArea.Left + this.LegendMargin;  	break;  case LegendPosition.TopRight:  case LegendPosition.BottomRight:  	left = this.PlotArea.Right - legendSize.Width - this.LegendMargin;  	break;  case LegendPosition.LeftTop:  case LegendPosition.RightTop:  	top = this.PlotArea.Top + this.LegendMargin;  	break;  case LegendPosition.LeftBottom:  case LegendPosition.RightBottom:  	top = this.PlotArea.Bottom - legendSize.Height - this.LegendMargin;  	break;  case LegendPosition.LeftMiddle:  case LegendPosition.RightMiddle:  	top = (this.PlotArea.Top + this.PlotArea.Bottom - legendSize.Height) * 0.5;  	break;  case LegendPosition.TopCenter:  case LegendPosition.BottomCenter:  	left = (this.PlotArea.Left + this.PlotArea.Right - legendSize.Width) * 0.5;  	break;  }  
Missing Default,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following switch statement is missing a default case: switch (this.LegendItemAlignment) {  case HorizontalAlignment.Center:  	x = (rect.Left + rect.Right) / 2;  	if (this.LegendSymbolPlacement == LegendSymbolPlacement.Left) {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	else {  		x -= (this.LegendSymbolLength + this.LegendSymbolMargin) / 2;  	}  	break;  case HorizontalAlignment.Right:  	x = rect.Right;  	// if (LegendSymbolPlacement == LegendSymbolPlacement.Right)  	x -= this.LegendSymbolLength + this.LegendSymbolMargin;  	break;  }  
Missing Default,OxyPlot,PlotModel,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\PlotModel\PlotModel.Legends.cs,RenderLegend,The following switch statement is missing a default case: switch (this.LegendItemAlignment) {  case HorizontalAlignment.Center:  	x0 = x - (textSize.Width * 0.5);  	break;  case HorizontalAlignment.Right:  	x0 = x - textSize.Width;  	break;  }  
Missing Default,OxyPlot.Axes,RangeColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\RangeColorAxis.cs,Render,The following switch statement is missing a default case: switch (this.Position) {  case AxisPosition.Left:  	left = model.PlotArea.Left - TierShift - width - distance;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Right:  	left = model.PlotArea.Right + TierShift + distance;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Top:  	left = model.PlotArea.Left;  	top = model.PlotArea.Top - TierShift - height - distance;  	break;  case AxisPosition.Bottom:  	left = model.PlotArea.Left;  	top = model.PlotArea.Bottom + TierShift + distance;  	break;  }  
Missing Default,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following switch statement is missing a default case: switch (this.TickStyle) {  case TickStyle.Outside:  	width += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	width += this.MajorTickSize * 0.75;  	break;  }  
Missing Default,OxyPlot.Axes,Axis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Axis.cs,Measure,The following switch statement is missing a default case: switch (this.TickStyle) {  case TickStyle.Outside:  	height += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	height += this.MajorTickSize * 0.75;  	break;  }  
Missing Default,OxyPlot.Axes,CategoryColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\CategoryColorAxis.cs,Render,The following switch statement is missing a default case: switch (this.Position) {  case AxisPosition.Left:  	left = model.PlotArea.Left - this.PositionTierMinShift - width;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Right:  	left = model.PlotArea.Right + this.PositionTierMinShift;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Top:  	left = model.PlotArea.Left;  	top = model.PlotArea.Top - this.PositionTierMinShift - height;  	break;  case AxisPosition.Bottom:  	left = model.PlotArea.Left;  	top = model.PlotArea.Bottom + this.PositionTierMinShift;  	break;  }  
Missing Default,OxyPlot.Axes,LinearColorAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\LinearColorAxis.cs,Render,The following switch statement is missing a default case: switch (this.Position) {  case AxisPosition.Left:  	left = model.PlotArea.Left - this.PositionTierMinShift - width - distance;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Right:  	left = model.PlotArea.Right + this.PositionTierMinShift + distance;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Top:  	left = model.PlotArea.Left;  	top = model.PlotArea.Top - this.PositionTierMinShift - height - distance;  	break;  case AxisPosition.Bottom:  	left = model.PlotArea.Left;  	top = model.PlotArea.Bottom + this.PositionTierMinShift + distance;  	break;  }  
Missing Default,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following switch statement is missing a default case: switch (this.actualIntervalType) {  case DateTimeIntervalType.Years:  	this.ActualMinorStep = 31;  	this.actualMinorIntervalType = DateTimeIntervalType.Years;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy";  	}  	break;  case DateTimeIntervalType.Months:  	this.actualMinorIntervalType = DateTimeIntervalType.Months;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Weeks:  	this.actualMinorIntervalType = DateTimeIntervalType.Days;  	this.ActualMajorStep = 7;  	this.ActualMinorStep = 1;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy/ww";  	}  	break;  case DateTimeIntervalType.Days:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Hours:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Minutes:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Seconds:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm:ss";  	}  	break;  case DateTimeIntervalType.Manual:  	break;  case DateTimeIntervalType.Auto:  	break;  }  
Missing Default,OxyPlot.Axes,DateTimeAxis,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\DateTimeAxis.cs,CreateDateTickValues,The following switch statement is missing a default case: switch (intervalType) {  case DateTimeIntervalType.Weeks:  	// make sure the first tick is at the 1st day of a week  	start = start.AddDays (-(int)start.DayOfWeek + (int)this.FirstDayOfWeek);  	break;  case DateTimeIntervalType.Months:  	// make sure the first tick is at the 1st of a month  	start = new DateTime (start.Year' start.Month' 1);  	break;  case DateTimeIntervalType.Years:  	// make sure the first tick is at Jan 1st  	start = new DateTime (start.Year' 1' 1);  	break;  }  
Missing Default,OxyPlot.Axes,AxisRendererBase,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\AxisRendererBase.cs,GetTickPositions,The following switch statement is missing a default case: switch (tickStyle) {  case TickStyle.Crossing:  	x0 = -tickSize * sign * 0.75;  	x1 = tickSize * sign * 0.75;  	break;  case TickStyle.Inside:  	x0 = -tickSize * sign;  	break;  case TickStyle.Outside:  	x1 = tickSize * sign;  	break;  }  
Missing Default,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,Render,The following switch statement is missing a default case: switch (axis.Position) {  case AxisPosition.Left:  	axisPosition = plotAreaLeft - totalShift;  	titlePosition = axisPosition - tierSize;  	break;  case AxisPosition.Right:  	axisPosition = plotAreaRight + totalShift;  	titlePosition = axisPosition + tierSize;  	break;  case AxisPosition.Top:  	axisPosition = plotAreaTop - totalShift;  	titlePosition = axisPosition - tierSize;  	break;  case AxisPosition.Bottom:  	axisPosition = plotAreaBottom + totalShift;  	titlePosition = axisPosition + tierSize;  	break;  }  
Missing Default,OxyPlot.Axes,HorizontalAndVerticalAxisRenderer,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Axes\Rendering\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The following switch statement is missing a default case: switch (axis.Position) {  case AxisPosition.Left:  	pt = new ScreenPoint (axisPosition + a1 - axis.AxisTickToLabelDistance' transformedValue);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Right' VerticalAlignment.Middle' out ha' out va);  	break;  case AxisPosition.Right:  	pt = new ScreenPoint (axisPosition + a1 + axis.AxisTickToLabelDistance' transformedValue);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Left' VerticalAlignment.Middle' out ha' out va);  	break;  case AxisPosition.Top:  	pt = new ScreenPoint (transformedValue' axisPosition + a1 - axis.AxisTickToLabelDistance);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Center' VerticalAlignment.Bottom' out ha' out va);  	break;  case AxisPosition.Bottom:  	pt = new ScreenPoint (transformedValue' axisPosition + a1 + axis.AxisTickToLabelDistance);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Center' VerticalAlignment.Top' out ha' out va);  	break;  }  
Missing Default,OxyPlot.Reporting,WikiReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,PadString,The following switch statement is missing a default case: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
Missing Default,OxyPlot.Reporting,HtmlReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\HtmlReportWriter.cs,WritePlot,The following switch statement is missing a default case: switch (this.PlotElementType) {  case HtmlPlotElementType.Embed:  case HtmlPlotElementType.Object:  	// TODO: need a Func<string'Stream> to provide streams for the plot files?  	////string source = string.Format(  	////    "{0}_Plot{1}.svg"' Path.GetFileNameWithoutExtension(this.outputFile)' plot.FigureNumber);  	////plot.PlotModel.SaveSvg(this.GetFullFileName(source)' plot.Width' plot.Height' this.textMeasurer);  	////this.WriteStartElement(this.PlotElementType == HtmlPlotElementType.Embed ? "embed" : "object");  	////this.WriteAttributeString("src"' source);  	////this.WriteAttributeString("type"' "image/svg+xml");  	////this.WriteEndElement();  	break;  case HtmlPlotElementType.Svg:  	this.WriteRaw (SvgExporter.ExportToString (plot.PlotModel' plot.Width' plot.Height' false' this.textMeasurer));  	break;  }  
Missing Default,OxyPlot.Reporting,TextReportWriter,C:\repos\andreasjacobsen93_XamarinThirdpartySamples\oxyplot-develop\Source\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,PadString,The following switch statement is missing a default case: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
