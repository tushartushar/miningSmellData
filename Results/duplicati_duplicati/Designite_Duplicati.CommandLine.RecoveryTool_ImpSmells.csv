Implementation smell,Namespace,Class,File,Method,Description
Long Method,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The method has 197 lines of code.
Long Method,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The method has 149 lines of code.
Complex Method,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,Cyclomatic complexity of the method is 20
Complex Method,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,Run,Cyclomatic complexity of the method is 18
Complex Method,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,SortFile,Cyclomatic complexity of the method is 15
Complex Method,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,MergeFiles,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,Cyclomatic complexity of the method is 50
Complex Method,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,Cyclomatic complexity of the method is 37
Long Statement,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The length of the statement  "		if (!options.ContainsKey ("auth_password") && !string.IsNullOrEmpty (System.Environment.GetEnvironmentVariable ("AUTH_PASSWORD"))) " is 130.
Long Statement,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The length of the statement  "		if (!options.ContainsKey ("auth_username") && !string.IsNullOrEmpty (System.Environment.GetEnvironmentVariable ("AUTH_USERNAME"))) " is 130.
Long Statement,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The length of the statement  "		bool isHelp = args.Count == 0 || (args.Count >= 1 && string.Equals (args [0]' "help"' StringComparison.InvariantCultureIgnoreCase)); " is 132.
Long Statement,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The length of the statement  "		if (!isHelp && ((options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) || (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) || (options.ContainsKey ("parameterfile") && !string.IsNullOrEmpty ("parameterfile")))) { " is 280.
Long Statement,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,ReadOptionsFromFile,The length of the statement  "		List<string> fargs = new List<string> (Library.Utility.Utility.ReadFileWithDefaultEncoding (Library.Utility.Utility.ExpandEnvironmentVariables (filename)).Replace ("\r\n"' "\n").Replace ("\r"' "\n").Split (new String[] { " is 220.
Long Statement,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,ReadOptionsFromFile,The length of the statement  "			throw new Duplicati.Library.Interface.UserInformationException ("Filters cannot be specified on the commandline if filters are also present in the parameter file"); " is 164.
Long Statement,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,ReadOptionsFromFile,The length of the statement  "		where !string.IsNullOrWhiteSpace (c) && !c.StartsWith ("#") && !c.StartsWith ("!") && !c.StartsWith ("REM "' StringComparison.InvariantCultureIgnoreCase) " is 153.
Long Statement,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The length of the statement  "		Console.WriteLine ("Invalid argument count ({0} expected 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args)); " is 144.
Long Statement,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The length of the statement  "			Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys)); " is 164.
Long Statement,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The length of the statement  "				if (p.FileType != Duplicati.Library.Main.RemoteVolumeType.Blocks && p.FileType != Duplicati.Library.Main.RemoteVolumeType.Files) { " is 130.
Long Statement,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The length of the statement  "		Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' lst.Count' downloaded' errors); " is 129.
Long Statement,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The length of the statement  "			Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those"); " is 125.
Long Statement,Duplicati.CommandLine.RecoveryTool,Help,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Help.cs,Run,The length of the statement  "	Console.Write (new System.IO.StreamReader (System.Reflection.Assembly.GetExecutingAssembly ().GetManifestResourceStream (System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Name + "." + RESOURCE_NAME)).ReadToEnd ()); " is 226.
Long Statement,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,Run,The length of the statement  "		Console.WriteLine ("Invalid argument count ({0} expected 2): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args)); " is 144.
Long Statement,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The length of the statement  "		Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args)); " is 149.
Long Statement,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The length of the statement  "		Library.Main.Volumes.VolumeReaderBase.UpdateOptionsFromManifest (p.CompressionModule' file' new Duplicati.Library.Main.Options (options)); " is 138.
Long Statement,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,EnumerateFilesInDList,The length of the statement  "		using (var filesetreader = new Library.Main.Volumes.FilesetVolumeReader (cm' new Duplicati.Library.Main.Options (options))) " is 123.
Long Statement,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,SelectListFile,The length of the statement  "			throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Valid range for version is 0 to {1}"' items.Length - 1)); " is 137.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "		Console.WriteLine ("Invalid argument count ({0} expected 4): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args)); " is 144.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "		Console.WriteLine ("Target compression module not found: {0}{1}Modules supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.CompressionLoader.Keys)); " is 185.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "			Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys)); " is 164.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "					Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]); " is 134.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "					Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types)); " is 189.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "		// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks " is 122.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) " is 125.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "					localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module; " is 142.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "				if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) { " is 134.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "						using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) " is 125.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "					using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options)) " is 126.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "								if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) { " is 128.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "										using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile))) " is 126.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "										using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile))) " is 126.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) { " is 127.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "		Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors); " is 140.
Long Statement,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The length of the statement  "			Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those"); " is 125.
Long Statement,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The length of the statement  "		Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args)); " is 149.
Long Statement,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The length of the statement  "	Library.Main.Volumes.VolumeReaderBase.UpdateOptionsFromManifest (Path.GetExtension (filelist).Trim ('.')' filelist' new Duplicati.Library.Main.Options (options)); " is 162.
Long Statement,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The length of the statement  "	var blockhasher = string.IsNullOrWhiteSpace (blockhash_str) ? null : System.Security.Cryptography.HashAlgorithm.Create (blockhash_str); " is 135.
Long Statement,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The length of the statement  "	var filehasher = string.IsNullOrWhiteSpace (filehash_str) ? null : System.Security.Cryptography.HashAlgorithm.Create (filehash_str); " is 132.
Long Statement,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The length of the statement  "		throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Block hash algorithm not valid: {0}"' blockhash_str)); " is 134.
Long Statement,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The length of the statement  "		throw new Duplicati.Library.Interface.UserInformationException (string.Format ("File hash algorithm not valid: {0}"' filehash_str)); " is 132.
Long Statement,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The length of the statement  "		Console.WriteLine ("Restoring {0} files to {1}"' filecount' string.IsNullOrWhiteSpace (targetpath) ? "original position" : targetpath); " is 135.
Complex Conditional,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The conditional expression  "!isHelp && ((options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) || (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) || (options.ContainsKey ("parameterfile") && !string.IsNullOrEmpty ("parameterfile")))"  is complex.
Complex Conditional,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The conditional expression  "(!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))"  is complex.
Empty Catch Block,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,SortFile,The method has an empty catch block.
Magic Number,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The following statement contains a magic number: try {  	var args = new List<string> (_args);  	var tmpparsed = Library.Utility.FilterCollector.ExtractOptions (args);  	var options = tmpparsed.Item1;  	var filter = tmpparsed.Item2;  	if (!options.ContainsKey ("auth_password") && !string.IsNullOrEmpty (System.Environment.GetEnvironmentVariable ("AUTH_PASSWORD")))  		options ["auth_password"] = System.Environment.GetEnvironmentVariable ("AUTH_PASSWORD");  	if (!options.ContainsKey ("auth_username") && !string.IsNullOrEmpty (System.Environment.GetEnvironmentVariable ("AUTH_USERNAME")))  		options ["auth_username"] = System.Environment.GetEnvironmentVariable ("AUTH_USERNAME");  	if (options.ContainsKey ("tempdir") && !string.IsNullOrEmpty (options ["tempdir"]))  		Library.Utility.TempFolder.SetSystemTempPath (options ["tempdir"]);  	bool isHelp = args.Count == 0 || (args.Count >= 1 && string.Equals (args [0]' "help"' StringComparison.InvariantCultureIgnoreCase));  	if (!isHelp && ((options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) || (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) || (options.ContainsKey ("parameterfile") && !string.IsNullOrEmpty ("parameterfile")))) {  		string filename;  		if (options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) {  			filename = options ["parameters-file"];  			options.Remove ("parameters-file");  		} else if (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) {  			filename = options ["parameter-file"];  			options.Remove ("parameter-file");  		} else {  			filename = options ["parameterfile"];  			options.Remove ("parameterfile");  		}  		if (!ReadOptionsFromFile (filename' ref filter' args' options))  			return 100;  	}  	var actions = new Dictionary<string' CommandRunner> (StringComparer.InvariantCultureIgnoreCase);  	actions ["download"] = Download.Run;  	actions ["recompress"] = Recompress.Run;  	actions ["index"] = Index.Run;  	actions ["list"] = List.Run;  	actions ["restore"] = Restore.Run;  	actions ["help"] = Help.Run;  	CommandRunner command;  	actions.TryGetValue (args.FirstOrDefault () ?? ""' out command);  	command = command ?? actions ["help"];  	return command (args' options' filter);  } catch (Exception ex) {  	if (ex is Duplicati.Library.Interface.UserInformationException)  		Console.WriteLine (ex.Message);  	else  		Console.WriteLine ("Program crashed: {0}{1}"' Environment.NewLine' ex.ToString ());  	return 200;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The following statement contains a magic number: try {  	var args = new List<string> (_args);  	var tmpparsed = Library.Utility.FilterCollector.ExtractOptions (args);  	var options = tmpparsed.Item1;  	var filter = tmpparsed.Item2;  	if (!options.ContainsKey ("auth_password") && !string.IsNullOrEmpty (System.Environment.GetEnvironmentVariable ("AUTH_PASSWORD")))  		options ["auth_password"] = System.Environment.GetEnvironmentVariable ("AUTH_PASSWORD");  	if (!options.ContainsKey ("auth_username") && !string.IsNullOrEmpty (System.Environment.GetEnvironmentVariable ("AUTH_USERNAME")))  		options ["auth_username"] = System.Environment.GetEnvironmentVariable ("AUTH_USERNAME");  	if (options.ContainsKey ("tempdir") && !string.IsNullOrEmpty (options ["tempdir"]))  		Library.Utility.TempFolder.SetSystemTempPath (options ["tempdir"]);  	bool isHelp = args.Count == 0 || (args.Count >= 1 && string.Equals (args [0]' "help"' StringComparison.InvariantCultureIgnoreCase));  	if (!isHelp && ((options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) || (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) || (options.ContainsKey ("parameterfile") && !string.IsNullOrEmpty ("parameterfile")))) {  		string filename;  		if (options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) {  			filename = options ["parameters-file"];  			options.Remove ("parameters-file");  		} else if (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) {  			filename = options ["parameter-file"];  			options.Remove ("parameter-file");  		} else {  			filename = options ["parameterfile"];  			options.Remove ("parameterfile");  		}  		if (!ReadOptionsFromFile (filename' ref filter' args' options))  			return 100;  	}  	var actions = new Dictionary<string' CommandRunner> (StringComparer.InvariantCultureIgnoreCase);  	actions ["download"] = Download.Run;  	actions ["recompress"] = Recompress.Run;  	actions ["index"] = Index.Run;  	actions ["list"] = List.Run;  	actions ["restore"] = Restore.Run;  	actions ["help"] = Help.Run;  	CommandRunner command;  	actions.TryGetValue (args.FirstOrDefault () ?? ""' out command);  	command = command ?? actions ["help"];  	return command (args' options' filter);  } catch (Exception ex) {  	if (ex is Duplicati.Library.Interface.UserInformationException)  		Console.WriteLine (ex.Message);  	else  		Console.WriteLine ("Program crashed: {0}{1}"' Environment.NewLine' ex.ToString ());  	return 200;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The following statement contains a magic number: if (!isHelp && ((options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) || (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) || (options.ContainsKey ("parameterfile") && !string.IsNullOrEmpty ("parameterfile")))) {  	string filename;  	if (options.ContainsKey ("parameters-file") && !string.IsNullOrEmpty ("parameters-file")) {  		filename = options ["parameters-file"];  		options.Remove ("parameters-file");  	} else if (options.ContainsKey ("parameter-file") && !string.IsNullOrEmpty ("parameter-file")) {  		filename = options ["parameter-file"];  		options.Remove ("parameter-file");  	} else {  		filename = options ["parameterfile"];  		options.Remove ("parameterfile");  	}  	if (!ReadOptionsFromFile (filename' ref filter' args' options))  		return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The following statement contains a magic number: if (!ReadOptionsFromFile (filename' ref filter' args' options))  	return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Program,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Program.cs,RealMain,The following statement contains a magic number: return 200;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: if (args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: if (args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [1]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [2]);  	if (!Directory.Exists (args [2])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var lst = backend.List ();  	Console.WriteLine ("Found {0} files"' lst.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	string passphrase;  	options.TryGetValue ("passphrase"' out passphrase);  	foreach (var file in lst) {  		try {  			Console.Write ("{0}: {1}"' i' file.Name);  			var p = Duplicati.Library.Main.Volumes.VolumeBase.ParseFilename (file);  			if (p == null) {  				Console.WriteLine (" - Not a Duplicati file' ignoring");  				continue;  			}  			var local = Path.Combine (targetfolder' file.Name);  			if (p.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				local = local.Substring (0' local.Length - p.EncryptionModule.Length - 1);  			}  			if (p.FileType != Duplicati.Library.Main.RemoteVolumeType.Blocks && p.FileType != Duplicati.Library.Main.RemoteVolumeType.Files) {  				Console.WriteLine (" - Filetype {0}' skipping"' p.FileType);  				continue;  			}  			if (File.Exists (local)) {  				Console.WriteLine (" - Already exists' skipping");  				continue;  			}  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (file.Size));  			using (var tf = new Library.Utility.TempFile ()) {  				backend.Get (file.Name' tf);  				if (p.EncryptionModule != null) {  					Console.Write (" - decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (p.EncryptionModule' passphrase' options))  						using (var tf2 = new Library.Utility.TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' local);  						}  				} else  					File.Copy (tf' local);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  		i++;  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' lst.Count' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0)  		return 200;  	else  		return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [1]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [2]);  	if (!Directory.Exists (args [2])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var lst = backend.List ();  	Console.WriteLine ("Found {0} files"' lst.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	string passphrase;  	options.TryGetValue ("passphrase"' out passphrase);  	foreach (var file in lst) {  		try {  			Console.Write ("{0}: {1}"' i' file.Name);  			var p = Duplicati.Library.Main.Volumes.VolumeBase.ParseFilename (file);  			if (p == null) {  				Console.WriteLine (" - Not a Duplicati file' ignoring");  				continue;  			}  			var local = Path.Combine (targetfolder' file.Name);  			if (p.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				local = local.Substring (0' local.Length - p.EncryptionModule.Length - 1);  			}  			if (p.FileType != Duplicati.Library.Main.RemoteVolumeType.Blocks && p.FileType != Duplicati.Library.Main.RemoteVolumeType.Files) {  				Console.WriteLine (" - Filetype {0}' skipping"' p.FileType);  				continue;  			}  			if (File.Exists (local)) {  				Console.WriteLine (" - Already exists' skipping");  				continue;  			}  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (file.Size));  			using (var tf = new Library.Utility.TempFile ()) {  				backend.Get (file.Name' tf);  				if (p.EncryptionModule != null) {  					Console.Write (" - decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (p.EncryptionModule' passphrase' options))  						using (var tf2 = new Library.Utility.TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' local);  						}  				} else  					File.Copy (tf' local);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  		i++;  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' lst.Count' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0)  		return 200;  	else  		return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [1]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [2]);  	if (!Directory.Exists (args [2])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var lst = backend.List ();  	Console.WriteLine ("Found {0} files"' lst.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	string passphrase;  	options.TryGetValue ("passphrase"' out passphrase);  	foreach (var file in lst) {  		try {  			Console.Write ("{0}: {1}"' i' file.Name);  			var p = Duplicati.Library.Main.Volumes.VolumeBase.ParseFilename (file);  			if (p == null) {  				Console.WriteLine (" - Not a Duplicati file' ignoring");  				continue;  			}  			var local = Path.Combine (targetfolder' file.Name);  			if (p.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				local = local.Substring (0' local.Length - p.EncryptionModule.Length - 1);  			}  			if (p.FileType != Duplicati.Library.Main.RemoteVolumeType.Blocks && p.FileType != Duplicati.Library.Main.RemoteVolumeType.Files) {  				Console.WriteLine (" - Filetype {0}' skipping"' p.FileType);  				continue;  			}  			if (File.Exists (local)) {  				Console.WriteLine (" - Already exists' skipping");  				continue;  			}  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (file.Size));  			using (var tf = new Library.Utility.TempFile ()) {  				backend.Get (file.Name' tf);  				if (p.EncryptionModule != null) {  					Console.Write (" - decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (p.EncryptionModule' passphrase' options))  						using (var tf2 = new Library.Utility.TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' local);  						}  				} else  					File.Copy (tf' local);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  		i++;  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' lst.Count' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0)  		return 200;  	else  		return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [1]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [2]);  	if (!Directory.Exists (args [2])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var lst = backend.List ();  	Console.WriteLine ("Found {0} files"' lst.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	string passphrase;  	options.TryGetValue ("passphrase"' out passphrase);  	foreach (var file in lst) {  		try {  			Console.Write ("{0}: {1}"' i' file.Name);  			var p = Duplicati.Library.Main.Volumes.VolumeBase.ParseFilename (file);  			if (p == null) {  				Console.WriteLine (" - Not a Duplicati file' ignoring");  				continue;  			}  			var local = Path.Combine (targetfolder' file.Name);  			if (p.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				local = local.Substring (0' local.Length - p.EncryptionModule.Length - 1);  			}  			if (p.FileType != Duplicati.Library.Main.RemoteVolumeType.Blocks && p.FileType != Duplicati.Library.Main.RemoteVolumeType.Files) {  				Console.WriteLine (" - Filetype {0}' skipping"' p.FileType);  				continue;  			}  			if (File.Exists (local)) {  				Console.WriteLine (" - Already exists' skipping");  				continue;  			}  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (file.Size));  			using (var tf = new Library.Utility.TempFile ()) {  				backend.Get (file.Name' tf);  				if (p.EncryptionModule != null) {  					Console.Write (" - decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (p.EncryptionModule' passphrase' options))  						using (var tf2 = new Library.Utility.TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' local);  						}  				} else  					File.Copy (tf' local);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  		i++;  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' lst.Count' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0)  		return 200;  	else  		return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [1]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [2]);  	if (!Directory.Exists (args [2])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var lst = backend.List ();  	Console.WriteLine ("Found {0} files"' lst.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	string passphrase;  	options.TryGetValue ("passphrase"' out passphrase);  	foreach (var file in lst) {  		try {  			Console.Write ("{0}: {1}"' i' file.Name);  			var p = Duplicati.Library.Main.Volumes.VolumeBase.ParseFilename (file);  			if (p == null) {  				Console.WriteLine (" - Not a Duplicati file' ignoring");  				continue;  			}  			var local = Path.Combine (targetfolder' file.Name);  			if (p.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				local = local.Substring (0' local.Length - p.EncryptionModule.Length - 1);  			}  			if (p.FileType != Duplicati.Library.Main.RemoteVolumeType.Blocks && p.FileType != Duplicati.Library.Main.RemoteVolumeType.Files) {  				Console.WriteLine (" - Filetype {0}' skipping"' p.FileType);  				continue;  			}  			if (File.Exists (local)) {  				Console.WriteLine (" - Already exists' skipping");  				continue;  			}  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (file.Size));  			using (var tf = new Library.Utility.TempFile ()) {  				backend.Get (file.Name' tf);  				if (p.EncryptionModule != null) {  					Console.Write (" - decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (p.EncryptionModule' passphrase' options))  						using (var tf2 = new Library.Utility.TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' local);  						}  				} else  					File.Copy (tf' local);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  		i++;  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' lst.Count' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0)  		return 200;  	else  		return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: if (backend == null) {  	Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: if (!Directory.Exists (args [2])) {  	Console.WriteLine ("Creating target folder: {0}"' targetfolder);  	Directory.CreateDirectory (targetfolder);  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: if (needspass > 0 && downloaded == 0) {  	Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: if (errors > 0)  	return 200;  else  	return 0;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Download,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Download.cs,Run,The following statement contains a magic number: return 200;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Help,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Help.cs,Run,The following statement contains a magic number: if (args.Count >= 1 && !string.Equals ("help"' args [0])) {  	Console.WriteLine ("Unsupported command: {0}"' args [0]);  	Console.WriteLine ();  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Help,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Help.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,Run,The following statement contains a magic number: if (args.Count != 2) {  	Console.WriteLine ("Invalid argument count ({0} expected 2): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,Run,The following statement contains a magic number: if (args.Count != 2) {  	Console.WriteLine ("Invalid argument count ({0} expected 2): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,Run,The following statement contains a magic number: if (!Directory.Exists (folder)) {  	Console.WriteLine ("Folder not found: {0}"' folder);  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Index,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Index.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: if (args.Count != 2 && args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: if (args.Count != 2 && args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: if (args.Count != 2 && args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: if (!Directory.Exists (folder)) {  	Console.WriteLine ("Folder not found: {0}"' folder);  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: if (args.Count == 2) {  	var times = ParseListFiles (folder);  	foreach (var v in times.Zip (Enumerable.Range (0' times.Length)' (a' b) => new KeyValuePair<int' DateTime> (b' a.Key)))  		Console.WriteLine ("{0}: {1}"' v.Key' v.Value.ToLocalTime ());  } else {  	var file = SelectListFile (args [2]' folder);  	var p = Library.Main.Volumes.VolumeBase.ParseFilename (file);  	Library.Main.Volumes.VolumeReaderBase.UpdateOptionsFromManifest (p.CompressionModule' file' new Duplicati.Library.Main.Options (options));  	foreach (var f in EnumerateFilesInDList (file' filter' options))  		Console.WriteLine ("{0} ({1})"' f.Path' Library.Utility.Utility.FormatSizeString (f.Size));  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,List,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\List.cs,Run,The following statement contains a magic number: if (args.Count == 2) {  	var times = ParseListFiles (folder);  	foreach (var v in times.Zip (Enumerable.Range (0' times.Length)' (a' b) => new KeyValuePair<int' DateTime> (b' a.Key)))  		Console.WriteLine ("{0}: {1}"' v.Key' v.Value.ToLocalTime ());  } else {  	var file = SelectListFile (args [2]' folder);  	var p = Library.Main.Volumes.VolumeBase.ParseFilename (file);  	Library.Main.Volumes.VolumeReaderBase.UpdateOptionsFromManifest (p.CompressionModule' file' new Duplicati.Library.Main.Options (options));  	foreach (var f in EnumerateFilesInDList (file' filter' options))  		Console.WriteLine ("{0} ({1})"' f.Path' Library.Utility.Utility.FormatSizeString (f.Size));  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (args.Count != 4) {  	Console.WriteLine ("Invalid argument count ({0} expected 4): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (args.Count != 4) {  	Console.WriteLine ("Invalid argument count ({0} expected 4): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (!Library.DynamicLoader.CompressionLoader.Keys.Contains (target_compr_module)) {  	Console.WriteLine ("Target compression module not found: {0}{1}Modules supported: {2}"' args [1]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.CompressionLoader.Keys));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: using (var backend = Library.DynamicLoader.BackendLoader.GetBackend (args [2]' options)) {  	if (backend == null) {  		Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  		return 100;  	}  	var targetfolder = Path.GetFullPath (args [3]);  	if (!Directory.Exists (args [3])) {  		Console.WriteLine ("Creating target folder: {0}"' targetfolder);  		Directory.CreateDirectory (targetfolder);  	}  	Console.WriteLine ("Listing files on backend: {0} ..."' backend.ProtocolKey);  	var rawlist = backend.List ();  	Console.WriteLine ("Found {0} files at remote storage"' rawlist.Count);  	var i = 0;  	var downloaded = 0;  	var errors = 0;  	var needspass = 0;  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_Options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  			else if (types.Length == 1)  				Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  			else  				Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  		}  		return 100;  	}  	bool reencrypt = Library.Utility.Utility.ParseBoolOption (options' "reencrypt");  	bool reupload = Library.Utility.Utility.ParseBoolOption (options' "reupload");  	// Needs order (Files or Blocks) and Indexes as last because indexes content will be adjusted based on recompressed blocks  	var files = remotefiles.Where (a => a.FileType == RemoteVolumeType.Files).ToArray ();  	var blocks = remotefiles.Where (a => a.FileType == RemoteVolumeType.Blocks).ToArray ();  	var indexes = remotefiles.Where (a => a.FileType == RemoteVolumeType.Index).ToArray ();  	remotefiles = files.Concat (blocks).ToArray ().Concat (indexes).ToArray ();  	Console.WriteLine ("Found {0} files which belongs to backup with prefix {1}"' remotefiles.Count ()' m_Options.Prefix);  	foreach (var remoteFile in remotefiles) {  		try {  			Console.Write ("{0}/{1}: {2}"' ++i' remotefiles.Count ()' remoteFile.File.Name);  			var localFileSource = Path.Combine (targetfolder' remoteFile.File.Name);  			string localFileTarget;  			string localFileSourceEncryption = "";  			if (remoteFile.EncryptionModule != null) {  				if (string.IsNullOrWhiteSpace (m_Options.Passphrase)) {  					needspass++;  					Console.WriteLine (" - No passphrase supplied' skipping");  					continue;  				}  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  					localFileSourceEncryption = m.FilenameExtension;  				localFileSource = localFileSource.Substring (0' localFileSource.Length - localFileSourceEncryption.Length - 1);  			}  			if (remoteFile.CompressionModule != null)  				localFileTarget = localFileSource.Substring (0' localFileSource.Length - remoteFile.CompressionModule.Length - 1) + "." + target_compr_module;  			else {  				Console.WriteLine (" - cannot detect compression type");  				continue;  			}  			if ((!reencrypt && File.Exists (localFileTarget)) || (reencrypt && File.Exists (localFileTarget + "." + localFileSourceEncryption))) {  				Console.WriteLine (" - target file already exist");  				continue;  			}  			if (File.Exists (localFileSource))  				File.Delete (localFileSource);  			Console.Write (" - downloading ({0})..."' Library.Utility.Utility.FormatSizeString (remoteFile.File.Size));  			DateTime originLastWriteTime;  			FileInfo destinationFileInfo;  			using (var tf = new TempFile ()) {  				backend.Get (remoteFile.File.Name' tf);  				originLastWriteTime = new FileInfo (tf).LastWriteTime;  				downloaded++;  				if (remoteFile.EncryptionModule != null) {  					Console.Write (" decrypting ...");  					using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options))  						using (var tf2 = new TempFile ()) {  							m.Decrypt (tf' tf2);  							File.Copy (tf2' localFileSource);  							File.Delete (tf2);  						}  				} else  					File.Copy (tf' localFileSource);  				File.Delete (tf);  				destinationFileInfo = new FileInfo (localFileSource);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (remoteFile.CompressionModule != null) {  				Console.Write (" recompressing ...");  				//Recompressing from eg. zip to zip  				if (localFileSource == localFileTarget) {  					File.Move (localFileSource' localFileSource + ".same");  					localFileSource = localFileSource + ".same";  				}  				using (var cmOld = Library.DynamicLoader.CompressionLoader.GetModule (remoteFile.CompressionModule' localFileSource' options))  					using (var cmNew = Library.DynamicLoader.CompressionLoader.GetModule (target_compr_module' localFileTarget' options))  						foreach (var cmfile in cmOld.ListFiles ("")) {  							string cmfileNew = cmfile;  							var cmFileVolume = VolumeBase.ParseFilename (cmfileNew);  							if (remoteFile.FileType == RemoteVolumeType.Index && cmFileVolume != null && cmFileVolume.FileType == RemoteVolumeType.Blocks) {  								// Correct inner filename extension to target compression type  								cmfileNew = cmfileNew.Replace ("." + cmFileVolume.CompressionModule' "." + target_compr_module);  								if (!reencrypt)  									cmfileNew = cmfileNew.Replace ("." + cmFileVolume.EncryptionModule' "");  								//Because compression changes blocks file sizes - needs to be updated  								string textJSON;  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var sourceStreamReader = new StreamReader (sourceStream)) {  										textJSON = sourceStreamReader.ReadToEnd ();  										JToken token = JObject.Parse (textJSON);  										var fileInfoBlocks = new FileInfo (Path.Combine (targetfolder' cmfileNew.Replace ("vol/"' "")));  										var filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_Options.FileHashAlgorithm);  										using (var fileStream = fileInfoBlocks.Open (FileMode.Open)) {  											fileStream.Position = 0;  											token ["volumehash"] = Convert.ToBase64String (filehasher.ComputeHash (fileStream));  											fileStream.Close ();  										}  										token ["volumesize"] = fileInfoBlocks.Length;  										textJSON = token.ToString ();  									}  								using (var sourceStream = new MemoryStream (System.Text.Encoding.UTF8.GetBytes (textJSON)))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							} else {  								using (var sourceStream = cmOld.OpenRead (cmfile))  									using (var cs = cmNew.CreateFile (cmfileNew' Library.Interface.CompressionHint.Compressible' cmOld.GetLastWriteTime (cmfile)))  										Library.Utility.Utility.CopyStream (sourceStream' cs);  							}  						}  				File.Delete (localFileSource);  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reencrypt && remoteFile.EncryptionModule != null) {  				Console.Write (" reencrypting ...");  				using (var m = Library.DynamicLoader.EncryptionLoader.GetModule (remoteFile.EncryptionModule' m_Options.Passphrase' options)) {  					m.Encrypt (localFileTarget' localFileTarget + "." + localFileSourceEncryption);  					File.Delete (localFileTarget);  					localFileTarget = localFileTarget + "." + localFileSourceEncryption;  				}  				destinationFileInfo = new FileInfo (localFileTarget);  				destinationFileInfo.LastWriteTime = originLastWriteTime;  			}  			if (reupload) {  				Console.Write (" reuploading ...");  				backend.Put ((new FileInfo (localFileTarget)).Name' localFileTarget);  				backend.Delete (remoteFile.File.Name);  				File.Delete (localFileTarget);  			}  			Console.WriteLine (" done!");  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  	}  	if (reupload) {  		var remoteverificationfileexist = rawlist.Any (x => x.Name == (m_Options.Prefix + "-verification.json"));  		if (remoteverificationfileexist) {  			Console.WriteLine ("Found verification file {0} - deleting"' m_Options.Prefix + "-verification.json");  			backend.Delete (m_Options.Prefix + "-verification.json");  		}  	}  	if (needspass > 0 && downloaded == 0) {  		Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  		return 100;  	}  	Console.WriteLine ("Download complete' of {0} remote files' {1} were downloaded with {2} errors"' remotefiles.Count ()' downloaded' errors);  	if (needspass > 0)  		Console.WriteLine ("Additonally {0} remote files were skipped because of encryption' supply --passphrase to download those");  	if (errors > 0) {  		Console.WriteLine ("There were errors during recompress of remote backend files!");  		return 200;  	}  	return 0;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (backend == null) {  	Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (backend == null) {  	Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: Console.WriteLine ("Backend not found: {0}{1}Backends supported: {2}"' args [2]' Environment.NewLine' string.Join ("' "' Library.DynamicLoader.BackendLoader.Keys));  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (!Directory.Exists (args [3])) {  	Console.WriteLine ("Creating target folder: {0}"' targetfolder);  	Directory.CreateDirectory (targetfolder);  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (remotefiles.Length == 0) {  	if (rawlist.Count == 0)  		Console.WriteLine ("No files were found at the remote location' perhaps the target url is incorrect?");  	else {  		var tmp = (from x in rawlist  		let n = VolumeBase.ParseFilename (x)  		where n != null  		select n.Prefix).ToArray ();  		var types = tmp.Distinct ().ToArray ();  		if (tmp.Length == 0)  			Console.WriteLine ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count);  		else if (types.Length == 1)  			Console.WriteLine ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]);  		else  			Console.WriteLine ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types));  	}  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (needspass > 0 && downloaded == 0) {  	Console.WriteLine ("No files downloaded' try adding --passphrase to decrypt files");  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: if (errors > 0) {  	Console.WriteLine ("There were errors during recompress of remote backend files!");  	return 200;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Recompress,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Recompress.cs,Run,The following statement contains a magic number: return 200;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (args.Count != 2 && args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (args.Count != 2 && args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (args.Count != 2 && args.Count != 3) {  	Console.WriteLine ("Invalid argument count ({0} expected 2 or 3): {1}{2}"' args.Count' Environment.NewLine' string.Join (Environment.NewLine' args));  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (!Directory.Exists (folder)) {  	Console.WriteLine ("Folder not found: {0}"' folder);  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (!File.Exists (ixfile)) {  	Console.WriteLine ("Index file not found' perhaps you need to run the index command?");  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (args.Count == 2) {  	var time = List.ParseListFiles (folder).First ();  	filelist = time.Value;  	Console.WriteLine ("Using set 0 with timestamp {0}"' time.Key.ToLocalTime ());  } else {  	filelist = List.SelectListFile (args [2]' folder);  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (args.Count == 2) {  	var time = List.ParseListFiles (folder).First ();  	filelist = time.Value;  	Console.WriteLine ("Using set 0 with timestamp {0}"' time.Key.ToLocalTime ());  } else {  	filelist = List.SelectListFile (args [2]' folder);  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: filelist = List.SelectListFile (args [2]' folder);  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: if (blocksize <= 0) {  	Console.WriteLine ("Invalid blocksize: {0}' try setting --blocksize manually");  	return 100;  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: return 100;  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,Run,The following statement contains a magic number: using (var mru = new CompressedFileMRUCache (options)) {  	Console.WriteLine ("Building lookup table for file hashes");  	var lookup = new HashLookupHelper (ixfile' mru' (int)blocksize' blockhasher.HashSize / 8);  	var filecount = 0L;  	string largestprefix = null;  	string[] largestprefixparts = null;  	if (!string.IsNullOrWhiteSpace (targetpath))  		Console.WriteLine ("Computing restore path");  	foreach (var f in List.EnumerateFilesInDList (filelist' filter' options)) {  		if (largestprefix == null) {  			largestprefix = f.Path;  			largestprefixparts = largestprefix.Split (new char[] {  				Path.DirectorySeparatorChar  			});  		} else if (largestprefix.Length > 1) {  			var parts = f.Path.Split (new char[] {  				Path.DirectorySeparatorChar  			});  			var ni = 0;  			for (; ni < Math.Min (parts.Length' largestprefixparts.Length); ni++)  				if (!Library.Utility.Utility.ClientFilenameStringComparer.Equals (parts [ni]' largestprefixparts [ni]))  					break;  			if (ni != largestprefixparts.Length) {  				if (ni == 0) {  					largestprefixparts = new string[0];  					largestprefix = string.Empty;  				} else {  					Array.Resize (ref largestprefixparts' ni - 1);  					largestprefix = string.Join (Path.DirectorySeparatorChar.ToString ()' largestprefixparts);  				}  			}  		}  		filecount++;  	}  	Console.WriteLine ("Restoring {0} files to {1}"' filecount' string.IsNullOrWhiteSpace (targetpath) ? "original position" : targetpath);  	if (Library.Utility.Utility.IsClientLinux || largestprefix.Length > 0)  		largestprefix = Library.Utility.Utility.AppendDirSeparator (largestprefix);  	if (!string.IsNullOrEmpty (largestprefix))  		Console.WriteLine ("Removing common prefix {0} from files"' largestprefix);  	var i = 0L;  	var errors = 0L;  	foreach (var f in List.EnumerateFilesInDList (filelist' filter' options)) {  		try {  			var targetfile = MapToRestorePath (f.Path' largestprefix' targetpath);  			if (!Directory.Exists (Path.GetDirectoryName (targetfile)))  				Directory.CreateDirectory (Path.GetDirectoryName (targetfile));  			Console.Write ("{0}: {1} ({2})"' i' targetfile' Library.Utility.Utility.FormatSizeString (f.Size));  			using (var tf = new Library.Utility.TempFile ()) {  				using (var sw = File.OpenWrite (tf)) {  					if (f.BlocklistHashes == null) {  						lookup.WriteHash (sw' f.Hash);  					} else {  						var blhi = 0L;  						foreach (var blh in f.BlocklistHashes) {  							Console.Write (" {0}"' blhi);  							var blockhashoffset = blhi * hashesprblock * blocksize;  							try {  								var bi = 0;  								foreach (var h in lookup.ReadBlocklistHashes (blh)) {  									try {  										sw.Position = blockhashoffset + (bi * blocksize);  										lookup.WriteHash (sw' h);  									} catch (Exception ex) {  										Console.WriteLine ("Failed to read hash: {0}{1}{2}"' h' Environment.NewLine' ex.ToString ());  									}  									bi++;  								}  							} catch (Exception ex) {  								Console.WriteLine ("Failed to read Blocklist hash: {0}{1}{2}"' blh' Environment.NewLine' ex.ToString ());  							}  							blhi++;  						}  					}  				}  				string fh;  				using (var fs = File.OpenRead (tf))  					fh = Convert.ToBase64String (filehasher.ComputeHash (fs));  				if (fh == f.Hash) {  					Console.WriteLine (" done!");  					File.Copy (tf' targetfile' true);  				} else {  					Console.Write (" - Restored file hash mismatch");  					if (File.Exists (targetfile))  						Console.WriteLine (" - not overwriting existing file: {0}"' targetfile);  					else  						Console.WriteLine (" - restoring file in damaged condition");  				}  			}  		} catch (Exception ex) {  			Console.WriteLine (" error: {0}"' ex.ToString ());  			errors++;  		}  		i++;  	}  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,MapToRestorePath,The following statement contains a magic number: if (string.IsNullOrWhiteSpace (prefixpath)) {  	//Special case' restoring to new folder' but files are from different drives  	// So we use the format <restore path> / <drive letter> / <source path>  	// To avoid generating paths with a colon  	if (path.Substring (1' 1) == ":")  		prefixpath = path.Substring (0' 1) + path.Substring (2);  	return Path.Combine (restorepath' prefixpath);  }  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,MapToRestorePath,The following statement contains a magic number: if (path.Substring (1' 1) == ":")  	prefixpath = path.Substring (0' 1) + path.Substring (2);  
Magic Number,Duplicati.CommandLine.RecoveryTool,Restore,F:\newReposMay17\duplicati_duplicati\Duplicati\CommandLine\RecoveryTool\Restore.cs,MapToRestorePath,The following statement contains a magic number: prefixpath = path.Substring (0' 1) + path.Substring (2);  
