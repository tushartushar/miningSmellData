Implementation smell,Namespace,Class,File,Method,Description
Long Identifier,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,,The length of the parameter COMPRESSION_LEVEL_OPTION_ALIAS is 30.
Long Identifier,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,,The length of the parameter CENTRAL_HEADER_ENTRY_SIZE_ZIP64_EXTRA is 37.
Long Statement,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,LoadEntryTable,The length of the statement  "                    Logging.Log.WriteMessage("Zip archive appears to have a broken Central Record Header' switching to stream mode"' Logging.LogMessageType.Warning' ex); " is 149.
Long Statement,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,LoadEntryTable,The length of the statement  "                        Logging.Log.WriteMessage(string.Format("Zip archive appears to have broken records' returning the {0} records that could be recovered"' d.Count)' Logging.LogMessageType.Warning' ex2); " is 183.
Long Statement,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,CreateFile,The length of the statement  "                DeflateCompressionLevel = hint == CompressionHint.Noncompressible ? SharpCompress.Compressors.Deflate.CompressionLevel.None : m_defaultCompressionLevel' " is 152.
Long Statement,Duplicati.Library.Compression.Strings,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\Strings.cs,CompressionmethodLong,The length of the statement  "{ return LC.L(@"This option can be used to set an alternative compressor method' such as LZMA. Note that using another value than Deflate will cause the {0} option to be ignored."' optionname); }" is 195.
Complex Conditional,Duplicati.Library.Compression,SevenZipCompression,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\SevenZipCompression.cs,SevenZipCompression,The conditional expression  "options != null                  && options.TryGetValue(THREAD_COUNT_OPTION' out threadCountSetting)                  && Int32.TryParse(threadCountSetting' out threadCountValue)                  && threadCountValue > 0"  is complex.
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,FileArchiveZip,The following statement contains a magic number: if (File.Exists(filename) && new FileInfo(filename).Length > 0)              {                  m_isWriting = false;                  m_filename = filename;              }              else              {                  var compression = new ZipWriterOptions(CompressionType.Deflate);                    compression.CompressionType = DEFAULT_COMPRESSION_METHOD;                  compression.DeflateCompressionLevel = DEFAULT_COMPRESSION_LEVEL;                    m_usingZip64 = compression.UseZip64 =                      options.ContainsKey(COMPRESSION_ZIP64_OPTION)                      ? Duplicati.Library.Utility.Utility.ParseBoolOption(options' COMPRESSION_ZIP64_OPTION)                      : DEFAULT_ZIP64;                    string cpmethod;                  CompressionType tmptype;                  if (options.TryGetValue(COMPRESSION_METHOD_OPTION' out cpmethod) && Enum.TryParse<SharpCompress.Common.CompressionType>(cpmethod' true' out tmptype))                      compression.CompressionType = tmptype;                    string cplvl;                  int tmplvl;                  if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                  else if (options.TryGetValue(COMPRESSION_LEVEL_OPTION_ALIAS' out cplvl) && int.TryParse(cplvl' out tmplvl))                      compression.DeflateCompressionLevel = (SharpCompress.Compressors.Deflate.CompressionLevel)Math.Max(Math.Min(9' tmplvl)' 0);                    m_defaultCompressionLevel = compression.DeflateCompressionLevel;                  m_compressionType = compression.CompressionType;                    m_isWriting = true;                  m_stream = new System.IO.FileStream(filename' FileMode.Create' FileAccess.Write' FileShare.Read);                  m_writer = WriterFactory.Open(m_stream' ArchiveType.Zip' compression);                    //Size of endheader' taken from SharpCompress ZipWriter                  m_flushBufferSize = 8 + 2 + 2 + 4 + 4 + 2 + 0;              }
Magic Number,Duplicati.Library.Compression,FileArchiveZip,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\FileArchiveZip.cs,LoadEntryTable,The following statement contains a magic number: if (m_entryDict == null)              {                  try                  {                      var d = new Dictionary<string' IEntry>(Duplicati.Library.Utility.Utility.ClientFilenameStringComparer);                      foreach (var en in Archive.Entries)                          d[en.Key] = en;                      m_entryDict = d;                  }                  catch (Exception ex)                  {                      // If we get an exception here' it may be caused by the Central Header                      // being defect' so we switch to the less efficient reader interface                      if (m_using_reader)                          throw;                        Logging.Log.WriteMessage("Zip archive appears to have a broken Central Record Header' switching to stream mode"' Logging.LogMessageType.Warning' ex);                      SwitchToReader();                        var d = new Dictionary<string' IEntry>(Duplicati.Library.Utility.Utility.ClientFilenameStringComparer);                        try                      {                          using (var fs = new System.IO.FileStream(m_filename' FileMode.Open' FileAccess.Read' FileShare.Read))                          using (var rd = SharpCompress.Readers.Zip.ZipReader.Open(fs' new ReaderOptions() { LookForHeader = false }))                              while (rd.MoveToNextEntry())                              {                                  d[rd.Entry.Key] = rd.Entry;                                    // Some streams require this                                  // to correctly find the next entry                                  using (rd.OpenEntryStream())                                  { }                              }                      }                      catch (Exception ex2)                      {                          // If we have zero files' or just a manifest' don't bother                          if (d.Count < 2)                              throw;                                                    Logging.Log.WriteMessage(string.Format("Zip archive appears to have broken records' returning the {0} records that could be recovered"' d.Count)' Logging.LogMessageType.Warning' ex2);                      }                                            m_entryDict = d;                  }              }
Magic Number,Duplicati.Library.Compression,SevenZipCompression,C:\repos\duplicati_duplicati\Duplicati\Library\Compression\SevenZipCompression.cs,SevenZipCompression,The following statement contains a magic number: if (options.TryGetValue(COMPRESSION_LEVEL_OPTION' out cplvl) && int.TryParse(cplvl' out tmplvl))                  tmplvl = Math.Max(Math.Min(9' tmplvl)' 0);              else                  tmplvl = DEFAULT_COMPRESSION_LEVEL;
