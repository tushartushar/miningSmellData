Implementation smell,Namespace,Class,File,Method,Description
Long Method,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The method has 191 lines of code.
Long Method,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The method has 185 lines of code.
Long Method,Duplicati.Library.Main.Operation,ListFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The method has 143 lines of code.
Long Method,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The method has 369 lines of code.
Long Method,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The method has 105 lines of code.
Long Method,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The method has 161 lines of code.
Long Method,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The method has 185 lines of code.
Long Method,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The method has 200 lines of code.
Long Method,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The method has 335 lines of code.
Long Method,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The method has 158 lines of code.
Long Method,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The method has 108 lines of code.
Long Method,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The method has 122 lines of code.
Long Method,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has 162 lines of code.
Long Method,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The method has 130 lines of code.
Long Method,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The method has 153 lines of code.
Long Method,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The method has 151 lines of code.
Long Method,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The method has 125 lines of code.
Long Method,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The method has 116 lines of code.
Long Method,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The method has 106 lines of code.
Long Method,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The method has 108 lines of code.
Long Method,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The method has 111 lines of code.
Long Method,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The method has 134 lines of code.
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,Cyclomatic complexity of the method is 14
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main.Operation,FilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AttributeFilter,Cyclomatic complexity of the method is 17
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,CreateDirectoryStructure,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,GetFilesetsToDelete,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,DoRun,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,Cyclomatic complexity of the method is 25
Complex Method,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Put,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,Cyclomatic complexity of the method is 15
Complex Method,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,Cyclomatic complexity of the method is 20
Complex Method,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,Cyclomatic complexity of the method is 29
Complex Method,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetFilelistWhereClause,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Database,LocalTestDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,FilterByVerificationCount,Cyclomatic complexity of the method is 9
Long Parameter List,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,ProcessStream,The method has 6 parameters. Parameters: stream' hint' backend' blocklisthashes' hashcollector' skipfilehash
Long Parameter List,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The method has 7 parameters. Parameters: backend' key' data' offset' len' hint' isBlocklistData
Long Parameter List,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddFileToOutput,The method has 8 parameters. Parameters: backend' filename' size' lastmodified' metadata' hashlist' filehash' blocklisthashes
Long Parameter List,Duplicati.Library.Main.Operation,FilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FilterHandler,The method has 7 parameters. Parameters: snapshot' attributeFilter' sourcefilter' filter' symlinkPolicy' hardlinkPolicy' logWriter
Long Parameter List,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The method has 5 parameters. Parameters: dbparent' updating' filter' filelistfilter' blockprocessor
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The method has 6 parameters. Parameters: database' blocks' options' result' blockbuffer' metadatastorage
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The method has 5 parameters. Parameters: database' options' blockbuffer' hasher' result
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The method has 6 parameters. Parameters: database' options' blockbuffer' hasher' result' metadatastorage
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The method has 6 parameters. Parameters: database' blockbuffer' blockhasher' filehasher' options' result
Long Parameter List,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The method has 5 parameters. Parameters: db' transaction' hasVerifiedBacked' forceCompact' sharedManager
Long Parameter List,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyRemoteList,The method has 5 parameters. Parameters: backend' options' database' log' protectedfile
Long Parameter List,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,UploadVerificationFile,The method has 5 parameters. Parameters: backendurl' options' result' db' transaction
Long Parameter List,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The method has 5 parameters. Parameters: backend' options' database' log' protectedfile
Long Parameter List,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,SelectTime,The method has 5 parameters. Parameters: value' list' index' time' el
Long Parameter List,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The method has 5 parameters. Parameters: baseVersion' compareVersion' filterstrings' compositefilter' callback
Long Parameter List,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The method has 6 parameters. Parameters: db' vol' tf' options' log' sample_percent
Long Parameter List,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has 5 parameters. Parameters: db' filter' filtercommand' pgoffset' pgspan
Long Parameter List,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,GetBrokenFilesetsFromRemote,The method has 6 parameters. Parameters: backendurl' result' db' transaction' options' missing
Long Parameter List,Duplicati.Library.Main,AsyncDownloadedFile,C:\repos\duplicati_duplicati\Duplicati\Library\Main\AsyncDownloader.cs,AsyncDownloadedFile,The method has 5 parameters. Parameters: name' hash' size' tempfile' exception
Long Parameter List,Duplicati.Library.Main,FileEntryItem,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,FileEntryItem,The method has 5 parameters. Parameters: operation' remotefilename' size' hash' indexfile
Long Parameter List,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ListChanges,The method has 5 parameters. Parameters: baseVersion' targetVersion' filterstrings' filter' callback
Long Parameter List,Duplicati.Library.Main,ListChangesResults,C:\repos\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,SetResult,The method has 18 parameters. Parameters: baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' addedFolders' addedSymlinks' addedFiles' deletedFolders' deletedSymlinks' deletedFiles' modifiedFolders' modifiedSymlinks' modifiedFiles' addedSize' deletedSize' previousSize' currentSize' changeDetails
Long Parameter List,Duplicati.Library.Main,IBackendProgress,C:\repos\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,Update,The method has 6 parameters. Parameters: action' path' size' progress' bytes_pr_second' isBlocking
Long Parameter List,Duplicati.Library.Main,BackendProgressUpdater,C:\repos\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,Update,The method has 6 parameters. Parameters: action' path' size' progress' bytes_pr_second' isBlocking
Long Parameter List,Duplicati.Library.Main,IOperationProgress,C:\repos\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,UpdateOverall,The method has 7 parameters. Parameters: phase' progress' filesprocessed' filesizeprocessed' filecount' filesize' countingfiles
Long Parameter List,Duplicati.Library.Main,OperationProgressUpdater,C:\repos\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,UpdateOverall,The method has 7 parameters. Parameters: phase' progress' filesprocessed' filesizeprocessed' filecount' filesize' countingfiles
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The method has 7 parameters. Parameters: filehash' size' blocksize' hashes' blocklistHashes' blocksetid' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddMetadataset,The method has 7 parameters. Parameters: filehash' size' blocksize' blockhashes' blocklisthashes' metadataid' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The method has 5 parameters. Parameters: filename' lastmodified' blocksetID' metadataID' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The method has 6 parameters. Parameters: path' filesetid' oldModified' lastFileSize' oldMetahash' oldMetasize
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AppendFilesFromPreviousSet,The method has 5 parameters. Parameters: transaction' deleted' filesetid' prevId' timestamp
Long Parameter List,Duplicati.Library.Main.Database,PathEntryKeeper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,PathEntryKeeper,The method has 5 parameters. Parameters: fileId' lastmodified' filesize' metahash' metasize
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The method has 5 parameters. Parameters: name' state' size' hash' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The method has 6 parameters. Parameters: name' state' size' hash' suppressCleanup' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The method has 7 parameters. Parameters: name' state' size' hash' suppressCleanup' deleteGraceTime' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The method has 5 parameters. Parameters: file' hash' size' type' state
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The method has 5 parameters. Parameters: name' type' state' deleteGraceTime' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The method has 6 parameters. Parameters: name' type' state' size' deleteGraceTime' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalBlockSource,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocks,The method has 5 parameters. Parameters: connection' filetablename' blocktablename' blocksize' skipMetadata
Long Parameter List,Duplicati.Library.Main.Database,FilesAndMetadata,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FilesAndMetadata,The method has 5 parameters. Parameters: connection' filetablename' blocktablename' blocksize' curvolume
Long Parameter List,Duplicati.Library.Main.Database,IBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetBlockRestored,The method has 5 parameters. Parameters: targetfileid' index' hash' blocksize' metadata
Long Parameter List,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetBlockRestored,The method has 5 parameters. Parameters: targetfileid' index' hash' size' metadata
Long Parameter List,Duplicati.Library.Main.Database,RemoteVolumeEntry,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\RemoteVolumeEntry.cs,RemoteVolumeEntry,The method has 6 parameters. Parameters: name' hash' size' type' state' deleteGracePeriod
Long Parameter List,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetCompactReport,The method has 5 parameters. Parameters: volsize' wastethreshold' smallfilesize' maxsmallfilecount' transaction
Long Parameter List,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,CompactReport,The method has 5 parameters. Parameters: volsize' wastethreshold' smallfilesize' maxsmallfilecount' report
Long Parameter List,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckBlocklistCorrect,The method has 5 parameters. Parameters: hash' length' blocklist' blocksize' blockhashlength
Long Parameter List,Duplicati.Library.Main.Database,IStorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddElement,The method has 6 parameters. Parameters: path' filehash' metahash' size' type' asNew
Long Parameter List,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddElement,The method has 6 parameters. Parameters: path' filehash' metahash' size' type' asNew
Long Parameter List,Duplicati.Library.Main.Database,IFilelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Add,The method has 8 parameters. Parameters: path' size' hash' metasize' metahash' blocklistHashes' type' time
Long Parameter List,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Add,The method has 8 parameters. Parameters: path' size' hash' metasize' metahash' blocklistHashes' type' time
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddDirectoryEntry,The method has 5 parameters. Parameters: filesetid' path' time' metadataid' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddSymlinkEntry,The method has 5 parameters. Parameters: filesetid' path' time' metadataid' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddFileEntry,The method has 6 parameters. Parameters: filesetid' path' time' blocksetid' metadataid' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The method has 7 parameters. Parameters: type' filesetid' path' time' blocksetid' metadataid' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddMetadataset,The method has 5 parameters. Parameters: metahash' metahashsize' metablocklisthashes' expectedmetablocklisthashes' transaction
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The method has 5 parameters. Parameters: fullhash' size' blocklisthashes' expectedblocklisthashes' transaction
Long Parameter List,Duplicati.Library.Main.Volumes,BlockVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\BlockVolumeWriter.cs,AddBlock,The method has 5 parameters. Parameters: hash' data' offset' size' hint
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddFile,The method has 11 parameters. Parameters: name' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blocklisthashes' metablocklisthashes
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddAlternateStream,The method has 11 parameters. Parameters: name' filehash' size' lastmodified' metahash' metablockhash' metasize' blockhash' blocksize' blocklisthashes' metablocklisthashes
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddFileEntry,The method has 12 parameters. Parameters: type' name' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blocklisthashes' metablocklisthashes
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddDirectory,The method has 5 parameters. Parameters: name' metahash' metasize' metablockhash' metablocklisthashes
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddMetaEntry,The method has 6 parameters. Parameters: type' name' metahash' metasize' metablockhash' metablocklisthashes
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddSymlink,The method has 5 parameters. Parameters: name' metahash' metasize' metablockhash' metablocklisthashes
Long Parameter List,Duplicati.Library.Main.Volumes,VolumeBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The method has 6 parameters. Parameters: filetype' prefix' guid' timestamp' compressionmodule' encryptionmodule
Long Identifier,Duplicati.Library.Main,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Options.cs,,The length of the parameter DEFAULT_BLOCK_HASH_LOOKUP_SIZE is 30.
Long Identifier,Duplicati.Library.Main,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Options.cs,,The length of the parameter DEFAULT_METADATA_HASH_LOOKUP_SIZE is 33.
Long Identifier,Duplicati.Library.Main,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Options.cs,,The length of the parameter DEFAULT_COMPRESSED_EXTENSION_FILE is 33.
Long Identifier,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,,The length of the parameter m_insertblocksetentryFastCommand is 32.
Long Identifier,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,,The length of the parameter m_insertblocklistHashesCommand is 30.
Long Identifier,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,,The length of the parameter m_selectfilelastmodifiedCommand is 31.
Long Identifier,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,,The length of the parameter m_selectblocklistHashesCommand is 30.
Long Identifier,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,,The length of the parameter m_selectduplicateRemoteVolumesCommand is 37.
Long Identifier,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,,The length of the parameter m_updateFileAsDataVerifiedCommand is 33.
Long Identifier,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,,The length of the parameter m_insertPreviousElementCommand is 30.
Long Identifier,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the parameter selectBlocklistBlocksetEntries is 30.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CountFilesThread,The length of the statement  "            foreach(var path in new FilterHandler(snapshot' m_attributeFilter' m_sourceFilter' m_filter' m_symlinkPolicy' m_options.HardlinkPolicy' null).EnumerateFilesAndFolders()) " is 169.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The length of the statement  "                    fsw.VolumeID = m_database.RegisterRemoteVolume(fsw.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction); " is 135.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The length of the statement  "                        foreach(var p in m_options.ControlFiles.Split(new char[] { System.IO.Path.PathSeparator }' StringSplitOptions.RemoveEmptyEntries)) " is 130.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The length of the statement  "                        m_result.AddDryrunMessage(string.Format("Would upload fileset: {0}' size: {1}"' fsw.RemoteFilename' Library.Utility.Utility.FormatSizeString(new FileInfo(fsw.LocalFilename).Length))); " is 183.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RecreateMissingIndexFiles,The length of the statement  "                    w.VolumeID = m_database.RegisterRemoteVolume(w.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' null); " is 122.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RecreateMissingIndexFiles,The length of the statement  "                        m_result.AddDryrunMessage(string.Format("would upload new index file {0}' with size {1}' previous size {2}"' w.RemoteFilename' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(w.Filesize))); " is 272.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RunMainOperation,The length of the statement  "            var filterhandler = new FilterHandler(snapshot' m_attributeFilter' m_sourceFilter' m_filter' m_symlinkPolicy' m_options.HardlinkPolicy' m_result); " is 146.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FinalizeRemoteVolumes,The length of the statement  "                        m_result.AddDryrunMessage(string.Format("Would upload block volume: {0}' size: {1}"' m_blockvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString(new FileInfo(m_blockvolume.LocalFilename).Length))); " is 208.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FinalizeRemoteVolumes,The length of the statement  "                            m_indexvolume.FinishVolume(Library.Utility.Utility.CalculateHash(m_blockvolume.LocalFilename)' new FileInfo(m_blockvolume.LocalFilename).Length); " is 145.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FinalizeRemoteVolumes,The length of the statement  "                            m_result.AddDryrunMessage(string.Format("Would upload index volume: {0}' size: {1}"' m_indexvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString(new FileInfo(m_indexvolume.LocalFilename).Length))); " is 208.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadRealFileList,The length of the statement  "                        foreach(var p in m_options.ControlFiles.Split(new char[] { System.IO.Path.PathSeparator }' StringSplitOptions.RemoveEmptyEntries)) " is 130.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadRealFileList,The length of the statement  "                        m_result.AddDryrunMessage(string.Format("Would upload fileset volume: {0}' size: {1}"' filesetvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString(new FileInfo(filesetvolume.LocalFilename).Length))); " is 210.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CompactIfRequired,The length of the statement  "                    new DeleteHandler(backend.BackendUrl' m_options' (DeleteResults)m_result.DeleteResults).DoRun(db' ref m_transaction' true' currentIsSmall' backend); " is 148.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CompactIfRequired,The length of the statement  "                    new CompactHandler(backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact(db' true' ref m_transaction' backend); " is 139.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                if (probe_path != null && Duplicati.Library.Utility.Utility.GuessDirSeparator(probe_path) != System.IO.Path.DirectorySeparatorChar.ToString()) " is 142.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                    throw new UserInformationException(string.Format("The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems' which is not supported. To proceed without losing remote data' delete all filesets and make sure the --{0} option is set' then run the backup again to re-use the existing data on the remote store."' "no-auto-compact")); " is 441.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                    throw new UserInformationException("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss."); " is 208.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                    throw new UserInformationException("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the backup process cannot continue. You may delete the local database and attempt to repair it again."); " is 246.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                                if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) " is 126.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                                        m_result.AddMessage(string.Format("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name)); " is 120.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                                    m_result.AddWarning(string.Format("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null); " is 174.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                                throw new UserInformationException(string.Format("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime()' m_database.OperationTimestamp.ToLocalTime())); " is 230.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                            var filesetvolumeid = m_database.RegisterRemoteVolume(filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction); " is 152.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "                            FilelistProcessor.UploadVerificationFile(backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction); " is 123.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,GenerateMetadata,The length of the statement  "                    metadata = snapshot.GetMetadata(path' attributes.HasFlag(System.IO.FileAttributes.ReparsePoint)' m_symlinkPolicy == Options.SymlinkStrategy.Follow); " is 148.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                IMetahash metahashandsize = m_options.StoreMetadata ? Utility.WrapMetadata(GenerateMetadata(snapshot' path' attributes)' m_options) : EMPTY_METADATA; " is 149.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                    oldId = m_database.GetFileEntry(path' m_lastfilesetid' out oldModified' out lastFileSize' out oldMetahash' out oldMetasize); " is 124.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                var tooLargeFile = m_options.SkipFilesLargerThan != long.MaxValue && m_options.SkipFilesLargerThan != 0 && filestatsize >= 0 && filestatsize > m_options.SkipFilesLargerThan; " is 173.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                var metadatachanged = !m_options.SkipMetadata && (metahashandsize.Blob.Length != oldMetasize || metahashandsize.FileHash != oldMetahash); " is 137.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                if ((oldId < 0 || m_options.DisableFiletimeCheck || timestampChanged || filesizeChanged || metadatachanged) && !tooLargeFile) " is 125.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                    m_result.AddVerboseMessage("Checking file for changes {0}' new: {1}' timestamp changed: {2}' size changed: {3}' metadatachanged: {4}' {5} vs {6}"' path' oldId <= 0' timestampChanged' filesizeChanged' metadatachanged' lastwrite' oldModified); " is 241.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                                    m_result.AddDryrunMessage(string.Format("Would add new file {0}' size {1}"' path' Library.Utility.Utility.FormatSizeString(filesize))); " is 135.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                                    m_result.AddDryrunMessage(string.Format("Would add changed file {0}' size {1}"' path' Library.Utility.Utility.FormatSizeString(filesize))); " is 139.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "                        m_result.AddVerboseMessage("Excluding file because the size {0} exceeds limit ({1}): {2}"' Library.Utility.Utility.FormatSizeString(filestatsize)' Library.Utility.Utility.FormatSizeString(m_options.SkipFilesLargerThan)' path); " is 226.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "                m_blockvolume.VolumeID = m_database.RegisterRemoteVolume(m_blockvolume.RemoteFilename' RemoteVolumeType.Blocks' RemoteVolumeState.Temporary' m_transaction); " is 156.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "                    m_indexvolume.VolumeID = m_database.RegisterRemoteVolume(m_indexvolume.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' m_transaction); " is 155.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "                        m_result.AddDryrunMessage(string.Format("Would upload block volume: {0}' size: {1}"' m_blockvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString(new FileInfo(m_blockvolume.LocalFilename).Length))); " is 208.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "                            m_indexvolume.FinishVolume(Library.Utility.Utility.CalculateHash(m_blockvolume.LocalFilename)' new FileInfo(m_blockvolume.LocalFilename).Length); " is 145.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "                            m_result.AddDryrunMessage(string.Format("Would upload index volume: {0}' size: {1}"' m_indexvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString(new FileInfo(m_indexvolume.LocalFilename).Length))); " is 208.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddMetadataToOutput,The length of the statement  "                m_result.AddWarning(string.Format("Metadata size is {0}' but the largest accepted size is {1}' recording empty metadata"' meta.Blob.Length' m_maxmetadatasize)' null); " is 166.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddMetadataToOutput,The length of the statement  "                m_database.AddMetadataset(meta.FileHash' meta.Blob.Length' m_blocksize' hashcollector' blocklisthashes' out metadataid' m_transaction); " is 135.
Long Statement,Duplicati.Library.Main.Operation,FilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AttributeFilter,The length of the statement  "                        m_logWriter.AddVerboseMessage("Excluding path due to filter: {0} => {1}"' path' match == null ? "null" : match.ToString()); " is 123.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "            var simpleList = !((filter is Library.Utility.FilterExpression && ((Library.Utility.FilterExpression)filter).Type == Library.Utility.FilterType.Simple) || m_options.AllVersions); " is 178.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "                throw new UserInformationException("Listing folder contents is not supported without a local database' consider using the \"repair\" option to rebuild the database."); " is 167.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "                throw new UserInformationException("Listing prefixes is not supported without a local database' consider using the \"repair\" option to rebuild the database."); " is 160.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "                using (var rd = new Volumes.FilesetVolumeReader(RestoreHandler.GetCompressionModule(firstEntry.File.Name)' tmpfile' m_options)) " is 127.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "                    using(var tmpfile = backend.Get(flentry.Value.File.Name' flentry.Value.File == null ? -1 : flentry.Value.File.Size' null)) " is 122.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,CreateResultSequence,The length of the statement  "            return (from n in filteredList select (Library.Interface.IListResultFileset)(new ListResultFileset(n.Key' n.Value.Time.ToLocalTime()' -1' -1))).ToArray(); " is 154.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,RunUpdate,The length of the statement  "                throw new UserInformationException(string.Format("Can only update with paths' try setting {0}"' "--repair-only-paths")); " is 120.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                            throw new UserInformationException(string.Format("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count)); " is 137.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                            throw new UserInformationException(string.Format("Found {0} parse-able files with the prefix {1}' did you forget to set the backup prefix?"' tmp.Length' types[0])); " is 164.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                            throw new UserInformationException(string.Format("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup prefix?"' tmp.Length' rawlist.Count' string.Join("' "' types))); " is 219.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                    volumeIds[fl.File.Name] = updating ? restoredb.GetRemoteVolumeID(fl.File.Name) : restoredb.RegisterRemoteVolume(fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded); " is 181.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                volumeIds[n.File.Name] = restoredb.RegisterRemoteVolume(n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan(0)' tr); " is 143.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                m_result.OperationProgressUpdater.UpdateProgress(((float)progress / filelistWork.Count()) * (m_options.RepairOnlyPaths ? 1f : 0.2f)); " is 133.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                                    metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr); " is 121.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                                    metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr); " is 121.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                                    metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr); " is 121.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                            if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)) " is 147.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                                m_result.AddError(string.Format("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null); " is 140.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                        m_result.AddVerboseMessage("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name))); " is 132.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                        m_result.AddVerboseMessage("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name))); " is 130.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                                        m_result.AddVerboseMessage("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name))); " is 139.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "                            throw new UserInformationException(string.Format("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files")); " is 264.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,ProbeForMatchingFilename,The length of the statement  "                            m_result.AddWarning(string.Format("Unable to find volume {0}' but mapping to matching file {1}"' filename' testfilename)' null); " is 128.
Long Statement,Duplicati.Library.Main.Operation,RestoreControlFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreControlFilesHandler.cs,Run,The length of the statement  "            using (var db = new Database.LocalDatabase(System.IO.File.Exists(m_options.Dbpath) ? m_options.Dbpath : (string)tmpdb' "RestoreControlFiles"' true)) " is 148.
Long Statement,Duplicati.Library.Main.Operation,RestoreControlFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreControlFilesHandler.cs,Run,The length of the statement  "                var filter = Library.Utility.JoinedFilterExpression.Join(new Library.Utility.FilterExpression(filterstrings)' compositefilter); " is 127.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,Run,The length of the statement  "                RecreateDatabaseHandler.NumberedFilterFilelistDelegate filelistfilter = FilterNumberedFilelist(m_options.Time' m_options.Version); " is 130.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,Run,The length of the statement  "                        m_options.RawOptions["version"] = string.Join("'"' Enumerable.Range(0' m_options.Version.Length).Select(x => x.ToString())); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "            var blockhasher = fullblockverification ? Library.Utility.HashAlgorithmHelper.Create(options.BlockHashAlgorithm) : null; " is 120.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "                                                result.AddWarning(string.Format("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null); " is 145.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "                                        result.AddWarning(string.Format("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null); " is 141.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "                            result.AddWarning(string.Format("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex); " is 122.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "                            result.AddWarning(string.Format("Failed to record metadata for file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex); " is 122.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ApplyStoredMetadata,The length of the statement  "                        result.AddWarning(string.Format("Failed to apply metadata to file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex); " is 120.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The length of the statement  "                        result.AddError(string.Format("Failed to patch with remote file: \"{0}\"' message: {1}"' blockvolume.Name' ex.Message)' ex); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The length of the statement  "                                    throw new Exception(string.Format("Failed to restore file: \"{0}\". File hash is {1}' expected hash is {2}"' file.Path' key' file.Hash)); " is 137.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The length of the statement  "                    m_result.AddMessage(string.Format("Failed to restore {0} files' additionally the following files failed to download' which may be the cause:{1}{2}"' fileErrors' Environment.NewLine' string.Join(Environment.NewLine' brokenFiles))); " is 230.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The length of the statement  "                                    result.AddWarning(string.Format("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' sourcepath' ex.Message)' ex); " is 154.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The length of the statement  "                        result.AddWarning(string.Format("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The length of the statement  "                                        result.AddWarning(string.Format("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' source.Path' ex.Message)' ex); " is 155.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The length of the statement  "                        result.AddWarning(string.Format("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PrepareBlockAndFileList,The length of the statement  "                    result.AddVerboseMessage("Mapping restore path prefix to \"{0}\" to \"{1}\""' largest_prefix' Library.Utility.Utility.AppendDirSeparator(options.Restorepath)); " is 159.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The length of the statement  "                                    result.AddDryrunMessage(string.Format("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength)); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The length of the statement  "                                    result.AddVerboseMessage("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : ""); " is 134.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The length of the statement  "                        var newname = m_systemIO.PathChangeExtension(targetpath' null) + "." + database.RestoreTime.ToLocalTime().ToString("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture); " is 180.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "            var report = db.GetCompactReport(m_options.VolumeSize' m_options.Threshold' m_options.SmallFileSize' m_options.SmallFileMaxCount' transaction); " is 143.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                    newvol.VolumeID = db.RegisterRemoteVolume(newvol.RemoteFilename' RemoteVolumeType.Blocks' RemoteVolumeState.Temporary' transaction); " is 132.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                        newvolindex.VolumeID = db.RegisterRemoteVolume(newvolindex.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' transaction); " is 141.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                    var remoteList = db.GetRemoteVolumes().Where(n => n.State == RemoteVolumeState.Uploaded || n.State == RemoteVolumeState.Verified).ToArray(); " is 140.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                                                    m_result.AddDryrunMessage(string.Format("Would upload generated blockset of size {0}"' Library.Utility.Utility.FormatSizeString(newvol.Filesize))); " is 147.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                                                newvol.VolumeID = db.RegisterRemoteVolume(newvol.RemoteFilename' RemoteVolumeType.Blocks' RemoteVolumeState.Temporary' transaction); " is 132.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                                                    newvolindex.VolumeID = db.RegisterRemoteVolume(newvolindex.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' transaction); " is 141.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                                    m_result.AddDryrunMessage(string.Format("Would upload generated blockset of size {0}"' Library.Utility.Utility.FormatSizeString(newvol.Filesize))); " is 147.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                            m_result.AddDryrunMessage(string.Format("Would delete {0} files' which would reduce storage by {1}"' m_result.DeletedFileCount' Library.Utility.Utility.FormatSizeString(m_result.DeletedFileSize))); " is 197.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                            m_result.AddDryrunMessage(string.Format("Would download {0} file(s) with a total size of {1}' delete {2} file(s) with a total size of {3}' and compact to {4} file(s) with a size of {5}' which would reduce storage by {6} file(s) and {7}"'  " is 237.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                            m_result.AddMessage(string.Format("Deleted {0} files' which reduced storage by {1}"' m_result.DeletedFileCount' Library.Utility.Utility.FormatSizeString(m_result.DeletedFileSize))); " is 181.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "                            m_result.AddMessage(string.Format("Downloaded {0} file(s) with a total size of {1}' deleted {2} file(s) with a total size of {3}' and compacted to {4} file(s) with a size of {5}' which reduced storage by {6} file(s) and {7}"'  " is 225.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,PerformDelete,The length of the statement  "                    m_result.AddDryrunMessage(string.Format("Would delete remote file: {0}' size: {1}"' f.Name' Library.Utility.Utility.FormatSizeString(f.Size))); " is 143.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The length of the statement  "                var filesetNumbers = db.FilesetTimes.Zip(Enumerable.Range(0' db.FilesetTimes.Count())' (a' b) => new Tuple<long' DateTime>(b' a.Value)).ToList(); " is 145.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The length of the statement  "                    m_result.AddMessage(string.Format("Preventing removal of last fileset' use --{0} to allow removal ..."' "allow-full-removal")); " is 127.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The length of the statement  "                    new CompactHandler(m_backendurl' m_options' (CompactResults)m_result.CompactResults).DoCompact(db' true' ref transaction' sharedManager); " is 137.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,GetFilesetsToDelete,The length of the statement  "                throw new Exception(string.Format("List of backup timestamps contains duplicates: {0}"' string.Join("' "' backups.Select(x => x.ToString())))); " is 143.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,GetFilesetsToDelete,The length of the statement  "                throw new Exception(string.Format("Too many entries {0} vs {1}' lists: {2} vs {3}"' removeCount' backups.Length' string.Join("' "' filtered.Select(x => x.ToString()))' string.Join("' "' backups.Select(x => x.ToString())))); " is 223.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "            Logging.Log.WriteMessage("[Retention Policy]: Start checking if backups can be removed"' Logging.LogMessageType.Information); " is 125.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "                string.Join("' "' retentionPolicyOptionValue.Select(x => x.Key + " / " + x.Value)))' Logging.LogMessageType.Information); " is 121.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "                DateTime timeFrame = (period > TimeSpan.Zero) ? (now - period) : DateTime.MinValue; // period equal or below 0 means "biggest time frame possible" " is 146.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "                Logging.Log.WriteMessage(string.Format("[Retention Policy]: Next time frame and interval pair: {0} / {1}"' timeFrame' interval)' Logging.LogMessageType.Profiling); " is 163.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "                    backupsInTimeFrame.Insert(0' clonedBackupList[0]); // Insert at begining to reverse order' which is nessecary for next step " is 123.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "                        Logging.Log.WriteMessage(string.Format("[Retention Policy]: Keeping backup: {0}"' backup)' Logging.LogMessageType.Profiling); " is 125.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "                        Logging.Log.WriteMessage(string.Format("[Retention Policy]: Marking backup for deletion: {0}"' backup)' Logging.LogMessageType.Profiling); " is 138.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,ApplyRetentionPolicy,The length of the statement  "            Logging.Log.WriteMessage(string.Format("[Retention Policy]: Backups outside of all time frames and thus not checked: {0}"' " is 122.
Long Statement,Duplicati.Library.Main.Operation,CreateBugReportHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CreateBugReportHandler.cs,Run,The length of the statement  "                    using(var cs = cm.CreateFile("log-database.sqlite"' Duplicati.Library.Interface.CompressionHint.Compressible' DateTime.UtcNow)) " is 127.
Long Statement,Duplicati.Library.Main.Operation,CreateBugReportHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CreateBugReportHandler.cs,Run,The length of the statement  "                    using(var fs = System.IO.File.Open(tmp' System.IO.FileMode.Open' System.IO.FileAccess.Read' System.IO.FileShare.ReadWrite)) " is 123.
Long Statement,Duplicati.Library.Main.Operation,CreateBugReportHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CreateBugReportHandler.cs,Run,The length of the statement  "                    using(var cs = new System.IO.StreamWriter(cm.CreateFile("system-info.txt"' Duplicati.Library.Interface.CompressionHint.Compressible' DateTime.UtcNow))) " is 151.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                    throw new UserInformationException("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss."); " is 208.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                    throw new UserInformationException("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss."); " is 235.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                            throw new UserInformationException(string.Format("Found no backup files with prefix {0}' but files with prefix {1}' did you forget to set the backup prefix?"' m_options.Prefix' tp.BackupPrefixes[0])); " is 200.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                            throw new UserInformationException(string.Format("Found no backup files with prefix {0}' but files with prefixes {1}' did you forget to set the backup prefix?"' m_options.Prefix' string.Join("' "' tp.BackupPrefixes))); " is 218.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                        throw new UserInformationException(string.Format("No files were missing' but {0} remote files were' found' did you mean to run recreate-database?"' tp.ExtraVolumes.Count())); " is 174.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                    m_result.AddError(string.Format("Failed to perform verification for file: {0}' please run verify; message: {1}"' n.Name' ex.Message)' ex); " is 138.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                            if (cmphash != rv.Hash || cmpsize != rv.Length || ! new [] { RemoteVolumeState.Uploading' RemoteVolumeState.Uploaded' RemoteVolumeState.Verified }.Contains(cmpstate)) " is 166.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                                throw new Exception(string.Format("Volume {0} hash/size mismatch ({1} - {2}) vs ({3} - {4})"' rv.Filename' cmphash' cmpsize' rv.Hash' rv.Length)); " is 146.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                            m_result.AddError(string.Format("Failed to perform cleanup for extra file: {0}' message: {1}"' n.File.Name' ex.Message)' ex); " is 125.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                    m_result.AddDryrunMessage(string.Format("would re-upload fileset {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(n.Size))); " is 254.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                                throw new Exception(string.Format("Internal consistency check failed' generated index block has wrong hash' {0} vs {1}"' bh' b.Item1)); " is 135.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                    m_result.AddDryrunMessage(string.Format("would re-upload index file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(n.Size))); " is 257.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                        m_result.AddMessage(string.Format("Repair cannot acquire {0} required blocks for volume {1}' which are required by the following filesets: "' missingBlocks' n.Name)); " is 166.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                        var recoverymsg = string.Format("If you want to continue working with the database' you can use the \"{0}\" and \"{1}\" commands to purge the missing data from the database and the remote storage."' "list-broken-files"' "purge-broken-files"); " is 242.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                            throw new UserInformationException(string.Format("Repair not possible' missing {0} blocks.\n" + recoverymsg' missingBlocks)); " is 125.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                                            m_result.AddDryrunMessage(string.Format("would re-upload block file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(n.Size))); " is 257.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "                            m_result.AddError(string.Format("Failed to perform cleanup for missing file: {0}' message: {1}"' n.Name' ex.Message)' ex); " is 122.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyRemoteList,The length of the statement  "                var s = string.Format("Found remote files reported as duplicates' either the backend module is broken or you need to manually remove the extra copies.\nThe following files were found multiple times: {0}"' string.Join("' "' doubles)); " is 233.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyRemoteList,The length of the statement  "                    s = string.Format("Found {0} files that are missing from the remote storage' and no files with the backup prefix {1}' but found the following backup prefixes: {2}"' missingCount' options.Prefix' string.Join("' "' tp.BackupPrefixes)); " is 233.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,CreateVerificationFile,The length of the statement  "            s.Serialize(stream' db.GetRemoteVolumes().Where(x => x.State != RemoteVolumeState.Temporary).Cast<IRemoteVolume>().ToArray()); " is 126.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,UploadVerificationFile,The length of the statement  "                    result.AddDryrunMessage(string.Format("Would upload verification file: {0}' size: {1}"' remotename' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(tempfile).Length))); " is 184.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The length of the statement  "                    throw new Exception(string.Format("The remote volume {0} appears in the database with state {1} and a deleted state' cannot continue"' e.Key' e.Value.ToString())); " is 163.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The length of the statement  "                            log.AddMessage(string.Format("promoting uploaded complete file from {0} to {2}: {1}"' i.State' i.Name' RemoteVolumeState.Uploaded)); " is 132.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The length of the statement  "                log.AddWarning(string.Format("remote file {1} is listed as {0} with size {2} but should be {3}' please verify the sha256 hash \"{4}\""' i.Item2.State' i.Item2.Name' i.Item1' i.Item2.Size' i.Item2.Hash)' null); " is 209.
Long Statement,Duplicati.Library.Main.Operation,ListControlFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListControlFilesHandler.cs,Run,The length of the statement  "            using (var db = new Database.LocalDatabase(System.IO.File.Exists(m_options.Dbpath) ? m_options.Dbpath : (string)tmpdb' "ListControlFiles"' true)) " is 145.
Long Statement,Duplicati.Library.Main.Operation,ListControlFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListControlFilesHandler.cs,Run,The length of the statement  "                var filter = Library.Utility.JoinedFilterExpression.Join(new Library.Utility.FilterExpression(filterstrings)' compositefilter); " is 127.
Long Statement,Duplicati.Library.Main.Operation,ListControlFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListControlFilesHandler.cs,Run,The length of the statement  "                            m_result.SetResult(new Library.Interface.IListResultFileset[] { new ListResultFileset(fileversion.Key' fileversion.Value.Time' -1' -1) }' files); " is 145.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "            var filter = Library.Utility.JoinedFilterExpression.Join(new Library.Utility.FilterExpression(filterstrings)' compositefilter); " is 127.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "                        throw new UserInformationException(string.Format("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count)); " is 145.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "                    var times = dbtimes.Zip(Enumerable.Range(0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long>(b' a.Value' a.Key)).ToList(); " is 131.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "                    var numberedList = parsedlist.Zip(Enumerable.Range(0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume>(b' a.Time' a)).ToList(); " is 157.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "                        throw new UserInformationException(string.Format("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count)); " is 150.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "                    using(var rd = new Volumes.FilesetVolumeReader(RestoreHandler.GetCompressionModule(baseFile.File.Name)' tmpfile' m_options)) " is 124.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "                    using(var rd = new Volumes.FilesetVolumeReader(RestoreHandler.GetCompressionModule(compareFile.File.Name)' tmpfile' m_options)) " is 127.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The length of the statement  "                                            m_results.AddDryrunMessage(string.Format("Sucessfully captured hash and size for {0}' would update database"' vol.Name)); " is 121.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The length of the statement  "                        m_results.AddResult(vol.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] { new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>(Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message) }); " is 240.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The length of the statement  "                        m_results.AddResult(f.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] { new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>(Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message) }); " is 238.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "                    IEnumerable<KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>> combined = new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[0]; " is 163.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "                                changes.Add(new KeyValuePair<Library.Interface.TestEntryStatus' string>(Library.Interface.TestEntryStatus.Modified' s.Key)); " is 124.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "                                    changes.Add(new KeyValuePair<Library.Interface.TestEntryStatus' string>(Library.Interface.TestEntryStatus.Modified' s.Key)); " is 124.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "                        return new KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>>(vol.Name' changes.Union(bl.Compare().ToList())); " is 132.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "                foreach(var path in new BackupHandler.FilterHandler(snapshot' m_options.FileAttributeFilter' sourcefilter' filter' m_options.SymlinkPolicy' m_options.HardlinkPolicy' m_result).EnumerateFilesAndFolders()) " is 203.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "                        if (m_options.SkipFilesLargerThan == long.MaxValue || m_options.SkipFilesLargerThan == 0 || size < m_options.SkipFilesLargerThan) " is 129.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "                            m_result.AddVerboseMessage("Including file: {0} ({1})"' path' size < 0 ? "unknown" : Duplicati.Library.Utility.Utility.FormatSizeString(size)); " is 143.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "                            m_result.AddVerboseMessage("Excluding file due to size: {0} ({1})"' path' size < 0 ? "unknown" : Duplicati.Library.Utility.Utility.FormatSizeString(size));                     " is 155.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "            yield return string.Format("Duplicati: {0} ({1})"' Duplicati.Library.Utility.Utility.getEntryAssembly().FullName' System.Reflection.Assembly.GetExecutingAssembly().FullName); " is 174.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "            yield return string.Format("Autoupdate urls: {0}"' string.Join(";"' Duplicati.Library.AutoUpdater.AutoUpdateSettings.URLs)); " is 124.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "            yield return string.Format("Version name: \"{0}\" ({1})"' Duplicati.Library.AutoUpdater.UpdaterManager.SelfVersion.Displayname' System.Reflection.Assembly.GetExecutingAssembly().GetName().Version' System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)); " is 290.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "            yield return string.Format("Current Version folder {0}"' System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)); " is 150.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "            yield return string.Format("Mono: {0} ({1}) ({2})"' Duplicati.Library.Utility.Utility.IsMono' Duplicati.Library.Utility.Utility.MonoVersion' Duplicati.Library.Utility.Utility.MonoDisplayVersion); " is 195.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "            yield return string.Format("Locale: {0}' {1}' {2}"' System.Threading.Thread.CurrentThread.CurrentCulture' System.Threading.Thread.CurrentThread.CurrentUICulture' System.Globalization.CultureInfo.InstalledUICulture); " is 215.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "            yield return string.Format("Date/time strings: {0} - {1}"' System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongDatePattern' System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongTimePattern); " is 229.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,Run,The length of the statement  "                throw new UserInformationException("Cannot purge with an empty filter' as that would cause all files to be removed.\nTo remove an entire backup set' use the \"delete\" command."); " is 179.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                    throw new UserInformationException(string.Format("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files")); " is 157.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                    throw new UserInformationException(string.Format("Unable to start the purge process as there are {0} orphan file(s)"' orphans)); " is 128.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                            throw new InvalidProgramException(string.Format("Fileset was reported with id {0}' but could not be found?"' versionid)); " is 121.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                            var tfn = Volumes.VolumeBase.GenerateFilename(RemoteVolumeType.Files' m_options' null' filesets[ix].Value.AddSeconds(secs)); " is 124.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                            throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts)); " is 160.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                            throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets[ix - 1].Value)); " is 193.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                                    m_result.AddMessage(string.Format("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString(tempset.RemovedFileSize))); " is 245.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                                        m_result.AddDryrunMessage(string.Format("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString(vol.Filesize)' prevfilename' tempset.RemovedFileCount)); " is 228.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "                                new CompactHandler(backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact(cdb' true' ref tr' backend); " is 129.
Long Statement,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,GetBrokenFilesetsFromRemote,The length of the statement  "                    throw new UserInformationException("Cannot continue because the database is marked as being under repair' but does not have broken files."); " is 140.
Long Statement,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,GetBrokenFilesetsFromRemote,The length of the statement  "                        result.AddMessage("Skipping operation because no files were found to be missing' and no filesets were recorded as broken."); " is 124.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "                        throw new UserInformationException(string.Format("Found no broken filesets' but {0} missing remote files"' sets.Length)); " is 121.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "                m_result.AddMessage(string.Format("Found {0} broken filesets with {1} affected files' purging files"' sets.Length' sets.Sum(x => x.Item3))); " is 140.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "                        m_result.AddMessage(string.Format("Removing entire fileset {1} as all {0} file(s) are broken"' fully_emptied.First().Timestamp' fully_emptied.First().RemoveCount)); " is 164.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "                        m_result.AddMessage(string.Format("Removing {0} filesets where all file(s) are broken: {1}"' fully_emptied.Length' string.Join("' "' fully_emptied.Select(x => x.Timestamp.ToLocalTime().ToString())))); " is 200.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "                                throw new Exception(string.Format("Failed to find match for {0} ({1}) in {2}"' bs.FilesetID' bs.Timestamp.ToLocalTime()' string.Join("' "' filesets.Select(x => x.ToString())))); " is 177.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "                            new PurgeFilesHandler(m_backendurl' opts' (PurgeFilesResults)m_result.PurgeResults).Run(pgdb' pgoffset' pgspan' (cmd' filesetid' tablename) => " is 142.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "                                m_result.AddDryrunMessage(string.Format("Would delete remote file: {0}' size: {1}"' f.Name' Library.Utility.Utility.FormatSizeString(f.Size))); " is 143.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "			var folder = System.IO.Path.Combine(System.Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' "Duplicati"); " is 126.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "				var newlocation = System.IO.Path.Combine(System.Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)' "Duplicati"); " is 136.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                configs = Newtonsoft.Json.JsonConvert.DeserializeObject<List<BackendEntry>>(System.IO.File.ReadAllText(file' System.Text.Encoding.UTF8)); " is 137.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                        if (username == null && o.Aliases != null && o.Aliases.Contains("auth-username"' StringComparer.OrdinalIgnoreCase) && ropts.ContainsKey(o.Name)) " is 144.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                        if (password == null && o.Aliases != null && o.Aliases.Contains("auth-password"' StringComparer.OrdinalIgnoreCase) && ropts.ContainsKey(o.Name)) " is 144.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                        if (username == null && o.Name.Equals("auth-username"' StringComparison.OrdinalIgnoreCase) && ropts.ContainsKey("auth-username")) " is 129.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                        if (password == null && o.Name.Equals("auth-password"' StringComparison.OrdinalIgnoreCase) && ropts.ContainsKey("auth-password")) " is 129.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                password = Library.Utility.Utility.ByteArrayAsHexString(System.Security.Cryptography.SHA256.Create().ComputeHash(System.Text.Encoding.UTF8.GetBytes(password + "!" + uri.Scheme + "!" + uri.HostAndPath))); " is 203.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                throw new Duplicati.Library.Interface.UserInformationException(string.Format("Multiple sources found for: {0}"' backend)); " is 122.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                    throw new Duplicati.Library.Interface.UserInformationException(String.Format("Multiple sources found for \"{0}\"' try supplying --{1}"' backend' "auth-username")); " is 163.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                    throw new Duplicati.Library.Interface.UserInformationException("Unable to find a unique name for the database' please use --dbpath"); " is 133.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "                System.IO.File.WriteAllText(file' Newtonsoft.Json.JsonConvert.SerializeObject(configs' settings)' System.Text.Encoding.UTF8); " is 125.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,IsDatabasePathInUse,The length of the statement  "            var folder = System.IO.Path.Combine(System.Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' "Duplicati"); " is 126.
Long Statement,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,IsDatabasePathInUse,The length of the statement  "            return Newtonsoft.Json.JsonConvert.DeserializeObject<List<BackendEntry>>(System.IO.File.ReadAllText(file' System.Text.Encoding.UTF8)).Any(x => string.Equals(path' x.Databasepath' Library.Utility.Utility.ClientFilenameStringComparision)); " is 237.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "                            m_statwriter.AddRetryAttempt(string.Format("Operation {0} with file {1} attempt {2} of {3} failed with message: {4}"' item.Operation' item.RemoteFilename' retries' m_numberofretries' ex.Message)' ex); " is 200.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "                            m_statwriter.SendEvent(item.BackendActionType' retries < m_numberofretries ? BackendEventType.Retrying : BackendEventType.Failed' item.RemoteFilename' item.Size); " is 162.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "                    if (lastException != null && !(lastException is Duplicati.Library.Interface.FileMissingException) && item.Operation == OperationType.Delete) " is 140.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "                                m_statwriter.AddMessage(LC.L("Recovered from problem with attempting to delete non-existing file {0}"' item.RemoteFilename)); " is 125.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,The length of the statement  "            m_db.LogDbOperation("put"' item.RemoteFilename' JsonConvert.SerializeObject(new { Size = item.Size' Hash = item.Hash })); " is 121.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,The length of the statement  "            Logging.Log.WriteMessage(string.Format("Uploaded {0} in {1}' {2}/s"' Library.Utility.Utility.FormatSizeString(item.Size)' duration' Library.Utility.Utility.FormatSizeString((long)(item.Size / duration.TotalSeconds)))' Duplicati.Library.Logging.LogMessageType.Profiling); " is 270.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,The length of the statement  "                var f = m_backend.List().Where(n => n.Name.Equals(item.RemoteFilename' StringComparison.OrdinalIgnoreCase)).FirstOrDefault(); " is 125.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,The length of the statement  "                    throw new Exception(string.Format("List verify failed for file: {0}' size was {1} but expected to be {2}"' f.Name' f.Size' item.Size)); " is 135.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "                                        m_statwriter.AddVerboseMessage("Filename extension \"{0}\" does not match encryption module \"{1}\"' using matching encryption module"' ext' m_options.EncryptionModule); " is 169.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "                                        m_statwriter.AddVerboseMessage("Filename extension \"{0}\" does not match encryption module \"{1}\"' guessing that it is not encrypted"' ext' m_options.EncryptionModule); " is 170.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "                                        m_statwriter.AddVerboseMessage("Filename extension \"{0}\" does not match encryption module \"{1}\"' attempting to use specified encryption module as no others match"' ext' m_options.EncryptionModule); " is 201.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "                Logging.Log.WriteMessage(string.Format("Downloaded {3}{0} in {1}' {2}/s"' Library.Utility.Utility.FormatSizeString(dataSizeDownloaded)' " is 135.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "                m_db.LogDbOperation("get"' item.RemoteFilename' JsonConvert.SerializeObject(new { Size = dataSizeDownloaded' Hash = fileHash })); " is 129.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoDelete,The length of the statement  "                var wr = ex as System.Net.WebException == null ? null : (ex as System.Net.WebException).Response as System.Net.HttpWebResponse; " is 127.
Long Statement,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoDelete,The length of the statement  "                    m_statwriter.AddWarning(LC.L("Delete operation failed for {0} with FileNotFound' listing contents"' item.RemoteFilename)' ex); " is 126.
Long Statement,Duplicati.Library.Main,FileEntryItem,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DeleteLocalFile,The length of the statement  "                    catch (Exception ex) { stat.AddWarning(string.Format("Failed to dispose temporary file: {0}"' this.LocalTempfile)' ex); } " is 121.
Long Statement,Duplicati.Library.Main,DatabaseCollector,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,FlushDbMessages,The length of the statement  "                        db.UpdateRemoteVolume(((DbUpdate)e).Remotename' RemoteVolumeState.Deleted' ((DbUpdate)e).Size' ((DbUpdate)e).Hash' true' TimeSpan.FromHours(2)' transaction); " is 157.
Long Statement,Duplicati.Library.Main,DatabaseCollector,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,FlushDbMessages,The length of the statement  "                        db.UpdateRemoteVolume(((DbUpdate)e).Remotename' ((DbUpdate)e).State' ((DbUpdate)e).Size' ((DbUpdate)e).Hash' transaction); " is 122.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,UpdateOptionsFromDb,The length of the statement  "            if (opts.ContainsKey("blockhash") && (!options.RawOptions.TryGetValue("block-hash-algorithm"' out n) || string.IsNullOrEmpty(n))) " is 129.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,UpdateOptionsFromDb,The length of the statement  "            if (opts.ContainsKey("filehash") && (!options.RawOptions.TryGetValue("file-hash-algorithm"' out n) || string.IsNullOrEmpty(n))) " is 127.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "                newDict.Add("passphrase"' Library.Utility.Utility.ByteArrayAsHexString(Library.Utility.Utility.RepeatedHashWithSalt(options.Passphrase' salt' 1200))); " is 150.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "                                throw new Duplicati.Library.Interface.UserInformationException("You have attempted to remove the passphrase on an existing backup' which is not supported. Please configure a new clean backup if you want to remove the passphrase."); " is 231.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "                                throw new Duplicati.Library.Interface.UserInformationException("You have attempted to add a passphrase to an existing backup' which is not supported. Please configure a new clean backup if you want to add a passphrase."); " is 221.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "                                throw new Duplicati.Library.Interface.UserInformationException("You have attempted to change a passphrase to an existing backup' which is not supported. Please configure a new clean backup if you want to change the passphrase."); " is 229.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("You have attempted to change the parameter \"{0}\" from \"{1}\" to \"{2}\"' which is not supported. Please configure a new clean backup if you want to change the parameter."' k.Key' opts[k.Key]' k.Value)); " is 283.
Long Statement,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "                throw new Duplicati.Library.Interface.UserInformationException("You have attempted to change the block-size on an existing backup' which is not supported. Please configure a new clean backup if you want to change the block-size."); " is 231.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The length of the statement  "                        Win32.SetThreadExecutionState(Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0)); " is 128.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                if (Library.Utility.Utility.IsClientWindows && (inputsources[i].StartsWith("*:"' StringComparison.Ordinal) || inputsources[i].StartsWith("?:"' StringComparison.Ordinal))) " is 170.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                        log.AddVerboseMessage(@"Adding source path ""{0}"" due to wildcard source path ""{1}"""' expandedSource' inputsources[i]); " is 122.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                else if (Library.Utility.Utility.IsClientWindows && inputsources[i].StartsWith(@"\\?\Volume{"' StringComparison.OrdinalIgnoreCase)) " is 131.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                    if (Guid.TryParse(inputsources[i].Substring(@"\\?\Volume{".Length' @"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX".Length)' out volumeGuid)) " is 132.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                            string expandedSource = driveLetter + inputsources[i].Substring(@"\\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}".Length); " is 124.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                            log.AddVerboseMessage(@"Adding source path ""{0}"" in place of volume guid source path ""{1}"""' expandedSource' inputsources[i]); " is 130.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                            // If we aren't allow to have missing sources' throw an exception indicating we couldn't find a drive where this volume is mounted " is 130.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                                throw new Duplicati.Library.Interface.UserInformationException(Strings.Controller.SourceVolumeNameNotFoundError(inputsources[i]' volumeGuid)); " is 142.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                            throw new Duplicati.Library.Interface.UserInformationException(Strings.Controller.SourceVolumeNameInvalidError(inputsources[i])); " is 129.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException(Strings.Controller.InvalidPathError(expandedSource' ex.Message)' ex); " is 132.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "            sources = Library.Utility.Utility.GetUniqueItems(sources' Library.Utility.Utility.ClientFilenameStringComparer' out pathDuplicates).OrderBy(a => a).ToList(); " is 157.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                    if (i != j && sources[i].StartsWith(sources[j]' Library.Utility.Utility.ClientFilenameStringComparision) && sources[i].EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()' Library.Utility.Utility.ClientFilenameStringComparision)) " is 235.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                                log.AddVerboseMessage("Removing source \"{0}\" because it is a subfolder of \"{1}\"' and using it as an include filter"' sources[i]' sources[j]); " is 145.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                                log.AddVerboseMessage("Removing source \"{0}\" because it is a subfolder or subfile of \"{1}\""' sources[i]' sources[j]); " is 121.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ExpandInputSources,The length of the statement  "                            log.AddVerboseMessage("Removing source \"{0}\" because it is a subfolder or subfile of \"{1}\""' sources[i]' sources[j]); " is 121.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,UpdateDatabaseWithVersions,The length of the statement  "            var filelistfilter = Operation.RestoreHandler.FilterNumberedFilelist(m_options.Time' m_options.Version' singleTimeMatch: true); " is 127.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The length of the statement  "                    result.WriteLogMessageDirect(Strings.Controller.StartingOperationMessage(m_options.MainAction)' Logging.LogMessageType.Information' null); " is 138.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The length of the statement  "                    result.WriteLogMessageDirect(Strings.Controller.CompletedOperationMessage(m_options.MainAction)' Logging.LogMessageType.Information' null); " is 139.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The length of the statement  "                    result.WriteLogMessageDirect(Strings.Controller.FailedOperationMessage(m_options.MainAction' ex.Message)' Logging.LogMessageType.Error' ex); " is 140.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,The length of the statement  "                        catch (Exception ex) { Logging.Log.WriteMessage(string.Format("OnFinish callback {0} failed: {1}"' mx.Key' ex.Message)' Duplicati.Library.Logging.LogMessageType.Warning' ex); } " is 176.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,The length of the statement  "                        catch (Exception ex) { Logging.Log.WriteMessage(string.Format("Dispose for {0} failed: {1}"' mx.Key' ex.Message)' Duplicati.Library.Logging.LogMessageType.Warning' ex); } " is 170.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "                m_options.LoadedModules.Add(new KeyValuePair<bool' Library.Interface.IGenericModule>(Array.IndexOf<string>(m_options.DisableModules' m.Key.ToLower()) < 0 && (m.LoadAsDefault || Array.IndexOf<string>(m_options.EnableModules' m.Key.ToLower()) >= 0)' m)); " is 252.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "            // Store the URL connection options separately' as these should only be visible to modules implementing IConnectionModule " is 121.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "                        ((Library.Interface.IGenericCallbackModule)mx.Value).OnStart(result.MainOperation.ToString()' ref m_backend' ref paths); " is 120.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "                filter = FilterExpression.Deserialize(m_options.RawOptions["filter"].Split(new string[] { System.IO.Path.PathSeparator.ToString() }' StringSplitOptions.RemoveEmptyEntries)); " is 173.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "                    Library.Logging.Log.WriteMessage(Strings.Controller.FailedForceLocaleError(ex.Message)' Logging.LogMessageType.Warning); " is 120.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The length of the statement  "                throw new Interface.UserInformationException(string.Format("Setting both --{0} and --{1} is not permitted"' "keep-versions"' "keep-time")); " is 139.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The length of the statement  "                throw new Interface.UserInformationException(string.Format("An error occoured while processing the value of --{0}"' "retention-policy")' e); " is 140.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The length of the statement  "            Dictionary<string' Library.Interface.ICommandLineArgument> supportedOptions = new Dictionary<string' Library.Interface.ICommandLineArgument>(); " is 143.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The length of the statement  "            List<Library.Interface.ICommandLineArgument> moduleOptions = new List<Duplicati.Library.Interface.ICommandLineArgument>(); " is 122.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptionValue,The length of the statement  "                var flags = (value ?? string.Empty).ToLowerInvariant().Split(new[] {"'"}' StringSplitOptions.None).Select(flag => flag.Trim()).Distinct(); " is 138.
Long Statement,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptionValue,The length of the statement  "                if (!string.IsNullOrEmpty(value) && Library.Utility.Utility.ParseBool(value' true) != Library.Utility.Utility.ParseBool(value' false)) " is 134.
Long Statement,Duplicati.Library.Main,BasicResults,C:\repos\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,AddBackendEvent,The length of the statement  "                        Logging.Log.WriteMessage(string.Format("Backend event: {0} - {1}: {2} ({3})"' action' type' path' size <= 0 ? "" : Library.Utility.Utility.FormatSizeString(size))' Duplicati.Library.Logging.LogMessageType.Information' null); " is 224.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                    @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + " is 239.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                    @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + " is 167.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                    @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + " is 168.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                    @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + " is 169.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                    using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition))) " is 199.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                        using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" "))) " is 125.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                var tc = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString()' RemoteVolumeState.Uploading.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString()); " is 332.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "                    Logging.Log.WriteMessage(string.Format("Failed to create block cache' this could mean you have hash collisions in your table' the hash that failed is {0}. Error message: {1}."' failedhash' ex.Message)' Logging.LogMessageType.Warning);" is 234.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlock,The length of the statement  "                Logging.Log.WriteMessage(string.Format("Found hash collision on {0}' sizes {1} vs {2}. Disabling cache from now on."' key' size' exsize)' Logging.LogMessageType.Warning); " is 170.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The length of the statement  "                        m_result.AddError(string.Format("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null); " is 247.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The length of the statement  "                                m_result.AddError(string.Format("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64(0' -1))' null); " is 131.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetPreviousFilesetID,The length of the statement  "            var lastFilesetId = cmd.ExecuteScalarInt64(@"SELECT ""ID"" FROM ""Fileset"" WHERE ""Timestamp"" < ? AND ""ID"" != ? ORDER BY ""Timestamp"" DESC "' -1' NormalizeDateTimeToEpochSeconds(timestamp)' filesetid);                 " is 206.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                results.AddedFolders = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' m_filesetId' FOLDER_BLOCKSET_ID' lastFilesetId); " is 460.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                results.AddedSymlinks = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' m_filesetId' SYMLINK_BLOCKSET_ID' lastFilesetId); " is 462.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                results.DeletedFolders = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' lastFilesetId' FOLDER_BLOCKSET_ID' m_filesetId); " is 462.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                results.DeletedSymlinks = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' lastFilesetId' SYMLINK_BLOCKSET_ID' m_filesetId); " is 464.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                var subqueryNonFiles = @"SELECT ""File"".""Path""' ""Blockset"".""Fullhash"" FROM ""File""' ""FilesetEntry""' ""Metadataset""' ""Blockset"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""Metadataset"".""ID"" = ""File"".""MetadataID"" AND ""File"".""BlocksetID"" = ? AND ""Metadataset"".""BlocksetID"" = ""Blockset"".""ID"" AND ""FilesetEntry"".""FilesetID"" = ? "; " is 375.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                results.ModifiedFolders = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM (" + subqueryNonFiles + @") A' (" + subqueryNonFiles + @") B WHERE ""A"".""Path"" = ""B"".""Path"" AND ""A"".""Fullhash"" != ""B"".""Fullhash"" "' 0' lastFilesetId' FOLDER_BLOCKSET_ID' m_filesetId' FOLDER_BLOCKSET_ID); " is 290.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                results.ModifiedSymlinks = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM (" + subqueryNonFiles + @") A' (" + subqueryNonFiles + @") B WHERE ""A"".""Path"" = ""B"".""Path"" AND ""A"".""Fullhash"" != ""B"".""Fullhash"" "' 0' lastFilesetId' SYMLINK_BLOCKSET_ID' m_filesetId' SYMLINK_BLOCKSET_ID); " is 293.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                    var subqueryFiles = @"SELECT ""File"".""Path""' ""A"".""Fullhash"" AS ""Filehash""' ""B"".""Fullhash"" AS ""Metahash"" FROM ""File""' ""FilesetEntry""' ""Blockset"" A' ""Blockset"" B' ""Metadataset""  WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""A"".""ID"" = ""File"".""BlocksetID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""MetadataID"" = ""Metadataset"".""ID"" AND ""Metadataset"".""BlocksetID"" = ""B"".""ID"" "; " is 440.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                    results.AddedFiles = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""{0}"")"' tmpName1)' 0' m_filesetId' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID); " is 404.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                    results.DeletedFiles = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""{0}"" WHERE ""{0}"".""Path"" NOT IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' tmpName1)' 0' m_filesetId); " is 300.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "                    results.ModifiedFiles = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""{0}"" A' ""{1}"" B WHERE ""A"".""Path"" = ""B"".""Path"" AND (""A"".""Filehash"" != ""B"".""Filehash"" OR ""A"".""Metahash"" != ""B"".""Metahash"")"' tmpName1' tmpName2)' 0); " is 260.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AppendFilesFromPreviousSet,The length of the statement  "                cmd.ExecuteNonQuery( @"INSERT INTO ""FilesetEntry"" (""FilesetID""' ""FileID""' ""Lastmodified"") SELECT ? AS ""FilesetID""' ""FileID""' ""Lastmodified"" FROM (SELECT DISTINCT ""FilesetID""' ""FileID""' ""Lastmodified"" FROM ""FilesetEntry"" WHERE ""FilesetID"" = ? AND ""FileID"" NOT IN (SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" = ?)) "' filesetid' lastFilesetId' filesetid); " is 395.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AppendFilesFromPreviousSet,The length of the statement  "                    cmdDelete.CommandText = @"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" = ? AND ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ?) "; " is 148.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetIncompleteFilesets,The length of the statement  "                using(var rd = cmd.ExecuteReader(@"SELECT DISTINCT ""Fileset"".""ID""' ""Fileset"".""Timestamp"" FROM ""Fileset""' ""RemoteVolume"" WHERE ""RemoteVolume"".""ID"" = ""Fileset"".""VolumeID"" AND ""Fileset"".""ID"" IN (SELECT ""FilesetID"" FROM ""FilesetEntry"")  AND (""RemoteVolume"".""State"" = ""Uploading"" OR ""RemoteVolume"".""State"" = ""Temporary"")")) " is 358.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromName,The length of the statement  "            using(var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' name)) " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The length of the statement  "            using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id)) " is 159.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetMissingIndexFiles,The length of the statement  "            using(var rd = cmd.ExecuteReader(@"SELECT ""Name"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND NOT ""ID"" IN (SELECT ""BlockVolumeID"" FROM ""IndexBlockLink"") AND ""State"" IN (?'?)"' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString())) " is 300.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The length of the statement  "                    if ((c = cmd.ExecuteNonQuery(@"UPDATE ""RemoteVolume"" SET ""DeleteGraceTime"" = ? WHERE ""Name"" = ? "' (DateTime.UtcNow + deleteGraceTime).Ticks' name)) != 1) " is 160.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UnlinkRemoteVolume,The length of the statement  "                var c = cmd.ExecuteNonQuery(@"DELETE FROM ""RemoteVolume"" WHERE ""Name"" = ? AND ""State"" = ? "' name' state.ToString()); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "                deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery)); " is 155.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "                deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" IN (SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery)); " is 174.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "                deletecmd.ExecuteNonQuery(string.Format(@"INSERT OR IGNORE INTO ""{0}"" (""ID"") {1}"' blocksetidstable' bsIdsSubQuery)); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "                deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""BlocksetID"" IN ({0}) OR ""MetadataID"" IN ({0})"' bsIdsSubQuery)); " is 138.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "                deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery)); " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "                deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""BlocklistHash"" WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery)); " is 170.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetFilesetIDs,The length of the statement  "                        m_result.AddWarning(string.Format("Restore time or version did not match any existing backups' selecting newest backup")' null); " is 128.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetFiles,The length of the statement  "            using(var rd = cmd.ExecuteReader(@"SELECT ""A"".""Path""' ""B"".""Length""' ""B"".""FullHash""' ""D"".""FullHash"" FROM ""File"" A' ""Blockset"" B' ""Metadataset"" C' ""Blockset"" D' ""FilesetEntry"" E WHERE ""A"".""BlocksetID"" = ""B"".""ID"" AND ""A"".""MetadataID"" = ""C"".""ID"" AND ""C"".""BlocksetID"" = ""D"".""ID"" AND ""A"".""ID"" = ""E"".""FileID"" AND ""E"".""FilesetID"" = ? "' filesetId)) " is 402.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" "; " is 235.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                                sb.AppendFormat("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(0)' rd.GetValue(2)' Environment.NewLine); " is 157.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                var unique_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0); " is 137.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                    throw new InvalidDataException(string.Format("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count)); " is 150.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0); " is 752.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                    throw new InvalidDataException(string.Format("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash)); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                if (cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0) " is 233.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                    foreach(var filesetid in cmd.ExecuteReaderEnumerable(@"SELECT ""ID"" FROM ""Fileset"" ").Select(x => x.ConvertValueToInt64(0' -1))) " is 131.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                        var expandedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid); " is 299.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                        //var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID); " is 326.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                        var storedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid); " is 153.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "                            throw new Exception(string.Format("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist)); " is 149.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetBlocks,The length of the statement  "            using(var rd = cmd.ExecuteReader(@"SELECT DISTINCT ""Hash""' ""Size"" FROM ""Block"" WHERE ""VolumeID"" = ?"' volumeid)) " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The length of the statement  "                        filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash }); " is 160.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The length of the statement  "                        filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash }); " is 158.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The length of the statement  "                        filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash }); " is 211.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RenameRemoteFile,The length of the statement  "                    throw new Exception(string.Format("Unexpected result from renaming \"{0}\" to \"{1}\"' expected {2} got {3}"' oldname' newname' 1' c)); " is 135.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RenameRemoteFile,The length of the statement  "                var type = (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' cmd.ExecuteScalar(@"SELECT ""Type"" FROM ""Remotevolume"" WHERE ""Name"" = ?"' newname).ToString()' true); " is 172.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,CreateFileset,The length of the statement  "                var id = cmd.ExecuteScalarInt64(@"INSERT INTO ""Fileset"" (""OperationID""' ""Timestamp""' ""VolumeID"") VALUES (?' ?' ?); SELECT last_insert_rowid();"' -1' m_operationid' NormalizeDateTimeToEpochSeconds(timestamp)' volumeid); " is 226.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetBlocklists,The length of the statement  "                    @"(SELECT ""BlocklistHash"".""BlocksetID""' ""Block"".""Hash""' * FROM  ""BlocklistHash""'""Block"" WHERE  ""BlocklistHash"".""Hash"" = ""Block"".""Hash"" AND ""Block"".""VolumeID"" = ?) A' " +  " is 193.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetBlocklists,The length of the statement  "                    @" ""B"".""Index"" >= (""A"".""Index"" * {0}) AND ""B"".""Index"" < ((""A"".""Index"" + 1) * {0}) AND ""C"".""ID"" = ""B"".""BlockID"" " +  " is 138.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,DisposeAllFields,The length of the statement  "                    x.GetFields(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.FlattenHierarchy) " is 185.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "                        + @" SELECT   IFNULL(COUNT(""P"".""FileId"")' 0)' IFNULL(SUM(""P"".""TotalBlocks"")' 0)' IFNULL(SUM(""P"".""TotalSize"")' 0) " " is 126.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "                        + @"        ' IFNULL(COUNT(CASE WHEN ""P"".""BlocksRestored"" BETWEEN 1 AND ""P"".""TotalBlocks"" - 1 THEN 1 ELSE NULL END)' 0) " " is 129.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "                        + @"       ' ""BlocksRestored"" = ""{0}"".""BlocksRestored"" + NEW.""BlocksRestored"" - OLD.""BlocksRestored"" " // simple delta " is 128.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "                        + @"       ' ""SizeRestored"" = ""{0}"".""SizeRestored"" + NEW.""SizeRestored"" - OLD.""SizeRestored"" " // simple delta " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "                              @"CREATE TEMPORARY TRIGGER ""UpdateFilesNewlyDone_{1}"" AFTER UPDATE OF ""BlocksRestored""' ""TotalBlocks"" ON ""{1}"" " " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                    m_restoreTime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId)); " is 135.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable)); " is 268.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable)); " is 287.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable)); " is 124.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable)); " is 130.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                        cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable); " is 336.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                    else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) " is 197.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                            cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable); " is 410.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                                using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable))) " is 169.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                                var actualrestoretime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId)); " is 143.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                                log.AddWarning(string.Format("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime()' sb)' null); " is 179.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                        cmd.CommandText = string.Format(@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?"); " is 217.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                            cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable); " is 152.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                                    if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString())) " is 125.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) " is 218.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "                            log.AddVerboseMessage("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString(filesize)); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFirstPath,The length of the statement  "                cmd.CommandText = string.Format(@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' m_tempfiletable); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetLargestPrefix,The length of the statement  "                cmd.CommandText = string.Format(@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' m_tempfiletable); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "            var dirsep = Duplicati.Library.Utility.Utility.GuessDirSeparator(string.IsNullOrWhiteSpace(largest_prefix) ? GetFirstPath() : largest_prefix); " is 142.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""Targetpath"" = CASE WHEN SUBSTR(""Path""' 2' 1) == "":"" THEN ""\\"" || SUBSTR(""Path""' 1' 1) || SUBSTR(""Path""' 3) ELSE ""Path"" END"' m_tempfiletable)); " is 213.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""Targetpath"" = CASE WHEN SUBSTR(""Path""' 1' 2) == ""\\"" THEN ""\\"" || SUBSTR(""Path""' 2) ELSE ""Path"" END"' m_tempfiletable)); " is 188.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""Targetpath"" = CASE WHEN SUBSTR(""Path""' 1' 1) == ""/"" THEN ? || SUBSTR(""Path""' 2) ELSE ""Path"" END"' m_tempfiletable)' Library.Utility.Utility.AppendDirSeparator(System.IO.Path.GetPathRoot(Library.Utility.TempFolder.SystemTempPath)).Replace("\\"' "/")); " is 316.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""TargetPath"" = CASE WHEN SUBSTR(""Path""' 2' 1) == "":"" THEN SUBSTR(""Path""' 1' 1) || SUBSTR(""Path""' 3) ELSE ""Path"" END"' m_tempfiletable)); " is 203.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""TargetPath"" = CASE WHEN SUBSTR(""Path""' 1' 2) == ""\\"" THEN SUBSTR(""Path""' 2) ELSE ""TargetPath"" END"' m_tempfiletable)); " is 184.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""TargetPath"" = SUBSTR(""Path""' ?)"' m_tempfiletable)' largest_prefix.Length + 1); " is 139.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""TargetPath"" = REPLACE(""TargetPath""' ""\""' ""/"")"' m_tempfiletable)); " is 130.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""TargetPath"" = REPLACE(REPLACE(""TargetPath""' ""\""' ""_"")' ""/""' ""\"")"' m_tempfiletable)); " is 153.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""TargetPath"" = ? || ""TargetPath"" "' m_tempfiletable)' Library.Utility.Utility.AppendDirSeparator(destination)); " is 170.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FindMissingBlocks,The length of the statement  "                cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""FileID""' ""Index""' ""Hash""' ""Size""' ""Restored""' ""Metadata"") SELECT DISTINCT ""{1}"".""ID""' ""BlocksetEntry"".""Index""' ""Block"".""Hash""' ""Block"".""Size""' 0' 0 FROM ""{1}""' ""BlocksetEntry""' ""Block"" WHERE ""{1}"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" "' m_tempblocktable' m_tempfiletable); " is 430.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FindMissingBlocks,The length of the statement  "                    cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""FileID""' ""Index""' ""Hash""' ""Size""' ""Restored""' ""Metadata"") SELECT DISTINCT ""{1}"".""ID""' ""BlocksetEntry"".""Index""' ""Block"".""Hash""' ""Block"".""Size""' 0' 1 FROM ""{1}""' ""BlocksetEntry""' ""Block""' ""Metadataset"" WHERE ""{1}"".""MetadataID"" = ""Metadataset"".""ID"" AND ""Metadataset"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" "' m_tempblocktable' m_tempfiletable); " is 507.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FindMissingBlocks,The length of the statement  "                    log.AddVerboseMessage("Restore list contains {0} blocks with a total size of {1}"' p1 + p2' Library.Utility.Utility.FormatSizeString(size)); " is 140.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,UpdateTargetPath,The length of the statement  "                cmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""TargetPath"" = ? WHERE ""ID"" = ?"' m_tempfiletable)' newname' ID); " is 124.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocks,The length of the statement  "            return LocalBlockSource.GetFilesAndSourceBlocks(m_connection' m_tempfiletable' m_tempblocktable' blocksize' skipMetadata); " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The length of the statement  "                // If the end of very large files (e.g. iso's) is restored before the beginning' most OS write out zeros to fill the file. " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The length of the statement  "                // We just order all volumes by the maximum block index they contain. This query is slow' but should be worth the effort. " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The length of the statement  "                using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable))) " is 279.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The length of the statement  "                        yield return new FileToRestore(rd.ConvertValueToInt64(0)' rd.ConvertValueToString(1)' rd.ConvertValueToString(2)' rd.ConvertValueToInt64(3)); " is 141.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DropRestoreTable,The length of the statement  "                    catch(Exception ex) { if (m_result != null) m_result.AddWarning(string.Format("Cleanup error: {0}"' ex.Message)'  ex); } " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DropRestoreTable,The length of the statement  "                    catch(Exception ex) { if (m_result != null) m_result.AddWarning(string.Format("Cleanup error: {0}"' ex.Message)'  ex); } " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DropRestoreTable,The length of the statement  "                    catch (Exception ex) { if (m_result != null) m_result.AddWarning(string.Format("Cleanup error: {0}"' ex.Message)' ex); } " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DropRestoreTable,The length of the statement  "                    catch (Exception ex) { if (m_result != null) m_result.AddWarning(string.Format("Cleanup error: {0}"' ex.Message)' ex); } " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DropRestoreTable,The length of the statement  "                    catch (Exception ex) { if (m_result != null) m_result.AddWarning(string.Format("Cleanup error: {0}"' ex.Message)' ex); } " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetTargetFolders,The length of the statement  "            using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""TargetPath"" FROM ""{0}"" WHERE ""BlocksetID"" == ?"' m_tempfiletable)' FOLDER_BLOCKSET_ID)) " is 151.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "            var whereclause = string.Format(@" ""{0}"".""ID"" = ""{1}"".""FileID"" AND ""{1}"".""Restored"" = 0 AND ""{1}"".""Metadata"" = 0 AND ""{0}"".""TargetPath"" != ""{0}"".""Path"" "' m_tempfiletable' m_tempblocktable);         " is 214.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "            var sourepaths = string.Format(@"SELECT DISTINCT ""{0}"".""Path"" FROM ""{0}""' ""{1}"" WHERE " + whereclause' m_tempfiletable' m_tempblocktable); " is 146.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "            var latestBlocksetIds = @"SELECT ""File"".""Path""' ""File"".""BlocksetID""' MAX(""Fileset"".""Timestamp"") FROM ""Fileset""' ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""FilesetEntry"".""FilesetID"" = ""Fileset"".""ID"" AND ""File"".""Path"" IN (" + sourepaths + @") GROUP BY ""File"".""Path"" "; " is 337.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "            var sources = string.Format(@"SELECT DISTINCT ""{0}"".""TargetPath""' ""{0}"".""Path""' ""{0}"".""ID""' ""{1}"".""Index""' ""{1}"".""Hash""' ""{1}"".""Size"" FROM ""{0}""' ""{1}""' ""File""' (" + latestBlocksetIds + @") S' ""Block""' ""BlocksetEntry"" WHERE ""BlocksetEntry"".""BlocksetID"" = ""S"".""BlocksetID"" AND ""BlocksetEntry"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""{1}"".""Index"" = ""BlocksetEntry"".""Index"" AND ""{1}"".""Hash"" = ""Block"".""Hash"" AND ""{1}"".""Size"" = ""Block"".""Size"" AND ""S"".""Path"" = ""{0}"".""Path"" AND " + whereclause + @" ORDER BY ""{0}"".""ID""' ""{1}"".""Index"" "' m_tempfiletable' m_tempblocktable); " is 710.
Long Statement,Duplicati.Library.Main.Database,ExistingFile,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetExistingFilesWithBlocks,The length of the statement  "                    cmd.CommandText = string.Format(@"SELECT ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""{0}"".""ID""' ""Blockset"".""Length""' ""Block"".""Hash""' ""BlocksetEntry"".""Index""' ""Block"".""Size"" FROM ""{0}""' ""Blockset""' ""BlocksetEntry""' ""Block"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""BlocksetEntry"".""BlocksetID"" = ""{0}"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" ORDER BY ""{0}"".""TargetPath""' ""BlocksetEntry"".""Index"""' tablename); " is 498.
Long Statement,Duplicati.Library.Main.Database,LocalBlockSource,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocks,The length of the statement  "                    cmd.CommandText = string.Format(@"SELECT DISTINCT ""A"".""TargetPath""' ""A"".""ID""' ""B"".""Hash""' (""B"".""Index"" * {2})' ""B"".""Index""' ""B"".""Size""' ""C"".""Path""' (""D"".""Index"" * {2})' ""E"".""Size""' ""B"".""Metadata"" FROM ""{0}"" ""A""' ""{1}"" ""B""' ""File"" ""C""' ""BlocksetEntry"" ""D""' ""Block"" E WHERE ""A"".""ID"" = ""B"".""FileID"" AND ""C"".""BlocksetID"" = ""D"".""BlocksetID"" AND ""D"".""BlockID"" = ""E"".""ID"" AND ""B"".""Hash"" = ""E"".""Hash"" AND ""B"".""Size"" = ""E"".""Size"" AND ""B"".""Restored"" = 0"' filetablename' blocktablename' blocksize); " is 590.
Long Statement,Duplicati.Library.Main.Database,ExtensionMethods,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\ExtensionMethods.cs,GetSQLiteExecutionPlan,The length of the statement  "                    + string.Join("\n"' dt.Rows.Cast<System.Data.DataRow>().Select(r => String.Join("\t"' r.ItemArray.Select(o => o == null ? "" : o.ToString()).ToArray())).ToArray()); " is 164.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,InitializeCommands,The length of the statement  "            m_moveBlockToNewVolumeCommand.CommandText = @"UPDATE ""Block"" SET ""VolumeID"" = ? WHERE ""Hash"" = ? AND ""Size"" = ?"; " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                var deleted = cmd.ExecuteNonQuery(@"DELETE FROM ""Fileset"" WHERE ""Timestamp"" IN (" + q + @") "' toDelete.Select(x => NormalizeDateTimeToEpochSeconds(x)).Cast<object>().ToArray()); " is 182.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                cmd.ExecuteNonQuery(@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" NOT IN (SELECT DISTINCT ""ID"" FROM ""Fileset"")"); " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                cmd.ExecuteNonQuery(@"DELETE FROM ""Metadataset"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""MetadataID"" FROM ""File"") "); " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                cmd.ExecuteNonQuery(@"DELETE FROM ""Blockset"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""BlocksetID"" FROM ""File"" UNION SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") "); " is 175.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                cmd.ExecuteNonQuery(@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" NOT IN (SELECT DISTINCT ""ID"" FROM ""Blockset"") "); " is 126.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                cmd.ExecuteNonQuery(@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" NOT IN (SELECT DISTINCT ""ID"" FROM ""Blockset"") "); " is 126.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                cmd.ExecuteNonQuery(@"INSERT INTO ""DeletedBlock"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""Block"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""BlockID"" AS ""BlockID"" FROM ""BlocksetEntry"" UNION SELECT DISTINCT ""ID"" FROM ""Block""' ""BlocklistHash"" WHERE ""Block"".""Hash"" = ""BlocklistHash"".""Hash"") "); " is 349.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                cmd.ExecuteNonQuery(@"DELETE FROM ""Block"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""BlockID"" FROM ""BlocksetEntry"" UNION SELECT DISTINCT ""ID"" FROM ""Block""' ""BlocklistHash"" WHERE ""Block"".""Hash"" = ""BlocklistHash"".""Hash"") ");         " is 237.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                var updated = cmd.ExecuteNonQuery(@"UPDATE ""RemoteVolume"" SET ""State"" = ? WHERE ""Type"" = ? AND ""State"" IN (?' ?) AND ""ID"" NOT IN (SELECT ""VolumeID"" FROM ""Fileset"") "' RemoteVolumeState.Deleting.ToString()' RemoteVolumeType.Files.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString()); " is 333.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                    throw new Exception(string.Format("Unexpected number of remote volumes marked as deleted. Found {0} filesets' but {1} volumes"' deleted' updated)); " is 147.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "                using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Size"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND ""State"" = ? "' RemoteVolumeType.Files.ToString()' RemoteVolumeState.Deleting.ToString())) " is 198.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var usedBlocks = @"SELECT SUM(""Block"".""Size"") AS ""ActiveSize""' ""Block"".""VolumeID"" AS ""VolumeID"" FROM ""Block""' ""Remotevolume"" WHERE ""Block"".""VolumeID"" = ""Remotevolume"".""ID"" AND ""Block"".""ID"" NOT IN (SELECT ""Block"".""ID"" FROM ""Block""'""DeletedBlock"" WHERE ""Block"".""Hash"" = ""DeletedBlock"".""Hash"" AND ""Block"".""Size"" = ""DeletedBlock"".""Size"") GROUP BY ""Block"".""VolumeID"" "; " is 420.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var lastmodifiedFile = @"SELECT ""Block"".""VolumeID"" AS ""VolumeID""' ""Fileset"".""Timestamp"" AS ""Sorttime"" FROM ""Fileset""' ""FilesetEntry""' ""File""' ""BlocksetEntry""' ""Block"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""File"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" "; " is 415.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var lastmodifiedMetadata = @"SELECT ""Block"".""VolumeID"" AS ""VolumeID""' ""Fileset"".""Timestamp"" AS ""Sorttime"" FROM ""Fileset""' ""FilesetEntry""' ""File""' ""BlocksetEntry""' ""Block""' ""Metadataset"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""File"".""MetadataID"" = ""Metadataset"".""ID"" AND ""Metadataset"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" "; " is 496.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var scantime = @"SELECT ""VolumeID"" AS ""VolumeID""' MIN(""Sorttime"") AS ""Sorttime"" FROM (" + lastmodifiedFile + @" UNION " + lastmodifiedMetadata + @") GROUP BY ""VolumeID"" "; " is 181.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var active = @"SELECT ""A"".""ActiveSize"" AS ""ActiveSize""'  0 AS ""InactiveSize""' ""A"".""VolumeID"" AS ""VolumeID""' CASE WHEN ""B"".""Sorttime"" IS NULL THEN 0 ELSE ""B"".""Sorttime"" END AS ""Sorttime"" FROM (" + usedBlocks + @") A LEFT OUTER JOIN (" + scantime + @") B ON ""B"".""VolumeID"" = ""A"".""VolumeID"" "; " is 322.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var inactive = @"SELECT 0 AS ""ActiveSize""' SUM(""Size"") AS ""InactiveSize""' ""VolumeID"" AS ""VolumeID""' 0 AS ""SortScantime"" FROM ""DeletedBlock"" GROUP BY ""VolumeID"" "; " is 178.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var empty = @"SELECT 0 AS ""ActiveSize""' 0 AS ""InactiveSize""' ""Remotevolume"".""ID"" AS ""VolumeID""' 0 AS ""SortScantime"" FROM ""Remotevolume"" WHERE ""Remotevolume"".""Type"" = ? AND ""Remotevolume"".""State"" IN (?' ?) AND ""Remotevolume"".""ID"" NOT IN (SELECT ""VolumeID"" FROM ""Block"") "; " is 301.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "            var collected = @"SELECT ""VolumeID"" AS ""VolumeID""' SUM(""ActiveSize"") AS ""ActiveSize""' SUM(""InactiveSize"") AS ""InactiveSize""' MAX(""Sortime"") AS ""Sorttime"" FROM (" + combined + @") GROUP BY ""VolumeID"" "; " is 219.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "                    cmd.ExecuteNonQuery(createtable' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString()); " is 147.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "                    using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename))) " is 259.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "                            yield return new VolumeUsage(rd.GetValue(0).ToString()' rd.ConvertValueToInt64(1' 0) + rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(3' 0)); " is 177.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetCompactReport,The length of the statement  "            return new CompactReport(volsize' wastethreshold' smallfilesize' maxsmallfilecount' GetWastedSpaceReport(transaction).ToList()); " is 128.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The length of the statement  "                using(var rd = cmd.ExecuteReader(@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL ")) " is 324.
Long Statement,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,ReportCompactData,The length of the statement  "                    log.AddVerboseMessage(string.Format("Found {0} small volumes(s) with a total size of {1}"' m_smallvolumes.Count()' Library.Utility.Utility.FormatSizeString(m_smallspace))); " is 172.
Long Statement,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,ReportCompactData,The length of the statement  "                    log.AddVerboseMessage(string.Format("Found {0} volume(s) with a total of {1:F2}% wasted space ({2} of {3})"' m_wastevolumes.Count()' wastepercentage' Library.Utility.Utility.FormatSizeString(m_wastedspace)' Library.Utility.Utility.FormatSizeString(m_fullsize))); " is 262.
Long Statement,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,ReportCompactData,The length of the statement  "                    log.AddMessage(string.Format("Compacting because there is {0:F2}% wasted space and the limit is {1}%"' wastepercentage' m_wastethreshold)); " is 139.
Long Statement,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,ReportCompactData,The length of the statement  "                    log.AddMessage(string.Format("Compacting because there are {0} in small volumes and the volume size is {1}"' Library.Utility.Utility.FormatSizeString(m_smallspace)' Library.Utility.Utility.FormatSizeString(m_volsize))); " is 219.
Long Statement,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,ReportCompactData,The length of the statement  "                    log.AddMessage(string.Format("Compacting because there are {0} small volumes and the maximum is {1}"' m_smallvolumecount' m_maxsmallfilecount)); " is 144.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                    upcmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""RealPath"" TEXT NOT NULL' ""Obfuscated"" TEXT NULL)"' tablename)); " is 166.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                    upcmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""RealPath"") SELECT DISTINCT ""Path"" FROM ""File"" ORDER BY ""Path"" "' tablename)); " is 145.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                    upcmd.ExecuteNonQuery(string.Format(@"UPDATE ""{0}"" SET ""Obfuscated"" = ? || length(""RealPath"") || ? || ""ID"" || (CASE WHEN substr(""RealPath""' length(""RealPath"")) = ? THEN ? ELSE ? END) "' tablename)' Library.Utility.Utility.IsClientLinux ? "/" : "X:\\"' Library.Utility.Utility.DirectorySeparatorString' Library.Utility.Utility.DirectorySeparatorString' Library.Utility.Utility.DirectorySeparatorString' ".bin"); " is 422.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                            upcmd.ExecuteNonQuery(@"UPDATE ""LogData"" SET ""Message"" = replace(""Message""' ?' ?)' ""Exception"" = replace(""Exception""' ?' ?)"' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(0)' rd.GetValue(1) ); " is 201.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                cmd.ExecuteNonQuery(@"UPDATE ""LogData"" SET ""Message"" = ""ERASED!"" WHERE ""Message"" LIKE ""%/%"" OR ""Message"" LIKE ""%:\%"" ");                 " is 134.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                cmd.ExecuteNonQuery(@"UPDATE ""LogData"" SET ""Exception"" = ""ERASED!"" WHERE ""Exception"" LIKE ""%/%"" OR ""Exception"" LIKE ""%:\%"" ");                 " is 140.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                cmd.ExecuteNonQuery(string.Format(@"UPDATE ""File"" SET ""Path"" = (SELECT ""Obfuscated"" FROM ""{0}"" WHERE ""Path"" = ""RealPath"") "' tablename)); " is 149.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetFilesetIdFromRemotename,The length of the statement  "                var filesetid = cmd.ExecuteScalarInt64(@"SELECT ""Fileset"".""ID"" FROM ""Fileset""'""RemoteVolume"" WHERE ""Fileset"".""VolumeID"" = ""RemoteVolume"".""ID"" AND ""RemoteVolume"".""Name"" = ?"' -1' filelist); " is 208.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetBlockVolumesFromIndexName,The length of the statement  "                foreach(var rd in cmd.ExecuteReaderEnumerable(@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""ID"" IN (SELECT ""BlockVolumeID"" FROM ""IndexBlockLink"" WHERE ""IndexVolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?))"' name)) " is 265.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                    @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + " is 143.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                    var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID"""; " is 261.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                        c2.CommandText = string.Format(@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename); " is 170.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                            SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")  " is 159.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                        c2.CommandText = string.Format(@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename); " is 203.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                        c2.CommandText += string.Format(@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename); " is 150.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                            c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0)); " is 153.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename)); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename)); " is 164.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate metadatahashes!"); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "                var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1"; " is 207.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "                            SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")  " is 160.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "                        c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"; " is 178.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "                        c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"; " is 125.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "                            c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0)); " is 153.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate file entries!"); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "            var sql = string.Format(@"SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"""' blocksize / hashsize); " is 681.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "                        c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))"; " is 206.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "                        c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;"; " is 212.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "                            foreach(var h in c2.ExecuteReaderEnumerable(@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) " is 221.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "                                        var c = c5.ExecuteScalarInt64(null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString()); " is 178.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "                                    var c = c5.ExecuteScalarInt64(null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString()); " is 183.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash)); " is 171.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "                var dup_sql = @"SELECT * FROM (SELECT ""BlocksetID""' ""Index""' COUNT(*) AS ""EC"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID""' ""Index"") WHERE ""EC"" > 1"; " is 161.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "                    var unique_count = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0); " is 137.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "                        c2.CommandText = @"DELETE FROM ""BlocklistHash"" WHERE rowid IN (SELECT rowid FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ? AND ""Index"" = ? LIMIT ?)"; " is 154.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "                                throw new Exception(string.Format("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected)); " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Failed to repair' result should have been {0} blocklist hashes' but result was {1} blocklist hashes"' unique_count' real_count)); " is 207.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException("Repaired blocklisthashes' but the database was broken afterwards' rolled back changes"' ex); " is 156.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The length of the statement  "                cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL)"' tablename)); " is 133.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The length of the statement  "                var aliens = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT ""A"".""VolumeID"" FROM ""{0}"" B LEFT OUTER JOIN ""Block"" A ON ""A"".""Hash"" = ""B"".""Hash"" AND ""A"".""Size"" = ""B"".""Size"") WHERE ""VolumeID"" != ? "' tablename)' 0' id); " is 261.
Long Statement,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetSourceFilesWithBlocks,The length of the statement  "                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT DISTINCT ""{0}"".""Hash""' ""{0}"".""Size""' ""File"".""Path""' ""BlocksetEntry"".""Index"" * {1} FROM  ""{0}""' ""Block""' ""BlocksetEntry""' ""File"" WHERE ""File"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""Block"".""ID"" = ""BlocksetEntry"".""BlockID"" AND ""{0}"".""Hash"" = ""Block"".""Hash"" AND ""{0}"".""Size"" = ""Block"".""Size"" AND ""{0}"".""Restored"" = ? "' m_tablename' blocksize)' 0)) " is 470.
Long Statement,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetMissingBlocks,The length of the statement  "                    foreach(var rd in cmd.ExecuteReaderEnumerable(string.Format(@"SELECT ""{0}"".""Hash""' ""{0}"".""Size"" FROM ""{0}"" WHERE ""{0}"".""Restored"" = ? "' m_tablename)' 0)) " is 168.
Long Statement,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetFilesetsUsingMissingBlocks,The length of the statement  "                var blocks = @"SELECT DISTINCT ""File"".""ID"" AS ID FROM ""{0}""' ""Block""' ""Blockset""' ""BlocksetEntry""' ""File"" WHERE ""Block"".""Hash"" = ""{0}"".""Hash"" AND ""Block"".""Size"" = ""{0}"".""Size"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""BlocksetEntry"".""BlocksetID"" = ""Blockset"".""ID"" AND ""File"".""BlocksetID"" = ""Blockset"".""ID"" "; " is 370.
Long Statement,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetFilesetsUsingMissingBlocks,The length of the statement  "                var blocklists = @"SELECT DISTINCT ""File"".""ID"" AS ID FROM ""{0}""' ""Block""' ""Blockset""' ""BlocklistHash""' ""File"" WHERE ""Block"".""Hash"" = ""{0}"".""Hash"" AND ""Block"".""Size"" = ""{0}"".""Size"" AND ""BlocklistHash"".""Hash"" = ""Block"".""Hash"" AND ""BlocklistHash"".""BlocksetID"" = ""Blockset"".""ID"" AND ""File"".""BlocksetID"" = ""Blockset"".""ID"" "; " is 373.
Long Statement,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetFilesetsUsingMissingBlocks,The length of the statement  "                var cmdtxt = @"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size"" FROM ""RemoteVolume""' ""FilesetEntry""' ""Fileset"" WHERE ""RemoteVolume"".""ID"" = ""Fileset"".""VolumeID"" AND ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""RemoteVolume"".""Type"" = ? AND ""FilesetEntry"".""FileID"" IN  (SELECT DISTINCT ""ID"" FROM ( " + blocks + " UNION " + blocklists + " ))"; " is 422.
Long Statement,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetMissingBlockSources,The length of the statement  "                    foreach(var rd in cmd.ExecuteReaderEnumerable(string.Format(@"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size"" FROM ""RemoteVolume""' ""Block""' ""{0}"" WHERE ""Block"".""Hash"" = ""{0}"".""Hash"" AND ""Block"".""Size"" = ""{0}"".""Size"" AND ""Block"".""VolumeID"" = ""RemoteVolume"".""ID"" AND ""Remotevolume"".""Name"" != ? "' m_tablename)' m_volumename)) " is 405.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,GetLargestPrefix,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT DISTINCT ""Path"" FROM ""File""' ""FilesetEntry"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""FilesetEntry"".""FilesetID"" IN (SELECT ""FilesetID"" FROM ""{1}"") ) "' tmpnames.Tablename' m_tablename)); " is 301.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,GetLargestPrefix,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" WHERE SUBSTR(""Path""' 1' 1) != ?"' tmpnames.Tablename)' prefixrule); " is 125.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,GetLargestPrefix,The length of the statement  "                    cmd.CommandText = string.Format(@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' tmpnames.Tablename); " is 124.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,GetLargestPrefix,The length of the statement  "                        var roots = cmd.ExecuteReaderEnumerable(string.Format(@"SELECT DISTINCT SUBSTR(""Path""' 1' 1) FROM ""{0}"""' tmpnames.Tablename)).Select(x => x.ConvertValueToString(0)).ToArray(); " is 180.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,GetLargestPrefix,The length of the statement  "                            new FileversionFixed() { Path = maxpath == "" ? "" : Duplicati.Library.Utility.Utility.AppendDirSeparator(maxpath' dirsep) } " is 124.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderEntries,The length of the statement  "                    prefix = Duplicati.Library.Utility.Utility.AppendDirSeparator(prefix' Duplicati.Library.Utility.Utility.GuessDirSeparator(prefix)); " is 131.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The length of the statement  "                    else if (filter as Library.Utility.FilterExpression == null || ((Library.Utility.FilterExpression)filter).Type != Duplicati.Library.Utility.FilterType.Simple || ((Library.Utility.FilterExpression)filter).GetSimpleList().Length != 1) " is 232.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The length of the statement  "                    using(var tmpnames = new FilteredFilenameTable(m_connection' new Library.Utility.FilterExpression(new string[] { pathprefix + "*" }' true)' null)) " is 146.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT DISTINCT ""Path"" FROM ""File""' ""FilesetEntry"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""FilesetEntry"".""FilesetID"" IN (SELECT ""FilesetID"" FROM ""{1}"") ) "' tmpnames.Tablename' m_tablename));   " is 301.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The length of the statement  "                        var filesets = string.Format(@"SELECT ""FilesetID""' ""Timestamp"" FROM ""{0}"" ORDER BY ""Timestamp"" DESC"' m_tablename); " is 123.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The length of the statement  "                        var cartesianPathFileset = string.Format(@"SELECT ""A"".""Path""' ""B"".""FilesetID"" FROM ""{0}"" A' (" + filesets + @") B ORDER BY ""A"".""Path"" ASC' ""B"".""Timestamp"" DESC"' tbname' m_tablename); " is 201.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The length of the statement  "                        var filesWithSizes = string.Format(@"SELECT ""Length""' ""FilesetEntry"".""FilesetID""' ""File"".""Path"" FROM ""Blockset""' ""FilesetEntry""' ""File"" WHERE ""File"".""BlocksetID"" = ""Blockset"".""ID"" AND ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND FilesetEntry.""FilesetID"" IN (SELECT DISTINCT ""FilesetID"" FROM ""{0}"") "' m_tablename); " is 349.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The length of the statement  "                        var query = @"SELECT ""C"".""Path""' ""D"".""Length""' ""C"".""FilesetID"" FROM (" + cartesianPathFileset + @") C LEFT OUTER JOIN (" + filesWithSizes + @") D ON ""C"".""FilesetID"" = ""D"".""FilesetID"" AND ""C"".""Path"" = ""D"".""Path"""; " is 240.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFiles,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT DISTINCT ""Path"" FROM ""File""' ""FilesetEntry"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""FilesetEntry"".""FilesetID"" IN (SELECT ""FilesetID"" FROM ""{1}"") ) "' tmpnames.Tablename' m_tablename));   " is 301.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFiles,The length of the statement  "                    var filesets = string.Format(@"SELECT ""FilesetID""' ""Timestamp"" FROM ""{0}"" ORDER BY ""Timestamp"" DESC"' m_tablename); " is 123.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFiles,The length of the statement  "                    var cartesianPathFileset = string.Format(@"SELECT ""A"".""Path""' ""B"".""FilesetID"" FROM ""{0}"" A' (" + filesets + @") B ORDER BY ""A"".""Path"" ASC' ""B"".""Timestamp"" DESC"' tmpnames.Tablename' m_tablename); " is 213.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFiles,The length of the statement  "                    var filesWithSizes = string.Format(@"SELECT ""Length""' ""FilesetEntry"".""FilesetID""' ""File"".""Path"" FROM ""Blockset""' ""FilesetEntry""' ""File"" WHERE ""File"".""BlocksetID"" = ""Blockset"".""ID"" AND ""FilesetEntry"".""FileID"" = ""File"".""ID""  AND FilesetEntry.""FilesetID"" IN (SELECT DISTINCT ""FilesetID"" FROM ""{0}"") "' m_tablename); " is 350.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFiles,The length of the statement  "                    var query = @"SELECT ""C"".""Path""' ""D"".""Length""' ""C"".""FilesetID"" FROM (" + cartesianPathFileset + @") C LEFT OUTER JOIN (" + filesWithSizes + @") D ON ""C"".""FilesetID"" = ""D"".""FilesetID"" AND ""C"".""Path"" = ""D"".""Path"""; " is 240.
Long Statement,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,TakeFirst,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" WHERE ""FilesetID"" NOT IN (SELECT ""FilesetID"" FROM ""{0}"" ORDER BY ""Timestamp"" DESC LIMIT 1 )"' m_tablename)); " is 172.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                var folders = string.Format(@"SELECT ""File"".""Path"" AS ""Path""' NULL AS ""FileHash""' ""Blockset"".""Fullhash"" AS ""MetaHash""' -1 AS ""Size""' {0} AS ""Type""' ""FilesetEntry"".""FilesetID"" AS ""FilesetID"" FROM ""File""'""FilesetEntry""'""Metadataset""'""Blockset"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" = -100 AND ""Metadataset"".""ID""=""File"".""MetadataID"" AND ""Metadataset"".""BlocksetID"" = ""Blockset"".""ID"" "' (int)Library.Interface.ListChangesElementType.Folder); " is 526.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                var symlinks = string.Format(@"SELECT ""File"".""Path"" AS ""Path""' NULL AS ""FileHash""' ""Blockset"".""Fullhash"" AS ""MetaHash""' -1 AS ""Size""' {0} AS ""Type""' ""FilesetEntry"".""FilesetID"" AS ""FilesetID"" FROM ""File""'""FilesetEntry""'""Metadataset""'""Blockset"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" = -200 AND ""Metadataset"".""ID""=""File"".""MetadataID"" AND ""Metadataset"".""BlocksetID"" = ""Blockset"".""ID"" "' (int)Library.Interface.ListChangesElementType.Symlink); " is 528.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                var files = string.Format(@"SELECT ""File"".""Path"" AS ""Path""' ""FB"".""FullHash"" AS ""FileHash""' ""MB"".""Fullhash"" AS ""MetaHash""' ""FB"".""Length"" AS ""Size""' {0} AS ""Type""' ""FilesetEntry"".""FilesetID"" AS ""FilesetID"" FROM ""File""'""FilesetEntry""'""Metadataset""'""Blockset"" MB' ""Blockset"" FB WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" >= 0 AND ""Metadataset"".""ID""=""File"".""MetadataID"" AND ""Metadataset"".""BlocksetID"" = ""MB"".""ID"" AND ""File"".""BlocksetID"" = ""FB"".""ID"" "' (int)Library.Interface.ListChangesElementType.File); " is 602.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId); " is 256.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                    else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) " is 197.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId); " is 334.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                            cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename); " is 146.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                            using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId)) " is 208.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The length of the statement  "                                    if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString())) " is 125.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,GetSqls,The length of the statement  "                    string.Format(@"SELECT ""Path"" FROM ""{0}"" WHERE {2} ""{0}"".""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_currentTable' m_previousTable' string.Format(allTypes ? "" : @" ""{0}"".""Type"" = ? AND "' m_currentTable))' " is 223.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,GetSqls,The length of the statement  "                    string.Format(@"SELECT ""Path"" FROM ""{0}"" WHERE {2} ""{0}"".""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_previousTable' m_currentTable' string.Format(allTypes ? "" : @" ""{0}"".""Type"" = ? AND "' m_previousTable))' " is 224.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,GetSqls,The length of the statement  "                    string.Format(@"SELECT ""{0}"".""Path"" FROM ""{0}""'""{1}"" WHERE {2} ""{0}"".""Path"" = ""{1}"".""Path"" AND (""{0}"".""FileHash"" != ""{1}"".""FileHash"" OR ""{0}"".""MetaHash"" != ""{1}"".""MetaHash"" OR ""{0}"".""Type"" != ""{1}"".""Type"") "' m_currentTable' m_previousTable' string.Format(allTypes ? "" : @" ""{0}"".""Type"" = ? AND "' m_currentTable)) " is 359.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangeSizeReport,The length of the statement  "                    result.AddedSize = cmd.ExecuteScalarInt64(string.Format(@"SELECT SUM(""Size"") FROM ""{0}"" WHERE ""{0}"".""Path"" IN ({1}) "' m_currentTable' added)' 0); " is 154.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangeSizeReport,The length of the statement  "                    result.DeletedSize = cmd.ExecuteScalarInt64(string.Format(@"SELECT SUM(""Size"") FROM ""{0}"" WHERE ""{0}"".""Path"" IN ({1}) "' m_previousTable' deleted)' 0); " is 159.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Added' Library.Interface.ListChangesElementType.Folder' s);                         " is 213.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Added' Library.Interface.ListChangesElementType.Symlink' s); " is 214.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Added' Library.Interface.ListChangesElementType.File' s); " is 211.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Deleted' Library.Interface.ListChangesElementType.Folder' s); " is 215.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Deleted' Library.Interface.ListChangesElementType.Symlink' s); " is 216.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Deleted' Library.Interface.ListChangesElementType.File' s); " is 213.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Modified' Library.Interface.ListChangesElementType.Folder' s); " is 216.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                    foreach(var s in ReaderToStringList(cmd.ExecuteReader(modified' (int)Library.Interface.ListChangesElementType.Symlink))) " is 120.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Modified' Library.Interface.ListChangesElementType.Symlink' s); " is 217.
Long Statement,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,CreateChangedFileReport,The length of the statement  "                        yield return new Tuple<Library.Interface.ListChangesChangeType' Library.Interface.ListChangesElementType' string>(Library.Interface.ListChangesChangeType.Modified' Library.Interface.ListChangesElementType.File' s); " is 214.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,UpdateVerificationCount,The length of the statement  "                cmd.ExecuteNonQuery(@"UPDATE ""RemoteVolume"" SET ""VerificationCount"" = MAX(1' CASE WHEN ""VerificationCount"" <= 0 THEN (SELECT MAX(""VerificationCount"") FROM ""RemoteVolume"") ELSE ""VerificationCount"" + 1 END) WHERE ""Name"" = ?"' name); " is 244.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,FilterByVerificationCount,The length of the statement  "            var starved = (from n in volumes where n.VerificationCount != 0 && n.VerificationCount < maxverification orderby n.VerificationCount select n); " is 143.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "                using(var rd = cmd.ExecuteReader(@"SELECT ""ID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE (""State"" = ? OR ""State"" = ?) AND (""Hash"" = """" OR ""Hash"" IS NULL OR ""Size"" <= 0) "' RemoteVolumeState.Verified.ToString()' RemoteVolumeState.Uploaded.ToString())) " is 303.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "                using(var rd = cmd.ExecuteReader(@"SELECT ""A"".""VolumeID""' ""A"".""Name""' ""A"".""Size""' ""A"".""Hash""' ""A"".""VerificationCount"" FROM (SELECT ""ID"" AS ""VolumeID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE ""State"" IN (?' ?)) A' ""Fileset"" " +  whereClause + @" ""A"".""VolumeID"" = ""Fileset"".""VolumeID"" ORDER BY ""Fileset"".""Timestamp"" "' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString()' tp.Item2)) " is 485.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "                using(var rd = cmd.ExecuteReader(@"SELECT ""ID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE ""Type"" = ? AND ""State"" IN (?' ?)"' RemoteVolumeType.Index.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString())) " is 282.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "                using(var rd = cmd.ExecuteReader(@"SELECT ""ID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE ""Type"" = ? AND ""State"" IN (?' ?)"' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString())) " is 283.
Long Statement,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var create = @"CREATE TEMPORARY TABLE ""{1}"" AS SELECT ""A"".""Path"" AS ""Path""' CASE WHEN ""B"".""Fullhash"" IS NULL THEN -1 ELSE ""B"".""Length"" END AS ""Size""' ""B"".""Fullhash"" AS ""Hash""' ""C"".""Length"" AS ""Metasize""' ""C"".""Fullhash"" AS ""Metahash"" FROM (SELECT ""File"".""Path""' ""File"".""BlocksetID"" AS ""FileBlocksetID""' ""Metadataset"".""BlocksetID"" AS ""MetadataBlocksetID"" from ""Remotevolume""' ""Fileset""' ""FilesetEntry""' ""File""' ""Metadataset"" WHERE ""Remotevolume"".""Name"" = ? AND ""Fileset"".""VolumeID"" = ""Remotevolume"".""ID"" AND ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""MetadataID"" = ""Metadataset"".""ID"") A LEFT OUTER JOIN ""Blockset"" B ON ""B"".""ID"" = ""A"".""FileBlocksetID"" LEFT OUTER JOIN ""Blockset"" C ON ""C"".""ID""=""A"".""MetadataBlocksetID"" "; " is 890.
Long Statement,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var extra = @"SELECT ? AS ""Type""' ""{0}"".""Path"" AS ""Path"" FROM ""{0}"" WHERE ""{0}"".""Path"" NOT IN ( SELECT ""Path"" FROM ""{1}"" )"; " is 142.
Long Statement,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var missing = @"SELECT ? AS ""Type""' ""Path"" AS ""Path"" FROM ""{1}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{0}"")"; " is 126.
Long Statement,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var modified = @"SELECT ? AS ""Type""' ""E"".""Path"" AS ""Path"" FROM ""{0}"" E' ""{1}"" D WHERE ""D"".""Path"" = ""E"".""Path"" AND (""D"".""Size"" != ""E"".""Size"" OR ""D"".""Hash"" != ""E"".""Hash"" OR ""D"".""Metasize"" != ""E"".""Metasize"" OR ""D"".""Metahash"" != ""E"".""Metahash"")  "; " is 296.
Long Statement,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                        using(var rd = cmd.ExecuteReader(string.Format(extra + " UNION " + missing + " UNION " + modified' m_tablename' cmpName)' (int)Library.Interface.TestEntryStatus.Extra' (int)Library.Interface.TestEntryStatus.Missing' (int)Library.Interface.TestEntryStatus.Modified)) " is 265.
Long Statement,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                                yield return new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>((Duplicati.Library.Interface.TestEntryStatus)rd.GetInt64(0)' rd.GetString(1)); " is 161.
Long Statement,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var create = @"CREATE TEMPORARY TABLE ""{1}"" AS SELECT ""A"".""Name""' ""A"".""Hash""' ""A"".""Size"" FROM ""Remotevolume"" A' ""Remotevolume"" B' ""IndexBlockLink"" WHERE ""B"".""Name"" = ? AND ""A"".""ID"" = ""IndexBlockLink"".""BlockVolumeID"" AND ""B"".""ID"" = ""IndexBlockLink"".""IndexVolumeID"" "; " is 306.
Long Statement,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var extra = @"SELECT ? AS ""Type""' ""{0}"".""Name"" AS ""Name"" FROM ""{0}"" WHERE ""{0}"".""Name"" NOT IN ( SELECT ""Name"" FROM ""{1}"" )"; " is 142.
Long Statement,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var missing = @"SELECT ? AS ""Type""' ""Name"" AS ""Name"" FROM ""{1}"" WHERE ""Name"" NOT IN (SELECT ""Name"" FROM ""{0}"")"; " is 126.
Long Statement,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var modified = @"SELECT ? AS ""Type""' ""E"".""Name"" AS ""Name"" FROM ""{0}"" E' ""{1}"" D WHERE ""D"".""Name"" = ""E"".""Name"" AND (""D"".""Hash"" != ""E"".""Hash"" OR ""D"".""Size"" != ""E"".""Size"") "; " is 207.
Long Statement,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                        using(var rd = cmd.ExecuteReader(string.Format(extra + " UNION " + missing + " UNION " + modified' m_tablename' cmpName)' (int)Library.Interface.TestEntryStatus.Extra' (int)Library.Interface.TestEntryStatus.Missing' (int)Library.Interface.TestEntryStatus.Modified)) " is 265.
Long Statement,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                                yield return new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>((Duplicati.Library.Interface.TestEntryStatus)rd.GetInt64(0)' rd.GetString(1) ); " is 162.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var curBlocks = @"SELECT ""Block"".""Hash"" AS ""Hash""' ""Block"".""Size"" AS ""Size"" FROM ""Remotevolume""' ""Block"" WHERE ""Remotevolume"".""Name"" = ? AND ""Remotevolume"".""ID"" = ""Block"".""VolumeID"""; " is 211.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var delBlocks = @"SELECT ""DeletedBlock"".""Hash"" AS ""Hash""' ""DeletedBlock"".""Size"" AS ""Size"" FROM ""DeletedBlock""' ""RemoteVolume"" WHERE ""RemoteVolume"".""Name"" = ? AND ""RemoteVolume"".""ID"" = ""DeletedBlock"".""VolumeID"""; " is 239.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var create = @"CREATE TEMPORARY TABLE ""{0}"" AS SELECT DISTINCT ""Hash"" AS ""Hash""' ""Size"" AS ""Size"" FROM ({1} UNION {2})"; " is 130.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var extra = @"SELECT ? AS ""Type""' ""{0}"".""Hash"" AS ""Hash"" FROM ""{0}"" WHERE ""{0}"".""Hash"" NOT IN ( SELECT ""Hash"" FROM ""{1}"" )"; " is 142.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var missing = @"SELECT ? AS ""Type""' ""Hash"" AS ""Hash"" FROM ""{1}"" WHERE ""Hash"" NOT IN (SELECT ""Hash"" FROM ""{0}"")"; " is 126.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                var modified = @"SELECT ? AS ""Type""' ""E"".""Hash"" AS ""Hash"" FROM ""{0}"" E' ""{1}"" D WHERE ""D"".""Hash"" = ""E"".""Hash"" AND ""D"".""Size"" != ""E"".""Size""  "; " is 170.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                        using(var rd = cmd.ExecuteReader(string.Format(extra + " UNION " + missing + " UNION " + modified' m_tablename' cmpName)' (int)Library.Interface.TestEntryStatus.Extra' (int)Library.Interface.TestEntryStatus.Missing' (int)Library.Interface.TestEntryStatus.Modified)) " is 265.
Long Statement,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The length of the statement  "                                yield return new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>((Duplicati.Library.Interface.TestEntryStatus)rd.GetInt64(0)' rd.GetString(1) ); " is 162.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                var selectAllBlocks = @"SELECT DISTINCT ""FullHash""' ""Length"" FROM (" + selectBlockHashes + " UNION " + selectSmallBlocks + " )"; " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    @" FROM (SELECT ""A"".""FullHash""' ""A"".""Length""' CASE WHEN ""B"".""Hash"" IS NULL THEN '' ELSE ""B"".""Hash"" END AS ""Hash""' CASE WHEN ""B"".""Size"" is NULL THEN -1 ELSE ""B"".""Size"" END AS ""Size"" FROM ({0}) A" +  " is 224.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    @"SELECT ""E"".""BlocksetID"" AS ""BlocksetID""' ""D"".""FullIndex"" AS ""Index""' ""F"".""ID"" AS ""BlockID"" FROM ( " + " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    @") D' ""BlocklistHash"" E' ""Block"" F' ""Block"" G WHERE ""D"".""BlocksetID"" = ""E"".""BlocksetID"" AND ""D"".""BlocklistHash"" = ""E"".""Hash"" AND ""D"".""BlocklistSize"" = ""G"".""Size"" AND ""D"".""BlocklistHash"" = ""G"".""Hash"" AND ""D"".""Blockhash"" = ""F"".""Hash"" AND ""D"".""BlockSize"" = ""F"".""Size"" "' " is 322.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    // TODO: The BlocklistHash join seems to be unnecessary' but the join might be required to work around a from really old versions of Duplicati " is 142.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    //@") D' ""Block"" WHERE  ""BlockQuery"".""BlockHash"" = ""Block"".""Hash"" AND ""BlockQuery"".""BlockSize"" = ""Block"".""Size"" "; " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    @"SELECT ""Blockset"".""ID"" AS ""BlocksetID""' 0 AS ""Index""' ""Block"".""ID"" AS ""BlockID"" FROM ""Blockset""' ""Block""' ""{1}"" S WHERE ""Blockset"".""Fullhash"" = ""S"".""FileHash"" AND ""S"".""BlockHash"" = ""Block"".""Hash"" AND ""S"".""BlockSize"" = ""Block"".""Size"" AND ""Blockset"".""Length"" = ""S"".""BlockSize"" AND ""Blockset"".""Length"" <= {0} "' " is 366.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    @") H WHERE (""H"".""BlocksetID"" || ':' || ""H"".""Index"") NOT IN (SELECT (""ExistingBlocksetEntries"".""BlocksetID"" || ':' || ""ExistingBlocksetEntries"".""Index"") FROM ""BlocksetEntry"" ""ExistingBlocksetEntries"" )"; " is 223.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "                    throw new Exception("The recreate failed' please create a bug-report from this database and send it to the developers for further analysis"); " is 141.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The length of the statement  "                m_result.AddWarning(string.Format("Mismatching number of blocklist hashes detected on blockset {2}. Expected {0} blocklist hashes' but found {1}"' expectedblocklisthashes' c' blocksetid)' null); " is 194.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The length of the statement  "                    throw new Exception(string.Format("Failed to update table' found {0} entries for key {1} with size {2}"' c 'hash' size)); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetBlockLists,The length of the statement  "                cmd.CommandText = string.Format(@"SELECT DISTINCT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash""' ""Block"" WHERE ""Block"".""Hash"" = ""BlocklistHash"".""Hash"" AND ""Block"".""VolumeID"" = ?"); " is 198.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The length of the statement  "                var selectCommand = @"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size""' ""RemoteVolume"".""ID"" FROM ""RemoteVolume"""; " is 166.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The length of the statement  "                        @"SELECT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash"" LEFT OUTER JOIN ""BlocksetEntry"" ON ""BlocksetEntry"".""Index"" = (""BlocklistHash"".""Index"" * {0}) AND ""BlocksetEntry"".""BlocksetID"" = ""BlocklistHash"".""BlocksetID"" WHERE ""BlocksetEntry"".""BlocksetID"" IS NULL"' " is 282.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetFilesets,The length of the statement  "                @"SELECT ""FilesetID"" FROM ""FilesetEntry"" WHERE ""FileID"" IN ( SELECT ""ID"" FROM ""File"" WHERE ""BlocksetID"" IN ( SELECT ""BlocksetID"" FROM ""BlocksetEntry"" WHERE ""BlockID"" IN ( SELECT ""ID"" From ""Block"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0})))))" + " is 308.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetFilesets,The length of the statement  "                @"SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))" + " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetFiles,The length of the statement  "                @"SELECT ""Path"" FROM ""File"" WHERE ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"" WHERE ""BlockID"" IN (SELECT ""ID"" FROM ""Block"" WHERE ""VolumeID"" IN (SELECT ""ID"" from ""RemoteVolume"" WHERE ""Name"" IN ({0}))))" + " is 241.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetFiles,The length of the statement  "                @"SELECT ""Path"" FROM ""File"" WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"" WHERE ""BlockID"" IN (SELECT ""ID"" FROM ""Block"" WHERE ""VolumeID"" IN (SELECT ""ID"" from ""RemoteVolume"" WHERE ""Name"" IN ({0})))))" + " is 302.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetFiles,The length of the statement  "                @"SELECT ""Path"" FROM ""File"" WHERE ""ID"" IN ( SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" IN ( SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))))" + " is 235.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetLogLines,The length of the statement  "                @"SELECT ""TimeStamp""' ""Message"" || "" "" || CASE WHEN ""Exception"" IS NULL THEN """" ELSE ""Exception"" END FROM ""LogData"" WHERE {0}" + " is 142.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetVolumes,The length of the statement  "                @" SELECT ""Name"" FROM ""Remotevolume"" WHERE ""ID"" IN ( SELECT ""VolumeID"" FROM ""Block"" WHERE ""ID"" IN ( SELECT ""BlockID"" FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ( SELECT ""BlocksetID"" FROM ""File"" WHERE ""ID"" IN ( SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" IN ( SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))))))) " + " is 423.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetVolumes,The length of the statement  "                @" SELECT ""Name"" FROM ""Remotevolume"" WHERE ""ID"" IN ( SELECT ""VolumeID"" FROM ""Block"" WHERE ""ID"" IN ( SELECT ""BlockID"" FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ( SELECT ""BlocksetID"" FROM ""Metadataset"" WHERE ""ID"" IN ( SELECT ""MetadataID"" FROM ""File"" WHERE ""ID"" IN ( SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" IN ( SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))))))))" + " is 484.
Long Statement,Duplicati.Library.Main.Database,LocalPurgeDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,GetRemoteVolumeNameForFileset,The length of the statement  "            using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""B"".""Name"" FROM ""Fileset"" A' ""RemoteVolume"" B WHERE ""A"".""VolumeID"" = ""B"".""ID"" AND ""A"".""ID"" = ? ")' id)) " is 180.
Long Statement,Duplicati.Library.Main.Database,LocalPurgeDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,CountOrphanFiles,The length of the statement  "            using (var rd = cmd.ExecuteReader(@"SELECT COUNT(*) FROM ""File"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""FileID"" FROM ""FilesetEntry"")")) " is 139.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ApplyFilter,The length of the statement  "                if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) " is 192.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ApplyFilter,The length of the statement  "                        cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""FileID"") SELECT DISTINCT ""A"".""FileID"" FROM ""FilesetEntry"" A' ""File"" B WHERE ""A"".""FilesetID"" = ? AND ""A"".""FileID"" = ""B"".""ID"" AND ""B"".""Path"" NOT IN ""{1}"""' m_tablename' filenamestable)' ParentID); " is 280.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ApplyFilter,The length of the statement  "                        using (var rd = cmd.ExecuteReader(@"SELECT ""B"".""Path""' ""A"".""FileID"" FROM ""FilesetEntry"" A' ""File"" B WHERE ""A"".""FilesetID"" = ? AND ""A"".""FileID"" = ""B"".""ID"" "' ParentID)) " is 191.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ApplyFilter,The length of the statement  "                                if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString())) " is 125.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,PostFilterChecks,The length of the statement  "                    RemovedFileSize = cmd.ExecuteScalarInt64(string.Format(@"SELECT SUM(""C"".""Length"") FROM ""{0}"" A' ""File"" B' ""Blockset"" C WHERE ""A"".""FileID"" = ""B"".""ID"" AND ""B"".""BlocksetID"" = ""C"".""ID"" "' m_tablename)' 0); " is 227.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,PostFilterChecks,The length of the statement  "                    var filesetcount = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetID"" = " + ParentID)' 0); " is 136.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,PostFilterChecks,The length of the statement  "                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Refusing to purge {0} files from fileset with ID {1}' as that would remove the entire fileset.\nTo delete a fileset' use the \"delete\" command."' RemovedFileCount' ParentID)); " is 254.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ConvertToPermanentFileset,The length of the statement  "                var remotevolid = m_parentdb.RegisterRemoteVolume(name' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction); " is 124.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ConvertToPermanentFileset,The length of the statement  "                    cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""FilesetEntry"" (""FilesetID""' ""FileID""' ""Lastmodified"") SELECT ?' ""FileID""' ""LastModified"" FROM ""FilesetEntry"" WHERE ""FilesetID"" = ? AND ""FileID"" NOT IN ""{0}"" "' m_tablename)' filesetid' ParentID); " is 264.
Long Statement,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ListAllDeletedFiles,The length of the statement  "                using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""B"".""Path""' ""C"".""Length"" FROM ""{0}"" A' ""File"" B' ""Blockset"" C WHERE ""A"".""FileID"" = ""B"".""ID"" AND ""B"".""BlocksetID"" = ""C"".""ID"" "' m_tablename))) " is 228.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilesets,The length of the statement  "                        yield return new Tuple<DateTime' long' long>(ParseFromEpochSeconds(rd.ConvertValueToInt64(0' 0))' rd.ConvertValueToInt64(1' -1)' rd.ConvertValueToInt64(2' 0)); " is 159.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilenames,The length of the statement  "                foreach (var rd in cmd.ExecuteReaderEnumerable(string.Format(BROKEN_FILE_NAMES' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID)' filesetid)) " is 133.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,InsertBrokenFileIDsIntoTable,The length of the statement  "                cmd.ExecuteNonQuery(string.Format(INSERT_BROKEN_IDS' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' tablename' IDfieldname)' filesetid); " is 130.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The length of the statement  "                throw new Exception("This function cannot be called when not in a transaction' as it leaves the database in an inconsistent state"); " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The length of the statement  "                deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery)); " is 155.
Long Statement,Duplicati.Library.Main.Volumes,FileEntryEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeReader.cs,MoveNext,The length of the statement  "                        throw new InvalidDataException(string.Format("Invalid JSON' expected StartObject' but got {0}' {1}"' m_reader.TokenType' m_reader.Value)); " is 138.
Long Statement,Duplicati.Library.Main.Volumes,FileEntry,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeReader.cs,Set,The length of the statement  "                            throw new InvalidDataException(string.Format("Invalid JSON' expected StartObject' but got {0}' {1}"' reader.TokenType' reader.Value)); " is 134.
Long Statement,Duplicati.Library.Main.Volumes,BlocklistHashEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeReader.cs,MoveNext,The length of the statement  "                                    throw new InvalidDataException(string.Format("Invalid JSON' expected String' but found {0}' {1}"' m_reader.TokenType' m_reader.Value)); " is 135.
Long Statement,Duplicati.Library.Main.Volumes,ControlFileEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeReader.cs,MoveNext,The length of the statement  "                    m_current = new KeyValuePair<string' Stream>(m_files[m_index].Substring(CONTROL_FILES_FOLDER.Length)' m_compression.OpenRead(m_files[m_index])); " is 144.
Long Statement,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddFile,The length of the statement  "            AddFileEntry(FilelistEntryType.File' name' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blocklisthashes' metablocklisthashes); " is 168.
Long Statement,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddAlternateStream,The length of the statement  "            AddFileEntry(FilelistEntryType.AlternateStream' name' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blocklisthashes' metablocklisthashes); " is 179.
Long Statement,Duplicati.Library.Main.Volumes,VolumeBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The length of the statement  "            return GenerateFilename(filetype' options.Prefix' guid' timestamp' options.CompressionModule' options.NoEncryption ? null : options.EncryptionModule); " is 150.
Long Statement,Duplicati.Library.Main.Volumes,VolumeBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The length of the statement  "                volumename = prefix + "-" + Library.Utility.Utility.SerializeDateTime(timestamp) + "." + (ParsedVolume.REMOTE_TYPENAME_MAP[filetype]) + "." + compressionmodule; " is 160.
Long Statement,Duplicati.Library.Main.Volumes,VolumeBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The length of the statement  "                volumename = prefix + "-" + (filetype == RemoteVolumeType.Blocks ? "b" : "i") + guid + "." + (ParsedVolume.REMOTE_TYPENAME_MAP[filetype]) + "." + compressionmodule; " is 164.
Long Statement,Duplicati.Library.Main.Volumes,ParsedVolume,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,Parse,The length of the statement  "                    Time = m.Groups["time"].Success ? Library.Utility.Utility.DeserializeDateTime(m.Groups["time"].Value).ToUniversalTime() : new DateTime(0' DateTimeKind.Utc)' " is 156.
Long Statement,Duplicati.Library.Main.Volumes,VolumeReaderBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeReaderBase.cs,SkipJsonToken,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid JSON' expected \"{0}\"' but got {1}' {2}"' type' reader.TokenType' reader.Value)); " is 136.
Long Statement,Duplicati.Library.Main.Volumes,VolumeReaderBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeReaderBase.cs,ReadJsonProperty,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid JSON' expected property \"{0}\"' but got {1}' {2}"' propertyname' reader.TokenType' reader.Value)); " is 153.
Long Statement,Duplicati.Library.Main.Volumes,VolumeWriterBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeWriterBase.cs,ResetRemoteFilename,The length of the statement  "            m_volumename = GenerateFilename(this.FileType' options.Prefix' GenerateGuid(options)' timestamp' options.CompressionModule' options.NoEncryption ? null : options.EncryptionModule); " is 180.
Long Statement,Duplicati.Library.Main.Volumes,VolumeWriterBase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeWriterBase.cs,AddManifestfile,The length of the statement  "            using (var sr = new StreamWriter(m_compression.CreateFile(MANIFEST_FILENAME' CompressionHint.Compressible' DateTime.UtcNow)' ENCODING)) " is 135.
Long Statement,Duplicati.Library.Main.Volumes,IndexVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeWriter.cs,StartVolume,The length of the statement  "            m_streamwriter = new StreamWriter(m_compression.CreateFile(INDEX_VOLUME_FOLDER + filename' CompressionHint.Compressible' DateTime.UtcNow)); " is 139.
Long Statement,Duplicati.Library.Main.Volumes,IndexVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeWriter.cs,WriteBlocklist,The length of the statement  "            using (var s = m_compression.CreateFile(INDEX_BLOCKLIST_FOLDER + Library.Utility.Utility.Base64PlainToBase64Url(hash)' CompressionHint.Noncompressible' DateTime.UtcNow)) " is 169.
Long Statement,Duplicati.Library.Main.Volumes,IndexVolumeWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeWriter.cs,WriteBlocklist,The length of the statement  "            using (var s = m_compression.CreateFile(INDEX_BLOCKLIST_FOLDER + Library.Utility.Utility.Base64PlainToBase64Url(hash)' CompressionHint.Noncompressible' DateTime.UtcNow)) " is 169.
Long Statement,Duplicati.Library.Main.Volumes,BlockEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeReader.cs,MoveNext,The length of the statement  "                                throw new InvalidDataException(string.Format("Invalid JSON' expected StartObject' but got {0}' {1}"' m_reader.TokenType' m_reader.Value)); " is 138.
Long Statement,Duplicati.Library.Main.Volumes,BlockEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeReader.cs,Reset,The length of the statement  "                                throw new InvalidDataException(string.Format("Invalid JSON' expected property \"blocks\"' but got {0}' {1}"' m_reader.TokenType' m_reader.Value)); " is 146.
Long Statement,Duplicati.Library.Main.Strings,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,HashMismatchError,The length of the statement  "{ return LC.L(@"Hash mismatch on file ""{0}""' recorded hash: {1}' actual hash {2}"' filename' recordedhash' actualhash); }" is 123.
Long Statement,Duplicati.Library.Main.Strings,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,DownloadedFileSizeError,The length of the statement  "{ return LC.L(@"The file {0} was downloaded and had size {1} but the size was expected to be {2}"' filename' actualsize' expectedsize); }" is 137.
Long Statement,Duplicati.Library.Main.Strings,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedBooleanValue,The length of the statement  "{ return LC.L(@"The value ""{1}"" supplied to --{0} does not parse into a valid boolean' this will be treated as if it was set to ""true"""' optionname' value); }" is 162.
Long Statement,Duplicati.Library.Main.Strings,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedEnumerationValue,The length of the statement  "{ return LC.L(@"The option --{0} does not support the value ""{1}""' supported values are: {2}"' optionname' value' string.Join("' "' values)); }" is 145.
Long Statement,Duplicati.Library.Main.Strings,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedFlagsValue,The length of the statement  "{ return LC.L(@"The option --{0} does not support the value ""{1}""' supported flag values are: {2}"' optionname' value' string.Join("' "' values)); }" is 150.
Long Statement,Duplicati.Library.Main.Strings,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedOptionDisabledModuleWarning,The length of the statement  "{ return LC.L(@"The option --{0} is not supported because the module {1} is not currently loaded"' optionname' modulename); }" is 125.
Long Statement,Duplicati.Library.Main.Strings,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,FailedForceLocaleError,The length of the statement  "{ return LC.L(@"Failed to apply 'force-locale' setting. Please try to update .NET-Framework. Exception was: ""{0}"" "' exMsg); }" is 128.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,DefaultFiltersLong,The length of the statement  "{ return LC.L(@"Exclude files that match the given filter sets. Which default filter sets should be used. Valid sets are ""{0}""' ""{1}""' ""{2}""' and ""{3}"". If this parameter is set with no value' the set for the current operating system will be used."' windows' osx' linux' all); }" is 286.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,SymlinkpolicyLong,The length of the statement  "{ return LC.L(@"Use this option to handle symlinks differently. The ""{0}"" option will simply record a symlink with its name and destination' and a restore will recreate the symlink as a link. Use the option ""{1}"" to ignore all symlinks and not store any information about them. Previous versions of Duplicati used the setting ""{2}""' which will cause symlinked files to be included and restore as normal files."' store' ignore' follow); }" is 443.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,HardlinkpolicyLong,The length of the statement  "{ return LC.L(@"Use this option to handle hardlinks (only works on Linux/OSX). The ""{0}"" option will record a hardlink ID for each hardlink to avoid storing hardlinked paths multiple times. The option ""{1}"" will ignore hardlink information' and treat each hardlink as a unique path. The option ""{2}"" will ignore all hardlinks with more than one link."' first' all' none); }" is 379.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,ExcludefilesattributesLong,The length of the statement  "{ return LC.L(@"Use this option to exclude files with certain attributes. Use a comma separated list of attribute names to specify more than one. Possible values are: {0}"' string.Join("' "' attributes)); }" is 206.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,CompressionextensionfileLong,The length of the statement  "{ return LC.L(@"This property can be used to point to a text file where each line contains a file extension that indicates a non-compressible file. Files that have an extension found in the file will not be compressed' but simply stored in the archive. The file format ignores any lines that do not start with a period' and considers a space to indicate the end of the extension. A default file is supplied' that also serves as an example. The default file is placed in {0}."' path); }" is 485.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,DeletedfilesLong,The length of the statement  "{ return LC.L(@"This option can be used to supply a list of deleted files. This option will be ignored unless the option --{0} is also set."' optionname); }" is 156.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,BackendtestsamplesLong,The length of the statement  "{ return LC.L(@"After a backup is completed' some files are selected for verification on the remote backend. Use this option to change how many. If this value is set to 0 or the option --{0} is set' no remote files are verified"' optionname); }" is 244.
Long Statement,Duplicati.Library.Main.Strings,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,FullremoteverificationLong,The length of the statement  "{ return LC.L(@"After a backup is completed' some files are selected for verification on the remote backend. Use this option to turn on full verification' which will decrypt the files and examine the insides of each volume' instead of simply verifying the external hash' If the option --{0} is set' no remote files are verified. This option is automatically set when then verification is performed directly."' optionname); }" is 424.
Complex Conditional,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The conditional expression  "(oldId < 0 || m_options.DisableFiletimeCheck || timestampChanged || filesizeChanged || metadatachanged) && !tooLargeFile"  is complex.
Complex Conditional,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The conditional expression  "fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)"  is complex.
Complex Conditional,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The conditional expression  "!m_options.NoAutoCompact && (forceCompact || (toDelete != null && toDelete.Length > 0))"  is complex.
Complex Conditional,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The conditional expression  "username == null && o.Aliases != null && o.Aliases.Contains("auth-username"' StringComparer.OrdinalIgnoreCase) && ropts.ContainsKey(o.Name)"  is complex.
Complex Conditional,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The conditional expression  "password == null && o.Aliases != null && o.Aliases.Contains("auth-password"' StringComparer.OrdinalIgnoreCase) && ropts.ContainsKey(o.Name)"  is complex.
Complex Conditional,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Put,The conditional expression  "req2 != null && m_queue.Enqueue(req2) && (m_options.SynchronousUpload || synchronous)"  is complex.
Complex Conditional,Duplicati.Library.Main.Volumes,FileEntry,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeReader.cs,FileEntry,The conditional expression  "(this.Type == FilelistEntryType.File || this.Type == FilelistEntryType.AlternateStream) && m_reader.TokenType == JsonToken.PropertyName && m_reader.Value != null && m_reader.Value.ToString() == "blocklists""  is complex.
Complex Conditional,Duplicati.Library.Main.Volumes,FileEntry,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeReader.cs,FileEntry,The conditional expression  "(this.Type == FilelistEntryType.File || this.Type == FilelistEntryType.AlternateStream) && m_reader.TokenType == JsonToken.PropertyName && m_reader.Value != null && m_reader.Value.ToString() == "blockhash""  is complex.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CountFilesThread,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CountFilesThread,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RunMainOperation,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,FilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Mixin,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,CompactHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,DeleteHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,TestFilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,TestFilterHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,RestoreHandlerMetadataStorage,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandlerMetadataStorage.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,RestoreHandlerMetadataStorage,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandlerMetadataStorage.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,SystemInfoHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,Options,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Options.cs,GetSupportedHashes,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,BackendManager,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,RenameFileAfterError,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoDelete,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,FilteredFilenameTable,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,ExtensionMethods,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\ExtensionMethods.cs,ConvertValueToInt64,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,SelectFolderContents,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,Basiclist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,Basiclist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,Basiclist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,Blocklist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Compare,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The method has an empty catch block.
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The following statement contains a magic number: using(var trn = m_database.BeginTransaction())              {                  var incompleteSet = incompleteFilesets.Last();                  var badIds = from n in incompleteFilesets select n.Key;                    var prevs = (from n in m_database.FilesetTimes                       where                       n.Key < incompleteSet.Key                      &&                      !badIds.Contains(n.Key)                      orderby n.Key                                                                      select n.Key).ToArray();                    var prevId = prevs.Length == 0 ? -1 : prevs.Last();                    FilesetVolumeWriter fsw = null;                  try                  {                      var s = 1;                      var fileTime = incompleteSet.Value + TimeSpan.FromSeconds(s);                      var oldFilesetID = incompleteSet.Key;                        // Probe for an unused filename                      while (s < 60)                      {                          var id = m_database.GetRemoteVolumeID(VolumeBase.GenerateFilename(RemoteVolumeType.Files' m_options' null' fileTime));                          if (id < 0)                              break;                            fileTime = incompleteSet.Value + TimeSpan.FromSeconds(++s);                      }                        fsw = new FilesetVolumeWriter(m_options' fileTime);                      fsw.VolumeID = m_database.RegisterRemoteVolume(fsw.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);                        if (!string.IsNullOrEmpty(m_options.ControlFiles))                          foreach(var p in m_options.ControlFiles.Split(new char[] { System.IO.Path.PathSeparator }' StringSplitOptions.RemoveEmptyEntries))                              fsw.AddControlFile(p' m_options.GetCompressionHintFromFilename(p));                        var newFilesetID = m_database.CreateFileset(fsw.VolumeID' fileTime' trn);                      m_database.LinkFilesetToVolume(newFilesetID' fsw.VolumeID' trn);                      m_database.AppendFilesFromPreviousSet(trn' null' newFilesetID' prevId' fileTime);                        m_database.WriteFileset(fsw' trn' newFilesetID);                        if (m_options.Dryrun)                      {                          m_result.AddDryrunMessage(string.Format("Would upload fileset: {0}' size: {1}"' fsw.RemoteFilename' Library.Utility.Utility.FormatSizeString(new FileInfo(fsw.LocalFilename).Length)));                      }                      else                      {                          m_database.UpdateRemoteVolume(fsw.RemoteFilename' RemoteVolumeState.Uploading' -1' null' trn);                            using(new Logging.Timer("CommitUpdateFilelistVolume"))                              trn.Commit();                            backend.Put(fsw);                          fsw = null;                      }                  }                  finally                  {                      if (fsw != null)                          try { fsw.Dispose(); }                      catch { fsw = null; }                  }                                        }
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RecreateMissingIndexFiles,The following statement contains a magic number: if (m_options.IndexfilePolicy != Options.IndexFileStrategy.None)              {                  var blockhasher = Library.Utility.HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm);                  var hashsize = blockhasher.HashSize / 8;                    foreach (var blockfile in m_database.GetMissingIndexFiles())                  {                      m_result.AddMessage(string.Format("Re-creating missing index file for {0}"' blockfile));                      var w = new IndexVolumeWriter(m_options);                      w.VolumeID = m_database.RegisterRemoteVolume(w.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' null);                        var blockvolume = m_database.GetRemoteVolumeFromName(blockfile);                      w.StartVolume(blockvolume.Name);                      var volumeid = m_database.GetRemoteVolumeID(blockvolume.Name);                        foreach (var b in m_database.GetBlocks(volumeid))                          w.AddBlock(b.Hash' b.Size);                        w.FinishVolume(blockvolume.Hash' blockvolume.Size);                        if (m_options.IndexfilePolicy == Options.IndexFileStrategy.Full)                          foreach (var b in m_database.GetBlocklists(volumeid' m_options.Blocksize' hashsize))                              w.WriteBlocklist(b.Item1' b.Item2' 0' b.Item3);                        w.Close();                        m_database.AddIndexBlockLink(w.VolumeID' volumeid' null);                        if (m_options.Dryrun)                          m_result.AddDryrunMessage(string.Format("would upload new index file {0}' with size {1}' previous size {2}"' w.RemoteFilename' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(w.Filesize)));                      else                      {                          m_database.UpdateRemoteVolume(w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);                          backend.Put(w);                      }                  }              }
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: using(m_database = new LocalBackupDatabase(m_options.Dbpath' m_options))              {                  m_result.SetDatabase(m_database);                  m_result.Dryrun = m_options.Dryrun;                    Utility.UpdateOptionsFromDb(m_database' m_options);                  Utility.VerifyParameters(m_database' m_options);                    var probe_path = m_database.GetFirstPath();                  if (probe_path != null && Duplicati.Library.Utility.Utility.GuessDirSeparator(probe_path) != System.IO.Path.DirectorySeparatorChar.ToString())                      throw new UserInformationException(string.Format("The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems' which is not supported. To proceed without losing remote data' delete all filesets and make sure the --{0} option is set' then run the backup again to re-use the existing data on the remote store."' "no-auto-compact"));                    if (m_database.PartiallyRecreated)                      throw new UserInformationException("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");                                    if (m_database.RepairInProgress)                      throw new UserInformationException("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the backup process cannot continue. You may delete the local database and attempt to repair it again.");                    m_blocksize = m_options.Blocksize;                  m_maxmetadatasize = (m_blocksize / (long)m_options.BlockhashSize) * m_blocksize;                    m_blockbuffer = new byte[m_options.Blocksize * Math.Max(1' m_options.FileReadBufferSize / m_options.Blocksize)];                  m_blocklistbuffer = new byte[m_options.Blocksize];                    m_blockhasher = Library.Utility.HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm);                  m_filehasher = Library.Utility.HashAlgorithmHelper.Create(m_options.FileHashAlgorithm);                    if (m_blockhasher == null)                      throw new UserInformationException(Strings.Common.InvalidHashAlgorithm(m_options.BlockHashAlgorithm));                  if (m_filehasher == null)                      throw new UserInformationException(Strings.Common.InvalidHashAlgorithm(m_options.FileHashAlgorithm));                    if (!m_blockhasher.CanReuseTransform)                      throw new UserInformationException(Strings.Common.InvalidCryptoSystem(m_options.BlockHashAlgorithm));                  if (!m_filehasher.CanReuseTransform)                      throw new UserInformationException(Strings.Common.InvalidCryptoSystem(m_options.FileHashAlgorithm));                    m_database.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' false);                  // If there is no filter' we set an empty filter to simplify the code                  // If there is a filter' we make sure that the sources are included                  m_filter = filter ?? new Library.Utility.FilterExpression();                  m_sourceFilter = new Library.Utility.FilterExpression(sources' true);                                    m_backendLogFlushTimer = DateTime.Now.Add(FLUSH_TIMESPAN);                  System.Threading.Thread parallelScanner = null;                        try                  {                      using(var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' m_database))                      using(var filesetvolume = new FilesetVolumeWriter(m_options' m_database.OperationTimestamp))                      {                          using(var snapshot = GetSnapshot(sources' m_options' m_result))                          {                              // Start parallel scan                              if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1)                              {                                  parallelScanner = new System.Threading.Thread(CountFilesThread) {                                      Name = "Read ahead file counter"'                                      IsBackground = true                                  };                                  parallelScanner.Start(snapshot);                              }                                string lasttempfilelist = null;                              long lasttempfileid = -1;                              if (!m_options.DisableSyntheticFilelist)                              {                                  var candidates = m_database.GetIncompleteFilesets(null).OrderBy(x => x.Value).ToArray();                                  if (candidates.Length > 0)                                  {                                      lasttempfileid = candidates.Last().Key;                                      lasttempfilelist = m_database.GetRemoteVolumeFromID(lasttempfileid).Name;                                  }                              }                                // Verify before uploading a synthetic list                              PreBackupVerify(backend' lasttempfilelist);                                // If we have an incomplete entry' upload it now                              if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace(lasttempfilelist) && lasttempfileid >= 0)                              {                                  // Check that we still need to process this after the cleanup has performed its duties                                  var syntbase = m_database.GetRemoteVolumeFromID(lasttempfileid);                                  if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary))                                  {                                      UploadSyntheticFilelist(backend);                                        // Remove the protected file                                      if (syntbase.State == RemoteVolumeState.Uploading)                                      {                                          m_result.AddMessage(string.Format("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));                                          backend.Delete(syntbase.Name' syntbase.Size);                                      }                                      else if (syntbase.State == RemoteVolumeState.Temporary)                                      {                                          m_result.AddMessage(string.Format("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));                                          m_database.RemoveRemoteVolume(syntbase.Name);                                      }                                  }                                  else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)                                      m_result.AddWarning(string.Format("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);                              }                                var prevfileset = m_database.FilesetTimes.FirstOrDefault();                              if (prevfileset.Value.ToUniversalTime() > m_database.OperationTimestamp.ToUniversalTime())                                  throw new UserInformationException(string.Format("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime()' m_database.OperationTimestamp.ToLocalTime()));                                                            m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;                                // Rebuild any index files that are missing                              RecreateMissingIndexFiles(backend);                                m_database.BuildLookupTable(m_options);                              m_transaction = m_database.BeginTransaction();                                var repcnt = 0;                              while(repcnt < 100 && m_database.GetRemoteVolumeID(filesetvolume.RemoteFilename) >= 0)                                  filesetvolume.ResetRemoteFilename(m_options' m_database.OperationTimestamp.AddSeconds(repcnt++));                                                            if (m_database.GetRemoteVolumeID(filesetvolume.RemoteFilename) >= 0)                                  throw new Exception("Unable to generate a unique fileset name");                                m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_ProcessingFiles);                              var filesetvolumeid = m_database.RegisterRemoteVolume(filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);                              m_database.CreateFileset(filesetvolumeid' VolumeBase.ParseFilename(filesetvolume.RemoteFilename).Time' m_transaction);                                            RunMainOperation(snapshot' backend);                                //If the scanner is still running for some reason' make sure we kill it now                               if (parallelScanner != null && parallelScanner.IsAlive)                                  parallelScanner.Abort();                          }                            var lastVolumeSize = FinalizeRemoteVolumes(backend);                                                    using(new Logging.Timer("UpdateChangeStatistics"))                              m_database.UpdateChangeStatistics(m_result);                          using(new Logging.Timer("VerifyConsistency"))                              m_database.VerifyConsistency(m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);                                UploadRealFileList(backend' filesetvolume);                                                                    m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_WaitForUpload);                          using(new Logging.Timer("Async backend wait"))                              backend.WaitForEmpty(m_database' m_transaction);                                                        if (m_result.TaskControlRendevouz() != TaskControlState.Stop)                               CompactIfRequired(backend' lastVolumeSize);  						using (new Logging.Timer("Async backend wait"))                             backend.WaitForComplete(m_database' m_transaction);  						if (m_options.UploadVerificationFile)                          {                              m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_VerificationUpload);                              FilelistProcessor.UploadVerificationFile(backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);                          }                            if (m_options.Dryrun)                          {                              m_transaction.Rollback();                              m_transaction = null;                          }                          else                          {                              using(new Logging.Timer("CommitFinalizingBackup"))                                  m_transaction.Commit();                                                                m_transaction = null;                                if (m_result.TaskControlRendevouz() != TaskControlState.Stop)                              {                                  if (m_options.NoBackendverification)                                      UpdateStorageStatsFromDatabase();                                  else                                      PostBackupVerification();                              }                          }                                                    m_database.WriteResults();                                              m_database.PurgeLogData(m_options.LogRetention);                          if (m_options.AutoVacuum)                          {                              m_database.Vacuum();                          }                          m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_Complete);                          return;                      }                  }                  catch (Exception ex)                  {                      m_result.AddError("Fatal error"' ex);                      throw;                  }                  finally                  {                      if (parallelScanner != null && parallelScanner.IsAlive)                      {                          parallelScanner.Abort();                          parallelScanner.Join(500);                          if (parallelScanner.IsAlive)                              m_result.AddWarning("Failed to terminate filecounter thread"' null);                      }                                        if (m_transaction != null)                          try { m_transaction.Rollback(); }                          catch (Exception ex) { m_result.AddError(string.Format("Rollback error: {0}"' ex.Message)' ex); }                  }              }
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: using(m_database = new LocalBackupDatabase(m_options.Dbpath' m_options))              {                  m_result.SetDatabase(m_database);                  m_result.Dryrun = m_options.Dryrun;                    Utility.UpdateOptionsFromDb(m_database' m_options);                  Utility.VerifyParameters(m_database' m_options);                    var probe_path = m_database.GetFirstPath();                  if (probe_path != null && Duplicati.Library.Utility.Utility.GuessDirSeparator(probe_path) != System.IO.Path.DirectorySeparatorChar.ToString())                      throw new UserInformationException(string.Format("The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems' which is not supported. To proceed without losing remote data' delete all filesets and make sure the --{0} option is set' then run the backup again to re-use the existing data on the remote store."' "no-auto-compact"));                    if (m_database.PartiallyRecreated)                      throw new UserInformationException("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");                                    if (m_database.RepairInProgress)                      throw new UserInformationException("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the backup process cannot continue. You may delete the local database and attempt to repair it again.");                    m_blocksize = m_options.Blocksize;                  m_maxmetadatasize = (m_blocksize / (long)m_options.BlockhashSize) * m_blocksize;                    m_blockbuffer = new byte[m_options.Blocksize * Math.Max(1' m_options.FileReadBufferSize / m_options.Blocksize)];                  m_blocklistbuffer = new byte[m_options.Blocksize];                    m_blockhasher = Library.Utility.HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm);                  m_filehasher = Library.Utility.HashAlgorithmHelper.Create(m_options.FileHashAlgorithm);                    if (m_blockhasher == null)                      throw new UserInformationException(Strings.Common.InvalidHashAlgorithm(m_options.BlockHashAlgorithm));                  if (m_filehasher == null)                      throw new UserInformationException(Strings.Common.InvalidHashAlgorithm(m_options.FileHashAlgorithm));                    if (!m_blockhasher.CanReuseTransform)                      throw new UserInformationException(Strings.Common.InvalidCryptoSystem(m_options.BlockHashAlgorithm));                  if (!m_filehasher.CanReuseTransform)                      throw new UserInformationException(Strings.Common.InvalidCryptoSystem(m_options.FileHashAlgorithm));                    m_database.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' false);                  // If there is no filter' we set an empty filter to simplify the code                  // If there is a filter' we make sure that the sources are included                  m_filter = filter ?? new Library.Utility.FilterExpression();                  m_sourceFilter = new Library.Utility.FilterExpression(sources' true);                                    m_backendLogFlushTimer = DateTime.Now.Add(FLUSH_TIMESPAN);                  System.Threading.Thread parallelScanner = null;                        try                  {                      using(var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' m_database))                      using(var filesetvolume = new FilesetVolumeWriter(m_options' m_database.OperationTimestamp))                      {                          using(var snapshot = GetSnapshot(sources' m_options' m_result))                          {                              // Start parallel scan                              if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1)                              {                                  parallelScanner = new System.Threading.Thread(CountFilesThread) {                                      Name = "Read ahead file counter"'                                      IsBackground = true                                  };                                  parallelScanner.Start(snapshot);                              }                                string lasttempfilelist = null;                              long lasttempfileid = -1;                              if (!m_options.DisableSyntheticFilelist)                              {                                  var candidates = m_database.GetIncompleteFilesets(null).OrderBy(x => x.Value).ToArray();                                  if (candidates.Length > 0)                                  {                                      lasttempfileid = candidates.Last().Key;                                      lasttempfilelist = m_database.GetRemoteVolumeFromID(lasttempfileid).Name;                                  }                              }                                // Verify before uploading a synthetic list                              PreBackupVerify(backend' lasttempfilelist);                                // If we have an incomplete entry' upload it now                              if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace(lasttempfilelist) && lasttempfileid >= 0)                              {                                  // Check that we still need to process this after the cleanup has performed its duties                                  var syntbase = m_database.GetRemoteVolumeFromID(lasttempfileid);                                  if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary))                                  {                                      UploadSyntheticFilelist(backend);                                        // Remove the protected file                                      if (syntbase.State == RemoteVolumeState.Uploading)                                      {                                          m_result.AddMessage(string.Format("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));                                          backend.Delete(syntbase.Name' syntbase.Size);                                      }                                      else if (syntbase.State == RemoteVolumeState.Temporary)                                      {                                          m_result.AddMessage(string.Format("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));                                          m_database.RemoveRemoteVolume(syntbase.Name);                                      }                                  }                                  else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)                                      m_result.AddWarning(string.Format("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);                              }                                var prevfileset = m_database.FilesetTimes.FirstOrDefault();                              if (prevfileset.Value.ToUniversalTime() > m_database.OperationTimestamp.ToUniversalTime())                                  throw new UserInformationException(string.Format("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime()' m_database.OperationTimestamp.ToLocalTime()));                                                            m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;                                // Rebuild any index files that are missing                              RecreateMissingIndexFiles(backend);                                m_database.BuildLookupTable(m_options);                              m_transaction = m_database.BeginTransaction();                                var repcnt = 0;                              while(repcnt < 100 && m_database.GetRemoteVolumeID(filesetvolume.RemoteFilename) >= 0)                                  filesetvolume.ResetRemoteFilename(m_options' m_database.OperationTimestamp.AddSeconds(repcnt++));                                                            if (m_database.GetRemoteVolumeID(filesetvolume.RemoteFilename) >= 0)                                  throw new Exception("Unable to generate a unique fileset name");                                m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_ProcessingFiles);                              var filesetvolumeid = m_database.RegisterRemoteVolume(filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);                              m_database.CreateFileset(filesetvolumeid' VolumeBase.ParseFilename(filesetvolume.RemoteFilename).Time' m_transaction);                                            RunMainOperation(snapshot' backend);                                //If the scanner is still running for some reason' make sure we kill it now                               if (parallelScanner != null && parallelScanner.IsAlive)                                  parallelScanner.Abort();                          }                            var lastVolumeSize = FinalizeRemoteVolumes(backend);                                                    using(new Logging.Timer("UpdateChangeStatistics"))                              m_database.UpdateChangeStatistics(m_result);                          using(new Logging.Timer("VerifyConsistency"))                              m_database.VerifyConsistency(m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);                                UploadRealFileList(backend' filesetvolume);                                                                    m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_WaitForUpload);                          using(new Logging.Timer("Async backend wait"))                              backend.WaitForEmpty(m_database' m_transaction);                                                        if (m_result.TaskControlRendevouz() != TaskControlState.Stop)                               CompactIfRequired(backend' lastVolumeSize);  						using (new Logging.Timer("Async backend wait"))                             backend.WaitForComplete(m_database' m_transaction);  						if (m_options.UploadVerificationFile)                          {                              m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_VerificationUpload);                              FilelistProcessor.UploadVerificationFile(backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);                          }                            if (m_options.Dryrun)                          {                              m_transaction.Rollback();                              m_transaction = null;                          }                          else                          {                              using(new Logging.Timer("CommitFinalizingBackup"))                                  m_transaction.Commit();                                                                m_transaction = null;                                if (m_result.TaskControlRendevouz() != TaskControlState.Stop)                              {                                  if (m_options.NoBackendverification)                                      UpdateStorageStatsFromDatabase();                                  else                                      PostBackupVerification();                              }                          }                                                    m_database.WriteResults();                                              m_database.PurgeLogData(m_options.LogRetention);                          if (m_options.AutoVacuum)                          {                              m_database.Vacuum();                          }                          m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.Backup_Complete);                          return;                      }                  }                  catch (Exception ex)                  {                      m_result.AddError("Fatal error"' ex);                      throw;                  }                  finally                  {                      if (parallelScanner != null && parallelScanner.IsAlive)                      {                          parallelScanner.Abort();                          parallelScanner.Join(500);                          if (parallelScanner.IsAlive)                              m_result.AddWarning("Failed to terminate filecounter thread"' null);                      }                                        if (m_transaction != null)                          try { m_transaction.Rollback(); }                          catch (Exception ex) { m_result.AddError(string.Format("Rollback error: {0}"' ex.Message)' ex); }                  }              }
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: using(var restoredb = new LocalRecreateDatabase(dbparent' m_options))              using(var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' restoredb))              {                  restoredb.RepairInProgress = true;                    var volumeIds = new Dictionary<string' long>();                    var rawlist = backend.List();                            //First step is to examine the remote storage to see what                  // kind of data we can find                  var remotefiles =                  (from x in rawlist                  let n = VolumeBase.ParseFilename(x)                  where                      n != null                          &&                      n.Prefix == m_options.Prefix                  select n).ToArray(); //ToArray() ensures that we do not remote-request it multiple times                    if (remotefiles.Length == 0)                  {                      if (rawlist.Count == 0)                          throw new UserInformationException("No files were found at the remote location' perhaps the target url is incorrect?");                      else                      {                          var tmp =                       (from x in rawlist                          let n = VolumeBase.ParseFilename(x)                      where                          n != null                      select n.Prefix).ToArray();                                            var types = tmp.Distinct().ToArray();                          if (tmp.Length == 0)                              throw new UserInformationException(string.Format("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count));                          else if (types.Length == 1)                              throw new UserInformationException(string.Format("Found {0} parse-able files with the prefix {1}' did you forget to set the backup prefix?"' tmp.Length' types[0]));                          else                              throw new UserInformationException(string.Format("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup prefix?"' tmp.Length' rawlist.Count' string.Join("' "' types)));                      }                  }                    //Then we select the filelist we should work with'                  // and create the filelist table to fit                  IEnumerable<IParsedVolume> filelists =                      from n in remotefiles                      where n.FileType == RemoteVolumeType.Files                      orderby n.Time descending                      select n;                    if (filelists.Count() <= 0)                      throw new UserInformationException(string.Format("No filelists found on the remote destination"));                                    if (filelistfilter != null)                      filelists = filelistfilter(filelists).Select(x => x.Value).ToArray();                    if (filelists.Count() <= 0)                      throw new UserInformationException(string.Format("No filelists"));                    // If we are updating' all files should be accounted for                  foreach(var fl in remotefiles)                      volumeIds[fl.File.Name] = updating ? restoredb.GetRemoteVolumeID(fl.File.Name) : restoredb.RegisterRemoteVolume(fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded);                    var hasUpdatedOptions = false;                    if (updating)                  {                      Utility.UpdateOptionsFromDb(restoredb' m_options);                      Utility.VerifyParameters(restoredb' m_options);                  }                    //Record all blocksets and files needed                  using(var tr = restoredb.BeginTransaction())                  {                      var filelistWork = (from n in filelists orderby n.Time select new RemoteVolume(n.File) as IRemoteVolume).ToList();                      m_result.AddMessage(string.Format("Rebuild database started' downloading {0} filelists"' filelistWork.Count));                        var progress = 0;                        // Register the files we are working with' if not already updated                      if (updating)                      {                          foreach(var n in filelists)                              if (volumeIds[n.File.Name] == -1)                                  volumeIds[n.File.Name] = restoredb.RegisterRemoteVolume(n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan(0)' tr);                      }                                                        var isFirstFilelist = true;                      var blocksize = m_options.Blocksize;                      var hashes_pr_block = blocksize / m_options.BlockhashSize;                        foreach(var entry in new AsyncDownloader(filelistWork' backend))                          try                          {                              if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                              {                                  backend.WaitForComplete(restoredb' null);                                  m_result.EndTime = DateTime.UtcNow;                                  return;                              }                                                            progress++;                              if (filelistWork.Count == 1 && m_options.RepairOnlyPaths)                                  m_result.OperationProgressUpdater.UpdateProgress(0.5f);                              else                                  m_result.OperationProgressUpdater.UpdateProgress(((float)progress / filelistWork.Count()) * (m_options.RepairOnlyPaths ? 1f : 0.2f));                                using(var tmpfile = entry.TempFile)                              {                                  isFirstFilelist = false;                                    if (entry.Hash != null && entry.Size > 0)                                      restoredb.UpdateRemoteVolume(entry.Name' RemoteVolumeState.Verified' entry.Size' entry.Hash' tr);                                    var parsed = VolumeBase.ParseFilename(entry.Name);                                    if (!hasUpdatedOptions && !updating)                                   {                                      VolumeReaderBase.UpdateOptionsFromManifest(parsed.CompressionModule' tmpfile' m_options);                                      hasUpdatedOptions = true;                                      // Recompute the cached sizes                                      blocksize = m_options.Blocksize;                                      hashes_pr_block = blocksize / m_options.BlockhashSize;                                  }                                      // Create timestamped operations based on the file timestamp                                  var filesetid = restoredb.CreateFileset(volumeIds[entry.Name]' parsed.Time' tr);                                  using(var filelistreader = new FilesetVolumeReader(parsed.CompressionModule' tmpfile' m_options))                                      foreach(var fe in filelistreader.Files.Where(x => Library.Utility.FilterExpression.Matches(filter' x.Path)))                                      {                                          try                                          {                                              var expectedmetablocks = (fe.Metasize + blocksize - 1)  / blocksize;                                              var expectedmetablocklisthashes = (expectedmetablocks + hashes_pr_block - 1) / hashes_pr_block;                                              if (expectedmetablocks <= 1) expectedmetablocklisthashes = 0;                                                var metadataid = long.MinValue;                                              switch (fe.Type)                                              {                                                  case FilelistEntryType.Folder:                                                      metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);                                                      restoredb.AddDirectoryEntry(filesetid' fe.Path' fe.Time' metadataid' tr);                                                      break;                                                  case FilelistEntryType.File:                                                      var expectedblocks = (fe.Size + blocksize - 1) / blocksize;                                                      var expectedblocklisthashes = (expectedblocks + hashes_pr_block - 1) / hashes_pr_block;                                                      if (expectedblocks <= 1) expectedblocklisthashes = 0;                                                        var blocksetid = restoredb.AddBlockset(fe.Hash' fe.Size' fe.BlocklistHashes' expectedblocklisthashes' tr);                                                      metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);                                                      restoredb.AddFileEntry(filesetid' fe.Path' fe.Time' blocksetid' metadataid' tr);                                                        if (fe.Size <= blocksize)                                                      {                                                          if (!string.IsNullOrWhiteSpace(fe.Blockhash))                                                              restoredb.AddSmallBlocksetLink(fe.Hash' fe.Blockhash' fe.Blocksize' tr);                                                          else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)                                                              restoredb.AddSmallBlocksetLink(fe.Hash' fe.Hash' fe.Size' tr);                                                          else                                                              m_result.AddWarning(string.Format("No block hash found for file: {0}"' fe.Path)' null);                                                      }                                                        break;                                                  case FilelistEntryType.Symlink:                                                      metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);                                                      restoredb.AddSymlinkEntry(filesetid' fe.Path' fe.Time' metadataid' tr);                                                      break;                                                  default:                                                      m_result.AddWarning(string.Format("Skipping file-entry with unknown type {0}: {1} "' fe.Type' fe.Path)' null);                                                      break;                                              }                                                if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink))                                              {                                                  if (!string.IsNullOrWhiteSpace(fe.Metablockhash))                                                      restoredb.AddSmallBlocksetLink(fe.Metahash' fe.Metablockhash' fe.Metasize' tr);                                                  else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)                                                      restoredb.AddSmallBlocksetLink(fe.Metahash' fe.Metahash' fe.Metasize' tr);                                                  else                                                      m_result.AddWarning(string.Format("No block hash found for file metadata: {0}"' fe.Path)' null);                                                                                              }                                          }                                          catch (Exception ex)                                          {                                              m_result.AddWarning(string.Format("Failed to process file-entry: {0}"' fe.Path)' ex);                                          }                                      }                              }                          }                          catch (Exception ex)                          {                              m_result.AddWarning(string.Format("Failed to process file: {0}"' entry.Name)' ex);                              if (ex is System.Threading.ThreadAbortException)                              {                                  m_result.EndTime = DateTime.UtcNow;                                  throw;                              }                                if (isFirstFilelist && ex is System.Security.Cryptography.CryptographicException)                              {                                  m_result.EndTime = DateTime.UtcNow;                                  throw;                              }                          }                        //Make sure we write the config                      if (!updating)                          Utility.VerifyParameters(restoredb' m_options' tr);                        using(new Logging.Timer("CommitUpdateFilesetFromRemote"))                          tr.Commit();                  }                                if (!m_options.RepairOnlyPaths)                  {                      var hashalg = Library.Utility.HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm);                      if (hashalg == null)                          throw new UserInformationException(Strings.Common.InvalidHashAlgorithm(m_options.BlockHashAlgorithm));                      var hashsize = hashalg.HashSize / 8;                        //Grab all index files' and update the block table                      using(var tr = restoredb.BeginTransaction())                      {                          var indexfiles = (                                           from n in remotefiles                                            where n.FileType == RemoteVolumeType.Index                                            select new RemoteVolume(n.File) as IRemoteVolume).ToList();                            m_result.AddMessage(string.Format("Filelists restored' downloading {0} index files"' indexfiles.Count));                            var progress = 0;                                                                foreach(var sf in new AsyncDownloader(indexfiles' backend))                              try                              {                                  if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                                  {                                      backend.WaitForComplete(restoredb' null);                                      m_result.EndTime = DateTime.UtcNow;                                      return;                                  }                                    progress++;                                  m_result.OperationProgressUpdater.UpdateProgress((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);                                    using(var tmpfile = sf.TempFile)                                  {                                      if (sf.Hash != null && sf.Size > 0)                                          restoredb.UpdateRemoteVolume(sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);                                                        using(var svr = new IndexVolumeReader(RestoreHandler.GetCompressionModule(sf.Name)' tmpfile' m_options' hashsize))                                      {                                          foreach(var a in svr.Volumes)                                          {                                              var filename = a.Filename;                                              var volumeID = restoredb.GetRemoteVolumeID(filename);                                                // No such file                                              if (volumeID < 0)                                                  volumeID = ProbeForMatchingFilename(ref filename' restoredb);                                                // Still broken' register a missing item                                              if (volumeID < 0)                                              {                                                  var p = VolumeBase.ParseFilename(filename);                                                  if (p == null)                                                      throw new Exception(string.Format("Unable to parse filename: {0}"' filename));                                                  m_result.AddError(string.Format("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);                                                  volumeID = restoredb.RegisterRemoteVolume(filename' p.FileType' RemoteVolumeState.Verified' tr);                                              }                                                                                            //Add all block/volume mappings                                              foreach(var b in a.Blocks)                                                  restoredb.UpdateBlock(b.Key' b.Value' volumeID' tr);                                                restoredb.UpdateRemoteVolume(filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);                                              restoredb.AddIndexBlockLink(restoredb.GetRemoteVolumeID(sf.Name)' volumeID' tr);                                          }                                                                            //If there are blocklists in the index file' update the blocklists                                          foreach(var b in svr.BlockLists)                                              restoredb.UpdateBlockset(b.Hash' b.Blocklist' tr);                                      }                                  }                              }                              catch (Exception ex)                              {                                  //Not fatal                                  m_result.AddWarning(string.Format("Failed to process index file: {0}"' sf.Name)' ex);                                  if (ex is System.Threading.ThreadAbortException)                                  {                                      m_result.EndTime = DateTime.UtcNow;                                      throw;                                  }                              }                            using(new Logging.Timer("CommitRecreatedDb"))                              tr.Commit();                                                // TODO: In some cases' we can avoid downloading all index files'                           // if we are lucky and pick the right ones                      }                        // We have now grabbed as much information as possible'                      // if we are still missing data' we must now fetch block files                      restoredb.FindMissingBlocklistHashes(hashsize' m_options.Blocksize' null);                                        //We do this in three passes                      for(var i = 0; i < 3; i++)                      {                          // Grab the list matching the pass type                          var lst = restoredb.GetMissingBlockListVolumes(i' m_options.Blocksize' hashsize).ToList();                          if (lst.Count > 0)                          {                              switch (i)                              {                                  case 0:                                      if (m_options.Verbose)                                          m_result.AddVerboseMessage("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name)));                                      else                                          m_result.AddMessage(string.Format("Processing required {0} blocklist volumes"' lst.Count));                                      break;                                  case 1:                                      if (m_options.Verbose)                                          m_result.AddVerboseMessage("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name)));                                      else                                          m_result.AddMessage(string.Format("Probing {0} candidate blocklist volumes"' lst.Count));                                      break;                                  default:                                      if (m_options.Verbose)                                          m_result.AddVerboseMessage("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name)));                                      else                                          m_result.AddMessage(string.Format("Processing all of the {0} volumes for blocklists"' lst.Count));                                      break;                              }                          }                            var progress = 0;                          foreach(var sf in new AsyncDownloader(lst' backend))                              using(var tmpfile = sf.TempFile)                              using(var rd = new BlockVolumeReader(RestoreHandler.GetCompressionModule(sf.Name)' tmpfile' m_options))                              using(var tr = restoredb.BeginTransaction())                              {                                  if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                                  {                                      backend.WaitForComplete(restoredb' null);                                      m_result.EndTime = DateTime.UtcNow;                                      return;                                  }                                                                    progress++;                                  m_result.OperationProgressUpdater.UpdateProgress((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));                                    var volumeid = restoredb.GetRemoteVolumeID(sf.Name);                                    restoredb.UpdateRemoteVolume(sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);                                                                // Update the block table so we know about the block/volume map                                  foreach(var h in rd.Blocks)                                      restoredb.UpdateBlock(h.Key' h.Value' volumeid' tr);                                                                // Grab all known blocklists from the volume                                  foreach(var blocklisthash in restoredb.GetBlockLists(volumeid))                                      restoredb.UpdateBlockset(blocklisthash' rd.ReadBlocklist(blocklisthash' hashsize)' tr);                                        // Update tables so we know if we are done                                  restoredb.FindMissingBlocklistHashes(hashsize' m_options.Blocksize' tr);                                                            using(new Logging.Timer("CommitRestoredBlocklist"))                                      tr.Commit();                                        //At this point we can patch files with data from the block volume                                  if (blockprocessor != null)                                      blockprocessor(sf.Name' rd);                              }                      }                  }                                    backend.WaitForComplete(restoredb' null);                    if (m_options.RepairOnlyPaths)                  {                      m_result.AddMessage("Recreate/path-update completed' not running consistency checks");                  }                  else                  {                      m_result.AddMessage("Recreate completed' verifying the database consistency");                        //All done' we must verify that we have all blocklist fully intact                      // if this fails' the db will not be deleted' so it can be used'                      // except to continue a backup                      m_result.EndTime = DateTime.UtcNow;                        using (var lbfdb = new LocalListBrokenFilesDatabase(restoredb))                      {                          var broken = lbfdb.GetBrokenFilesets(new DateTime(0)' null' null).Count();                          if (broken != 0)                              throw new UserInformationException(string.Format("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files"));                      }                        restoredb.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' true);                        m_result.AddMessage("Recreate completed' and consistency checks completed' marking database as complete");                        restoredb.RepairInProgress = false;                  }                    m_result.EndTime = DateTime.UtcNow;              }
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: using(var restoredb = new LocalRecreateDatabase(dbparent' m_options))              using(var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' restoredb))              {                  restoredb.RepairInProgress = true;                    var volumeIds = new Dictionary<string' long>();                    var rawlist = backend.List();                            //First step is to examine the remote storage to see what                  // kind of data we can find                  var remotefiles =                  (from x in rawlist                  let n = VolumeBase.ParseFilename(x)                  where                      n != null                          &&                      n.Prefix == m_options.Prefix                  select n).ToArray(); //ToArray() ensures that we do not remote-request it multiple times                    if (remotefiles.Length == 0)                  {                      if (rawlist.Count == 0)                          throw new UserInformationException("No files were found at the remote location' perhaps the target url is incorrect?");                      else                      {                          var tmp =                       (from x in rawlist                          let n = VolumeBase.ParseFilename(x)                      where                          n != null                      select n.Prefix).ToArray();                                            var types = tmp.Distinct().ToArray();                          if (tmp.Length == 0)                              throw new UserInformationException(string.Format("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count));                          else if (types.Length == 1)                              throw new UserInformationException(string.Format("Found {0} parse-able files with the prefix {1}' did you forget to set the backup prefix?"' tmp.Length' types[0]));                          else                              throw new UserInformationException(string.Format("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup prefix?"' tmp.Length' rawlist.Count' string.Join("' "' types)));                      }                  }                    //Then we select the filelist we should work with'                  // and create the filelist table to fit                  IEnumerable<IParsedVolume> filelists =                      from n in remotefiles                      where n.FileType == RemoteVolumeType.Files                      orderby n.Time descending                      select n;                    if (filelists.Count() <= 0)                      throw new UserInformationException(string.Format("No filelists found on the remote destination"));                                    if (filelistfilter != null)                      filelists = filelistfilter(filelists).Select(x => x.Value).ToArray();                    if (filelists.Count() <= 0)                      throw new UserInformationException(string.Format("No filelists"));                    // If we are updating' all files should be accounted for                  foreach(var fl in remotefiles)                      volumeIds[fl.File.Name] = updating ? restoredb.GetRemoteVolumeID(fl.File.Name) : restoredb.RegisterRemoteVolume(fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded);                    var hasUpdatedOptions = false;                    if (updating)                  {                      Utility.UpdateOptionsFromDb(restoredb' m_options);                      Utility.VerifyParameters(restoredb' m_options);                  }                    //Record all blocksets and files needed                  using(var tr = restoredb.BeginTransaction())                  {                      var filelistWork = (from n in filelists orderby n.Time select new RemoteVolume(n.File) as IRemoteVolume).ToList();                      m_result.AddMessage(string.Format("Rebuild database started' downloading {0} filelists"' filelistWork.Count));                        var progress = 0;                        // Register the files we are working with' if not already updated                      if (updating)                      {                          foreach(var n in filelists)                              if (volumeIds[n.File.Name] == -1)                                  volumeIds[n.File.Name] = restoredb.RegisterRemoteVolume(n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan(0)' tr);                      }                                                        var isFirstFilelist = true;                      var blocksize = m_options.Blocksize;                      var hashes_pr_block = blocksize / m_options.BlockhashSize;                        foreach(var entry in new AsyncDownloader(filelistWork' backend))                          try                          {                              if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                              {                                  backend.WaitForComplete(restoredb' null);                                  m_result.EndTime = DateTime.UtcNow;                                  return;                              }                                                            progress++;                              if (filelistWork.Count == 1 && m_options.RepairOnlyPaths)                                  m_result.OperationProgressUpdater.UpdateProgress(0.5f);                              else                                  m_result.OperationProgressUpdater.UpdateProgress(((float)progress / filelistWork.Count()) * (m_options.RepairOnlyPaths ? 1f : 0.2f));                                using(var tmpfile = entry.TempFile)                              {                                  isFirstFilelist = false;                                    if (entry.Hash != null && entry.Size > 0)                                      restoredb.UpdateRemoteVolume(entry.Name' RemoteVolumeState.Verified' entry.Size' entry.Hash' tr);                                    var parsed = VolumeBase.ParseFilename(entry.Name);                                    if (!hasUpdatedOptions && !updating)                                   {                                      VolumeReaderBase.UpdateOptionsFromManifest(parsed.CompressionModule' tmpfile' m_options);                                      hasUpdatedOptions = true;                                      // Recompute the cached sizes                                      blocksize = m_options.Blocksize;                                      hashes_pr_block = blocksize / m_options.BlockhashSize;                                  }                                      // Create timestamped operations based on the file timestamp                                  var filesetid = restoredb.CreateFileset(volumeIds[entry.Name]' parsed.Time' tr);                                  using(var filelistreader = new FilesetVolumeReader(parsed.CompressionModule' tmpfile' m_options))                                      foreach(var fe in filelistreader.Files.Where(x => Library.Utility.FilterExpression.Matches(filter' x.Path)))                                      {                                          try                                          {                                              var expectedmetablocks = (fe.Metasize + blocksize - 1)  / blocksize;                                              var expectedmetablocklisthashes = (expectedmetablocks + hashes_pr_block - 1) / hashes_pr_block;                                              if (expectedmetablocks <= 1) expectedmetablocklisthashes = 0;                                                var metadataid = long.MinValue;                                              switch (fe.Type)                                              {                                                  case FilelistEntryType.Folder:                                                      metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);                                                      restoredb.AddDirectoryEntry(filesetid' fe.Path' fe.Time' metadataid' tr);                                                      break;                                                  case FilelistEntryType.File:                                                      var expectedblocks = (fe.Size + blocksize - 1) / blocksize;                                                      var expectedblocklisthashes = (expectedblocks + hashes_pr_block - 1) / hashes_pr_block;                                                      if (expectedblocks <= 1) expectedblocklisthashes = 0;                                                        var blocksetid = restoredb.AddBlockset(fe.Hash' fe.Size' fe.BlocklistHashes' expectedblocklisthashes' tr);                                                      metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);                                                      restoredb.AddFileEntry(filesetid' fe.Path' fe.Time' blocksetid' metadataid' tr);                                                        if (fe.Size <= blocksize)                                                      {                                                          if (!string.IsNullOrWhiteSpace(fe.Blockhash))                                                              restoredb.AddSmallBlocksetLink(fe.Hash' fe.Blockhash' fe.Blocksize' tr);                                                          else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)                                                              restoredb.AddSmallBlocksetLink(fe.Hash' fe.Hash' fe.Size' tr);                                                          else                                                              m_result.AddWarning(string.Format("No block hash found for file: {0}"' fe.Path)' null);                                                      }                                                        break;                                                  case FilelistEntryType.Symlink:                                                      metadataid = restoredb.AddMetadataset(fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);                                                      restoredb.AddSymlinkEntry(filesetid' fe.Path' fe.Time' metadataid' tr);                                                      break;                                                  default:                                                      m_result.AddWarning(string.Format("Skipping file-entry with unknown type {0}: {1} "' fe.Type' fe.Path)' null);                                                      break;                                              }                                                if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink))                                              {                                                  if (!string.IsNullOrWhiteSpace(fe.Metablockhash))                                                      restoredb.AddSmallBlocksetLink(fe.Metahash' fe.Metablockhash' fe.Metasize' tr);                                                  else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)                                                      restoredb.AddSmallBlocksetLink(fe.Metahash' fe.Metahash' fe.Metasize' tr);                                                  else                                                      m_result.AddWarning(string.Format("No block hash found for file metadata: {0}"' fe.Path)' null);                                                                                              }                                          }                                          catch (Exception ex)                                          {                                              m_result.AddWarning(string.Format("Failed to process file-entry: {0}"' fe.Path)' ex);                                          }                                      }                              }                          }                          catch (Exception ex)                          {                              m_result.AddWarning(string.Format("Failed to process file: {0}"' entry.Name)' ex);                              if (ex is System.Threading.ThreadAbortException)                              {                                  m_result.EndTime = DateTime.UtcNow;                                  throw;                              }                                if (isFirstFilelist && ex is System.Security.Cryptography.CryptographicException)                              {                                  m_result.EndTime = DateTime.UtcNow;                                  throw;                              }                          }                        //Make sure we write the config                      if (!updating)                          Utility.VerifyParameters(restoredb' m_options' tr);                        using(new Logging.Timer("CommitUpdateFilesetFromRemote"))                          tr.Commit();                  }                                if (!m_options.RepairOnlyPaths)                  {                      var hashalg = Library.Utility.HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm);                      if (hashalg == null)                          throw new UserInformationException(Strings.Common.InvalidHashAlgorithm(m_options.BlockHashAlgorithm));                      var hashsize = hashalg.HashSize / 8;                        //Grab all index files' and update the block table                      using(var tr = restoredb.BeginTransaction())                      {                          var indexfiles = (                                           from n in remotefiles                                            where n.FileType == RemoteVolumeType.Index                                            select new RemoteVolume(n.File) as IRemoteVolume).ToList();                            m_result.AddMessage(string.Format("Filelists restored' downloading {0} index files"' indexfiles.Count));                            var progress = 0;                                                                foreach(var sf in new AsyncDownloader(indexfiles' backend))                              try                              {                                  if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                                  {                                      backend.WaitForComplete(restoredb' null);                                      m_result.EndTime = DateTime.UtcNow;                                      return;                                  }                                    progress++;                                  m_result.OperationProgressUpdater.UpdateProgress((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);                                    using(var tmpfile = sf.TempFile)                                  {                                      if (sf.Hash != null && sf.Size > 0)                                          restoredb.UpdateRemoteVolume(sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);                                                        using(var svr = new IndexVolumeReader(RestoreHandler.GetCompressionModule(sf.Name)' tmpfile' m_options' hashsize))                                      {                                          foreach(var a in svr.Volumes)                                          {                                              var filename = a.Filename;                                              var volumeID = restoredb.GetRemoteVolumeID(filename);                                                // No such file                                              if (volumeID < 0)                                                  volumeID = ProbeForMatchingFilename(ref filename' restoredb);                                                // Still broken' register a missing item                                              if (volumeID < 0)                                              {                                                  var p = VolumeBase.ParseFilename(filename);                                                  if (p == null)                                                      throw new Exception(string.Format("Unable to parse filename: {0}"' filename));                                                  m_result.AddError(string.Format("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);                                                  volumeID = restoredb.RegisterRemoteVolume(filename' p.FileType' RemoteVolumeState.Verified' tr);                                              }                                                                                            //Add all block/volume mappings                                              foreach(var b in a.Blocks)                                                  restoredb.UpdateBlock(b.Key' b.Value' volumeID' tr);                                                restoredb.UpdateRemoteVolume(filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);                                              restoredb.AddIndexBlockLink(restoredb.GetRemoteVolumeID(sf.Name)' volumeID' tr);                                          }                                                                            //If there are blocklists in the index file' update the blocklists                                          foreach(var b in svr.BlockLists)                                              restoredb.UpdateBlockset(b.Hash' b.Blocklist' tr);                                      }                                  }                              }                              catch (Exception ex)                              {                                  //Not fatal                                  m_result.AddWarning(string.Format("Failed to process index file: {0}"' sf.Name)' ex);                                  if (ex is System.Threading.ThreadAbortException)                                  {                                      m_result.EndTime = DateTime.UtcNow;                                      throw;                                  }                              }                            using(new Logging.Timer("CommitRecreatedDb"))                              tr.Commit();                                                // TODO: In some cases' we can avoid downloading all index files'                           // if we are lucky and pick the right ones                      }                        // We have now grabbed as much information as possible'                      // if we are still missing data' we must now fetch block files                      restoredb.FindMissingBlocklistHashes(hashsize' m_options.Blocksize' null);                                        //We do this in three passes                      for(var i = 0; i < 3; i++)                      {                          // Grab the list matching the pass type                          var lst = restoredb.GetMissingBlockListVolumes(i' m_options.Blocksize' hashsize).ToList();                          if (lst.Count > 0)                          {                              switch (i)                              {                                  case 0:                                      if (m_options.Verbose)                                          m_result.AddVerboseMessage("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name)));                                      else                                          m_result.AddMessage(string.Format("Processing required {0} blocklist volumes"' lst.Count));                                      break;                                  case 1:                                      if (m_options.Verbose)                                          m_result.AddVerboseMessage("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name)));                                      else                                          m_result.AddMessage(string.Format("Probing {0} candidate blocklist volumes"' lst.Count));                                      break;                                  default:                                      if (m_options.Verbose)                                          m_result.AddVerboseMessage("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join("' "' lst.Select(x => x.Name)));                                      else                                          m_result.AddMessage(string.Format("Processing all of the {0} volumes for blocklists"' lst.Count));                                      break;                              }                          }                            var progress = 0;                          foreach(var sf in new AsyncDownloader(lst' backend))                              using(var tmpfile = sf.TempFile)                              using(var rd = new BlockVolumeReader(RestoreHandler.GetCompressionModule(sf.Name)' tmpfile' m_options))                              using(var tr = restoredb.BeginTransaction())                              {                                  if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                                  {                                      backend.WaitForComplete(restoredb' null);                                      m_result.EndTime = DateTime.UtcNow;                                      return;                                  }                                                                    progress++;                                  m_result.OperationProgressUpdater.UpdateProgress((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));                                    var volumeid = restoredb.GetRemoteVolumeID(sf.Name);                                    restoredb.UpdateRemoteVolume(sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);                                                                // Update the block table so we know about the block/volume map                                  foreach(var h in rd.Blocks)                                      restoredb.UpdateBlock(h.Key' h.Value' volumeid' tr);                                                                // Grab all known blocklists from the volume                                  foreach(var blocklisthash in restoredb.GetBlockLists(volumeid))                                      restoredb.UpdateBlockset(blocklisthash' rd.ReadBlocklist(blocklisthash' hashsize)' tr);                                        // Update tables so we know if we are done                                  restoredb.FindMissingBlocklistHashes(hashsize' m_options.Blocksize' tr);                                                            using(new Logging.Timer("CommitRestoredBlocklist"))                                      tr.Commit();                                        //At this point we can patch files with data from the block volume                                  if (blockprocessor != null)                                      blockprocessor(sf.Name' rd);                              }                      }                  }                                    backend.WaitForComplete(restoredb' null);                    if (m_options.RepairOnlyPaths)                  {                      m_result.AddMessage("Recreate/path-update completed' not running consistency checks");                  }                  else                  {                      m_result.AddMessage("Recreate completed' verifying the database consistency");                        //All done' we must verify that we have all blocklist fully intact                      // if this fails' the db will not be deleted' so it can be used'                      // except to continue a backup                      m_result.EndTime = DateTime.UtcNow;                        using (var lbfdb = new LocalListBrokenFilesDatabase(restoredb))                      {                          var broken = lbfdb.GetBrokenFilesets(new DateTime(0)' null' null).Count();                          if (broken != 0)                              throw new UserInformationException(string.Format("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files"));                      }                        restoredb.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' true);                        m_result.AddMessage("Recreate completed' and consistency checks completed' marking database as complete");                        restoredb.RepairInProgress = false;                  }                    m_result.EndTime = DateTime.UtcNow;              }
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker())              using(var volumekeeper = database.GetMissingBlockData(blocks' options.Blocksize))              {                  foreach(var restorelist in volumekeeper.FilesWithMissingBlocks)                  {                      var targetpath = restorelist.Path;                      result.AddVerboseMessage("Patching file with remote data: {0}"' targetpath);                                            if (options.Dryrun)                      {                          result.AddDryrunMessage(string.Format("Would patch file with remote data: {0}"' targetpath));                      }                      else                      {                          try                          {                                 var folderpath = m_systemIO.PathGetDirectoryName(targetpath);                              if (!options.Dryrun && !m_systemIO.DirectoryExists(folderpath))                              {                                  result.AddWarning(string.Format("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);                                  m_systemIO.DirectoryCreate(folderpath);                              }                                                            // TODO: Much faster if we iterate the volume and checks what blocks are used'                              // because the compressors usually like sequential reading                              using(var file = m_systemIO.FileOpenWrite(targetpath))                                  foreach(var targetblock in restorelist.Blocks)                                  {                                      file.Position = targetblock.Offset;                                      var size = blocks.ReadBlock(targetblock.Key' blockbuffer);                                      if (targetblock.Size == size)                                      {                                          var valid = !fullblockverification;                                          if (!valid)                                          {                                              blockhasher.Initialize();                                              var key = Convert.ToBase64String(blockhasher.ComputeHash(blockbuffer' 0' size));                                              if (targetblock.Key == key)                                                  valid = true;                                              else                                                  result.AddWarning(string.Format("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null);                                          }                                            if (valid)                                          {                                              file.Write(blockbuffer' 0' size);                                              blockmarker.SetBlockRestored(restorelist.FileID' targetblock.Offset / blocksize' targetblock.Key' size' false);                                          }                                      }                                       else                                      {                                          result.AddWarning(string.Format("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null);                                      }                                  }                                                            if ((++updateCounter) % 20 == 0)                                  blockmarker.UpdateProcessed(result.OperationProgressUpdater);                          }                          catch (Exception ex)                          {                              result.AddWarning(string.Format("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex);                          }                      }                  }                    if (!options.SkipMetadata)                  {                      foreach(var restoremetadata in volumekeeper.MetadataWithMissingBlocks)                      {                          var targetpath = restoremetadata.Path;                          result.AddVerboseMessage("Recording metadata from remote data: {0}"' targetpath);                                                try                          {                              // TODO: When we support multi-block metadata this needs to deal with it                              using(var ms = new System.IO.MemoryStream())                              {                                  foreach(var targetblock in restoremetadata.Blocks)                                  {                                      ms.Position = targetblock.Offset;                                      var size = blocks.ReadBlock(targetblock.Key' blockbuffer);                                      if (targetblock.Size == size)                                      {                                          ms.Write(blockbuffer' 0' size);                                          blockmarker.SetBlockRestored(restoremetadata.FileID' targetblock.Offset / blocksize' targetblock.Key' size' true);                                      }                                     }                                    ms.Position = 0;                                   metadatastorage.Add(targetpath' ms);                                  //blockmarker.RecordMetadata(restoremetadata.FileID' ms);                              }                          }                          catch (Exception ex)                          {                              result.AddWarning(string.Format("Failed to record metadata for file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);                          }                      }                  }                  blockmarker.UpdateProcessed(result.OperationProgressUpdater);                  blockmarker.Commit(result);              }
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker())              {                  var updateCount = 0L;                  foreach(var entry in database.GetFilesAndSourceBlocksFast(options.Blocksize))                  {                      var targetpath = entry.TargetPath;                      var targetfileid = entry.TargetFileID;                      var sourcepath = entry.SourcePath;                      var patched = false;                                            try                      {                          if (m_systemIO.FileExists(sourcepath))                          {                              var folderpath = m_systemIO.PathGetDirectoryName(targetpath);                              if (!options.Dryrun && !m_systemIO.DirectoryExists(folderpath))                              {                                  result.AddWarning(string.Format("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);                                  m_systemIO.DirectoryCreate(folderpath);                              }                                                        using(var targetstream = options.Dryrun ? null : m_systemIO.FileOpenWrite(targetpath))                              {                                  try                                  {                                      using(var sourcestream = m_systemIO.FileOpenRead(sourcepath))                                      {                                          foreach(var block in entry.Blocks)                                          {                                              if (result.TaskControlRendevouz() == TaskControlState.Stop)                                                  return;                                                //TODO: Handle metadata                                                if (sourcestream.Length > block.Offset)                                              {                                                  sourcestream.Position = block.Offset;                                                                                                    var size = sourcestream.Read(blockbuffer' 0' blockbuffer.Length);                                                  if (size == block.Size)                                                  {                                                      var key = Convert.ToBase64String(hasher.ComputeHash(blockbuffer' 0' size));                                                      if (key == block.Hash)                                                      {                                                          patched = true;                                                          if (!options.Dryrun)                                                          {                                                              targetstream.Position = block.Offset;                                                              targetstream.Write(blockbuffer' 0' size);                                                          }                                                                                                                        blockmarker.SetBlockRestored(targetfileid' block.Index' key' block.Size' false);                                                      }                                                  }                                                                             }                                          }                                      }                                  }                                  catch (Exception ex)                                  {                                      result.AddWarning(string.Format("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' sourcepath' ex.Message)' ex);                                      if (ex is System.Threading.ThreadAbortException)                                          throw;                                  }                              }                                if ((++updateCount) % 20 == 0)                              {                                  blockmarker.UpdateProcessed(result.OperationProgressUpdater);                                  if (result.TaskControlRendevouz() == TaskControlState.Stop)                                      return;                              }                                                        }                          else                          {                              result.AddVerboseMessage("Local source file not found: {0}"' sourcepath);                          }                      }                      catch (Exception ex)                      {                          result.AddWarning(string.Format("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);                          if (ex is System.Threading.ThreadAbortException)                              throw;                      }                                            if (patched)                          result.AddVerboseMessage("Target file is patched with some local data: {0}"' targetpath);                      else                          result.AddVerboseMessage("Target file is not patched any local data: {0}"' targetpath);                                            if (patched && options.Dryrun)                          result.AddDryrunMessage(string.Format("Would patch file with local data: {0}"' targetpath));                  }                                    blockmarker.UpdateProcessed(result.OperationProgressUpdater);                  blockmarker.Commit(result);              }
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker())              {                  var updateCount = 0L;                  foreach (var restorelist in database.GetFilesAndSourceBlocks(options.SkipMetadata' options.Blocksize))                  {                      var targetpath = restorelist.TargetPath;                      var targetfileid = restorelist.TargetFileID;                      var patched = false;                      try                      {                          if (result.TaskControlRendevouz() == TaskControlState.Stop)                              return;                                                    var folderpath = m_systemIO.PathGetDirectoryName(targetpath);                          if (!options.Dryrun && !m_systemIO.DirectoryExists(folderpath))                          {                              result.AddWarning(string.Format("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);                              m_systemIO.DirectoryCreate(folderpath);                          }                                                using (var file = options.Dryrun ? null : m_systemIO.FileOpenWrite(targetpath))                              foreach (var targetblock in restorelist.Blocks)                              {                                  foreach (var source in targetblock.Blocksources)                                  {                                      try                                      {                                          if (result.TaskControlRendevouz() == TaskControlState.Stop)                                              return;                                            if (m_systemIO.FileExists(source.Path))                                          {                                              if (source.IsMetadata)                                              {                                                  // TODO: Handle this by reconstructing                                                   // metadata from file and checking the hash                                                    continue;                                              }                                              else                                              {                                                  using (var sourcefile = m_systemIO.FileOpenRead(source.Path))                                                  {                                                      sourcefile.Position = source.Offset;                                                      var size = sourcefile.Read(blockbuffer' 0' blockbuffer.Length);                                                      if (size == targetblock.Size)                                                      {                                                          var key = Convert.ToBase64String(hasher.ComputeHash(blockbuffer' 0' size));                                                          if (key == targetblock.Hash)                                                          {                                                              if (!options.Dryrun)                                                              {                                                                  if (targetblock.IsMetadata)                                                                      metadatastorage.Add(targetpath' new System.IO.MemoryStream(blockbuffer' 0' size));                                                                  else                                                                  {                                                                      file.Position = targetblock.Offset;                                                                      file.Write(blockbuffer' 0' size);                                                                  }                                                              }                                                                                                                                blockmarker.SetBlockRestored(targetfileid' targetblock.Index' key' targetblock.Size' false);                                                              patched = true;                                                              break;                                                          }                                                      }                                                  }                                              }                                          }                                      }                                      catch (Exception ex)                                      {                                          result.AddWarning(string.Format("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' source.Path' ex.Message)' ex);                                          if (ex is System.Threading.ThreadAbortException)                                              throw;                                      }                                  }                              }                                                            if ((++updateCount) % 20 == 0)                                  blockmarker.UpdateProcessed(result.OperationProgressUpdater);                      }                      catch (Exception ex)                      {                          result.AddWarning(string.Format("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);                      }                                            if (patched)                          result.AddVerboseMessage("Target file is patched with some local data: {0}"' targetpath);                      else                          result.AddVerboseMessage("Target file is not patched any local data: {0}"' targetpath);                                                if (patched && options.Dryrun)                          result.AddDryrunMessage(string.Format("Would patch file with local data: {0}"' targetpath));                  }                    blockmarker.UpdateProcessed(result.OperationProgressUpdater);                  blockmarker.Commit(result);              }
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: using(var blockmarker = database.CreateBlockMarker())              {                  var updateCount = 0L;                  foreach(var restorelist in database.GetExistingFilesWithBlocks())                  {                      var rename = !options.Overwrite;                      var targetpath = restorelist.TargetPath;                      var targetfileid = restorelist.TargetFileID;                      var targetfilehash = restorelist.TargetHash;                      var targetfilelength = restorelist.Length;                      if (m_systemIO.FileExists(targetpath))                      {                          try                          {                              if (result.TaskControlRendevouz() == TaskControlState.Stop)                                  return;                                var currentfilelength = m_systemIO.FileLength(targetpath);                              var wasTruncated = false;                                // Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)                              // We do it before scanning for blocks. This allows full verification on files that only needs to                               // be truncated (i.e. forthwritten log files).                              if (!rename && currentfilelength > targetfilelength)                              {                                  var currentAttr = m_systemIO.GetFileAttributes(targetpath);                                  if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) // clear readonly attribute                                  {                                      if (options.Dryrun) result.AddDryrunMessage(string.Format("Would reset read-only attribute on file: {0}"' targetpath));                                      else m_systemIO.SetFileAttributes(targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);                                  }                                  if (options.Dryrun)                                      result.AddDryrunMessage(string.Format("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));                                  else                                  {                                      using (var file = m_systemIO.FileOpenWrite(targetpath))                                          file.SetLength(targetfilelength);                                      currentfilelength = targetfilelength;                                  }                                  wasTruncated = true;                              }                                // If file size does not match and we have to rename on conflict'                               // the whole scan can be skipped here because all blocks have to be restored anyway.                              // For the other cases' we will check block and and file hashes and look for blocks                              // to be restored and files that can already be verified.                              if (!rename || currentfilelength == targetfilelength)                              {                                  // a file hash for verification will only be necessary if the file has exactly                                  // the wanted size so we have a chance to already mark the file as data-verified.                                  bool calcFileHash = (currentfilelength == targetfilelength);                                  if (calcFileHash) filehasher.Initialize();                                    using (var file = m_systemIO.FileOpenRead(targetpath))                                  using (var block = new Blockprocessor(file' blockbuffer))                                      foreach (var targetblock in restorelist.Blocks)                                      {                                          var size = block.Readblock();                                          if (size <= 0)                                              break;                                            //TODO: Handle Metadata                                            bool blockhashmatch = false;                                          if (size == targetblock.Size)                                          {                                              // Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.                                              // Actually' in future always calculate the file hash and mark the file data as already verified.                                                System.Threading.Tasks.Task calcFileHashTask = null;                                              if (calcFileHash)                                                  calcFileHashTask = System.Threading.Tasks.Task.Run(                                                      () => filehasher.TransformBlock(blockbuffer' 0' size' blockbuffer' 0));                                                var key = Convert.ToBase64String(blockhasher.ComputeHash(blockbuffer' 0' size));                                                if (calcFileHashTask != null) calcFileHashTask.Wait(); // wait because blockbuffer will be overwritten.                                                if (key == targetblock.Hash)                                              {                                                  blockmarker.SetBlockRestored(targetfileid' targetblock.Index' key' size' false);                                                  blockhashmatch = true;                                              }                                          }                                          if (calcFileHash && !blockhashmatch) // will not be necessary anymore                                          {                                              filehasher.TransformFinalBlock(blockbuffer' 0' 0); // So a new initialize will not throw                                              calcFileHash = false;                                              if (rename) // file does not match. So break.                                                  break;                                          }                                      }                                    bool fullfilehashmatch = false;                                  if (calcFileHash) // now check if files are identical                                  {                                      filehasher.TransformFinalBlock(blockbuffer' 0' 0);                                      var filekey = Convert.ToBase64String(filehasher.Hash);                                      fullfilehashmatch = (filekey == targetfilehash);                                  }                                    if (!rename && !fullfilehashmatch && !wasTruncated) // Reset read-only attribute (if set) to overwrite                                  {                                      var currentAttr = m_systemIO.GetFileAttributes(targetpath);                                      if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)                                      {                                          if (options.Dryrun) result.AddDryrunMessage(string.Format("Would reset read-only attribute on file: {0}"' targetpath));                                          else m_systemIO.SetFileAttributes(targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);                                      }                                  }                                    if (fullfilehashmatch)                                  {                                      //TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.                                      blockmarker.SetFileDataVerified(targetfileid);                                      result.AddVerboseMessage("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");                                      rename = false;                                  }                                  else if (rename)                                  {                                      // The new file will have none of the correct blocks'                                      // even if the scanned file had some                                      blockmarker.SetAllBlocksMissing(targetfileid);                                  }                              }                                                            if ((++updateCount) % 20 == 0)                              {                                  blockmarker.UpdateProcessed(result.OperationProgressUpdater);                                  if (result.TaskControlRendevouz() == TaskControlState.Stop)                                      return;                              }                          }                          catch (Exception ex)                          {                              result.AddWarning(string.Format("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);                              if (ex is System.Threading.ThreadAbortException)                                  throw;                          }                                              }                      else                      {                          result.AddVerboseMessage("Target file does not exist: {0}"' targetpath);                          rename = false;                      }                                            if (rename)                      {                          //Select a new filename                          var ext = m_systemIO.PathGetExtension(targetpath) ?? "";                          if (!string.IsNullOrEmpty(ext) && !ext.StartsWith("."' StringComparison.Ordinal))                              ext = "." + ext;                                                    // First we try with a simple date append' assuming that there are not many conflicts there                          var newname = m_systemIO.PathChangeExtension(targetpath' null) + "." + database.RestoreTime.ToLocalTime().ToString("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture);                          var tr = newname + ext;                          var c = 0;                          while (m_systemIO.FileExists(tr) && c < 1000)                          {                              try                              {                                  // If we have a file with the correct name'                                   // it is most likely the file we want                                  filehasher.Initialize();                                                                    string key;                                  using(var file = m_systemIO.FileOpenRead(tr))                                      key = Convert.ToBase64String(filehasher.ComputeHash(file));                                                                        if (key == targetfilehash)                                  {                                      //TODO: Also needs metadata check to make correct decision.                                      //      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.                                      blockmarker.SetAllBlocksRestored(targetfileid' false);                                      blockmarker.SetFileDataVerified(targetfileid);                                      break;                                  }                              }                              catch(Exception ex)                              {                                  result.AddWarning(string.Format("Failed to read candidate restore target {0}"' tr)' ex);                              }                              tr = newname + " (" + (c++).ToString() + ")" + ext;                          }                                                    newname = tr;                                                    result.AddVerboseMessage("Target file exists and will be restored to: {0}"' newname);                          database.UpdateTargetPath(targetfileid' newname);                       }                                                                }                    blockmarker.UpdateProcessed(result.OperationProgressUpdater);                  blockmarker.Commit(result);              }
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: using(var blockmarker = database.CreateBlockMarker())              {                  var updateCount = 0L;                  foreach(var restorelist in database.GetExistingFilesWithBlocks())                  {                      var rename = !options.Overwrite;                      var targetpath = restorelist.TargetPath;                      var targetfileid = restorelist.TargetFileID;                      var targetfilehash = restorelist.TargetHash;                      var targetfilelength = restorelist.Length;                      if (m_systemIO.FileExists(targetpath))                      {                          try                          {                              if (result.TaskControlRendevouz() == TaskControlState.Stop)                                  return;                                var currentfilelength = m_systemIO.FileLength(targetpath);                              var wasTruncated = false;                                // Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)                              // We do it before scanning for blocks. This allows full verification on files that only needs to                               // be truncated (i.e. forthwritten log files).                              if (!rename && currentfilelength > targetfilelength)                              {                                  var currentAttr = m_systemIO.GetFileAttributes(targetpath);                                  if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) // clear readonly attribute                                  {                                      if (options.Dryrun) result.AddDryrunMessage(string.Format("Would reset read-only attribute on file: {0}"' targetpath));                                      else m_systemIO.SetFileAttributes(targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);                                  }                                  if (options.Dryrun)                                      result.AddDryrunMessage(string.Format("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));                                  else                                  {                                      using (var file = m_systemIO.FileOpenWrite(targetpath))                                          file.SetLength(targetfilelength);                                      currentfilelength = targetfilelength;                                  }                                  wasTruncated = true;                              }                                // If file size does not match and we have to rename on conflict'                               // the whole scan can be skipped here because all blocks have to be restored anyway.                              // For the other cases' we will check block and and file hashes and look for blocks                              // to be restored and files that can already be verified.                              if (!rename || currentfilelength == targetfilelength)                              {                                  // a file hash for verification will only be necessary if the file has exactly                                  // the wanted size so we have a chance to already mark the file as data-verified.                                  bool calcFileHash = (currentfilelength == targetfilelength);                                  if (calcFileHash) filehasher.Initialize();                                    using (var file = m_systemIO.FileOpenRead(targetpath))                                  using (var block = new Blockprocessor(file' blockbuffer))                                      foreach (var targetblock in restorelist.Blocks)                                      {                                          var size = block.Readblock();                                          if (size <= 0)                                              break;                                            //TODO: Handle Metadata                                            bool blockhashmatch = false;                                          if (size == targetblock.Size)                                          {                                              // Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.                                              // Actually' in future always calculate the file hash and mark the file data as already verified.                                                System.Threading.Tasks.Task calcFileHashTask = null;                                              if (calcFileHash)                                                  calcFileHashTask = System.Threading.Tasks.Task.Run(                                                      () => filehasher.TransformBlock(blockbuffer' 0' size' blockbuffer' 0));                                                var key = Convert.ToBase64String(blockhasher.ComputeHash(blockbuffer' 0' size));                                                if (calcFileHashTask != null) calcFileHashTask.Wait(); // wait because blockbuffer will be overwritten.                                                if (key == targetblock.Hash)                                              {                                                  blockmarker.SetBlockRestored(targetfileid' targetblock.Index' key' size' false);                                                  blockhashmatch = true;                                              }                                          }                                          if (calcFileHash && !blockhashmatch) // will not be necessary anymore                                          {                                              filehasher.TransformFinalBlock(blockbuffer' 0' 0); // So a new initialize will not throw                                              calcFileHash = false;                                              if (rename) // file does not match. So break.                                                  break;                                          }                                      }                                    bool fullfilehashmatch = false;                                  if (calcFileHash) // now check if files are identical                                  {                                      filehasher.TransformFinalBlock(blockbuffer' 0' 0);                                      var filekey = Convert.ToBase64String(filehasher.Hash);                                      fullfilehashmatch = (filekey == targetfilehash);                                  }                                    if (!rename && !fullfilehashmatch && !wasTruncated) // Reset read-only attribute (if set) to overwrite                                  {                                      var currentAttr = m_systemIO.GetFileAttributes(targetpath);                                      if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)                                      {                                          if (options.Dryrun) result.AddDryrunMessage(string.Format("Would reset read-only attribute on file: {0}"' targetpath));                                          else m_systemIO.SetFileAttributes(targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);                                      }                                  }                                    if (fullfilehashmatch)                                  {                                      //TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.                                      blockmarker.SetFileDataVerified(targetfileid);                                      result.AddVerboseMessage("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");                                      rename = false;                                  }                                  else if (rename)                                  {                                      // The new file will have none of the correct blocks'                                      // even if the scanned file had some                                      blockmarker.SetAllBlocksMissing(targetfileid);                                  }                              }                                                            if ((++updateCount) % 20 == 0)                              {                                  blockmarker.UpdateProcessed(result.OperationProgressUpdater);                                  if (result.TaskControlRendevouz() == TaskControlState.Stop)                                      return;                              }                          }                          catch (Exception ex)                          {                              result.AddWarning(string.Format("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);                              if (ex is System.Threading.ThreadAbortException)                                  throw;                          }                                              }                      else                      {                          result.AddVerboseMessage("Target file does not exist: {0}"' targetpath);                          rename = false;                      }                                            if (rename)                      {                          //Select a new filename                          var ext = m_systemIO.PathGetExtension(targetpath) ?? "";                          if (!string.IsNullOrEmpty(ext) && !ext.StartsWith("."' StringComparison.Ordinal))                              ext = "." + ext;                                                    // First we try with a simple date append' assuming that there are not many conflicts there                          var newname = m_systemIO.PathChangeExtension(targetpath' null) + "." + database.RestoreTime.ToLocalTime().ToString("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture);                          var tr = newname + ext;                          var c = 0;                          while (m_systemIO.FileExists(tr) && c < 1000)                          {                              try                              {                                  // If we have a file with the correct name'                                   // it is most likely the file we want                                  filehasher.Initialize();                                                                    string key;                                  using(var file = m_systemIO.FileOpenRead(tr))                                      key = Convert.ToBase64String(filehasher.ComputeHash(file));                                                                        if (key == targetfilehash)                                  {                                      //TODO: Also needs metadata check to make correct decision.                                      //      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.                                      blockmarker.SetAllBlocksRestored(targetfileid' false);                                      blockmarker.SetFileDataVerified(targetfileid);                                      break;                                  }                              }                              catch(Exception ex)                              {                                  result.AddWarning(string.Format("Failed to read candidate restore target {0}"' tr)' ex);                              }                              tr = newname + " (" + (c++).ToString() + ")" + ext;                          }                                                    newname = tr;                                                    result.AddVerboseMessage("Target file exists and will be restored to: {0}"' newname);                          database.UpdateTargetPath(targetfileid' newname);                       }                                                                }                    blockmarker.UpdateProcessed(result.OperationProgressUpdater);                  blockmarker.Commit(result);              }
Magic Number,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,Run,The following statement contains a magic number: if (knownRemotes <= 0)              {                                  if (m_options.Dryrun)                  {                      m_result.AddDryrunMessage("Performing dryrun recreate");                  }                  else                  {                      var baseName = System.IO.Path.ChangeExtension(m_options.Dbpath' "backup");                      var i = 0;                      while (System.IO.File.Exists(baseName) && i++ < 1000)                          baseName = System.IO.Path.ChangeExtension(m_options.Dbpath' "backup-" + i.ToString());                                                m_result.AddMessage(string.Format("Renaming existing db from {0} to {1}"' m_options.Dbpath' baseName));                      System.IO.File.Move(m_options.Dbpath' baseName);                  }                                    RunRepairLocal(filter);                  RunRepairCommon();              }              else              {                  RunRepairCommon();                  RunRepairRemote();              }
Magic Number,Duplicati.Library.Main.Operation,RepairHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The following statement contains a magic number: using(var db = new LocalRepairDatabase(m_options.Dbpath))              using(var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' db))              {                  m_result.SetDatabase(db);                  Utility.UpdateOptionsFromDb(db' m_options);                  Utility.VerifyParameters(db' m_options);                    if (db.PartiallyRecreated)                      throw new UserInformationException("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");                    if (db.RepairInProgress)                      throw new UserInformationException("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");                    var tp = FilelistProcessor.RemoteListAnalysis(backend' m_options' db' m_result.BackendWriter' null);                  var buffer = new byte[m_options.Blocksize];                  var blockhasher = Library.Utility.HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm);                  var hashsize = blockhasher.HashSize / 8;                    if (blockhasher == null)                      throw new UserInformationException(Strings.Common.InvalidHashAlgorithm(m_options.BlockHashAlgorithm));                  if (!blockhasher.CanReuseTransform)                      throw new UserInformationException(Strings.Common.InvalidCryptoSystem(m_options.BlockHashAlgorithm));                                    var progress = 0;                  var targetProgess = tp.ExtraVolumes.Count() + tp.MissingVolumes.Count() + tp.VerificationRequiredVolumes.Count();                    if (m_options.Dryrun)                  {                      if (tp.ParsedVolumes.Count() == 0 && tp.OtherVolumes.Count() > 0)                      {                          if (tp.BackupPrefixes.Length == 1)                              throw new UserInformationException(string.Format("Found no backup files with prefix {0}' but files with prefix {1}' did you forget to set the backup prefix?"' m_options.Prefix' tp.BackupPrefixes[0]));                          else                              throw new UserInformationException(string.Format("Found no backup files with prefix {0}' but files with prefixes {1}' did you forget to set the backup prefix?"' m_options.Prefix' string.Join("' "' tp.BackupPrefixes)));                      }                      else if (tp.ParsedVolumes.Count() == 0 && tp.ExtraVolumes.Count() > 0)                      {                          throw new UserInformationException(string.Format("No files were missing' but {0} remote files were' found' did you mean to run recreate-database?"' tp.ExtraVolumes.Count()));                      }                  }                    if (tp.ExtraVolumes.Count() > 0 || tp.MissingVolumes.Count() > 0 || tp.VerificationRequiredVolumes.Count() > 0)                  {                      if (tp.VerificationRequiredVolumes.Any())                      {                          using(var testdb = new LocalTestDatabase(db))                          {                              foreach(var n in tp.VerificationRequiredVolumes)                                  try                                  {                                      if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                                      {                                          backend.WaitForComplete(db' null);                                          return;                                      }                                        progress++;                                      m_result.OperationProgressUpdater.UpdateProgress((float)progress / targetProgess);                                        long size;                                      string hash;                                      KeyValuePair<string' IEnumerable<KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>>> res;                                                                           using (var tf = backend.GetWithInfo(n.Name' out size' out hash))                                          res = TestHandler.TestVolumeInternals(testdb' n' tf' m_options' m_result' 1);                                        if (res.Value.Any())                                          throw new Exception(string.Format("Remote verification failure: {0}"' res.Value.First()));                                        if (!m_options.Dryrun)                                      {                                          m_result.AddMessage(string.Format("Sucessfully captured hash for {0}' updating database"' n.Name));                                          db.UpdateRemoteVolume(n.Name' RemoteVolumeState.Verified' size' hash);                                      }                                    }                                  catch (Exception ex)                                  {                                      m_result.AddError(string.Format("Failed to perform verification for file: {0}' please run verify; message: {1}"' n.Name' ex.Message)' ex);                                      if (ex is System.Threading.ThreadAbortException)                                          throw;                                  }                          }                      }                        // TODO: It is actually possible to use the extra files if we parse them                      foreach(var n in tp.ExtraVolumes)                          try                          {                              if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                              {                                  backend.WaitForComplete(db' null);                                  return;                              }                                progress++;                              m_result.OperationProgressUpdater.UpdateProgress((float)progress / targetProgess);                                // If this is a new index file' we can accept it if it matches our local data                              // This makes it possible to augment the remote store with new index data                              if (n.FileType == RemoteVolumeType.Index && m_options.IndexfilePolicy != Options.IndexFileStrategy.None)                              {                                  try                                  {                                      string hash;                                      long size;                                      using(var tf = backend.GetWithInfo(n.File.Name' out size' out hash))                                      using(var ifr = new IndexVolumeReader(n.CompressionModule' tf' m_options' m_options.BlockhashSize))                                      {                                          foreach(var rv in ifr.Volumes)                                          {                                              string cmphash;                                              long cmpsize;                                              RemoteVolumeType cmptype;                                              RemoteVolumeState cmpstate;                                              if (!db.GetRemoteVolume(rv.Filename' out cmphash' out cmpsize' out cmptype' out cmpstate))                                                  throw new Exception(string.Format("Unknown remote file {0} detected"' rv.Filename));                                                                                            if (!new [] { RemoteVolumeState.Uploading' RemoteVolumeState.Uploaded' RemoteVolumeState.Verified }.Contains(cmpstate))                                                  throw new Exception(string.Format("Volume {0} has local state {1}"' rv.Filename' cmpstate));                                                                                        if (cmphash != rv.Hash || cmpsize != rv.Length || ! new [] { RemoteVolumeState.Uploading' RemoteVolumeState.Uploaded' RemoteVolumeState.Verified }.Contains(cmpstate))                                                  throw new Exception(string.Format("Volume {0} hash/size mismatch ({1} - {2}) vs ({3} - {4})"' rv.Filename' cmphash' cmpsize' rv.Hash' rv.Length));                                                db.CheckAllBlocksAreInVolume(rv.Filename' rv.Blocks);                                          }                                            var blocksize = m_options.Blocksize;                                          foreach(var ixb in ifr.BlockLists)                                              db.CheckBlocklistCorrect(ixb.Hash' ixb.Length' ixb.Blocklist' blocksize' hashsize);                                            var selfid = db.GetRemoteVolumeID(n.File.Name);                                          foreach(var rv in ifr.Volumes)                                              db.AddIndexBlockLink(selfid' db.GetRemoteVolumeID(rv.Filename)' null);                                      }                                                                            // All checks fine' we accept the new index file                                      m_result.AddMessage(string.Format("Accepting new index file {0}"' n.File.Name));                                      db.RegisterRemoteVolume(n.File.Name' RemoteVolumeType.Index' size' RemoteVolumeState.Uploading);                                      db.UpdateRemoteVolume(n.File.Name' RemoteVolumeState.Verified' size' hash);                                      continue;                                  }                                  catch (Exception rex)                                  {                                      m_result.AddError(string.Format("Failed to accept new index file: {0}' message: {1}"' n.File.Name' rex.Message)' rex);                                  }                              }                                                        if (!m_options.Dryrun)                              {                                  db.RegisterRemoteVolume(n.File.Name' n.FileType' n.File.Size' RemoteVolumeState.Deleting);                                  backend.Delete(n.File.Name' n.File.Size);                              }                              else                                  m_result.AddDryrunMessage(string.Format("would delete file {0}"' n.File.Name));                          }                          catch (Exception ex)                          {                              m_result.AddError(string.Format("Failed to perform cleanup for extra file: {0}' message: {1}"' n.File.Name' ex.Message)' ex);                              if (ex is System.Threading.ThreadAbortException)                                  throw;                          }                                                    foreach(var n in tp.MissingVolumes)                      {                          IDisposable newEntry = null;                                                    try                          {                                if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                              {                                  backend.WaitForComplete(db' null);                                  return;                              }                                    progress++;                              m_result.OperationProgressUpdater.UpdateProgress((float)progress / targetProgess);                                if (n.Type == RemoteVolumeType.Files)                              {                                  var filesetId = db.GetFilesetIdFromRemotename(n.Name);                                  var w = new FilesetVolumeWriter(m_options' DateTime.UtcNow);                                  newEntry = w;                                  w.SetRemoteFilename(n.Name);                                                                    db.WriteFileset(w' null' filesetId);                                        w.Close();                                  if (m_options.Dryrun)                                      m_result.AddDryrunMessage(string.Format("would re-upload fileset {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(n.Size)));                                  else                                  {                                      db.UpdateRemoteVolume(w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);                                      backend.Put(w);                                  }                              }                              else if (n.Type == RemoteVolumeType.Index)                              {                                  var w = new IndexVolumeWriter(m_options);                                  newEntry = w;                                  w.SetRemoteFilename(n.Name);                                    var h = Library.Utility.HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm);                                                                    foreach(var blockvolume in db.GetBlockVolumesFromIndexName(n.Name))                                  {                                                                     w.StartVolume(blockvolume.Name);                                      var volumeid = db.GetRemoteVolumeID(blockvolume.Name);                                                                            foreach(var b in db.GetBlocks(volumeid))                                          w.AddBlock(b.Hash' b.Size);                                                                                w.FinishVolume(blockvolume.Hash' blockvolume.Size);                                                                            if (m_options.IndexfilePolicy == Options.IndexFileStrategy.Full)                                          foreach(var b in db.GetBlocklists(volumeid' m_options.Blocksize' hashsize))                                          {                                              var bh = Convert.ToBase64String(h.ComputeHash(b.Item2' 0' b.Item3));                                              if (bh != b.Item1)                                                  throw new Exception(string.Format("Internal consistency check failed' generated index block has wrong hash' {0} vs {1}"' bh' b.Item1));                                                                                            w.WriteBlocklist(b.Item1' b.Item2' 0' b.Item3);                                          }                                  }                                                                    w.Close();                                                                    if (m_options.Dryrun)                                      m_result.AddDryrunMessage(string.Format("would re-upload index file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(n.Size)));                                  else                                  {                                      db.UpdateRemoteVolume(w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);                                      backend.Put(w);                                  }                              }                              else if (n.Type == RemoteVolumeType.Blocks)                              {                                  var w = new BlockVolumeWriter(m_options);                                  newEntry = w;                                  w.SetRemoteFilename(n.Name);                                                                    using(var mbl = db.CreateBlockList(n.Name))                                  {                                      //First we grab all known blocks from local files                                      foreach(var block in mbl.GetSourceFilesWithBlocks(m_options.Blocksize))                                      {                                          var hash = block.Hash;                                          var size = (int)block.Size;                                                                                    foreach(var source in block.Sources)                                          {                                              var file = source.File;                                              var offset = source.Offset;                                                                                            try                                              {                                                  if (System.IO.File.Exists(file))                                                      using(var f = System.IO.File.OpenRead(file))                                                      {                                                          f.Position = offset;                                                          if (size == Library.Utility.Utility.ForceStreamRead(f' buffer' size))                                                          {                                                              var newhash = Convert.ToBase64String(blockhasher.ComputeHash(buffer' 0' size));                                                              if (newhash == hash)                                                              {                                                                  if (mbl.SetBlockRestored(hash' size))                                                                      w.AddBlock(hash' buffer' 0' size' Duplicati.Library.Interface.CompressionHint.Default);                                                                  break;                                                              }                                                          }                                                      }                                              }                                              catch (Exception ex)                                              {                                                  m_result.AddError(string.Format("Failed to access file: {0}"' file)' ex);                                              }                                          }                                      }                                                                            //Then we grab all remote volumes that have the missing blocks                                      foreach(var vol in new AsyncDownloader(mbl.GetMissingBlockSources().ToList()' backend))                                      {                                          try                                          {                                              using(var tmpfile = vol.TempFile)                                              using(var f = new BlockVolumeReader(RestoreHandler.GetCompressionModule(vol.Name)' tmpfile' m_options))                                                  foreach(var b in f.Blocks)                                                      if (mbl.SetBlockRestored(b.Key' b.Value))                                                          if (f.ReadBlock(b.Key' buffer) == b.Value)                                                              w.AddBlock(b.Key' buffer' 0' (int)b.Value' Duplicati.Library.Interface.CompressionHint.Default);                                          }                                          catch (Exception ex)                                          {                                              m_result.AddError(string.Format("Failed to access remote file: {0}"' vol.Name)' ex);                                          }                                      }                                                                            // If we managed to recover all blocks' NICE!                                      var missingBlocks = mbl.GetMissingBlocks().Count();                                      if (missingBlocks > 0)                                      {                                                                              m_result.AddMessage(string.Format("Repair cannot acquire {0} required blocks for volume {1}' which are required by the following filesets: "' missingBlocks' n.Name));                                          foreach(var f in mbl.GetFilesetsUsingMissingBlocks())                                              m_result.AddMessage(f.Name);                                            var recoverymsg = string.Format("If you want to continue working with the database' you can use the \"{0}\" and \"{1}\" commands to purge the missing data from the database and the remote storage."' "list-broken-files"' "purge-broken-files");                                            if (!m_options.Dryrun)                                          {                                              m_result.AddMessage("This may be fixed by deleting the filesets and running repair again");                                                throw new UserInformationException(string.Format("Repair not possible' missing {0} blocks.\n" + recoverymsg' missingBlocks));                                          }                                          else                                          {                                              m_result.AddMessage(recoverymsg);                                          }                                      }                                      else                                      {                                          if (m_options.Dryrun)                                              m_result.AddDryrunMessage(string.Format("would re-upload block file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString(new System.IO.FileInfo(w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString(n.Size)));                                          else                                          {                                              db.UpdateRemoteVolume(w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);                                              backend.Put(w);                                          }                                      }                                  }                              }                          }                          catch (Exception ex)                          {                              if (newEntry != null)                                  try { newEntry.Dispose(); }                                  catch { }                                  finally { newEntry = null; }                                                                m_result.AddError(string.Format("Failed to perform cleanup for missing file: {0}' message: {1}"' n.Name' ex.Message)' ex);                                                            if (ex is System.Threading.ThreadAbortException)                                  throw;                          }                      }                  }                  else                  {                      m_result.AddMessage("Destination and database are synchronized' not making any changes");                  }                    m_result.OperationProgressUpdater.UpdateProgress(1);                                  backend.WaitForComplete(db' null);                  db.WriteResults();              }
Magic Number,Duplicati.Library.Main.Operation,FilelistProcessor,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The following statement contains a magic number: foreach(var i in locallist)              {                  Volumes.IParsedVolume r;                  var remoteFound = lookup.TryGetValue(i.Name' out r);                  var correctSize = remoteFound && i.Size >= 0 && (i.Size == r.File.Size || r.File.Size < 0);                    lookup.Remove(i.Name);                    switch (i.State)                  {                      case RemoteVolumeState.Deleted:                          if (remoteFound)                              log.AddMessage(string.Format("ignoring remote file listed as {0}: {1}"' i.State' i.Name));                            break;                        case RemoteVolumeState.Temporary:                      case RemoteVolumeState.Deleting:                          if (remoteFound)                          {                              log.AddMessage(string.Format("removing remote file listed as {0}: {1}"' i.State' i.Name));                              backend.Delete(i.Name' i.Size' true);                          }                          else                          {                              if (i.deleteGracePeriod > DateTime.UtcNow)                              {                                  log.AddMessage(string.Format("keeping delete request for {0} until {1}"' i.Name' i.deleteGracePeriod.ToLocalTime()));                              }                              else                              {                                  if (string.Equals(i.Name' protectedfile) && i.State == RemoteVolumeState.Temporary)                                  {                                      log.AddMessage(string.Format("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));                                  }                                  else                                  {                                      log.AddMessage(string.Format("removing file listed as {0}: {1}"' i.State' i.Name));                                      cleanupRemovedRemoteVolumes.Add(i.Name);                                  }                              }                          }                          break;                      case RemoteVolumeState.Uploading:                          if (remoteFound && correctSize && r.File.Size >= 0)                          {                              log.AddMessage(string.Format("promoting uploaded complete file from {0} to {2}: {1}"' i.State' i.Name' RemoteVolumeState.Uploaded));                              database.UpdateRemoteVolume(i.Name' RemoteVolumeState.Uploaded' i.Size' i.Hash);                          }                          else if (!remoteFound)                          {                                if (string.Equals(i.Name' protectedfile))                              {                                  log.AddMessage(string.Format("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));                                  database.UpdateRemoteVolume(i.Name' RemoteVolumeState.Temporary' i.Size' i.Hash' false' new TimeSpan(0)' null);                              }                              else                              {                                  log.AddMessage(string.Format("scheduling missing file for deletion' currently listed as {0}: {1}"' i.State' i.Name));                                  cleanupRemovedRemoteVolumes.Add(i.Name);                                  database.UpdateRemoteVolume(i.Name' RemoteVolumeState.Deleting' i.Size' i.Hash' false' TimeSpan.FromHours(2)' null);                              }                          }                          else                          {                              if (string.Equals(i.Name' protectedfile))                              {                                  log.AddMessage(string.Format("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));                              }                              else                              {                                  log.AddMessage(string.Format("removing incomplete remote file listed as {0}: {1}"' i.State' i.Name));                                  backend.Delete(i.Name' i.Size' true);                              }                          }                          break;                        case RemoteVolumeState.Uploaded:                          if (!remoteFound)                              missing.Add(i);                          else if (correctSize)                              database.UpdateRemoteVolume(i.Name' RemoteVolumeState.Verified' i.Size' i.Hash);                          else                              missingHash.Add(new Tuple<long' RemoteVolumeEntry>(r.File.Size' i));                            break;                        case RemoteVolumeState.Verified:                          if (!remoteFound)                              missing.Add(i);                          else if (!correctSize)                              missingHash.Add(new Tuple<long' RemoteVolumeEntry>(r.File.Size' i));                            break;                                        default:                          log.AddWarning(string.Format("unknown state for remote file listed as {0}: {1}"' i.State' i.Name)' null);                          break;                  }                    backend.FlushDbMessages();              }
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using(var tmpdb = useLocalDb ? null : new Library.Utility.TempFile())              using(var db = new Database.LocalListChangesDatabase(useLocalDb ? m_options.Dbpath : (string)tmpdb))              using(var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' db))              using(var storageKeeper = db.CreateStorageHelper())              {                  m_result.SetDatabase(db);                                    if (useLocalDb)                  {                      var dbtimes = db.FilesetTimes.ToList();                      if (dbtimes.Count < 2)                          throw new UserInformationException(string.Format("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));                                            long baseVersionId;                      long compareVersionId;                                            var times = dbtimes.Zip(Enumerable.Range(0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long>(b' a.Value' a.Key)).ToList();                      var bt = SelectTime(baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);                      times.Remove(bt);                      SelectTime(compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);                                                                    storageKeeper.AddFromDb(baseVersionId' false' filter);                      storageKeeper.AddFromDb(compareVersionId' true' filter);                  }                  else                  {                      m_result.AddMessage("No local database' accessing remote store");                                            var parsedlist = (from n in backend.List()                                  let p = Volumes.VolumeBase.ParseFilename(n)                                  where p != null && p.FileType == RemoteVolumeType.Files                                  orderby p.Time descending                                  select p).ToArray();                                                        var numberedList = parsedlist.Zip(Enumerable.Range(0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume>(b' a.Time' a)).ToList();                      if (numberedList.Count < 2)                          throw new UserInformationException(string.Format("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));                        Volumes.IParsedVolume baseFile;                      Volumes.IParsedVolume compareFile;                                            var bt = SelectTime(baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);                      numberedList.Remove(bt);                      SelectTime(compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);                                            Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = (x) => {                          switch (x)                          {                              case FilelistEntryType.File:                                  return Library.Interface.ListChangesElementType.File;                              case FilelistEntryType.Folder:                                  return Library.Interface.ListChangesElementType.Folder;                              case FilelistEntryType.Symlink:                                  return Library.Interface.ListChangesElementType.Symlink;                              default:                                  return (Library.Interface.ListChangesElementType)(-1);                          }                      };                                            if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                          return;                                                using(var tmpfile = backend.Get(baseFile.File.Name' baseFile.File.Size' null))                      using(var rd = new Volumes.FilesetVolumeReader(RestoreHandler.GetCompressionModule(baseFile.File.Name)' tmpfile' m_options))                          foreach(var f in rd.Files)                              if (Library.Utility.FilterExpression.Matches(filter' f.Path))                                  storageKeeper.AddElement(f.Path' f.Hash' f.Metahash' f.Size' conv(f.Type)' false);                                                        if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                          return;                                            using(var tmpfile = backend.Get(compareFile.File.Name' compareFile.File.Size' null))                      using(var rd = new Volumes.FilesetVolumeReader(RestoreHandler.GetCompressionModule(compareFile.File.Name)' tmpfile' m_options))                          foreach(var f in rd.Files)                              if (Library.Utility.FilterExpression.Matches(filter' f.Path))                                  storageKeeper.AddElement(f.Path' f.Hash' f.Metahash' f.Size' conv(f.Type)' true);                  }                                    var changes = storageKeeper.CreateChangeCountReport();                  var sizes = storageKeeper.CreateChangeSizeReport();                    var lst = (m_options.Verbose || m_options.FullResult || callback != null) ?                          (from n in storageKeeper.CreateChangedFileReport()                           select n) : null;                    m_result.SetResult(                      baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex'                      changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles'                      changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles'                      changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles'                      sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize'                      (lst == null || callback == null) ? null : lst.ToArray()                  );                    if (callback != null)                      callback(m_result' lst);                    return;                                              }
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using(var tmpdb = useLocalDb ? null : new Library.Utility.TempFile())              using(var db = new Database.LocalListChangesDatabase(useLocalDb ? m_options.Dbpath : (string)tmpdb))              using(var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' db))              using(var storageKeeper = db.CreateStorageHelper())              {                  m_result.SetDatabase(db);                                    if (useLocalDb)                  {                      var dbtimes = db.FilesetTimes.ToList();                      if (dbtimes.Count < 2)                          throw new UserInformationException(string.Format("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));                                            long baseVersionId;                      long compareVersionId;                                            var times = dbtimes.Zip(Enumerable.Range(0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long>(b' a.Value' a.Key)).ToList();                      var bt = SelectTime(baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);                      times.Remove(bt);                      SelectTime(compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);                                                                    storageKeeper.AddFromDb(baseVersionId' false' filter);                      storageKeeper.AddFromDb(compareVersionId' true' filter);                  }                  else                  {                      m_result.AddMessage("No local database' accessing remote store");                                            var parsedlist = (from n in backend.List()                                  let p = Volumes.VolumeBase.ParseFilename(n)                                  where p != null && p.FileType == RemoteVolumeType.Files                                  orderby p.Time descending                                  select p).ToArray();                                                        var numberedList = parsedlist.Zip(Enumerable.Range(0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume>(b' a.Time' a)).ToList();                      if (numberedList.Count < 2)                          throw new UserInformationException(string.Format("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));                        Volumes.IParsedVolume baseFile;                      Volumes.IParsedVolume compareFile;                                            var bt = SelectTime(baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);                      numberedList.Remove(bt);                      SelectTime(compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);                                            Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = (x) => {                          switch (x)                          {                              case FilelistEntryType.File:                                  return Library.Interface.ListChangesElementType.File;                              case FilelistEntryType.Folder:                                  return Library.Interface.ListChangesElementType.Folder;                              case FilelistEntryType.Symlink:                                  return Library.Interface.ListChangesElementType.Symlink;                              default:                                  return (Library.Interface.ListChangesElementType)(-1);                          }                      };                                            if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                          return;                                                using(var tmpfile = backend.Get(baseFile.File.Name' baseFile.File.Size' null))                      using(var rd = new Volumes.FilesetVolumeReader(RestoreHandler.GetCompressionModule(baseFile.File.Name)' tmpfile' m_options))                          foreach(var f in rd.Files)                              if (Library.Utility.FilterExpression.Matches(filter' f.Path))                                  storageKeeper.AddElement(f.Path' f.Hash' f.Metahash' f.Size' conv(f.Type)' false);                                                        if (m_result.TaskControlRendevouz() == TaskControlState.Stop)                          return;                                            using(var tmpfile = backend.Get(compareFile.File.Name' compareFile.File.Size' null))                      using(var rd = new Volumes.FilesetVolumeReader(RestoreHandler.GetCompressionModule(compareFile.File.Name)' tmpfile' m_options))                          foreach(var f in rd.Files)                              if (Library.Utility.FilterExpression.Matches(filter' f.Path))                                  storageKeeper.AddElement(f.Path' f.Hash' f.Metahash' f.Size' conv(f.Type)' true);                  }                                    var changes = storageKeeper.CreateChangeCountReport();                  var sizes = storageKeeper.CreateChangeSizeReport();                    var lst = (m_options.Verbose || m_options.FullResult || callback != null) ?                          (from n in storageKeeper.CreateChangedFileReport()                           select n) : null;                    m_result.SetResult(                      baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex'                      changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles'                      changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles'                      changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles'                      sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize'                      (lst == null || callback == null) ? null : lst.ToArray()                  );                    if (callback != null)                      callback(m_result' lst);                    return;                                              }
Magic Number,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The following statement contains a magic number: if (m_options.FullRemoteVerification)              {                  foreach(var vol in new AsyncDownloader(files' backend))                  {                      try                      {                          if (m_results.TaskControlRendevouz() == TaskControlState.Stop)                          {                              backend.WaitForComplete(db' null);                              m_results.EndTime = DateTime.UtcNow;                              return;                          }                                progress++;                          m_results.OperationProgressUpdater.UpdateProgress((float)progress / files.Count);                            KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> res;                          using(var tf = vol.TempFile)                              res = TestVolumeInternals(db' vol' tf' m_options' m_results' m_options.FullBlockVerification ? 1.0 : 0.2);                          m_results.AddResult(res.Key' res.Value);                            if (!string.IsNullOrWhiteSpace(vol.Hash) && vol.Size > 0)                          {                              if (res.Value == null || !res.Value.Any())                              {                                  string dbhash;                                  long dbsize;                                  RemoteVolumeType dbtype;                                  RemoteVolumeState dbstate;                                    if (db.GetRemoteVolume(vol.Name' out dbhash' out dbsize' out dbtype' out dbstate))                                  {                                      if (string.IsNullOrWhiteSpace(dbhash) || dbsize <= 0)                                      {                                          if (m_options.Dryrun)                                          {                                              m_results.AddDryrunMessage(string.Format("Sucessfully captured hash and size for {0}' would update database"' vol.Name));                                          }                                          else                                          {                                              m_results.AddMessage(string.Format("Sucessfully captured hash and size for {0}' updating database"' vol.Name));                                              db.UpdateRemoteVolume(vol.Name' RemoteVolumeState.Verified' vol.Size' vol.Hash);                                          }                                      }                                  }                              }                          }                                                    db.UpdateVerificationCount(vol.Name);                      }                      catch (Exception ex)                      {                          m_results.AddResult(vol.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] { new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>(Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message) });                          m_results.AddError(string.Format("Failed to process file {0}"' vol.Name)' ex);                          if (ex is System.Threading.ThreadAbortException)                          {                              m_results.EndTime = DateTime.UtcNow;                              throw;                          }                      }                  }              }              else              {                  foreach(var f in files)                  {                      try                      {                          if (m_results.TaskControlRendevouz() == TaskControlState.Stop)                          {                              m_results.EndTime = DateTime.UtcNow;                              return;                          }                            progress++;                          m_results.OperationProgressUpdater.UpdateProgress((float)progress / files.Count);                            if (f.Size <= 0 || string.IsNullOrWhiteSpace(f.Hash))                          {                              m_results.AddMessage(string.Format("No hash or size recorded for {0}' performing full verification"' f.Name));                              KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> res;                              string hash;                              long size;                                using (var tf = backend.GetWithInfo(f.Name' out size' out hash))                                  res = TestVolumeInternals(db' f' tf' m_options' m_results' 1);                              m_results.AddResult(res.Key' res.Value);                                if (!string.IsNullOrWhiteSpace(hash) && size > 0)                              {                                  if (res.Value == null || !res.Value.Any())                                  {                                      if (m_options.Dryrun)                                      {                                          m_results.AddDryrunMessage(string.Format("Sucessfully captured hash and size for {0}' would update database"' f.Name));                                      }                                      else                                      {                                          m_results.AddMessage(string.Format("Sucessfully captured hash and size for {0}' updating database"' f.Name));                                          db.UpdateRemoteVolume(f.Name' RemoteVolumeState.Verified' size' hash);                                      }                                  }                              }                          }                          else                              backend.GetForTesting(f.Name' f.Size' f.Hash);                                                    db.UpdateVerificationCount(f.Name);                          m_results.AddResult(f.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[0]);                      }                      catch (Exception ex)                      {                          m_results.AddResult(f.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] { new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>(Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message) });                          m_results.AddError(string.Format("Failed to process file {0}"' f.Name)' ex);                          if (ex is System.Threading.ThreadAbortException)                          {                              m_results.EndTime = DateTime.UtcNow;                              throw;                          }                      }                  }              }
Magic Number,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The following statement contains a magic number: var hashsize = blockhasher.HashSize / 8;
Magic Number,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The following statement contains a magic number: sample_percent = Math.Min(1' Math.Max(sample_percent' 0.01));
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' db))              {                  if (db.PartiallyRecreated)                      throw new UserInformationException("The purge command does not work on partially recreated databases");                    if (db.RepairInProgress && filtercommand == null)                      throw new UserInformationException(string.Format("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));                    var versions = db.GetFilesetIDs(m_options.Time' m_options.Version).ToArray();                  if (versions.Length <= 0)                      throw new UserInformationException("No filesets matched the supplied time or versions");                    var orphans = db.CountOrphanFiles(null);                  if (orphans != 0)                      throw new UserInformationException(string.Format("Unable to start the purge process as there are {0} orphan file(s)"' orphans));                    Utility.UpdateOptionsFromDb(db' m_options);                  Utility.VerifyParameters(db' m_options);                    if (filtercommand == null)                  {                      db.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' false);                        if (m_options.NoBackendverification)                          FilelistProcessor.VerifyLocalList(backend' m_options' db' m_result.BackendWriter);                      else                          FilelistProcessor.VerifyRemoteList(backend' m_options' db' m_result.BackendWriter' null);                  }                    var filesets = db.FilesetTimes.ToArray();                    var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;                  var currentprogress = pgoffset;                    m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Process);                  m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                    // Reverse makes sure we re-write the old versions first                  foreach (var versionid in versions.Reverse())                  {                      using (var tr = db.BeginTransaction())                      {                          var ix = -1;                          for (var i = 0; i < filesets.Length; i++)                              if (filesets[i].Key == versionid)                              {                                  ix = i;                                  break;                              }                            if (ix < 0)                              throw new InvalidProgramException(string.Format("Fileset was reported with id {0}' but could not be found?"' versionid));                            var secs = 0;                          while (secs < 60)                          {                              secs++;                              var tfn = Volumes.VolumeBase.GenerateFilename(RemoteVolumeType.Files' m_options' null' filesets[ix].Value.AddSeconds(secs));                              if (db.GetRemoteVolumeID(tfn' tr) < 0)                                  break;                          }                            var ts = filesets[ix].Value.AddSeconds(secs);                          var prevfilename = db.GetRemoteVolumeNameForFileset(filesets[ix].Key' tr);                            if (secs >= 60)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));                            if (ix != 0 && filesets[ix - 1].Value <= ts)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets[ix - 1].Value));                            using (var tempset = db.CreateTemporaryFileset(versionid' tr))                          {                              if (filtercommand == null)                                  tempset.ApplyFilter(filter);                              else                                  tempset.ApplyFilter(filtercommand);                                if (tempset.RemovedFileCount == 0)                              {                                  m_result.AddMessage(string.Format("Not writing a new fileset for {0} as it was not changed"' prevfilename));                                  currentprogress += versionprogress;                                  tr.Rollback();                                  continue;                              }                              else                              {                                  using (var tf = new Library.Utility.TempFile())                                  using (var vol = new Volumes.FilesetVolumeWriter(m_options' ts))                                  {                                      var newids = tempset.ConvertToPermanentFileset(vol.RemoteFilename' ts);                                      vol.VolumeID = newids.Item1;                                        m_result.AddMessage(string.Format("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString(tempset.RemovedFileSize)));                                        db.WriteFileset(vol' tr' newids.Item2);                                        m_result.RemovedFileSize += tempset.RemovedFileSize;                                      m_result.RemovedFileCount += tempset.RemovedFileCount;                                      m_result.RewrittenFileLists++;                                        currentprogress += (versionprogress / 2);                                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                                        if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                      {                                          foreach (var fe in tempset.ListAllDeletedFiles())                                          {                                              var msg = string.Format("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString(fe.Value));                                                if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                                  Logging.Log.WriteMessage(msg' Logging.LogMessageType.Profiling);                                                if (m_options.Dryrun)                                                  m_result.AddDryrunMessage(msg);                                              else if (m_options.Verbose)                                                  m_result.AddVerboseMessage(msg);                                          }                                            if (m_options.Dryrun)                                              m_result.AddDryrunMessage("Writing files to remote storage");                                          else if (m_options.Verbose)                                              m_result.AddVerboseMessage("Writing files to remote storage");                                      }                                        if (m_options.Dryrun)                                      {                                          m_result.AddDryrunMessage(string.Format("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString(vol.Filesize)' prevfilename' tempset.RemovedFileCount));                                          tr.Rollback();                                      }                                      else                                      {                                          var lst = db.DropFilesetsFromTable(new[] { filesets[ix].Value }' tr).ToArray();                                          foreach (var f in lst)                                              db.UpdateRemoteVolume(f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);                                            tr.Commit();                                          backend.Put(vol' synchronous: true);                                          backend.Delete(prevfilename' -1' true);                                          backend.FlushDbMessages();                                      }                                  }                              }                          }                      }                        currentprogress += (versionprogress / 2);                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                  }                      if (doCompactStep)                  {                      if (m_result.RewrittenFileLists == 0)                      {                          m_result.AddMessage("Skipping compacting as no new volumes were written");                      }                      else                      {                          m_result.OperationProgressUpdater.UpdateProgress(pgoffset + (0.75f * pgspan));                          m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Compact);                          m_result.CompactResults = new CompactResults(m_result);                          using (var cdb = new Database.LocalDeleteDatabase(db))                          {                              var tr = cdb.BeginTransaction();                              try                              {                                  new CompactHandler(backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact(cdb' true' ref tr' backend);                              }                              catch                              {                                  try { tr.Rollback(); }                                  catch { }                              }                              finally                              {                                  try { tr.Commit(); }                                  catch { }                              }                          }                      }                        m_result.OperationProgressUpdater.UpdateProgress(pgoffset + pgspan);                      m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Complete);                  }                    backend.WaitForComplete(db' null);              }
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' db))              {                  if (db.PartiallyRecreated)                      throw new UserInformationException("The purge command does not work on partially recreated databases");                    if (db.RepairInProgress && filtercommand == null)                      throw new UserInformationException(string.Format("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));                    var versions = db.GetFilesetIDs(m_options.Time' m_options.Version).ToArray();                  if (versions.Length <= 0)                      throw new UserInformationException("No filesets matched the supplied time or versions");                    var orphans = db.CountOrphanFiles(null);                  if (orphans != 0)                      throw new UserInformationException(string.Format("Unable to start the purge process as there are {0} orphan file(s)"' orphans));                    Utility.UpdateOptionsFromDb(db' m_options);                  Utility.VerifyParameters(db' m_options);                    if (filtercommand == null)                  {                      db.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' false);                        if (m_options.NoBackendverification)                          FilelistProcessor.VerifyLocalList(backend' m_options' db' m_result.BackendWriter);                      else                          FilelistProcessor.VerifyRemoteList(backend' m_options' db' m_result.BackendWriter' null);                  }                    var filesets = db.FilesetTimes.ToArray();                    var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;                  var currentprogress = pgoffset;                    m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Process);                  m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                    // Reverse makes sure we re-write the old versions first                  foreach (var versionid in versions.Reverse())                  {                      using (var tr = db.BeginTransaction())                      {                          var ix = -1;                          for (var i = 0; i < filesets.Length; i++)                              if (filesets[i].Key == versionid)                              {                                  ix = i;                                  break;                              }                            if (ix < 0)                              throw new InvalidProgramException(string.Format("Fileset was reported with id {0}' but could not be found?"' versionid));                            var secs = 0;                          while (secs < 60)                          {                              secs++;                              var tfn = Volumes.VolumeBase.GenerateFilename(RemoteVolumeType.Files' m_options' null' filesets[ix].Value.AddSeconds(secs));                              if (db.GetRemoteVolumeID(tfn' tr) < 0)                                  break;                          }                            var ts = filesets[ix].Value.AddSeconds(secs);                          var prevfilename = db.GetRemoteVolumeNameForFileset(filesets[ix].Key' tr);                            if (secs >= 60)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));                            if (ix != 0 && filesets[ix - 1].Value <= ts)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets[ix - 1].Value));                            using (var tempset = db.CreateTemporaryFileset(versionid' tr))                          {                              if (filtercommand == null)                                  tempset.ApplyFilter(filter);                              else                                  tempset.ApplyFilter(filtercommand);                                if (tempset.RemovedFileCount == 0)                              {                                  m_result.AddMessage(string.Format("Not writing a new fileset for {0} as it was not changed"' prevfilename));                                  currentprogress += versionprogress;                                  tr.Rollback();                                  continue;                              }                              else                              {                                  using (var tf = new Library.Utility.TempFile())                                  using (var vol = new Volumes.FilesetVolumeWriter(m_options' ts))                                  {                                      var newids = tempset.ConvertToPermanentFileset(vol.RemoteFilename' ts);                                      vol.VolumeID = newids.Item1;                                        m_result.AddMessage(string.Format("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString(tempset.RemovedFileSize)));                                        db.WriteFileset(vol' tr' newids.Item2);                                        m_result.RemovedFileSize += tempset.RemovedFileSize;                                      m_result.RemovedFileCount += tempset.RemovedFileCount;                                      m_result.RewrittenFileLists++;                                        currentprogress += (versionprogress / 2);                                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                                        if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                      {                                          foreach (var fe in tempset.ListAllDeletedFiles())                                          {                                              var msg = string.Format("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString(fe.Value));                                                if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                                  Logging.Log.WriteMessage(msg' Logging.LogMessageType.Profiling);                                                if (m_options.Dryrun)                                                  m_result.AddDryrunMessage(msg);                                              else if (m_options.Verbose)                                                  m_result.AddVerboseMessage(msg);                                          }                                            if (m_options.Dryrun)                                              m_result.AddDryrunMessage("Writing files to remote storage");                                          else if (m_options.Verbose)                                              m_result.AddVerboseMessage("Writing files to remote storage");                                      }                                        if (m_options.Dryrun)                                      {                                          m_result.AddDryrunMessage(string.Format("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString(vol.Filesize)' prevfilename' tempset.RemovedFileCount));                                          tr.Rollback();                                      }                                      else                                      {                                          var lst = db.DropFilesetsFromTable(new[] { filesets[ix].Value }' tr).ToArray();                                          foreach (var f in lst)                                              db.UpdateRemoteVolume(f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);                                            tr.Commit();                                          backend.Put(vol' synchronous: true);                                          backend.Delete(prevfilename' -1' true);                                          backend.FlushDbMessages();                                      }                                  }                              }                          }                      }                        currentprogress += (versionprogress / 2);                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                  }                      if (doCompactStep)                  {                      if (m_result.RewrittenFileLists == 0)                      {                          m_result.AddMessage("Skipping compacting as no new volumes were written");                      }                      else                      {                          m_result.OperationProgressUpdater.UpdateProgress(pgoffset + (0.75f * pgspan));                          m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Compact);                          m_result.CompactResults = new CompactResults(m_result);                          using (var cdb = new Database.LocalDeleteDatabase(db))                          {                              var tr = cdb.BeginTransaction();                              try                              {                                  new CompactHandler(backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact(cdb' true' ref tr' backend);                              }                              catch                              {                                  try { tr.Rollback(); }                                  catch { }                              }                              finally                              {                                  try { tr.Commit(); }                                  catch { }                              }                          }                      }                        m_result.OperationProgressUpdater.UpdateProgress(pgoffset + pgspan);                      m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Complete);                  }                    backend.WaitForComplete(db' null);              }
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' db))              {                  if (db.PartiallyRecreated)                      throw new UserInformationException("The purge command does not work on partially recreated databases");                    if (db.RepairInProgress && filtercommand == null)                      throw new UserInformationException(string.Format("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));                    var versions = db.GetFilesetIDs(m_options.Time' m_options.Version).ToArray();                  if (versions.Length <= 0)                      throw new UserInformationException("No filesets matched the supplied time or versions");                    var orphans = db.CountOrphanFiles(null);                  if (orphans != 0)                      throw new UserInformationException(string.Format("Unable to start the purge process as there are {0} orphan file(s)"' orphans));                    Utility.UpdateOptionsFromDb(db' m_options);                  Utility.VerifyParameters(db' m_options);                    if (filtercommand == null)                  {                      db.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' false);                        if (m_options.NoBackendverification)                          FilelistProcessor.VerifyLocalList(backend' m_options' db' m_result.BackendWriter);                      else                          FilelistProcessor.VerifyRemoteList(backend' m_options' db' m_result.BackendWriter' null);                  }                    var filesets = db.FilesetTimes.ToArray();                    var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;                  var currentprogress = pgoffset;                    m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Process);                  m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                    // Reverse makes sure we re-write the old versions first                  foreach (var versionid in versions.Reverse())                  {                      using (var tr = db.BeginTransaction())                      {                          var ix = -1;                          for (var i = 0; i < filesets.Length; i++)                              if (filesets[i].Key == versionid)                              {                                  ix = i;                                  break;                              }                            if (ix < 0)                              throw new InvalidProgramException(string.Format("Fileset was reported with id {0}' but could not be found?"' versionid));                            var secs = 0;                          while (secs < 60)                          {                              secs++;                              var tfn = Volumes.VolumeBase.GenerateFilename(RemoteVolumeType.Files' m_options' null' filesets[ix].Value.AddSeconds(secs));                              if (db.GetRemoteVolumeID(tfn' tr) < 0)                                  break;                          }                            var ts = filesets[ix].Value.AddSeconds(secs);                          var prevfilename = db.GetRemoteVolumeNameForFileset(filesets[ix].Key' tr);                            if (secs >= 60)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));                            if (ix != 0 && filesets[ix - 1].Value <= ts)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets[ix - 1].Value));                            using (var tempset = db.CreateTemporaryFileset(versionid' tr))                          {                              if (filtercommand == null)                                  tempset.ApplyFilter(filter);                              else                                  tempset.ApplyFilter(filtercommand);                                if (tempset.RemovedFileCount == 0)                              {                                  m_result.AddMessage(string.Format("Not writing a new fileset for {0} as it was not changed"' prevfilename));                                  currentprogress += versionprogress;                                  tr.Rollback();                                  continue;                              }                              else                              {                                  using (var tf = new Library.Utility.TempFile())                                  using (var vol = new Volumes.FilesetVolumeWriter(m_options' ts))                                  {                                      var newids = tempset.ConvertToPermanentFileset(vol.RemoteFilename' ts);                                      vol.VolumeID = newids.Item1;                                        m_result.AddMessage(string.Format("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString(tempset.RemovedFileSize)));                                        db.WriteFileset(vol' tr' newids.Item2);                                        m_result.RemovedFileSize += tempset.RemovedFileSize;                                      m_result.RemovedFileCount += tempset.RemovedFileCount;                                      m_result.RewrittenFileLists++;                                        currentprogress += (versionprogress / 2);                                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                                        if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                      {                                          foreach (var fe in tempset.ListAllDeletedFiles())                                          {                                              var msg = string.Format("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString(fe.Value));                                                if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                                  Logging.Log.WriteMessage(msg' Logging.LogMessageType.Profiling);                                                if (m_options.Dryrun)                                                  m_result.AddDryrunMessage(msg);                                              else if (m_options.Verbose)                                                  m_result.AddVerboseMessage(msg);                                          }                                            if (m_options.Dryrun)                                              m_result.AddDryrunMessage("Writing files to remote storage");                                          else if (m_options.Verbose)                                              m_result.AddVerboseMessage("Writing files to remote storage");                                      }                                        if (m_options.Dryrun)                                      {                                          m_result.AddDryrunMessage(string.Format("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString(vol.Filesize)' prevfilename' tempset.RemovedFileCount));                                          tr.Rollback();                                      }                                      else                                      {                                          var lst = db.DropFilesetsFromTable(new[] { filesets[ix].Value }' tr).ToArray();                                          foreach (var f in lst)                                              db.UpdateRemoteVolume(f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);                                            tr.Commit();                                          backend.Put(vol' synchronous: true);                                          backend.Delete(prevfilename' -1' true);                                          backend.FlushDbMessages();                                      }                                  }                              }                          }                      }                        currentprogress += (versionprogress / 2);                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                  }                      if (doCompactStep)                  {                      if (m_result.RewrittenFileLists == 0)                      {                          m_result.AddMessage("Skipping compacting as no new volumes were written");                      }                      else                      {                          m_result.OperationProgressUpdater.UpdateProgress(pgoffset + (0.75f * pgspan));                          m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Compact);                          m_result.CompactResults = new CompactResults(m_result);                          using (var cdb = new Database.LocalDeleteDatabase(db))                          {                              var tr = cdb.BeginTransaction();                              try                              {                                  new CompactHandler(backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact(cdb' true' ref tr' backend);                              }                              catch                              {                                  try { tr.Rollback(); }                                  catch { }                              }                              finally                              {                                  try { tr.Commit(); }                                  catch { }                              }                          }                      }                        m_result.OperationProgressUpdater.UpdateProgress(pgoffset + pgspan);                      m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Complete);                  }                    backend.WaitForComplete(db' null);              }
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager(m_backendurl' m_options' m_result.BackendWriter' db))              {                  if (db.PartiallyRecreated)                      throw new UserInformationException("The purge command does not work on partially recreated databases");                    if (db.RepairInProgress && filtercommand == null)                      throw new UserInformationException(string.Format("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));                    var versions = db.GetFilesetIDs(m_options.Time' m_options.Version).ToArray();                  if (versions.Length <= 0)                      throw new UserInformationException("No filesets matched the supplied time or versions");                    var orphans = db.CountOrphanFiles(null);                  if (orphans != 0)                      throw new UserInformationException(string.Format("Unable to start the purge process as there are {0} orphan file(s)"' orphans));                    Utility.UpdateOptionsFromDb(db' m_options);                  Utility.VerifyParameters(db' m_options);                    if (filtercommand == null)                  {                      db.VerifyConsistency(null' m_options.Blocksize' m_options.BlockhashSize' false);                        if (m_options.NoBackendverification)                          FilelistProcessor.VerifyLocalList(backend' m_options' db' m_result.BackendWriter);                      else                          FilelistProcessor.VerifyRemoteList(backend' m_options' db' m_result.BackendWriter' null);                  }                    var filesets = db.FilesetTimes.ToArray();                    var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;                  var currentprogress = pgoffset;                    m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Process);                  m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                    // Reverse makes sure we re-write the old versions first                  foreach (var versionid in versions.Reverse())                  {                      using (var tr = db.BeginTransaction())                      {                          var ix = -1;                          for (var i = 0; i < filesets.Length; i++)                              if (filesets[i].Key == versionid)                              {                                  ix = i;                                  break;                              }                            if (ix < 0)                              throw new InvalidProgramException(string.Format("Fileset was reported with id {0}' but could not be found?"' versionid));                            var secs = 0;                          while (secs < 60)                          {                              secs++;                              var tfn = Volumes.VolumeBase.GenerateFilename(RemoteVolumeType.Files' m_options' null' filesets[ix].Value.AddSeconds(secs));                              if (db.GetRemoteVolumeID(tfn' tr) < 0)                                  break;                          }                            var ts = filesets[ix].Value.AddSeconds(secs);                          var prevfilename = db.GetRemoteVolumeNameForFileset(filesets[ix].Key' tr);                            if (secs >= 60)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));                            if (ix != 0 && filesets[ix - 1].Value <= ts)                              throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets[ix - 1].Value));                            using (var tempset = db.CreateTemporaryFileset(versionid' tr))                          {                              if (filtercommand == null)                                  tempset.ApplyFilter(filter);                              else                                  tempset.ApplyFilter(filtercommand);                                if (tempset.RemovedFileCount == 0)                              {                                  m_result.AddMessage(string.Format("Not writing a new fileset for {0} as it was not changed"' prevfilename));                                  currentprogress += versionprogress;                                  tr.Rollback();                                  continue;                              }                              else                              {                                  using (var tf = new Library.Utility.TempFile())                                  using (var vol = new Volumes.FilesetVolumeWriter(m_options' ts))                                  {                                      var newids = tempset.ConvertToPermanentFileset(vol.RemoteFilename' ts);                                      vol.VolumeID = newids.Item1;                                        m_result.AddMessage(string.Format("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString(tempset.RemovedFileSize)));                                        db.WriteFileset(vol' tr' newids.Item2);                                        m_result.RemovedFileSize += tempset.RemovedFileSize;                                      m_result.RemovedFileCount += tempset.RemovedFileCount;                                      m_result.RewrittenFileLists++;                                        currentprogress += (versionprogress / 2);                                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                                        if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                      {                                          foreach (var fe in tempset.ListAllDeletedFiles())                                          {                                              var msg = string.Format("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString(fe.Value));                                                if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)                                                  Logging.Log.WriteMessage(msg' Logging.LogMessageType.Profiling);                                                if (m_options.Dryrun)                                                  m_result.AddDryrunMessage(msg);                                              else if (m_options.Verbose)                                                  m_result.AddVerboseMessage(msg);                                          }                                            if (m_options.Dryrun)                                              m_result.AddDryrunMessage("Writing files to remote storage");                                          else if (m_options.Verbose)                                              m_result.AddVerboseMessage("Writing files to remote storage");                                      }                                        if (m_options.Dryrun)                                      {                                          m_result.AddDryrunMessage(string.Format("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString(vol.Filesize)' prevfilename' tempset.RemovedFileCount));                                          tr.Rollback();                                      }                                      else                                      {                                          var lst = db.DropFilesetsFromTable(new[] { filesets[ix].Value }' tr).ToArray();                                          foreach (var f in lst)                                              db.UpdateRemoteVolume(f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);                                            tr.Commit();                                          backend.Put(vol' synchronous: true);                                          backend.Delete(prevfilename' -1' true);                                          backend.FlushDbMessages();                                      }                                  }                              }                          }                      }                        currentprogress += (versionprogress / 2);                      m_result.OperationProgressUpdater.UpdateProgress(currentprogress);                  }                      if (doCompactStep)                  {                      if (m_result.RewrittenFileLists == 0)                      {                          m_result.AddMessage("Skipping compacting as no new volumes were written");                      }                      else                      {                          m_result.OperationProgressUpdater.UpdateProgress(pgoffset + (0.75f * pgspan));                          m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Compact);                          m_result.CompactResults = new CompactResults(m_result);                          using (var cdb = new Database.LocalDeleteDatabase(db))                          {                              var tr = cdb.BeginTransaction();                              try                              {                                  new CompactHandler(backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact(cdb' true' ref tr' backend);                              }                              catch                              {                                  try { tr.Rollback(); }                                  catch { }                              }                              finally                              {                                  try { tr.Commit(); }                                  catch { }                              }                          }                      }                        m_result.OperationProgressUpdater.UpdateProgress(pgoffset + pgspan);                      m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.PurgeFiles_Complete);                  }                    backend.WaitForComplete(db' null);              }
Magic Number,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The following statement contains a magic number: if (matches.Count == 0)              {                  var backupname = options.BackupName;                  if (string.IsNullOrEmpty(backupname) || backupname == Options.DefaultBackupName)                      backupname = GenerateRandomName();                  else                  {                      foreach(var c in System.IO.Path.GetInvalidFileNameChars())                          backupname = backupname.Replace(c.ToString()' "");                  }                                    var newpath = System.IO.Path.Combine(folder' backupname + ".sqlite");                  int max_tries = 100;                  while (System.IO.File.Exists(newpath) && max_tries-- > 0)                      newpath = System.IO.Path.Combine(folder' GenerateRandomName());                                    if (System.IO.File.Exists(newpath))                      throw new Duplicati.Library.Interface.UserInformationException("Unable to find a unique name for the database' please use --dbpath");                                    //Create a new one' add it to the list' and save it                  configs.Add(new BackendEntry() {                      Type = type'                      Server = server'                      Path = path'                      Prefix = prefix'                      Username = username'                      //Passwordhash = password'                      Port = port'                      Databasepath = newpath'                       ParameterFile = null                  });                                    var settings = new Newtonsoft.Json.JsonSerializerSettings();                  settings.Formatting = Newtonsoft.Json.Formatting.Indented;                  System.IO.File.WriteAllText(file' Newtonsoft.Json.JsonConvert.SerializeObject(configs' settings)' System.Text.Encoding.UTF8);                                    return newpath;              }              else              {                  return matches[0].Databasepath;              }
Magic Number,Duplicati.Library.Main,DatabaseLocator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GenerateRandomName,The following statement contains a magic number: for(var i = 0; i < 10; i++)                  backupname += (char)rnd.Next('A'' 'Z' + 1);
Magic Number,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: while (!m_queue.Completed)              {                  var item = m_queue.Dequeue();                  if (item != null)                  {                      int retries = 0;                      Exception lastException = null;                        do                      {                          try                          {                              if (m_taskControl != null)                                  m_taskControl.TaskControlRendevouz();                                                            if (m_options.NoConnectionReuse && m_backend != null)                              {                                  m_backend.Dispose();                                  m_backend = null;                              }                                if (m_backend == null)                                  m_backend = DynamicLoader.BackendLoader.GetBackend(m_backendurl' m_options.RawOptions);                              if (m_backend == null)                                  throw new Exception("Backend failed to re-load");                                using(new Logging.Timer(string.Format("RemoteOperation{0}"' item.Operation)))                                  switch (item.Operation)                                  {                                      case OperationType.Put:                                          DoPut(item);                                          // We do not auto create folders'                                          // because we know the folder exists                                          uploadSuccess = true;                                          break;                                      case OperationType.Get:                                          DoGet(item);                                          break;                                      case OperationType.List:                                          DoList(item);                                          break;                                      case OperationType.Delete:                                          DoDelete(item);                                          break;                                      case OperationType.CreateFolder:                                          DoCreateFolder(item);                                          break;                                      case OperationType.Terminate:                                          m_queue.SetCompleted();                                          break;                                      case OperationType.Nothing:                                          item.SignalComplete();                                          break;                                  }                                lastException = null;                              retries = m_numberofretries;                          }                          catch (Exception ex)                          {                              retries++;                              lastException = ex;                              m_statwriter.AddRetryAttempt(string.Format("Operation {0} with file {1} attempt {2} of {3} failed with message: {4}"' item.Operation' item.RemoteFilename' retries' m_numberofretries' ex.Message)' ex);                                                            // If the thread is aborted' we exit here                              if (ex is System.Threading.ThreadAbortException)                              {                                  m_queue.SetCompleted();                                  item.Exception = ex;                                  item.SignalComplete();                                  throw;                              }                                                            m_statwriter.SendEvent(item.BackendActionType' retries < m_numberofretries ? BackendEventType.Retrying : BackendEventType.Failed' item.RemoteFilename' item.Size);                                bool recovered = false;                              if (!uploadSuccess && ex is Duplicati.Library.Interface.FolderMissingException && m_options.AutocreateFolders)                              {                                  try                                   {                                       // If we successfully create the folder' we can re-use the connection                                      m_backend.CreateFolder();                                       recovered = true;                                  }                                  catch(Exception dex)                                   {                                       m_statwriter.AddWarning(string.Format("Failed to create folder: {0}"' ex.Message)' dex);                                   }                              }                                                            // To work around the Apache WEBDAV issue' we rename the file here                              if (item.Operation == OperationType.Put && retries < m_numberofretries && !item.NotTrackedInDb)                                  RenameFileAfterError(item);                                                            if (!recovered)                              {                                  try { m_backend.Dispose(); }                                  catch(Exception dex) { m_statwriter.AddWarning(LC.L("Failed to dispose backend instance: {0}"' ex.Message)' dex); }                                        m_backend = null;                                    if (retries < m_numberofretries && m_retrydelay.Ticks != 0)                                  {                                      var target = DateTime.Now.AddTicks(m_retrydelay.Ticks);                                      while (target > DateTime.Now)                                      {                                          if (m_taskControl != null && m_taskControl.IsAbortRequested())                                              break;                                                                                    System.Threading.Thread.Sleep(500);                                      }                                  }                              }                          }                                                  } while (retries < m_numberofretries);                        if (lastException != null && !(lastException is Duplicati.Library.Interface.FileMissingException) && item.Operation == OperationType.Delete)                      {                          m_statwriter.AddMessage(LC.L("Failed to delete file {0}' testing if file exists"' item.RemoteFilename));                          try                          {                              if (!m_backend.List().Select(x => x.Name).Contains(item.RemoteFilename))                              {                                  lastException = null;                                  m_statwriter.AddMessage(LC.L("Recovered from problem with attempting to delete non-existing file {0}"' item.RemoteFilename));                              }                          }                          catch(Exception ex)                          {                              m_statwriter.AddWarning(LC.L("Failed to recover from error deleting file {0}"' item.RemoteFilename)' ex);                          }                      }                        if (lastException != null)                      {                          item.Exception = lastException;                          if (item.Operation == OperationType.Put)                              item.DeleteLocalFile(m_statwriter);                                                                                    if (item.ExceptionKillsHandler)                          {                              m_lastException = lastException;                                //TODO: If there are temp files in the queue' we must delete them                              m_queue.SetCompleted();                             }                                                }                                            item.SignalComplete();                  }              }
Magic Number,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,RenameFileAfterError,The following statement contains a magic number: if (item.Indexfile != null)              {                  if (!item.IndexfileUpdated)                  {                      item.Indexfile.Item1.FinishVolume(item.Hash' item.Size);                      item.Indexfile.Item1.Close();                      item.IndexfileUpdated = true;                  }                                IndexVolumeWriter wr = null;                  try                  {                      var hashsize = HashAlgorithmHelper.Create(m_options.BlockHashAlgorithm).HashSize / 8;                      wr = new IndexVolumeWriter(m_options);                      using(var rd = new IndexVolumeReader(p.CompressionModule' item.Indexfile.Item2.LocalFilename' m_options' hashsize))                          wr.CopyFrom(rd' x => x == oldname ? newname : x);                      item.Indexfile.Item1.Dispose();                      item.Indexfile = new Tuple<IndexVolumeWriter' FileEntryItem>(wr' item.Indexfile.Item2);                      item.Indexfile.Item2.LocalTempfile.Dispose();                      item.Indexfile.Item2.LocalTempfile = wr.TempFile;                      wr.Close();                  }                  catch                  {                      if (wr != null)                          try { wr.Dispose(); }                          catch { }                          finally { wr = null; }                                                throw;                  }              }
Magic Number,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The following statement contains a magic number: try              {                  System.IO.Stream nextTierWriter = null; // target of our stacked streams                  if (!enableStreaming) // we will always need dlTarget if not streaming...                      dlTarget = new TempFile();                  else if (enableStreaming && useDecrypter == null)                  {                      dlTarget = new TempFile();                      dlToStream = System.IO.File.OpenWrite(dlTarget);                      nextTierWriter = dlToStream; // actually write through to file.                  }                    // setup decryption: fork off a StreamLink from stack' and setup decryptor task                  if (useDecrypter != null)                  {                      linkForkDecryptor = new DirectStreamLink(1 << 16' false' false' nextTierWriter);                      nextTierWriter = linkForkDecryptor.WriterStream;                      linkForkDecryptor.SetKnownLength(item.Size' false); // Set length to allow AES-decryption (not streamable yet)                      decryptTarget = new TempFile();                      decryptToStream = System.IO.File.OpenWrite(decryptTarget);                      taskDecrypter = new System.Threading.Tasks.Task(() =>                              {                                  using (var input = linkForkDecryptor.ReaderStream)                                  using (var output = decryptToStream)                                      lock (m_encryptionLock) { useDecrypter.Decrypt(input' output); }                              }                          );                  }                    // setup hashing: fork off a StreamLink from stack' then task computes hash                  linkForkHasher = new DirectStreamLink(1 << 16' false' false' nextTierWriter);                  nextTierWriter = linkForkHasher.WriterStream;                  taskHasher = new System.Threading.Tasks.Task<string>(() =>                          {                              using (var input = linkForkHasher.ReaderStream)                                  return CalculateFileHash(input);                          }                      );                    // OK' forks with tasks are set up' so let's do the download which is performed in main thread.                  bool hadException = false;                  try                  {                      if (enableStreaming)                      {                          using (var ss = new ShaderStream(nextTierWriter' false))                          {                              using (var ts = new ThrottledStream(ss' m_options.MaxUploadPrSecond' m_options.MaxDownloadPrSecond))                              using (var pgs = new Library.Utility.ProgressReportingStream(ts' item.Size' pg => HandleProgress(ts' pg)))                              {                                  taskHasher.Start(); // We do not start tasks earlier to be sure the input always gets closed.                                   if (taskDecrypter != null) taskDecrypter.Start();                                  ((Library.Interface.IStreamingBackend)m_backend).Get(item.RemoteFilename' pgs);                              }                              retDownloadSize = ss.TotalBytesWritten;                          }                      }                      else                      {                          m_backend.Get(item.RemoteFilename' dlTarget);                          retDownloadSize = new System.IO.FileInfo(dlTarget).Length;                          using (dlToStream = System.IO.File.OpenRead(dlTarget))                          {                              taskHasher.Start(); // We do not start tasks earlier to be sure the input always gets closed.                               if (taskDecrypter != null) taskDecrypter.Start();                              new DirectStreamLink.DataPump(dlToStream' nextTierWriter).Run();                          }                      }                  }                  catch (Exception)                  { hadException = true; throw; }                  finally                  {                      // This nested try-catch-finally blocks will make sure we do not miss any exceptions ans all started tasks                      // are properly ended and tidied up. For what is thrown: If exceptions in main thread occured (download) it is thrown'                      // then hasher task is checked and last decryption. This resembles old logic.                      try { retHashcode = taskHasher.Result; }                      catch (AggregateException ex) { if (!hadException) { hadException = true; throw ex.InnerExceptions[0]; } }                      finally                      {                          if (taskDecrypter != null)                          {                              try { taskDecrypter.Wait(); }                              catch (AggregateException ex)                              {                                  if (!hadException)                                  {                                      hadException = true;                                      if (ex.InnerExceptions[0] is System.Security.Cryptography.CryptographicException)                                          throw ex.InnerExceptions[0];                                      else                                          throw new System.Security.Cryptography.CryptographicException(ex.InnerExceptions[0].Message' ex.InnerExceptions[0]);                                  }                              }                          }                      }                  }                    if (useDecrypter != null) // return decrypted temp file                  { retTarget = decryptTarget; decryptTarget = null; }                  else // return downloaded file                  { retTarget = dlTarget; dlTarget = null; }              }              finally              {                  // Be tidy: manually do some cleanup to temp files' as we could not use using's.                  // Unclosed streams should only occur if we failed even before tasks were started.                  if (dlToStream != null) dlToStream.Dispose();                  if (dlTarget != null) dlTarget.Dispose();                  if (decryptToStream != null) decryptToStream.Dispose();                  if (decryptTarget != null) decryptTarget.Dispose();              }
Magic Number,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The following statement contains a magic number: try              {                  System.IO.Stream nextTierWriter = null; // target of our stacked streams                  if (!enableStreaming) // we will always need dlTarget if not streaming...                      dlTarget = new TempFile();                  else if (enableStreaming && useDecrypter == null)                  {                      dlTarget = new TempFile();                      dlToStream = System.IO.File.OpenWrite(dlTarget);                      nextTierWriter = dlToStream; // actually write through to file.                  }                    // setup decryption: fork off a StreamLink from stack' and setup decryptor task                  if (useDecrypter != null)                  {                      linkForkDecryptor = new DirectStreamLink(1 << 16' false' false' nextTierWriter);                      nextTierWriter = linkForkDecryptor.WriterStream;                      linkForkDecryptor.SetKnownLength(item.Size' false); // Set length to allow AES-decryption (not streamable yet)                      decryptTarget = new TempFile();                      decryptToStream = System.IO.File.OpenWrite(decryptTarget);                      taskDecrypter = new System.Threading.Tasks.Task(() =>                              {                                  using (var input = linkForkDecryptor.ReaderStream)                                  using (var output = decryptToStream)                                      lock (m_encryptionLock) { useDecrypter.Decrypt(input' output); }                              }                          );                  }                    // setup hashing: fork off a StreamLink from stack' then task computes hash                  linkForkHasher = new DirectStreamLink(1 << 16' false' false' nextTierWriter);                  nextTierWriter = linkForkHasher.WriterStream;                  taskHasher = new System.Threading.Tasks.Task<string>(() =>                          {                              using (var input = linkForkHasher.ReaderStream)                                  return CalculateFileHash(input);                          }                      );                    // OK' forks with tasks are set up' so let's do the download which is performed in main thread.                  bool hadException = false;                  try                  {                      if (enableStreaming)                      {                          using (var ss = new ShaderStream(nextTierWriter' false))                          {                              using (var ts = new ThrottledStream(ss' m_options.MaxUploadPrSecond' m_options.MaxDownloadPrSecond))                              using (var pgs = new Library.Utility.ProgressReportingStream(ts' item.Size' pg => HandleProgress(ts' pg)))                              {                                  taskHasher.Start(); // We do not start tasks earlier to be sure the input always gets closed.                                   if (taskDecrypter != null) taskDecrypter.Start();                                  ((Library.Interface.IStreamingBackend)m_backend).Get(item.RemoteFilename' pgs);                              }                              retDownloadSize = ss.TotalBytesWritten;                          }                      }                      else                      {                          m_backend.Get(item.RemoteFilename' dlTarget);                          retDownloadSize = new System.IO.FileInfo(dlTarget).Length;                          using (dlToStream = System.IO.File.OpenRead(dlTarget))                          {                              taskHasher.Start(); // We do not start tasks earlier to be sure the input always gets closed.                               if (taskDecrypter != null) taskDecrypter.Start();                              new DirectStreamLink.DataPump(dlToStream' nextTierWriter).Run();                          }                      }                  }                  catch (Exception)                  { hadException = true; throw; }                  finally                  {                      // This nested try-catch-finally blocks will make sure we do not miss any exceptions ans all started tasks                      // are properly ended and tidied up. For what is thrown: If exceptions in main thread occured (download) it is thrown'                      // then hasher task is checked and last decryption. This resembles old logic.                      try { retHashcode = taskHasher.Result; }                      catch (AggregateException ex) { if (!hadException) { hadException = true; throw ex.InnerExceptions[0]; } }                      finally                      {                          if (taskDecrypter != null)                          {                              try { taskDecrypter.Wait(); }                              catch (AggregateException ex)                              {                                  if (!hadException)                                  {                                      hadException = true;                                      if (ex.InnerExceptions[0] is System.Security.Cryptography.CryptographicException)                                          throw ex.InnerExceptions[0];                                      else                                          throw new System.Security.Cryptography.CryptographicException(ex.InnerExceptions[0].Message' ex.InnerExceptions[0]);                                  }                              }                          }                      }                  }                    if (useDecrypter != null) // return decrypted temp file                  { retTarget = decryptTarget; decryptTarget = null; }                  else // return downloaded file                  { retTarget = dlTarget; dlTarget = null; }              }              finally              {                  // Be tidy: manually do some cleanup to temp files' as we could not use using's.                  // Unclosed streams should only occur if we failed even before tasks were started.                  if (dlToStream != null) dlToStream.Dispose();                  if (dlTarget != null) dlTarget.Dispose();                  if (decryptToStream != null) decryptToStream.Dispose();                  if (decryptTarget != null) decryptTarget.Dispose();              }
Magic Number,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Dispose,The following statement contains a magic number: if (m_thread != null)              {                  if (!m_thread.Join(TimeSpan.FromSeconds(10)))                  {                      m_thread.Abort();                      m_thread.Join(TimeSpan.FromSeconds(10));                  }                    m_thread = null;              }
Magic Number,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Dispose,The following statement contains a magic number: if (m_thread != null)              {                  if (!m_thread.Join(TimeSpan.FromSeconds(10)))                  {                      m_thread.Abort();                      m_thread.Join(TimeSpan.FromSeconds(10));                  }                    m_thread = null;              }
Magic Number,Duplicati.Library.Main,DatabaseCollector,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,FlushDbMessages,The following statement contains a magic number: foreach(var e in entries)                      if (e is DbOperation)                          db.LogRemoteOperation(((DbOperation)e).Action' ((DbOperation)e).File' ((DbOperation)e).Result' transaction);                      else if (e is DbUpdate && ((DbUpdate)e).State == RemoteVolumeState.Deleted)                      {                          db.UpdateRemoteVolume(((DbUpdate)e).Remotename' RemoteVolumeState.Deleted' ((DbUpdate)e).Size' ((DbUpdate)e).Hash' true' TimeSpan.FromHours(2)' transaction);                          volsRemoved.Add(((DbUpdate)e).Remotename);                      }                      else if (e is DbUpdate)                          db.UpdateRemoteVolume(((DbUpdate)e).Remotename' ((DbUpdate)e).State' ((DbUpdate)e).Size' ((DbUpdate)e).Hash' transaction);                      else if (e is DbRename)                          db.RenameRemoteFile(((DbRename)e).Oldname' ((DbRename)e).Newname' transaction);                      else if (e != null)                          m_stats.AddError(string.Format("Queue had element of type: {0}' {1}"' e.GetType()' e)' null);
Magic Number,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The following statement contains a magic number: if (options.NoEncryption)              {                  newDict.Add("passphrase"' "no-encryption");              }              else              {                  string salt;                  opts.TryGetValue("passphrase-salt"' out salt);                  if (string.IsNullOrEmpty(salt))                  {                      // Not Crypto-class PRNG salts                      var buf = new byte[32];                      new Random().NextBytes(buf);                      //Add version so we can detect and change the algorithm                      salt = "v1:" + Library.Utility.Utility.ByteArrayAsHexString(buf);                  }                    newDict["passphrase-salt"] = salt;                                // We avoid storing the passphrase directly'                   // instead we salt and rehash repeatedly                  newDict.Add("passphrase"' Library.Utility.Utility.ByteArrayAsHexString(Library.Utility.Utility.RepeatedHashWithSalt(options.Passphrase' salt' 1200)));              }
Magic Number,Duplicati.Library.Main,Utility,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The following statement contains a magic number: if (options.NoEncryption)              {                  newDict.Add("passphrase"' "no-encryption");              }              else              {                  string salt;                  opts.TryGetValue("passphrase-salt"' out salt);                  if (string.IsNullOrEmpty(salt))                  {                      // Not Crypto-class PRNG salts                      var buf = new byte[32];                      new Random().NextBytes(buf);                      //Add version so we can detect and change the algorithm                      salt = "v1:" + Library.Utility.Utility.ByteArrayAsHexString(buf);                  }                    newDict["passphrase-salt"] = salt;                                // We avoid storing the passphrase directly'                   // instead we salt and rehash repeatedly                  newDict.Add("passphrase"' Library.Utility.Utility.ByteArrayAsHexString(Library.Utility.Utility.RepeatedHashWithSalt(options.Passphrase' salt' 1200)));              }
Magic Number,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (m_options != null && !m_options.AllowSleep)              {                  if (Duplicati.Library.Utility.Utility.IsClientWindows)                  {                      try                      {                          Win32.SetThreadExecutionState(Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0));                      }                      catch (Exception ex)                      {                          Logging.Log.WriteMessage("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);                      }                  }                  else if (Duplicati.Library.Utility.Utility.IsClientOSX)                  {                      if (isRunning)                      {                          try                          {                              if (m_caffeinate == null)                              {                                  // -s prevents sleep on AC' -i prevents sleep generally                                  var psi = new System.Diagnostics.ProcessStartInfo("caffeinate"' "-s");                                  psi.RedirectStandardInput = true;                                  psi.UseShellExecute = false;                                  m_caffeinate = System.Diagnostics.Process.Start(psi);                              }                          }                          catch (Exception ex)                          {                              Logging.Log.WriteMessage("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);                          }                      }                      else                      {                          try                          {                              if (m_caffeinate != null && !m_caffeinate.HasExited)                              {                                  // Send CTRL+C                                  m_caffeinate.StandardInput.Write("\x3");                                  m_caffeinate.StandardInput.Flush();                                  m_caffeinate.WaitForExit(500);                                    if (!m_caffeinate.HasExited)                                  {                                      m_caffeinate.Kill();                                      m_caffeinate.WaitForExit(500);                                      if (!m_caffeinate.HasExited)                                          throw new Exception("Failed to kill the caffeinate process");                                  }                              }                          }                          catch (Exception ex)                          {                              Logging.Log.WriteMessage("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);                          }                                                    }                  }              }
Magic Number,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (m_options != null && !m_options.AllowSleep)              {                  if (Duplicati.Library.Utility.Utility.IsClientWindows)                  {                      try                      {                          Win32.SetThreadExecutionState(Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0));                      }                      catch (Exception ex)                      {                          Logging.Log.WriteMessage("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);                      }                  }                  else if (Duplicati.Library.Utility.Utility.IsClientOSX)                  {                      if (isRunning)                      {                          try                          {                              if (m_caffeinate == null)                              {                                  // -s prevents sleep on AC' -i prevents sleep generally                                  var psi = new System.Diagnostics.ProcessStartInfo("caffeinate"' "-s");                                  psi.RedirectStandardInput = true;                                  psi.UseShellExecute = false;                                  m_caffeinate = System.Diagnostics.Process.Start(psi);                              }                          }                          catch (Exception ex)                          {                              Logging.Log.WriteMessage("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);                          }                      }                      else                      {                          try                          {                              if (m_caffeinate != null && !m_caffeinate.HasExited)                              {                                  // Send CTRL+C                                  m_caffeinate.StandardInput.Write("\x3");                                  m_caffeinate.StandardInput.Flush();                                  m_caffeinate.WaitForExit(500);                                    if (!m_caffeinate.HasExited)                                  {                                      m_caffeinate.Kill();                                      m_caffeinate.WaitForExit(500);                                      if (!m_caffeinate.HasExited)                                          throw new Exception("Failed to kill the caffeinate process");                                  }                              }                          }                          catch (Exception ex)                          {                              Logging.Log.WriteMessage("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);                          }                                                    }                  }              }
Magic Number,Duplicati.Library.Main,Controller,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SendMail,The following statement contains a magic number: return RunAction(new SendMailResults()' result =>              {                  result.Lines = new string[0];                  System.Threading.Thread.Sleep(5);              });
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: m_entries = Math.Max(16' maxmemory / (ulong)IntPtr.Size);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for(byte i = 0; i < 10; i++)                  HEXTB['0' + i] = i;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 6; i++)              {                  //Case insensitive support                  HEXTB['A' + i] = (byte)(i + 10);                  HEXTB['a' + i] = (byte)(i + 10);              }
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 6; i++)              {                  //Case insensitive support                  HEXTB['A' + i] = (byte)(i + 10);                  HEXTB['a' + i] = (byte)(i + 10);              }
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 6; i++)              {                  //Case insensitive support                  HEXTB['A' + i] = (byte)(i + 10);                  HEXTB['a' + i] = (byte)(i + 10);              }
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 26; i++)                  BAS64TB['A' + i] = i;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 26; i++)                  BAS64TB['a' + i] = (byte)(i + 26);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 26; i++)                  BAS64TB['a' + i] = (byte)(i + 26);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 10; i++)                  BAS64TB['0' + i] = (byte)(i + 52);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 10; i++)                  BAS64TB['0' + i] = (byte)(i + 52);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB['+'] = 62;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB['/'] = 63;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB['-'] = 62;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB['_'] = 63;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return                  ((value << 56) & 0xff00000000000000uL) |                  ((value << 40) & 0x00ff000000000000uL) |                  ((value << 24) & 0x0000ff0000000000uL) |                  ((value << 8)  & 0x000000ff00000000uL) |                  ((value >> 8)  & 0x00000000ff000000uL) |                  ((value >> 24) & 0x0000000000ff0000uL) |                  ((value >> 40) & 0x000000000000ff00uL) |                  ((value >> 56) & 0x00000000000000ffuL);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return                  (ulong)HEXTB[hash[0]] << 60 |                  (ulong)HEXTB[hash[1]] << 56 |                  (ulong)HEXTB[hash[2]] << 52 |                  (ulong)HEXTB[hash[3]] << 48 |                  (ulong)HEXTB[hash[4]] << 44 |                  (ulong)HEXTB[hash[5]] << 40 |                  (ulong)HEXTB[hash[6]] << 36 |                  (ulong)HEXTB[hash[7]] << 32 |                  (ulong)HEXTB[hash[8]] << 28 |                  (ulong)HEXTB[hash[9]] << 24 |                  (ulong)HEXTB[hash[10]] << 20 |                  (ulong)HEXTB[hash[11]] << 16 |                  (ulong)HEXTB[hash[12]] << 12 |                  (ulong)HEXTB[hash[13]] << 8 |                  (ulong)HEXTB[hash[14]] << 4 |                  (ulong)HEXTB[hash[15]] << 0;
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main,HashLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return                  (ulong)BAS64TB[hash[0]] << 58 |                  (ulong)BAS64TB[hash[1]] << 52 |                  (ulong)BAS64TB[hash[2]] << 46 |                  (ulong)BAS64TB[hash[3]] << 40 |                  (ulong)BAS64TB[hash[4]] << 34 |                  (ulong)BAS64TB[hash[5]] << 28 |                  (ulong)BAS64TB[hash[6]] << 22 |                  (ulong)BAS64TB[hash[7]] << 16 |                  (ulong)BAS64TB[hash[8]] << 10 |                  (ulong)BAS64TB[hash[9]] << 4 |                  (((ulong)BAS64TB[hash[10]] >> 2) & 0x0f);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findblockCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findblocksetCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findmetadatasetCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findfilesetCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblockCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertfileOperationCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertfileCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocksetCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocksetentryFastCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocksetentryCommand.AddParameters(4);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocklistHashesCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_selectfilelastmodifiedCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  //Need a temporary table with path/lastmodified lookups                  var scantableDefinition =                      @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " +                      @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A1"" LEFT JOIN " +                      @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " +                      @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " +                      @" WHERE ""A2"".""Path"" IS NULL " +                      @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " +                      @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " +                      @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";                    if (m_pathLookup != null)                      using(new Logging.Timer("Build path lastmodified lookup table"))                      using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))                          while (rd.Read())                          {                              var id = rd.GetInt64(0);                              var lastmodified = new DateTime(rd.GetInt64(1)' DateTimeKind.Utc);                              var filesize = rd.GetInt64(2);                              var path = rd.GetString(3);                              var metahash = rd.GetString(4);                              var metasize = rd.GetInt64(5);                              m_pathLookup.Insert(path' new PathEntryKeeper(id' lastmodified' filesize' metahash' metasize));                          }                    if (m_pathLookup != null)                      try                      {                          using(new Logging.Timer("Build path lookup table"))                          using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))                              while (rd.Read())                              {                                  var path = rd.GetValue(0).ToString();                                  var blocksetid = rd.GetInt64(1);                                  var metadataid = rd.GetInt64(2);                                  var filesetid = rd.GetInt64(3);                                    PathEntryKeeper r;                                  if (!m_pathLookup.TryFind(path' out r))                                  {                                      r = new PathEntryKeeper(-1' new DateTime(0' DateTimeKind.Utc)' -1' null' -1);                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                                      m_pathLookup.Insert(path' r);                                  }                                  else                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                              }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("Duplicate file entries detected' run repair to fix it"' ex);                      }                    var tc = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString()' RemoteVolumeState.Uploading.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                  if (tc > 0)                      throw new InvalidDataException("Detected blocks that are not reachable in the block table");              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  //Need a temporary table with path/lastmodified lookups                  var scantableDefinition =                      @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " +                      @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A1"" LEFT JOIN " +                      @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " +                      @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " +                      @" WHERE ""A2"".""Path"" IS NULL " +                      @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " +                      @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " +                      @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";                    if (m_pathLookup != null)                      using(new Logging.Timer("Build path lastmodified lookup table"))                      using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))                          while (rd.Read())                          {                              var id = rd.GetInt64(0);                              var lastmodified = new DateTime(rd.GetInt64(1)' DateTimeKind.Utc);                              var filesize = rd.GetInt64(2);                              var path = rd.GetString(3);                              var metahash = rd.GetString(4);                              var metasize = rd.GetInt64(5);                              m_pathLookup.Insert(path' new PathEntryKeeper(id' lastmodified' filesize' metahash' metasize));                          }                    if (m_pathLookup != null)                      try                      {                          using(new Logging.Timer("Build path lookup table"))                          using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))                              while (rd.Read())                              {                                  var path = rd.GetValue(0).ToString();                                  var blocksetid = rd.GetInt64(1);                                  var metadataid = rd.GetInt64(2);                                  var filesetid = rd.GetInt64(3);                                    PathEntryKeeper r;                                  if (!m_pathLookup.TryFind(path' out r))                                  {                                      r = new PathEntryKeeper(-1' new DateTime(0' DateTimeKind.Utc)' -1' null' -1);                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                                      m_pathLookup.Insert(path' r);                                  }                                  else                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                              }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("Duplicate file entries detected' run repair to fix it"' ex);                      }                    var tc = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString()' RemoteVolumeState.Uploading.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                  if (tc > 0)                      throw new InvalidDataException("Detected blocks that are not reachable in the block table");              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  //Need a temporary table with path/lastmodified lookups                  var scantableDefinition =                      @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " +                      @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A1"" LEFT JOIN " +                      @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " +                      @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " +                      @" WHERE ""A2"".""Path"" IS NULL " +                      @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " +                      @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " +                      @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";                    if (m_pathLookup != null)                      using(new Logging.Timer("Build path lastmodified lookup table"))                      using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))                          while (rd.Read())                          {                              var id = rd.GetInt64(0);                              var lastmodified = new DateTime(rd.GetInt64(1)' DateTimeKind.Utc);                              var filesize = rd.GetInt64(2);                              var path = rd.GetString(3);                              var metahash = rd.GetString(4);                              var metasize = rd.GetInt64(5);                              m_pathLookup.Insert(path' new PathEntryKeeper(id' lastmodified' filesize' metahash' metasize));                          }                    if (m_pathLookup != null)                      try                      {                          using(new Logging.Timer("Build path lookup table"))                          using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))                              while (rd.Read())                              {                                  var path = rd.GetValue(0).ToString();                                  var blocksetid = rd.GetInt64(1);                                  var metadataid = rd.GetInt64(2);                                  var filesetid = rd.GetInt64(3);                                    PathEntryKeeper r;                                  if (!m_pathLookup.TryFind(path' out r))                                  {                                      r = new PathEntryKeeper(-1' new DateTime(0' DateTimeKind.Utc)' -1' null' -1);                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                                      m_pathLookup.Insert(path' r);                                  }                                  else                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                              }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("Duplicate file entries detected' run repair to fix it"' ex);                      }                    var tc = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString()' RemoteVolumeState.Uploading.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                  if (tc > 0)                      throw new InvalidDataException("Detected blocks that are not reachable in the block table");              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  //Need a temporary table with path/lastmodified lookups                  var scantableDefinition =                      @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " +                      @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A1"" LEFT JOIN " +                      @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " +                      @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " +                      @" WHERE ""A2"".""Path"" IS NULL " +                      @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " +                      @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " +                      @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";                    if (m_pathLookup != null)                      using(new Logging.Timer("Build path lastmodified lookup table"))                      using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))                          while (rd.Read())                          {                              var id = rd.GetInt64(0);                              var lastmodified = new DateTime(rd.GetInt64(1)' DateTimeKind.Utc);                              var filesize = rd.GetInt64(2);                              var path = rd.GetString(3);                              var metahash = rd.GetString(4);                              var metasize = rd.GetInt64(5);                              m_pathLookup.Insert(path' new PathEntryKeeper(id' lastmodified' filesize' metahash' metasize));                          }                    if (m_pathLookup != null)                      try                      {                          using(new Logging.Timer("Build path lookup table"))                          using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))                              while (rd.Read())                              {                                  var path = rd.GetValue(0).ToString();                                  var blocksetid = rd.GetInt64(1);                                  var metadataid = rd.GetInt64(2);                                  var filesetid = rd.GetInt64(3);                                    PathEntryKeeper r;                                  if (!m_pathLookup.TryFind(path' out r))                                  {                                      r = new PathEntryKeeper(-1' new DateTime(0' DateTimeKind.Utc)' -1' null' -1);                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                                      m_pathLookup.Insert(path' r);                                  }                                  else                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                              }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("Duplicate file entries detected' run repair to fix it"' ex);                      }                    var tc = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString()' RemoteVolumeState.Uploading.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                  if (tc > 0)                      throw new InvalidDataException("Detected blocks that are not reachable in the block table");              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  //Need a temporary table with path/lastmodified lookups                  var scantableDefinition =                      @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " +                      @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A1"" LEFT JOIN " +                      @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " +                      @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " +                      @" WHERE ""A2"".""Path"" IS NULL " +                      @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " +                      @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " +                      @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";                    if (m_pathLookup != null)                      using(new Logging.Timer("Build path lastmodified lookup table"))                      using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))                          while (rd.Read())                          {                              var id = rd.GetInt64(0);                              var lastmodified = new DateTime(rd.GetInt64(1)' DateTimeKind.Utc);                              var filesize = rd.GetInt64(2);                              var path = rd.GetString(3);                              var metahash = rd.GetString(4);                              var metasize = rd.GetInt64(5);                              m_pathLookup.Insert(path' new PathEntryKeeper(id' lastmodified' filesize' metahash' metasize));                          }                    if (m_pathLookup != null)                      try                      {                          using(new Logging.Timer("Build path lookup table"))                          using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))                              while (rd.Read())                              {                                  var path = rd.GetValue(0).ToString();                                  var blocksetid = rd.GetInt64(1);                                  var metadataid = rd.GetInt64(2);                                  var filesetid = rd.GetInt64(3);                                    PathEntryKeeper r;                                  if (!m_pathLookup.TryFind(path' out r))                                  {                                      r = new PathEntryKeeper(-1' new DateTime(0' DateTimeKind.Utc)' -1' null' -1);                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                                      m_pathLookup.Insert(path' r);                                  }                                  else                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                              }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("Duplicate file entries detected' run repair to fix it"' ex);                      }                    var tc = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString()' RemoteVolumeState.Uploading.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                  if (tc > 0)                      throw new InvalidDataException("Detected blocks that are not reachable in the block table");              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  //Need a temporary table with path/lastmodified lookups                  var scantableDefinition =                      @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " +                      @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A1"" LEFT JOIN " +                      @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " +                      @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " +                      @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " +                      @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " +                      @" WHERE ""A2"".""Path"" IS NULL " +                      @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " +                      @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " +                      @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";                    if (m_pathLookup != null)                      using(new Logging.Timer("Build path lastmodified lookup table"))                      using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))                          while (rd.Read())                          {                              var id = rd.GetInt64(0);                              var lastmodified = new DateTime(rd.GetInt64(1)' DateTimeKind.Utc);                              var filesize = rd.GetInt64(2);                              var path = rd.GetString(3);                              var metahash = rd.GetString(4);                              var metasize = rd.GetInt64(5);                              m_pathLookup.Insert(path' new PathEntryKeeper(id' lastmodified' filesize' metahash' metasize));                          }                    if (m_pathLookup != null)                      try                      {                          using(new Logging.Timer("Build path lookup table"))                          using (var rd = cmd.ExecuteReader(string.Format(@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))                              while (rd.Read())                              {                                  var path = rd.GetValue(0).ToString();                                  var blocksetid = rd.GetInt64(1);                                  var metadataid = rd.GetInt64(2);                                  var filesetid = rd.GetInt64(3);                                    PathEntryKeeper r;                                  if (!m_pathLookup.TryFind(path' out r))                                  {                                      r = new PathEntryKeeper(-1' new DateTime(0' DateTimeKind.Utc)' -1' null' -1);                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                                      m_pathLookup.Insert(path' r);                                  }                                  else                                      r.AddFilesetID(blocksetid' metadataid' filesetid);                              }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("Duplicate file entries detected' run repair to fix it"' ex);                      }                    var tc = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString()' RemoteVolumeState.Uploading.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                  if (tc > 0)                      throw new InvalidDataException("Detected blocks that are not reachable in the block table");              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlock,The following statement contains a magic number: if (r == -1L)              {                  m_insertblockCommand.Transaction = transaction;                  m_insertblockCommand.SetParameterValue(0' key);                  m_insertblockCommand.SetParameterValue(1' volumeid);                  m_insertblockCommand.SetParameterValue(2' size);                  r = m_insertblockCommand.ExecuteScalarInt64();                  if (m_blockCache != null)                      m_blockCache.Add(key' size);                  return true;              }              else              {                  //Update lookup cache if required                  return false;              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_insertblocksetCommand.Transaction = tr.Parent;                  m_insertblocksetCommand.SetParameterValue(0' size);                  m_insertblocksetCommand.SetParameterValue(1' filehash);                  blocksetid = m_insertblocksetCommand.ExecuteScalarInt64();                    long ix = 0;                  if (blocklistHashes != null)                  {                      m_insertblocklistHashesCommand.SetParameterValue(0' blocksetid);                      m_insertblocklistHashesCommand.Transaction = tr.Parent;                      foreach(var bh in blocklistHashes)                      {                          m_insertblocklistHashesCommand.SetParameterValue(1' ix);                          m_insertblocklistHashesCommand.SetParameterValue(2' bh);                          m_insertblocklistHashesCommand.ExecuteNonQuery();                          ix++;                      }                  }                    m_insertblocksetentryCommand.SetParameterValue(0' blocksetid);                  m_insertblocksetentryCommand.Transaction = tr.Parent;                    m_insertblocksetentryFastCommand.SetParameterValue(0' blocksetid);                  m_insertblocksetentryFastCommand.Transaction = tr.Parent;                    ix = 0;                  long remainsize = size;                  foreach(var h in hashes)                  {                      var exsize = remainsize < blocksize ? remainsize : blocksize;                      m_insertblocksetentryCommand.SetParameterValue(1' ix);                      m_insertblocksetentryCommand.SetParameterValue(2' h);                      m_insertblocksetentryCommand.SetParameterValue(3' exsize);                      var c = m_insertblocksetentryCommand.ExecuteNonQuery();                      if (c != 1)                      {                          m_result.AddError(string.Format("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);                          using (var cmd = m_connection.CreateCommand(tr.Parent))                          {                              var bid = cmd.ExecuteScalarInt64(@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);                              if (bid == -1)                                  throw new Exception(string.Format("Could not find any blocks with the given hash: {0}"' h));                              foreach(var rd in cmd.ExecuteReaderEnumerable(@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))                                  m_result.AddError(string.Format("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64(0' -1))' null);                          }                            throw new Exception(string.Format("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));                      }                                            ix++;                      remainsize -= blocksize;                  }                    tr.Commit();              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_insertblocksetCommand.Transaction = tr.Parent;                  m_insertblocksetCommand.SetParameterValue(0' size);                  m_insertblocksetCommand.SetParameterValue(1' filehash);                  blocksetid = m_insertblocksetCommand.ExecuteScalarInt64();                    long ix = 0;                  if (blocklistHashes != null)                  {                      m_insertblocklistHashesCommand.SetParameterValue(0' blocksetid);                      m_insertblocklistHashesCommand.Transaction = tr.Parent;                      foreach(var bh in blocklistHashes)                      {                          m_insertblocklistHashesCommand.SetParameterValue(1' ix);                          m_insertblocklistHashesCommand.SetParameterValue(2' bh);                          m_insertblocklistHashesCommand.ExecuteNonQuery();                          ix++;                      }                  }                    m_insertblocksetentryCommand.SetParameterValue(0' blocksetid);                  m_insertblocksetentryCommand.Transaction = tr.Parent;                    m_insertblocksetentryFastCommand.SetParameterValue(0' blocksetid);                  m_insertblocksetentryFastCommand.Transaction = tr.Parent;                    ix = 0;                  long remainsize = size;                  foreach(var h in hashes)                  {                      var exsize = remainsize < blocksize ? remainsize : blocksize;                      m_insertblocksetentryCommand.SetParameterValue(1' ix);                      m_insertblocksetentryCommand.SetParameterValue(2' h);                      m_insertblocksetentryCommand.SetParameterValue(3' exsize);                      var c = m_insertblocksetentryCommand.ExecuteNonQuery();                      if (c != 1)                      {                          m_result.AddError(string.Format("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);                          using (var cmd = m_connection.CreateCommand(tr.Parent))                          {                              var bid = cmd.ExecuteScalarInt64(@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);                              if (bid == -1)                                  throw new Exception(string.Format("Could not find any blocks with the given hash: {0}"' h));                              foreach(var rd in cmd.ExecuteReaderEnumerable(@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))                                  m_result.AddError(string.Format("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64(0' -1))' null);                          }                            throw new Exception(string.Format("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));                      }                                            ix++;                      remainsize -= blocksize;                  }                    tr.Commit();              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_insertblocksetCommand.Transaction = tr.Parent;                  m_insertblocksetCommand.SetParameterValue(0' size);                  m_insertblocksetCommand.SetParameterValue(1' filehash);                  blocksetid = m_insertblocksetCommand.ExecuteScalarInt64();                    long ix = 0;                  if (blocklistHashes != null)                  {                      m_insertblocklistHashesCommand.SetParameterValue(0' blocksetid);                      m_insertblocklistHashesCommand.Transaction = tr.Parent;                      foreach(var bh in blocklistHashes)                      {                          m_insertblocklistHashesCommand.SetParameterValue(1' ix);                          m_insertblocklistHashesCommand.SetParameterValue(2' bh);                          m_insertblocklistHashesCommand.ExecuteNonQuery();                          ix++;                      }                  }                    m_insertblocksetentryCommand.SetParameterValue(0' blocksetid);                  m_insertblocksetentryCommand.Transaction = tr.Parent;                    m_insertblocksetentryFastCommand.SetParameterValue(0' blocksetid);                  m_insertblocksetentryFastCommand.Transaction = tr.Parent;                    ix = 0;                  long remainsize = size;                  foreach(var h in hashes)                  {                      var exsize = remainsize < blocksize ? remainsize : blocksize;                      m_insertblocksetentryCommand.SetParameterValue(1' ix);                      m_insertblocksetentryCommand.SetParameterValue(2' h);                      m_insertblocksetentryCommand.SetParameterValue(3' exsize);                      var c = m_insertblocksetentryCommand.ExecuteNonQuery();                      if (c != 1)                      {                          m_result.AddError(string.Format("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);                          using (var cmd = m_connection.CreateCommand(tr.Parent))                          {                              var bid = cmd.ExecuteScalarInt64(@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);                              if (bid == -1)                                  throw new Exception(string.Format("Could not find any blocks with the given hash: {0}"' h));                              foreach(var rd in cmd.ExecuteReaderEnumerable(@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))                                  m_result.AddError(string.Format("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64(0' -1))' null);                          }                            throw new Exception(string.Format("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));                      }                                            ix++;                      remainsize -= blocksize;                  }                    tr.Commit();              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddMetadataset,The following statement contains a magic number: metadataid = -2;
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: if (m_pathLookup != null)              {                  if (entryFound = (m_pathLookup.TryFind(filename' out entry) && entry != null))                  {                      var fid = entry.GetFilesetID(blocksetID' metadataID);                      if (fid >= 0)                          fileidobj = fid;                  }              }              else              {                  m_findfilesetCommand.Transaction = transaction;                  m_findfilesetCommand.SetParameterValue(0' blocksetID);                  m_findfilesetCommand.SetParameterValue(1' metadataID);                  m_findfilesetCommand.SetParameterValue(2' filename);                  fileidobj = m_findfilesetCommand.ExecuteScalarInt64();              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: if (fileidobj == -1)              {                  using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))                  {                      m_insertfileCommand.Transaction = tr.Parent;                      m_insertfileCommand.SetParameterValue(0' filename);                      m_insertfileCommand.SetParameterValue(1' blocksetID);                      m_insertfileCommand.SetParameterValue(2' metadataID);                      fileidobj = m_insertfileCommand.ExecuteScalarInt64();                      tr.Commit();                                            // We do not need to update this' because we will not ask for the same file twice                      if (m_pathLookup != null)                      {                          if (!entryFound)                          {                              entry = new PathEntryKeeper(-1' new DateTime(0' DateTimeKind.Utc)' -1' null' -1);                              entry.AddFilesetID(blocksetID' metadataID' fileidobj);                              m_pathLookup.Insert(filename' entry);                          }                          else                              entry.AddFilesetID(blocksetID' metadataID' fileidobj);                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: m_insertfileOperationCommand.SetParameterValue(2' lastmodified.ToUniversalTime().Ticks);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddUnmodifiedFile,The following statement contains a magic number: m_insertfileOperationCommand.SetParameterValue(2' lastmodified.ToUniversalTime().Ticks);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (m_pathLookup != null)              {                              PathEntryKeeper tmp;                  if (m_pathLookup.TryFind(path' out tmp) && tmp != null && tmp.FileID >= 0)                  {                      oldModified = tmp.Lastmodified;                      lastFileSize = tmp.Filesize;                      oldMetahash = tmp.Metahash;                      oldMetasize = tmp.Metasize;                      return tmp.FileID;                  }                  else                  {                      oldModified = new DateTime(0' DateTimeKind.Utc);                      lastFileSize = -1;                      oldMetahash = null;                      oldMetasize = -1;                      return -1;                  }              }              else              {                  m_findfileCommand.SetParameterValue(0' path);                    using(var rd = m_findfileCommand.ExecuteReader())                      if (rd.Read())                      {                          oldModified = new DateTime(rd.ConvertValueToInt64(1)' DateTimeKind.Utc);                          lastFileSize = rd.GetInt64(2);                          oldMetahash = rd.GetString(3);                          oldMetasize = rd.GetInt64(4);                          return rd.ConvertValueToInt64(0);                      }                      else                      {                          oldModified = new DateTime(0' DateTimeKind.Utc);                          lastFileSize = -1;                          oldMetahash = null;                          oldMetasize = -1;                          return -1;                      }              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (m_pathLookup != null)              {                              PathEntryKeeper tmp;                  if (m_pathLookup.TryFind(path' out tmp) && tmp != null && tmp.FileID >= 0)                  {                      oldModified = tmp.Lastmodified;                      lastFileSize = tmp.Filesize;                      oldMetahash = tmp.Metahash;                      oldMetasize = tmp.Metasize;                      return tmp.FileID;                  }                  else                  {                      oldModified = new DateTime(0' DateTimeKind.Utc);                      lastFileSize = -1;                      oldMetahash = null;                      oldMetasize = -1;                      return -1;                  }              }              else              {                  m_findfileCommand.SetParameterValue(0' path);                    using(var rd = m_findfileCommand.ExecuteReader())                      if (rd.Read())                      {                          oldModified = new DateTime(rd.ConvertValueToInt64(1)' DateTimeKind.Utc);                          lastFileSize = rd.GetInt64(2);                          oldMetahash = rd.GetString(3);                          oldMetasize = rd.GetInt64(4);                          return rd.ConvertValueToInt64(0);                      }                      else                      {                          oldModified = new DateTime(0' DateTimeKind.Utc);                          lastFileSize = -1;                          oldMetahash = null;                          oldMetasize = -1;                          return -1;                      }              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (m_pathLookup != null)              {                              PathEntryKeeper tmp;                  if (m_pathLookup.TryFind(path' out tmp) && tmp != null && tmp.FileID >= 0)                  {                      oldModified = tmp.Lastmodified;                      lastFileSize = tmp.Filesize;                      oldMetahash = tmp.Metahash;                      oldMetasize = tmp.Metasize;                      return tmp.FileID;                  }                  else                  {                      oldModified = new DateTime(0' DateTimeKind.Utc);                      lastFileSize = -1;                      oldMetahash = null;                      oldMetasize = -1;                      return -1;                  }              }              else              {                  m_findfileCommand.SetParameterValue(0' path);                    using(var rd = m_findfileCommand.ExecuteReader())                      if (rd.Read())                      {                          oldModified = new DateTime(rd.ConvertValueToInt64(1)' DateTimeKind.Utc);                          lastFileSize = rd.GetInt64(2);                          oldMetahash = rd.GetString(3);                          oldMetasize = rd.GetInt64(4);                          return rd.ConvertValueToInt64(0);                      }                      else                      {                          oldModified = new DateTime(0' DateTimeKind.Utc);                          lastFileSize = -1;                          oldMetahash = null;                          oldMetasize = -1;                          return -1;                      }              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AppendFilesFromPreviousSet,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              using(var cmdDelete = m_connection.CreateCommand())              using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  long lastFilesetId = prevId < 0 ? GetPreviousFilesetID(cmd' timestamp' filesetid) : prevId;                    cmd.Transaction = tr.Parent;                  cmd.ExecuteNonQuery( @"INSERT INTO ""FilesetEntry"" (""FilesetID""' ""FileID""' ""Lastmodified"") SELECT ? AS ""FilesetID""' ""FileID""' ""Lastmodified"" FROM (SELECT DISTINCT ""FilesetID""' ""FileID""' ""Lastmodified"" FROM ""FilesetEntry"" WHERE ""FilesetID"" = ? AND ""FileID"" NOT IN (SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" = ?)) "' filesetid' lastFilesetId' filesetid);                    if (deleted != null)                  {                      cmdDelete.Transaction = tr.Parent;                      cmdDelete.CommandText = @"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" = ? AND ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ?) ";                      cmdDelete.AddParameters(2);                      cmdDelete.SetParameterValue(0' filesetid);                        foreach (string s in deleted)                      {                          cmdDelete.SetParameterValue(1' s);                          cmdDelete.ExecuteNonQuery();                      }                  }                    tr.Commit();              }
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromName,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              using(var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' name))                  if (rd.Read())                      return new RemoteVolume(rd.GetValue(0).ToString()' rd.GetValue(1).ToString()' rd.ConvertValueToInt64(2));                  else                      return null;
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))                  if (rd.Read())                      return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  else                      return default(RemoteVolumeEntry);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))                  if (rd.Read())                      return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  else                      return default(RemoteVolumeEntry);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))                  if (rd.Read())                      return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  else                      return default(RemoteVolumeEntry);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))                  if (rd.Read())                      return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  else                      return default(RemoteVolumeEntry);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))                  if (rd.Read())                      return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  else                      return default(RemoteVolumeEntry);
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              using (var rd = cmd.ExecuteReader(@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))                  if (rd.Read())                      return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  else                      return default(RemoteVolumeEntry);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_insertlogCommand.AddParameters(5);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_insertremotelogCommand.AddParameters(5);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_updateremotevolumeCommand.AddParameters(5);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_removeremotevolumeCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_createremotevolumeCommand.AddParameters(7);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_insertIndexBlockLink.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The following statement contains a magic number: m_updateremotevolumeCommand.SetParameterValue(2' hash);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The following statement contains a magic number: m_updateremotevolumeCommand.SetParameterValue(3' size);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The following statement contains a magic number: m_updateremotevolumeCommand.SetParameterValue(4' name);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader())                  if (rd.Read())                  {                      type = (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(0).ToString());                      size = (rd.GetValue(1) == null || rd.GetValue(1) == DBNull.Value) ? -1 : rd.GetInt64(1);                      hash = (rd.GetValue(2) == null || rd.GetValue(2) == DBNull.Value) ? null : rd.GetValue(2).ToString();                      state = (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(3).ToString());                      return true;                  }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader())                  if (rd.Read())                  {                      type = (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(0).ToString());                      size = (rd.GetValue(1) == null || rd.GetValue(1) == DBNull.Value) ? -1 : rd.GetInt64(1);                      hash = (rd.GetValue(2) == null || rd.GetValue(2) == DBNull.Value) ? null : rd.GetValue(2).ToString();                      state = (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(3).ToString());                      return true;                  }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader())                  if (rd.Read())                  {                      type = (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(0).ToString());                      size = (rd.GetValue(1) == null || rd.GetValue(1) == DBNull.Value) ? -1 : rd.GetInt64(1);                      hash = (rd.GetValue(2) == null || rd.GetValue(2) == DBNull.Value) ? null : rd.GetValue(2).ToString();                      state = (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(3).ToString());                      return true;                  }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader())                  if (rd.Read())                  {                      type = (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(0).ToString());                      size = (rd.GetValue(1) == null || rd.GetValue(1) == DBNull.Value) ? -1 : rd.GetInt64(1);                      hash = (rd.GetValue(2) == null || rd.GetValue(2) == DBNull.Value) ? null : rd.GetValue(2).ToString();                      state = (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(3).ToString());                      return true;                  }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader())              {                  while (rd.Read())                  {                      yield return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader())              {                  while (rd.Read())                  {                      yield return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader())              {                  while (rd.Read())                  {                      yield return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader())              {                  while (rd.Read())                  {                      yield return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader())              {                  while (rd.Read())                  {                      yield return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader())              {                  while (rd.Read())                  {                      yield return new RemoteVolumeEntry(                          rd.GetValue(0).ToString()'                          (rd.GetValue(3) == null || rd.GetValue(3) == DBNull.Value) ? null : rd.GetValue(3).ToString()'                          rd.ConvertValueToInt64(2' -1)'                          (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType)' rd.GetValue(1).ToString())'                          (RemoteVolumeState)Enum.Parse(typeof(RemoteVolumeState)' rd.GetValue(4).ToString())'                          new DateTime(rd.ConvertValueToInt64(5' 0)' DateTimeKind.Utc)                      );                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogRemoteOperation,The following statement contains a magic number: m_insertremotelogCommand.SetParameterValue(2' operation);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogRemoteOperation,The following statement contains a magic number: m_insertremotelogCommand.SetParameterValue(3' path);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogRemoteOperation,The following statement contains a magic number: m_insertremotelogCommand.SetParameterValue(4' data);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogMessage,The following statement contains a magic number: m_insertlogCommand.SetParameterValue(2' type);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogMessage,The following statement contains a magic number: m_insertlogCommand.SetParameterValue(3' message);
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogMessage,The following statement contains a magic number: m_insertlogCommand.SetParameterValue(4' exception == null ? null : exception.ToString());
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper(m_connection' transaction))              using (var deletecmd = m_connection.CreateCommand())              {                  deletecmd.Transaction = tr.Parent;                    string temptransguid = Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                  var volidstable = "DelVolSetIds-" + temptransguid;                  var blocksetidstable = "DelBlockSetIds-" + temptransguid;                    // Create and fill a temp table with the volids to delete. We avoid using too many parameters that way.                  deletecmd.ExecuteNonQuery(string.Format(@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' volidstable));                  deletecmd.CommandText = string.Format(@"INSERT OR IGNORE INTO ""{0}"" (""ID"") VALUES (?)"' volidstable);                  deletecmd.Parameters.Clear();                  deletecmd.AddParameters(1);                  foreach (var name in names)                  {                      var volumeid = GetRemoteVolumeID(name' tr.Parent);                      deletecmd.SetParameterValue(0' volumeid);                      deletecmd.ExecuteNonQuery();                  }                  var volIdsSubQuery = string.Format(@"SELECT ""ID"" FROM ""{0}"" "' volidstable);                  deletecmd.Parameters.Clear();                                    // If the volume is a block or index volume' this will update the crosslink table' otherwise nothing will happen                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery));                                    // If the volume is a fileset' this will remove the fileset' otherwise nothing will happen                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" IN (SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Fileset"" WHERE ""VolumeID""  IN ({0})"' volIdsSubQuery));                                                                    var bsIdsSubQuery = string.Format(                        @"SELECT ""BlocksetEntry"".""BlocksetID"" FROM ""BlocksetEntry""' ""Block"" "                      + @" WHERE ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Block"".""VolumeID"" IN ({0}) "                      + @"UNION ALL "                      + @"SELECT ""BlocksetID"" FROM ""BlocklistHash"" "                      + @"WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"                      ' volIdsSubQuery);                    // Create a temporary table to cache subquery result' as it might take long (SQLite does not cache at all).                   deletecmd.ExecuteNonQuery(string.Format(@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' blocksetidstable));                  deletecmd.ExecuteNonQuery(string.Format(@"INSERT OR IGNORE INTO ""{0}"" (""ID"") {1}"' blocksetidstable' bsIdsSubQuery));                  bsIdsSubQuery = string.Format(@"SELECT ""ID"" FROM ""{0}"" "' blocksetidstable);                  deletecmd.Parameters.Clear();                    deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""BlocksetID"" IN ({0}) OR ""MetadataID"" IN ({0})"' bsIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Blockset"" WHERE ""ID"" IN ({0})"' bsIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));                    deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""BlocklistHash"" WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Block"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""DeletedBlock"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));                    // Clean up temp tables for subqueries. We truncate content and then try to delete.                  // Drop in try-block' as it fails in nested transactions (SQLite problem)                  // System.Data.SQLite.SQLiteException (0x80004005): database table is locked                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" "' blocksetidstable));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" "' volidstable));                  try                  {                      deletecmd.CommandTimeout = 2;                      deletecmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' blocksetidstable));                      deletecmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));                  }                  catch { /* Ignore' will be deleted on close anyway. */ }  				m_removeremotevolumeCommand.Transaction = tr.Parent;                 m_removeremotevolumeCommand.SetParameterValue(1' DateTime.UtcNow.Ticks); 				m_removeremotevolumeCommand.SetParameterValue(2' RemoteVolumeState.Deleted.ToString()); 				foreach (var name in names)                  {                      m_removeremotevolumeCommand.SetParameterValue(0' name);                      m_removeremotevolumeCommand.ExecuteNonQuery();                  }                  tr.Commit();              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper(m_connection' transaction))              using (var deletecmd = m_connection.CreateCommand())              {                  deletecmd.Transaction = tr.Parent;                    string temptransguid = Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                  var volidstable = "DelVolSetIds-" + temptransguid;                  var blocksetidstable = "DelBlockSetIds-" + temptransguid;                    // Create and fill a temp table with the volids to delete. We avoid using too many parameters that way.                  deletecmd.ExecuteNonQuery(string.Format(@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' volidstable));                  deletecmd.CommandText = string.Format(@"INSERT OR IGNORE INTO ""{0}"" (""ID"") VALUES (?)"' volidstable);                  deletecmd.Parameters.Clear();                  deletecmd.AddParameters(1);                  foreach (var name in names)                  {                      var volumeid = GetRemoteVolumeID(name' tr.Parent);                      deletecmd.SetParameterValue(0' volumeid);                      deletecmd.ExecuteNonQuery();                  }                  var volIdsSubQuery = string.Format(@"SELECT ""ID"" FROM ""{0}"" "' volidstable);                  deletecmd.Parameters.Clear();                                    // If the volume is a block or index volume' this will update the crosslink table' otherwise nothing will happen                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery));                                    // If the volume is a fileset' this will remove the fileset' otherwise nothing will happen                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" IN (SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Fileset"" WHERE ""VolumeID""  IN ({0})"' volIdsSubQuery));                                                                    var bsIdsSubQuery = string.Format(                        @"SELECT ""BlocksetEntry"".""BlocksetID"" FROM ""BlocksetEntry""' ""Block"" "                      + @" WHERE ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Block"".""VolumeID"" IN ({0}) "                      + @"UNION ALL "                      + @"SELECT ""BlocksetID"" FROM ""BlocklistHash"" "                      + @"WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"                      ' volIdsSubQuery);                    // Create a temporary table to cache subquery result' as it might take long (SQLite does not cache at all).                   deletecmd.ExecuteNonQuery(string.Format(@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' blocksetidstable));                  deletecmd.ExecuteNonQuery(string.Format(@"INSERT OR IGNORE INTO ""{0}"" (""ID"") {1}"' blocksetidstable' bsIdsSubQuery));                  bsIdsSubQuery = string.Format(@"SELECT ""ID"" FROM ""{0}"" "' blocksetidstable);                  deletecmd.Parameters.Clear();                    deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""BlocksetID"" IN ({0}) OR ""MetadataID"" IN ({0})"' bsIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Blockset"" WHERE ""ID"" IN ({0})"' bsIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));                    deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""BlocklistHash"" WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Block"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""DeletedBlock"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));                    // Clean up temp tables for subqueries. We truncate content and then try to delete.                  // Drop in try-block' as it fails in nested transactions (SQLite problem)                  // System.Data.SQLite.SQLiteException (0x80004005): database table is locked                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" "' blocksetidstable));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" "' volidstable));                  try                  {                      deletecmd.CommandTimeout = 2;                      deletecmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' blocksetidstable));                      deletecmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));                  }                  catch { /* Ignore' will be deleted on close anyway. */ }  				m_removeremotevolumeCommand.Transaction = tr.Parent;                 m_removeremotevolumeCommand.SetParameterValue(1' DateTime.UtcNow.Ticks); 				m_removeremotevolumeCommand.SetParameterValue(2' RemoteVolumeState.Deleted.ToString()); 				foreach (var name in names)                  {                      m_removeremotevolumeCommand.SetParameterValue(0' name);                      m_removeremotevolumeCommand.ExecuteNonQuery();                  }                  tr.Commit();              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_createremotevolumeCommand.SetParameterValue(0' m_operationid);                  m_createremotevolumeCommand.SetParameterValue(1' name);                  m_createremotevolumeCommand.SetParameterValue(2' type.ToString());                  m_createremotevolumeCommand.SetParameterValue(3' state.ToString());                  m_createremotevolumeCommand.SetParameterValue(4' size);                  m_createremotevolumeCommand.SetParameterValue(5' 0);                    if (deleteGraceTime.Ticks <= 0)                      m_createremotevolumeCommand.SetParameterValue(6' 0);                  else                      m_createremotevolumeCommand.SetParameterValue(6' (DateTime.UtcNow + deleteGraceTime).Ticks);                                    m_createremotevolumeCommand.Transaction = tr.Parent;                  var r = m_createremotevolumeCommand.ExecuteScalarInt64();                  tr.Commit();                  return r;              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_createremotevolumeCommand.SetParameterValue(0' m_operationid);                  m_createremotevolumeCommand.SetParameterValue(1' name);                  m_createremotevolumeCommand.SetParameterValue(2' type.ToString());                  m_createremotevolumeCommand.SetParameterValue(3' state.ToString());                  m_createremotevolumeCommand.SetParameterValue(4' size);                  m_createremotevolumeCommand.SetParameterValue(5' 0);                    if (deleteGraceTime.Ticks <= 0)                      m_createremotevolumeCommand.SetParameterValue(6' 0);                  else                      m_createremotevolumeCommand.SetParameterValue(6' (DateTime.UtcNow + deleteGraceTime).Ticks);                                    m_createremotevolumeCommand.Transaction = tr.Parent;                  var r = m_createremotevolumeCommand.ExecuteScalarInt64();                  tr.Commit();                  return r;              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_createremotevolumeCommand.SetParameterValue(0' m_operationid);                  m_createremotevolumeCommand.SetParameterValue(1' name);                  m_createremotevolumeCommand.SetParameterValue(2' type.ToString());                  m_createremotevolumeCommand.SetParameterValue(3' state.ToString());                  m_createremotevolumeCommand.SetParameterValue(4' size);                  m_createremotevolumeCommand.SetParameterValue(5' 0);                    if (deleteGraceTime.Ticks <= 0)                      m_createremotevolumeCommand.SetParameterValue(6' 0);                  else                      m_createremotevolumeCommand.SetParameterValue(6' (DateTime.UtcNow + deleteGraceTime).Ticks);                                    m_createremotevolumeCommand.Transaction = tr.Parent;                  var r = m_createremotevolumeCommand.ExecuteScalarInt64();                  tr.Commit();                  return r;              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_createremotevolumeCommand.SetParameterValue(0' m_operationid);                  m_createremotevolumeCommand.SetParameterValue(1' name);                  m_createremotevolumeCommand.SetParameterValue(2' type.ToString());                  m_createremotevolumeCommand.SetParameterValue(3' state.ToString());                  m_createremotevolumeCommand.SetParameterValue(4' size);                  m_createremotevolumeCommand.SetParameterValue(5' 0);                    if (deleteGraceTime.Ticks <= 0)                      m_createremotevolumeCommand.SetParameterValue(6' 0);                  else                      m_createremotevolumeCommand.SetParameterValue(6' (DateTime.UtcNow + deleteGraceTime).Ticks);                                    m_createremotevolumeCommand.Transaction = tr.Parent;                  var r = m_createremotevolumeCommand.ExecuteScalarInt64();                  tr.Commit();                  return r;              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_createremotevolumeCommand.SetParameterValue(0' m_operationid);                  m_createremotevolumeCommand.SetParameterValue(1' name);                  m_createremotevolumeCommand.SetParameterValue(2' type.ToString());                  m_createremotevolumeCommand.SetParameterValue(3' state.ToString());                  m_createremotevolumeCommand.SetParameterValue(4' size);                  m_createremotevolumeCommand.SetParameterValue(5' 0);                    if (deleteGraceTime.Ticks <= 0)                      m_createremotevolumeCommand.SetParameterValue(6' 0);                  else                      m_createremotevolumeCommand.SetParameterValue(6' (DateTime.UtcNow + deleteGraceTime).Ticks);                                    m_createremotevolumeCommand.Transaction = tr.Parent;                  var r = m_createremotevolumeCommand.ExecuteScalarInt64();                  tr.Commit();                  return r;              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using(var tr = new TemporaryTransactionWrapper(m_connection' transaction))              {                  m_createremotevolumeCommand.SetParameterValue(0' m_operationid);                  m_createremotevolumeCommand.SetParameterValue(1' name);                  m_createremotevolumeCommand.SetParameterValue(2' type.ToString());                  m_createremotevolumeCommand.SetParameterValue(3' state.ToString());                  m_createremotevolumeCommand.SetParameterValue(4' size);                  m_createremotevolumeCommand.SetParameterValue(5' 0);                    if (deleteGraceTime.Ticks <= 0)                      m_createremotevolumeCommand.SetParameterValue(6' 0);                  else                      m_createremotevolumeCommand.SetParameterValue(6' (DateTime.UtcNow + deleteGraceTime).Ticks);                                    m_createremotevolumeCommand.Transaction = tr.Parent;                  var r = m_createremotevolumeCommand.ExecuteScalarInt64();                  tr.Commit();                  return r;              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand(transaction))              {                  // Calculate the lengths for each blockset                                  var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";                  // For each blockset with wrong lengths' fetch the file path                  var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";                                    using(var rd = cmd.ExecuteReader(reportDetails))                      if (rd.Read())                      {                          var sb = new StringBuilder();                          sb.AppendLine("Found inconsistency in the following files while validating database: ");                          var c = 0;                          do                          {                              if (c < 5)                                  sb.AppendFormat("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(0)' rd.GetValue(2)' Environment.NewLine);                              c++;                          } while(rd.Read());                                                    c -= 5;                          if (c > 0)                              sb.AppendFormat("... and {0} more"' c);                                                    sb.Append(". Run repair to fix it.");                          throw new InvalidDataException(sb.ToString());                      }                    var real_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM ""BlocklistHash"""' 0);                  var unique_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);                    if (real_count != unique_count)                      throw new InvalidDataException(string.Format("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));                    var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);                  if (itemswithnoblocklisthash != 0)                      throw new InvalidDataException(string.Format("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));                    if (cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)                      throw new Exception("Detected file entries with not associated blocks");                      if (verifyfilelists)                  {                      using(var cmd2 = m_connection.CreateCommand(transaction))                      foreach(var filesetid in cmd.ExecuteReaderEnumerable(@"SELECT ""ID"" FROM ""Fileset"" ").Select(x => x.ConvertValueToInt64(0' -1)))                      {                          var expandedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);                          //var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);                          var storedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);                            if (expandedlist != storedlist)                              throw new Exception(string.Format("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand(transaction))              {                  // Calculate the lengths for each blockset                                  var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";                  // For each blockset with wrong lengths' fetch the file path                  var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";                                    using(var rd = cmd.ExecuteReader(reportDetails))                      if (rd.Read())                      {                          var sb = new StringBuilder();                          sb.AppendLine("Found inconsistency in the following files while validating database: ");                          var c = 0;                          do                          {                              if (c < 5)                                  sb.AppendFormat("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(0)' rd.GetValue(2)' Environment.NewLine);                              c++;                          } while(rd.Read());                                                    c -= 5;                          if (c > 0)                              sb.AppendFormat("... and {0} more"' c);                                                    sb.Append(". Run repair to fix it.");                          throw new InvalidDataException(sb.ToString());                      }                    var real_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM ""BlocklistHash"""' 0);                  var unique_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);                    if (real_count != unique_count)                      throw new InvalidDataException(string.Format("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));                    var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);                  if (itemswithnoblocklisthash != 0)                      throw new InvalidDataException(string.Format("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));                    if (cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)                      throw new Exception("Detected file entries with not associated blocks");                      if (verifyfilelists)                  {                      using(var cmd2 = m_connection.CreateCommand(transaction))                      foreach(var filesetid in cmd.ExecuteReaderEnumerable(@"SELECT ""ID"" FROM ""Fileset"" ").Select(x => x.ConvertValueToInt64(0' -1)))                      {                          var expandedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);                          //var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);                          var storedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);                            if (expandedlist != storedlist)                              throw new Exception(string.Format("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand(transaction))              {                  // Calculate the lengths for each blockset                                  var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";                  // For each blockset with wrong lengths' fetch the file path                  var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";                                    using(var rd = cmd.ExecuteReader(reportDetails))                      if (rd.Read())                      {                          var sb = new StringBuilder();                          sb.AppendLine("Found inconsistency in the following files while validating database: ");                          var c = 0;                          do                          {                              if (c < 5)                                  sb.AppendFormat("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(0)' rd.GetValue(2)' Environment.NewLine);                              c++;                          } while(rd.Read());                                                    c -= 5;                          if (c > 0)                              sb.AppendFormat("... and {0} more"' c);                                                    sb.Append(". Run repair to fix it.");                          throw new InvalidDataException(sb.ToString());                      }                    var real_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM ""BlocklistHash"""' 0);                  var unique_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);                    if (real_count != unique_count)                      throw new InvalidDataException(string.Format("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));                    var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);                  if (itemswithnoblocklisthash != 0)                      throw new InvalidDataException(string.Format("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));                    if (cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)                      throw new Exception("Detected file entries with not associated blocks");                      if (verifyfilelists)                  {                      using(var cmd2 = m_connection.CreateCommand(transaction))                      foreach(var filesetid in cmd.ExecuteReaderEnumerable(@"SELECT ""ID"" FROM ""Fileset"" ").Select(x => x.ConvertValueToInt64(0' -1)))                      {                          var expandedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);                          //var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);                          var storedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);                            if (expandedlist != storedlist)                              throw new Exception(string.Format("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand(transaction))              {                  // Calculate the lengths for each blockset                                  var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";                  // For each blockset with wrong lengths' fetch the file path                  var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";                                    using(var rd = cmd.ExecuteReader(reportDetails))                      if (rd.Read())                      {                          var sb = new StringBuilder();                          sb.AppendLine("Found inconsistency in the following files while validating database: ");                          var c = 0;                          do                          {                              if (c < 5)                                  sb.AppendFormat("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(0)' rd.GetValue(2)' Environment.NewLine);                              c++;                          } while(rd.Read());                                                    c -= 5;                          if (c > 0)                              sb.AppendFormat("... and {0} more"' c);                                                    sb.Append(". Run repair to fix it.");                          throw new InvalidDataException(sb.ToString());                      }                    var real_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM ""BlocklistHash"""' 0);                  var unique_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);                    if (real_count != unique_count)                      throw new InvalidDataException(string.Format("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));                    var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);                  if (itemswithnoblocklisthash != 0)                      throw new InvalidDataException(string.Format("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));                    if (cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)                      throw new Exception("Detected file entries with not associated blocks");                      if (verifyfilelists)                  {                      using(var cmd2 = m_connection.CreateCommand(transaction))                      foreach(var filesetid in cmd.ExecuteReaderEnumerable(@"SELECT ""ID"" FROM ""Fileset"" ").Select(x => x.ConvertValueToInt64(0' -1)))                      {                          var expandedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);                          //var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);                          var storedlist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);                            if (expandedlist != storedlist)                              throw new Exception(string.Format("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {              	cmd.Transaction = transaction;                  cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;                  cmd.AddParameter(FOLDER_BLOCKSET_ID);                  cmd.AddParameter(SYMLINK_BLOCKSET_ID);                  cmd.AddParameter(filesetId);                    string lastpath = null;                  using (var rd = cmd.ExecuteReader())                  while(rd.Read())                  {                      var blocksetID = rd.ConvertValueToInt64(0' -1);                      var path = rd.GetValue(2).ToString();                      var metalength = rd.ConvertValueToInt64(3' -1);                      var metahash = rd.GetValue(4).ToString();                      var metablockhash = rd.GetValue(6).ToString();                      var metablocklisthash = rd.GetValue(7).ToString();                        if (path == lastpath)                          m_result.AddWarning(string.Format("Duplicate path detected: {0}!"' path)' null);                        lastpath = path;                        if (blocksetID == FOLDER_BLOCKSET_ID)                          filesetvolume.AddDirectory(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                      else if (blocksetID == SYMLINK_BLOCKSET_ID)                          filesetvolume.AddSymlink(path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                  }                                            // TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x                    cmd.CommandText = LIST_FILESETS;                  cmd.Parameters.Clear();                  cmd.AddParameter(filesetId);                    using (var rd = cmd.ExecuteReader())                  if (rd.Read())                  {                      var more = false;                      do                      {                          var path = rd.GetValue(0).ToString();                          var filehash = rd.GetValue(3).ToString();                          var size = rd.ConvertValueToInt64(2);                          var lastmodified = new DateTime(rd.ConvertValueToInt64(1' 0)' DateTimeKind.Utc);                          var metahash = rd.GetValue(4).ToString();                          var metasize = rd.ConvertValueToInt64(5' -1);                          var p = rd.GetValue(6);                          var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable(rd);                          var blockhash = rd.GetValue(7).ToString();                          var blocksize = rd.ConvertValueToInt64(8' -1);                          var metablockhash = rd.GetValue(9).ToString();                          //var metablocksize = rd.ConvertValueToInt64(10' -1);                          var metablocklisthash = rd.GetValue(11).ToString();                            if (blockhash == filehash)                              blockhash = null;                            if (metablockhash == metahash)                              metablockhash = null;                            filesetvolume.AddFile(path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace(metablocklisthash) ? null : new string[] { metablocklisthash });                          if (blrd == null)                              more = rd.Read();                          else                              more = blrd.MoreData;                        } while (more);                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteResults,The following statement contains a magic number: if (m_connection != null && m_result != null)              {                  m_result.FlushLog();                  if (m_result.EndTime.Ticks == 0)                      m_result.EndTime = DateTime.UtcNow;                    LogMessage("Result"'                       Library.Utility.Utility.PrintSerializeObject(                          m_result'                           (StringBuilder)null'                           (prop' item) =>                               !typeof(IBackendProgressUpdater).IsAssignableFrom(prop.PropertyType) &&                               !typeof(IMessageSink).IsAssignableFrom(prop.PropertyType) &&                               !typeof(ILogWriter).IsAssignableFrom(prop.PropertyType) &&                              prop.Name != "VerboseOutput" &&                               prop.Name != "VerboseErrors" &&                             !(prop.Name == "MainOperation" && item is BackendWriter) &&                             !(prop.Name == "EndTime" && item is BackendWriter) &&                             !(prop.Name == "Duration" && item is BackendWriter) &&                             !(prop.Name == "BeginTime" && item is BackendWriter)'                           recurseobjects: true'                           collectionlimit: 5                      ).ToString()'                      null'                      null                  );              }
Magic Number,Duplicati.Library.Main.Database,BlocklistHashEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,MoveNext,The following statement contains a magic number: if (m_path == null)                      {                          m_path = m_reader.GetValue(0).ToString();                          m_current = m_reader.GetValue(6).ToString();                          return true;                      }                      else                      {                          if (m_current == null)                              return false;                            if (!m_reader.Read())                          {                              m_current = null;                              m_parent.MoreData = false;                              return false;                          }                            var np = m_reader.GetValue(0).ToString();                          if (m_path != np)                          {                              m_current = null;                              return false;                          }                            m_current = m_reader.GetValue(6).ToString();                          return true;                      }
Magic Number,Duplicati.Library.Main.Database,BlocklistHashEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,MoveNext,The following statement contains a magic number: if (m_path == null)                      {                          m_path = m_reader.GetValue(0).ToString();                          m_current = m_reader.GetValue(6).ToString();                          return true;                      }                      else                      {                          if (m_current == null)                              return false;                            if (!m_reader.Read())                          {                              m_current = null;                              m_parent.MoreData = false;                              return false;                          }                            var np = m_reader.GetValue(0).ToString();                          if (m_path != np)                          {                              m_current = null;                              return false;                          }                            m_current = m_reader.GetValue(6).ToString();                          return true;                      }
Magic Number,Duplicati.Library.Main.Database,FilteredFilenameTable,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,FilteredFilenameTable,The following statement contains a magic number: if (type != Library.Utility.FilterType.Regexp && !Library.Utility.Utility.IsFSCaseSensitive && filter.ToString().Any(x => x > 127))                      type = Library.Utility.FilterType.Regexp;
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              {                  var filesetIds = GetFilesetIDs(NormalizeDateTime(restoretime)' versions).ToList();                  while(filesetIds.Count > 0)                  {                      var filesetId = filesetIds[0];                      filesetIds.RemoveAt(0);                                            m_restoreTime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));                                            var ix = this.FilesetTimes.Select((value' index) => new { value.Key' index })                              .Where(n => n.Key == filesetId)                              .Select(pair => pair.index + 1)                              .FirstOrDefault() - 1;                                                    log.AddMessage(string.Format("Searching backup {0} ({1}) ..."' ix' m_restoreTime));                                            cmd.Parameters.Clear();                            cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));                      // better suited to speed up commit on UpdateBlocks                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));                        if (filter == null || filter.Empty)                      {                          // Simple case' restore everything                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);                          cmd.AddParameter(filesetId);                          cmd.ExecuteNonQuery();                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // If we get a list of filenames' the lookup table is faster                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          using(var tr = m_connection.BeginTransaction())                          {                              var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                              var m_filenamestable = "Filenames-" + guid;                              cmd.Transaction = tr;                              cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));                              cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);                              cmd.AddParameter();                                                            foreach(var s in p)                              {                                  cmd.SetParameterValue(0' s);                                  cmd.ExecuteNonQuery();                              }                                cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);                              cmd.SetParameterValue(0' filesetId);                              var c = cmd.ExecuteNonQuery();                                                            cmd.Parameters.Clear();                                                            if (c != p.Length && c != 0)                              {                                  var sb = new StringBuilder();                                  sb.AppendLine();                                                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))                                      while (rd.Read())                                          sb.AppendLine(rd.GetValue(0).ToString());                                        var actualrestoretime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));                                  log.AddWarning(string.Format("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime()' sb)' null);                                  cmd.Parameters.Clear();                              }                                                            cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));                                                            using(new Logging.Timer("CommitPrepareFileset"))                                  tr.Commit();                          }                      }                      else                      {                          // Restore but filter elements based on the filter expression                          // If this is too slow' we could add a special handler for wildcard searches too                          cmd.CommandText = string.Format(@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");                          cmd.AddParameter(filesetId);                                object[] values = new object[3];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);                              cmd2.AddParameter();                              cmd2.AddParameter();                              cmd2.AddParameter();                                    using(var rd = cmd.ExecuteReader())                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                                                                  using(var rd = cmd.ExecuteReader(string.Format(@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable)))                      {                          var filecount = 0L;                          var filesize = 0L;                            if (rd.Read())                          {                              filecount = rd.ConvertValueToInt64(0' 0);                              filesize = rd.ConvertValueToInt64(1' 0);                          }                            if (filecount > 0)                          {                              log.AddVerboseMessage("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString(filesize));                              return new Tuple<long' long>(filecount' filesize);                          }                      }                                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              {                  var filesetIds = GetFilesetIDs(NormalizeDateTime(restoretime)' versions).ToList();                  while(filesetIds.Count > 0)                  {                      var filesetId = filesetIds[0];                      filesetIds.RemoveAt(0);                                            m_restoreTime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));                                            var ix = this.FilesetTimes.Select((value' index) => new { value.Key' index })                              .Where(n => n.Key == filesetId)                              .Select(pair => pair.index + 1)                              .FirstOrDefault() - 1;                                                    log.AddMessage(string.Format("Searching backup {0} ({1}) ..."' ix' m_restoreTime));                                            cmd.Parameters.Clear();                            cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));                      // better suited to speed up commit on UpdateBlocks                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));                        if (filter == null || filter.Empty)                      {                          // Simple case' restore everything                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);                          cmd.AddParameter(filesetId);                          cmd.ExecuteNonQuery();                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // If we get a list of filenames' the lookup table is faster                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          using(var tr = m_connection.BeginTransaction())                          {                              var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                              var m_filenamestable = "Filenames-" + guid;                              cmd.Transaction = tr;                              cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));                              cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);                              cmd.AddParameter();                                                            foreach(var s in p)                              {                                  cmd.SetParameterValue(0' s);                                  cmd.ExecuteNonQuery();                              }                                cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);                              cmd.SetParameterValue(0' filesetId);                              var c = cmd.ExecuteNonQuery();                                                            cmd.Parameters.Clear();                                                            if (c != p.Length && c != 0)                              {                                  var sb = new StringBuilder();                                  sb.AppendLine();                                                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))                                      while (rd.Read())                                          sb.AppendLine(rd.GetValue(0).ToString());                                        var actualrestoretime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));                                  log.AddWarning(string.Format("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime()' sb)' null);                                  cmd.Parameters.Clear();                              }                                                            cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));                                                            using(new Logging.Timer("CommitPrepareFileset"))                                  tr.Commit();                          }                      }                      else                      {                          // Restore but filter elements based on the filter expression                          // If this is too slow' we could add a special handler for wildcard searches too                          cmd.CommandText = string.Format(@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");                          cmd.AddParameter(filesetId);                                object[] values = new object[3];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);                              cmd2.AddParameter();                              cmd2.AddParameter();                              cmd2.AddParameter();                                    using(var rd = cmd.ExecuteReader())                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                                                                  using(var rd = cmd.ExecuteReader(string.Format(@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable)))                      {                          var filecount = 0L;                          var filesize = 0L;                            if (rd.Read())                          {                              filecount = rd.ConvertValueToInt64(0' 0);                              filesize = rd.ConvertValueToInt64(1' 0);                          }                            if (filecount > 0)                          {                              log.AddVerboseMessage("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString(filesize));                              return new Tuple<long' long>(filecount' filesize);                          }                      }                                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              {                  var filesetIds = GetFilesetIDs(NormalizeDateTime(restoretime)' versions).ToList();                  while(filesetIds.Count > 0)                  {                      var filesetId = filesetIds[0];                      filesetIds.RemoveAt(0);                                            m_restoreTime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));                                            var ix = this.FilesetTimes.Select((value' index) => new { value.Key' index })                              .Where(n => n.Key == filesetId)                              .Select(pair => pair.index + 1)                              .FirstOrDefault() - 1;                                                    log.AddMessage(string.Format("Searching backup {0} ({1}) ..."' ix' m_restoreTime));                                            cmd.Parameters.Clear();                            cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));                      // better suited to speed up commit on UpdateBlocks                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));                        if (filter == null || filter.Empty)                      {                          // Simple case' restore everything                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);                          cmd.AddParameter(filesetId);                          cmd.ExecuteNonQuery();                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // If we get a list of filenames' the lookup table is faster                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          using(var tr = m_connection.BeginTransaction())                          {                              var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                              var m_filenamestable = "Filenames-" + guid;                              cmd.Transaction = tr;                              cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));                              cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);                              cmd.AddParameter();                                                            foreach(var s in p)                              {                                  cmd.SetParameterValue(0' s);                                  cmd.ExecuteNonQuery();                              }                                cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);                              cmd.SetParameterValue(0' filesetId);                              var c = cmd.ExecuteNonQuery();                                                            cmd.Parameters.Clear();                                                            if (c != p.Length && c != 0)                              {                                  var sb = new StringBuilder();                                  sb.AppendLine();                                                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))                                      while (rd.Read())                                          sb.AppendLine(rd.GetValue(0).ToString());                                        var actualrestoretime = ParseFromEpochSeconds(cmd.ExecuteScalarInt64(@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));                                  log.AddWarning(string.Format("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime()' sb)' null);                                  cmd.Parameters.Clear();                              }                                                            cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));                                                            using(new Logging.Timer("CommitPrepareFileset"))                                  tr.Commit();                          }                      }                      else                      {                          // Restore but filter elements based on the filter expression                          // If this is too slow' we could add a special handler for wildcard searches too                          cmd.CommandText = string.Format(@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");                          cmd.AddParameter(filesetId);                                object[] values = new object[3];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);                              cmd2.AddParameter();                              cmd2.AddParameter();                              cmd2.AddParameter();                                    using(var rd = cmd.ExecuteReader())                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                                                                  using(var rd = cmd.ExecuteReader(string.Format(@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable)))                      {                          var filecount = 0L;                          var filesize = 0L;                            if (rd.Read())                          {                              filecount = rd.ConvertValueToInt64(0' 0);                              filesize = rd.ConvertValueToInt64(1' 0);                          }                            if (filecount > 0)                          {                              log.AddVerboseMessage("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString(filesize));                              return new Tuple<long' long>(filecount' filesize);                          }                      }                                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetLargestPrefix,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  cmd.CommandText = string.Format(@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' m_tempfiletable);                  var v0 = cmd.ExecuteScalar();                  string maxpath = "";                  if (v0 != null && v0 != DBNull.Value)                      maxpath = v0.ToString();                    var dirsep = Duplicati.Library.Utility.Utility.GuessDirSeparator(maxpath);                    cmd.CommandText = string.Format(@"SELECT COUNT(*) FROM ""{0}"""' m_tempfiletable);                  var filecount = cmd.ExecuteScalarInt64(-1);                  long foundfiles = -1;                    //TODO: Handle FS case-sensitive?                  cmd.CommandText = string.Format(@"SELECT COUNT(*) FROM ""{0}"" WHERE SUBSTR(""Path""' 1' ?) = ?"' m_tempfiletable);                  cmd.AddParameter();                  cmd.AddParameter();                    while (filecount != foundfiles && maxpath.Length > 0)                  {                      var mp = Library.Utility.Utility.AppendDirSeparator(maxpath' dirsep);                      cmd.SetParameterValue(0' mp.Length);                      cmd.SetParameterValue(1' mp);                      foundfiles = cmd.ExecuteScalarInt64(-1);                        if (filecount != foundfiles)                      {                          var oldlen = maxpath.Length;                            var lix = maxpath.LastIndexOf(dirsep' maxpath.Length - 2' StringComparison.Ordinal);                          maxpath = maxpath.Substring(0' lix + 1);                          if (string.IsNullOrWhiteSpace(maxpath) || maxpath.Length == oldlen)                              maxpath = "";                      }                  }                    return maxpath == "" ? "" : Library.Utility.Utility.AppendDirSeparator(maxpath' dirsep);              }
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  // Return order from SQLite-DISTINCT is likely to be sorted by Name' which is bad for restore.                  // If the end of very large files (e.g. iso's) is restored before the beginning' most OS write out zeros to fill the file.                  // If we manage to get the volumes in an order restoring front blocks first' this can save time.                  // An optimal algorithm would build a depency net with cycle resolution to find the best near topological                  // order of volumes' but this is a bit too fancy here.                  // We will just put a very simlpe heuristic to work' that will try to prefer volumes containing lower block indexes:                  // We just order all volumes by the maximum block index they contain. This query is slow' but should be worth the effort.                  // Now it is likely to restore all files from front to back. Large files will always be done last.                  // One could also use like the average block number in a volume' that needs to be measured.                    cmd.CommandText = string.Format(                        @"SELECT ""RV"".""Name""' ""RV"".""Hash""' ""RV"".""Size""' ""BB"".""MaxIndex"" "                      + @"  FROM ""RemoteVolume"" ""RV"" INNER JOIN "                      + @"        (SELECT ""B"".""VolumeID""' MAX(""TB"".""Index"") as ""MaxIndex"" "                      + @"           FROM ""Block"" ""B""' ""{0}"" ""TB"" "                      + @"          WHERE ""TB"".""Restored"" = 0 "                      + @"            AND ""B"".""Hash"" = ""TB"".""Hash"" "                      + @"            AND ""B"".""Size"" = ""TB"".""Size"" "                      + @"          GROUP BY  ""B"".""VolumeID"" "                      + @"        ) as ""BB"" ON ""RV"".""ID"" = ""BB"".""VolumeID"" "                      + @"  ORDER BY ""BB"".""MaxIndex"" "                      ' m_tempblocktable);                    using (var rd = cmd.ExecuteReader())                  {                      object[] r = new object[3];                      while (rd.Read())                      {                          rd.GetValues(r);                          yield return new RemoteVolume(                              rd.ConvertValueToString(0)'                              rd.ConvertValueToString(1)'                              rd.ConvertValueToInt64(2' -1)                          );                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  // Return order from SQLite-DISTINCT is likely to be sorted by Name' which is bad for restore.                  // If the end of very large files (e.g. iso's) is restored before the beginning' most OS write out zeros to fill the file.                  // If we manage to get the volumes in an order restoring front blocks first' this can save time.                  // An optimal algorithm would build a depency net with cycle resolution to find the best near topological                  // order of volumes' but this is a bit too fancy here.                  // We will just put a very simlpe heuristic to work' that will try to prefer volumes containing lower block indexes:                  // We just order all volumes by the maximum block index they contain. This query is slow' but should be worth the effort.                  // Now it is likely to restore all files from front to back. Large files will always be done last.                  // One could also use like the average block number in a volume' that needs to be measured.                    cmd.CommandText = string.Format(                        @"SELECT ""RV"".""Name""' ""RV"".""Hash""' ""RV"".""Size""' ""BB"".""MaxIndex"" "                      + @"  FROM ""RemoteVolume"" ""RV"" INNER JOIN "                      + @"        (SELECT ""B"".""VolumeID""' MAX(""TB"".""Index"") as ""MaxIndex"" "                      + @"           FROM ""Block"" ""B""' ""{0}"" ""TB"" "                      + @"          WHERE ""TB"".""Restored"" = 0 "                      + @"            AND ""B"".""Hash"" = ""TB"".""Hash"" "                      + @"            AND ""B"".""Size"" = ""TB"".""Size"" "                      + @"          GROUP BY  ""B"".""VolumeID"" "                      + @"        ) as ""BB"" ON ""RV"".""ID"" = ""BB"".""VolumeID"" "                      + @"  ORDER BY ""BB"".""MaxIndex"" "                      ' m_tempblocktable);                    using (var rd = cmd.ExecuteReader())                  {                      object[] r = new object[3];                      while (rd.Read())                      {                          rd.GetValues(r);                          yield return new RemoteVolume(                              rd.ConvertValueToString(0)'                              rd.ConvertValueToString(1)'                              rd.ConvertValueToInt64(2' -1)                          );                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  cmd.AddParameter(!onlyNonVerified);                  using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable)))                      while (rd.Read())                          yield return new FileToRestore(rd.ConvertValueToInt64(0)' rd.ConvertValueToString(1)' rd.ConvertValueToString(2)' rd.ConvertValueToInt64(3));              }
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  cmd.AddParameter(!onlyNonVerified);                  using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable)))                      while (rd.Read())                          yield return new FileToRestore(rd.ConvertValueToInt64(0)' rd.ConvertValueToString(1)' rd.ConvertValueToString(2)' rd.ConvertValueToInt64(3));              }
Magic Number,Duplicati.Library.Main.Database,FilesAndMetadata,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FilesAndMetadata,The following statement contains a magic number: using (var c = m_connection.CreateCommand())                  {                      m_tmptable = "VolumeFiles-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                      c.CommandText = string.Format(@"CREATE TEMPORARY TABLE ""{0}"" ( ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL )"' m_tmptable);                      c.ExecuteNonQuery();                          c.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Hash""' ""Size"") VALUES (?'?)"' m_tmptable);                      c.AddParameters(2);                      foreach (var s in curvolume.Blocks)                      {                          c.SetParameterValue(0' s.Key);                          c.SetParameterValue(1' s.Value);                          c.ExecuteNonQuery();                      }                        // The index _HashSizeIndex is not needed anymore. Index on "Blocks-..." is used on Join in GetMissingBlocks                    }
Magic Number,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DirectBlockMarker,The following statement contains a magic number: m_insertblockCommand.AddParameters(5);
Magic Number,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DirectBlockMarker,The following statement contains a magic number: m_updateAsRestoredCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetBlockRestored,The following statement contains a magic number: m_insertblockCommand.SetParameterValue(2' hash);
Magic Number,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetBlockRestored,The following statement contains a magic number: m_insertblockCommand.SetParameterValue(3' size);
Magic Number,Duplicati.Library.Main.Database,DirectBlockMarker,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetBlockRestored,The following statement contains a magic number: m_insertblockCommand.SetParameterValue(4' metadata);
Magic Number,Duplicati.Library.Main.Database,RemoteVolume,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\RemoteVolume.cs,RemoteVolume,The following statement contains a magic number: this.Size = rd.ConvertValueToInt64(2);
Magic Number,Duplicati.Library.Main.Database,RemoteVolume,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\RemoteVolume.cs,RemoteVolume,The following statement contains a magic number: this.Hash = rd.ConvertValueToString(3);
Magic Number,Duplicati.Library.Main.Database,RemoteVolume,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\RemoteVolume.cs,RemoteVolume,The following statement contains a magic number: this.VerificationCount = rd.ConvertValueToInt64(4);
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,InitializeCommands,The following statement contains a magic number: m_moveBlockToNewVolumeCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  cmd.Transaction = transaction;                  try                  {                      cmd.ExecuteNonQuery(createtable' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                      using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))                          while (rd.Read())                              yield return new VolumeUsage(rd.GetValue(0).ToString()' rd.ConvertValueToInt64(1' 0) + rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(3' 0));                  }                  finally                   {                      try { cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename)); }                      catch { }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  cmd.Transaction = transaction;                  try                  {                      cmd.ExecuteNonQuery(createtable' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                      using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))                          while (rd.Read())                              yield return new VolumeUsage(rd.GetValue(0).ToString()' rd.ConvertValueToInt64(1' 0) + rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(3' 0));                  }                  finally                   {                      try { cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename)); }                      catch { }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand())              {                  cmd.Transaction = transaction;                  try                  {                      cmd.ExecuteNonQuery(createtable' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                      using (var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))                          while (rd.Read())                              yield return new VolumeUsage(rd.GetValue(0).ToString()' rd.ConvertValueToInt64(1' 0) + rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(2' 0)' rd.ConvertValueToInt64(3' 0));                  }                  finally                   {                      try { cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename)); }                      catch { }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,MoveBlockToNewVolume,The following statement contains a magic number: m_moveBlockToNewVolumeCommand.SetParameterValue(2' size);
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              {                  // Although the generated index volumes are always in pairs'                  // this code handles many-to-many relations between                  // index files and block volumes' should this be added later                  var lookupBlock = new Dictionary<string' List<IRemoteVolume>>();                  var lookupIndexfiles = new Dictionary<string' List<string>>();                                    cmd.Transaction = transaction;                                    using(var rd = cmd.ExecuteReader(@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL "))                      while(rd.Read())                      {                          var name = rd.GetValue(0).ToString();                          List<IRemoteVolume> indexfileList;                          if (!lookupBlock.TryGetValue(name' out indexfileList))                          {                                  indexfileList = new List<IRemoteVolume>();                              lookupBlock.Add(name' indexfileList);                          }                                                    var v = new RemoteVolume(rd.GetString(1)' rd.GetString(2)' rd.GetInt64(3));                          indexfileList.Add(v);                            List<string> blockList;                          if (!lookupIndexfiles.TryGetValue(v.Name' out blockList))                          {                                  blockList = new List<string>();                              lookupIndexfiles.Add(v.Name' blockList);                          }                          blockList.Add(name);                      }                    foreach(var r in deleteableVolumes.Distinct())                  {                      // Return the input                      yield return r;                      List<IRemoteVolume> indexfileList;                      if (lookupBlock.TryGetValue(r.Name' out indexfileList))                          foreach(var sh in indexfileList)                          {                              List<string> backref;                              if (lookupIndexfiles.TryGetValue(sh.Name' out backref))                              {                                  //If this is the last reference'                                   // remove the index file as well                                  if (backref.Remove(r.Name) && backref.Count == 0)                                      yield return sh;                              }                          }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              {                  // Although the generated index volumes are always in pairs'                  // this code handles many-to-many relations between                  // index files and block volumes' should this be added later                  var lookupBlock = new Dictionary<string' List<IRemoteVolume>>();                  var lookupIndexfiles = new Dictionary<string' List<string>>();                                    cmd.Transaction = transaction;                                    using(var rd = cmd.ExecuteReader(@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL "))                      while(rd.Read())                      {                          var name = rd.GetValue(0).ToString();                          List<IRemoteVolume> indexfileList;                          if (!lookupBlock.TryGetValue(name' out indexfileList))                          {                                  indexfileList = new List<IRemoteVolume>();                              lookupBlock.Add(name' indexfileList);                          }                                                    var v = new RemoteVolume(rd.GetString(1)' rd.GetString(2)' rd.GetInt64(3));                          indexfileList.Add(v);                            List<string> blockList;                          if (!lookupIndexfiles.TryGetValue(v.Name' out blockList))                          {                                  blockList = new List<string>();                              lookupIndexfiles.Add(v.Name' blockList);                          }                          blockList.Add(name);                      }                    foreach(var r in deleteableVolumes.Distinct())                  {                      // Return the input                      yield return r;                      List<IRemoteVolume> indexfileList;                      if (lookupBlock.TryGetValue(r.Name' out indexfileList))                          foreach(var sh in indexfileList)                          {                              List<string> backref;                              if (lookupIndexfiles.TryGetValue(sh.Name' out backref))                              {                                  //If this is the last reference'                                   // remove the index file as well                                  if (backref.Remove(r.Name) && backref.Count == 0)                                      yield return sh;                              }                          }                  }              }
Magic Number,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,CompactReport,The following statement contains a magic number: m_wastevolumes = from n in m_report where ((((n.WastedSize / (float)n.DataSize) * 100) >= wastethreshold) || (((n.WastedSize / (float)volsize) * 100) >= wastethreshold)) && !m_cleandelete.Contains(n) select n;
Magic Number,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,CompactReport,The following statement contains a magic number: m_wastevolumes = from n in m_report where ((((n.WastedSize / (float)n.DataSize) * 100) >= wastethreshold) || (((n.WastedSize / (float)volsize) * 100) >= wastethreshold)) && !m_cleandelete.Contains(n) select n;
Magic Number,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,ReportCompactData,The following statement contains a magic number: var wastepercentage = ((m_wastedspace / (float)m_fullsize) * 100);
Magic Number,Duplicati.Library.Main.Database,CompactReport,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,ReportCompactData,The following statement contains a magic number: if (m_deletablevolumes > 0)                      log.AddMessage(string.Format("Compacting because there are {0} fully deletable volume(s)"' m_deletablevolumes));                  else if (wastepercentage >= m_wastethreshold && m_wastevolumes.Count() >= 2)                      log.AddMessage(string.Format("Compacting because there is {0:F2}% wasted space and the limit is {1}%"' wastepercentage' m_wastethreshold));                  else if (m_smallspace > m_volsize)                      log.AddMessage(string.Format("Compacting because there are {0} in small volumes and the volume size is {1}"' Library.Utility.Utility.FormatSizeString(m_smallspace)' Library.Utility.Utility.FormatSizeString(m_volsize)));                  else if (m_smallvolumecount > m_maxsmallfilecount)                      log.AddMessage(string.Format("Compacting because there are {0} small volumes and the maximum is {1}"' m_smallvolumecount' m_maxsmallfilecount));                  else                      log.AddMessage("Compacting not required");
Magic Number,Duplicati.Library.Main.Database,BlockQuery,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,BlockQuery,The following statement contains a magic number: m_command.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetBlockVolumesFromIndexName,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  foreach(var rd in cmd.ExecuteReaderEnumerable(@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""ID"" IN (SELECT ""BlockVolumeID"" FROM ""IndexBlockLink"" WHERE ""IndexVolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?))"' name))                      yield return new RemoteVolume(rd.GetString(0)' rd.ConvertValueToString(1)' rd.ConvertValueToInt64(2));
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  cmd.Transaction = tr;                    var sql_count =                       @"SELECT COUNT(*) FROM (" +                      @" SELECT DISTINCT c1 FROM (" +                      @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " +                      @")" +                      @")";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 1)                  {                      m_result.AddMessage("Found duplicate metadatahashes' repairing");                        var tablename = "TmpFile-" + Guid.NewGuid().ToString("N");                        cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));                        var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = string.Format(@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);                          c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";                          using(var rd = cmd.ExecuteReader(sql))                              while (rd.Read())                                  c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(1)' rd.GetValue(0));                      }                        sql = string.Format(@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);                        using(var c2 = m_connection.CreateCommand())                      {                          c2.Transaction = tr;                          c2.CommandText = string.Format(@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);                          c2.CommandText += string.Format(@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));                      cmd.ExecuteNonQuery(string.Format(@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"DROP TABLE ""{0}"" "' tablename));                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate metadatahashes!");                        m_result.AddMessage("Duplicate metadatahashes repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  cmd.Transaction = tr;                    var sql_count =                       @"SELECT COUNT(*) FROM (" +                      @" SELECT DISTINCT c1 FROM (" +                      @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " +                      @")" +                      @")";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 1)                  {                      m_result.AddMessage("Found duplicate metadatahashes' repairing");                        var tablename = "TmpFile-" + Guid.NewGuid().ToString("N");                        cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));                        var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = string.Format(@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);                          c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";                          using(var rd = cmd.ExecuteReader(sql))                              while (rd.Read())                                  c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(1)' rd.GetValue(0));                      }                        sql = string.Format(@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);                        using(var c2 = m_connection.CreateCommand())                      {                          c2.Transaction = tr;                          c2.CommandText = string.Format(@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);                          c2.CommandText += string.Format(@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));                      cmd.ExecuteNonQuery(string.Format(@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"DROP TABLE ""{0}"" "' tablename));                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate metadatahashes!");                        m_result.AddMessage("Duplicate metadatahashes repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  cmd.Transaction = tr;                    var sql_count =                       @"SELECT COUNT(*) FROM (" +                      @" SELECT DISTINCT c1 FROM (" +                      @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " +                      @")" +                      @")";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 1)                  {                      m_result.AddMessage("Found duplicate metadatahashes' repairing");                        var tablename = "TmpFile-" + Guid.NewGuid().ToString("N");                        cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));                        var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = string.Format(@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);                          c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";                          using(var rd = cmd.ExecuteReader(sql))                              while (rd.Read())                                  c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(1)' rd.GetValue(0));                      }                        sql = string.Format(@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);                        using(var c2 = m_connection.CreateCommand())                      {                          c2.Transaction = tr;                          c2.CommandText = string.Format(@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);                          c2.CommandText += string.Format(@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));                      cmd.ExecuteNonQuery(string.Format(@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"DROP TABLE ""{0}"" "' tablename));                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate metadatahashes!");                        m_result.AddMessage("Duplicate metadatahashes repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  cmd.Transaction = tr;                    var sql_count =                       @"SELECT COUNT(*) FROM (" +                      @" SELECT DISTINCT c1 FROM (" +                      @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " +                      @")" +                      @")";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 1)                  {                      m_result.AddMessage("Found duplicate metadatahashes' repairing");                        var tablename = "TmpFile-" + Guid.NewGuid().ToString("N");                        cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));                        var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = string.Format(@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);                          c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";                          using(var rd = cmd.ExecuteReader(sql))                              while (rd.Read())                                  c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(1)' rd.GetValue(0));                      }                        sql = string.Format(@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);                        using(var c2 = m_connection.CreateCommand())                      {                          c2.Transaction = tr;                          c2.CommandText = string.Format(@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);                          c2.CommandText += string.Format(@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));                      cmd.ExecuteNonQuery(string.Format(@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));                      cmd.ExecuteNonQuery(string.Format(@"DROP TABLE ""{0}"" "' tablename));                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate metadatahashes!");                        m_result.AddMessage("Duplicate metadatahashes repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 0)                  {                      m_result.AddMessage("Found duplicate file entries' repairing");                        var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";                          c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate file entries!");                        m_result.AddMessage("Duplicate file entries repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 0)                  {                      m_result.AddMessage("Found duplicate file entries' repairing");                        var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";                          c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate file entries!");                        m_result.AddMessage("Duplicate file entries repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 0)                  {                      m_result.AddMessage("Found duplicate file entries' repairing");                        var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";                          c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate file entries!");                        m_result.AddMessage("Duplicate file entries repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 0)                  {                      m_result.AddMessage("Found duplicate file entries' repairing");                        var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";                          c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";                          foreach(var rd in cmd.ExecuteReaderEnumerable(sql))                              c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(1)' rd.GetValue(2)' rd.GetValue(3)' rd.GetValue(0));                      }                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64(0);                      if (x > 1)                          throw new Duplicati.Library.Interface.UserInformationException("Repair failed' there are still duplicate file entries!");                        m_result.AddMessage("Duplicate file entries repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: var hashsize = blockhasher.HashSize / 8;
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(countsql' 0);                  if (itemswithnoblocklisthash != 0)                  {                      m_result.AddMessage(string.Format("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));                      using(var c2 = m_connection.CreateCommand(tr))                      using(var c3 = m_connection.CreateCommand(tr))                      using(var c4 = m_connection.CreateCommand(tr))                      using(var c5 = m_connection.CreateCommand(tr))                      using(var c6 = m_connection.CreateCommand(tr))                      {                          c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";                          c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";                          c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";                          c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";                            foreach(var e in cmd.ExecuteReaderEnumerable(sql))                          {                              var blocksetid = e.ConvertValueToInt64(0);                              var ix = 0L;                                c2.ExecuteNonQuery(@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);                                foreach(var h in c2.ExecuteReaderEnumerable(@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid))                              {                                  var tmp = Convert.FromBase64String(h.GetString(0));                                  if (blocklistbuffer.Length - blocklistoffset < tmp.Length)                                  {                                      var blkey = Convert.ToBase64String(blockhasher.ComputeHash(blocklistbuffer' 0' blocklistoffset));                                        // Ensure that the block exists in "blocks"                                      if (c4.ExecuteScalarInt64(null' -1' blkey' blocklistoffset) != 1)                                      {                                          var c = c5.ExecuteScalarInt64(null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                                          if (c <= 0)                                              throw new Exception(string.Format("Missing block for blocklisthash: {0}"' blkey));                                          else                                          {                                              var rc = c6.ExecuteNonQuery(null' c' c);                                              if (rc != 2)                                                  throw new Exception(string.Format("Unexpected update count: {0}"' rc));                                          }                                      }                                        // Add to table                                      c3.ExecuteNonQuery(null' blocksetid' ix' blkey);                                      ix++;                                      blocklistoffset = 0;                                  }                                    Array.Copy(tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);                                  blocklistoffset += tmp.Length;                                }                                if (blocklistoffset != 0)                              {                                  var blkeyfinal = Convert.ToBase64String(blockhasher.ComputeHash(blocklistbuffer' 0' blocklistoffset));                                    // Ensure that the block exists in "blocks"                                  if (c4.ExecuteScalarInt64(null' -1' blkeyfinal' blocklistoffset) != 1)                                  {                                      var c = c5.ExecuteScalarInt64(null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                                      if (c == 0)                                          throw new Exception(string.Format("Missing block for blocklisthash: {0}"' blkeyfinal));                                      else                                      {                                          var rc = c6.ExecuteNonQuery(null' c' c);                                          if (rc != 2)                                              throw new Exception(string.Format("Unexpected update count: {0}"' rc));                                      }                                  }                                    // Add to table                                  c3.ExecuteNonQuery(null' blocksetid' ix' blkeyfinal);                                  ix++;                              }                          }                      }                          itemswithnoblocklisthash = cmd.ExecuteScalarInt64(countsql' 0);                      if (itemswithnoblocklisthash != 0)                          throw new Duplicati.Library.Interface.UserInformationException(string.Format("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));                        m_result.AddMessage("Missing blocklisthashes repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(countsql' 0);                  if (itemswithnoblocklisthash != 0)                  {                      m_result.AddMessage(string.Format("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));                      using(var c2 = m_connection.CreateCommand(tr))                      using(var c3 = m_connection.CreateCommand(tr))                      using(var c4 = m_connection.CreateCommand(tr))                      using(var c5 = m_connection.CreateCommand(tr))                      using(var c6 = m_connection.CreateCommand(tr))                      {                          c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";                          c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";                          c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";                          c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";                            foreach(var e in cmd.ExecuteReaderEnumerable(sql))                          {                              var blocksetid = e.ConvertValueToInt64(0);                              var ix = 0L;                                c2.ExecuteNonQuery(@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);                                foreach(var h in c2.ExecuteReaderEnumerable(@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid))                              {                                  var tmp = Convert.FromBase64String(h.GetString(0));                                  if (blocklistbuffer.Length - blocklistoffset < tmp.Length)                                  {                                      var blkey = Convert.ToBase64String(blockhasher.ComputeHash(blocklistbuffer' 0' blocklistoffset));                                        // Ensure that the block exists in "blocks"                                      if (c4.ExecuteScalarInt64(null' -1' blkey' blocklistoffset) != 1)                                      {                                          var c = c5.ExecuteScalarInt64(null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                                          if (c <= 0)                                              throw new Exception(string.Format("Missing block for blocklisthash: {0}"' blkey));                                          else                                          {                                              var rc = c6.ExecuteNonQuery(null' c' c);                                              if (rc != 2)                                                  throw new Exception(string.Format("Unexpected update count: {0}"' rc));                                          }                                      }                                        // Add to table                                      c3.ExecuteNonQuery(null' blocksetid' ix' blkey);                                      ix++;                                      blocklistoffset = 0;                                  }                                    Array.Copy(tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);                                  blocklistoffset += tmp.Length;                                }                                if (blocklistoffset != 0)                              {                                  var blkeyfinal = Convert.ToBase64String(blockhasher.ComputeHash(blocklistbuffer' 0' blocklistoffset));                                    // Ensure that the block exists in "blocks"                                  if (c4.ExecuteScalarInt64(null' -1' blkeyfinal' blocklistoffset) != 1)                                  {                                      var c = c5.ExecuteScalarInt64(null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString()' RemoteVolumeState.Uploaded.ToString()' RemoteVolumeState.Verified.ToString());                                      if (c == 0)                                          throw new Exception(string.Format("Missing block for blocklisthash: {0}"' blkeyfinal));                                      else                                      {                                          var rc = c6.ExecuteNonQuery(null' c' c);                                          if (rc != 2)                                              throw new Exception(string.Format("Unexpected update count: {0}"' rc));                                      }                                  }                                    // Add to table                                  c3.ExecuteNonQuery(null' blocksetid' ix' blkeyfinal);                                  ix++;                              }                          }                      }                          itemswithnoblocklisthash = cmd.ExecuteScalarInt64(countsql' 0);                      if (itemswithnoblocklisthash != 0)                          throw new Duplicati.Library.Interface.UserInformationException(string.Format("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));                        m_result.AddMessage("Missing blocklisthashes repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var dup_sql = @"SELECT * FROM (SELECT ""BlocksetID""' ""Index""' COUNT(*) AS ""EC"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID""' ""Index"") WHERE ""EC"" > 1";                    var sql_count = @"SELECT COUNT(*) FROM (" + dup_sql + ")";                    var x = cmd.ExecuteScalarInt64(sql_count' 0);                  if (x > 0)                  {                      m_result.AddMessage("Found duplicate blocklisthash entries' repairing");                        var unique_count = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);                        using(var c2 = m_connection.CreateCommand(tr))                      {                          c2.CommandText = @"DELETE FROM ""BlocklistHash"" WHERE rowid IN (SELECT rowid FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ? AND ""Index"" = ? LIMIT ?)";                          foreach(var rd in cmd.ExecuteReaderEnumerable(dup_sql))                          {                              var expected = rd.GetInt32(2) - 1;                              var actual = c2.ExecuteNonQuery(null' rd.GetValue(0)' rd.GetValue(1)' expected);                              if (actual != expected)                                  throw new Exception(string.Format("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected));                          }                      }                        cmd.CommandText = sql_count;                      x = cmd.ExecuteScalarInt64();                      if (x > 1)                          throw new Exception("Repair failed' there are still duplicate file entries!");                        var real_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM ""BlocklistHash"""' 0);                        if (real_count != unique_count)                          throw new Duplicati.Library.Interface.UserInformationException(string.Format("Failed to repair' result should have been {0} blocklist hashes' but result was {1} blocklist hashes"' unique_count' real_count));                        try                      {                          VerifyConsistency(tr' blocksize' hashsize' true);                      }                      catch(Exception ex)                      {                          throw new Duplicati.Library.Interface.UserInformationException("Repaired blocklisthashes' but the database was broken afterwards' rolled back changes"' ex);                      }                        m_result.AddMessage("Duplicate blocklisthashes repaired succesfully");                      tr.Commit();                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The following statement contains a magic number: using(var tr = m_connection.BeginTransaction())              using(var cmd = m_connection.CreateCommand(tr))              {                  var tablename = "ProbeBlocks-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                    cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL)"' tablename));                  cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Hash""' ""Size"") VALUES (?' ?)"' tablename);                  cmd.AddParameters(2);                    foreach(var kp in blocks)                  {                      cmd.SetParameterValue(0' kp.Key);                      cmd.SetParameterValue(1' kp.Value);                      cmd.ExecuteNonQuery();                  }                    var id = cmd.ExecuteScalarInt64(@"SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' -1' filename);                  var aliens = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT ""A"".""VolumeID"" FROM ""{0}"" B LEFT OUTER JOIN ""Block"" A ON ""A"".""Hash"" = ""B"".""Hash"" AND ""A"".""Size"" = ""B"".""Size"") WHERE ""VolumeID"" != ? "' tablename)' 0' id);                    cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' tablename));                    if (aliens != 0)                      throw new Exception(string.Format("Not all blocks were found in {0}"' filename));              }
Magic Number,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,MissingBlockList,The following statement contains a magic number: m_insertCommand.AddParameters(4);
Magic Number,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,SetBlockRestored,The following statement contains a magic number: m_insertCommand.SetParameterValue(2' size);
Magic Number,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,SetBlockRestored,The following statement contains a magic number: m_insertCommand.SetParameterValue(3' 0);
Magic Number,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetFilesetsUsingMissingBlocks,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand(m_transaction.Parent))                      foreach(var rd in cmd.ExecuteReaderEnumerable(string.Format(cmdtxt' m_tablename)' RemoteVolumeType.Files.ToString()))                          yield return new RemoteVolume(rd.GetString(0)' rd.ConvertValueToString(1)' rd.ConvertValueToInt64(2));
Magic Number,Duplicati.Library.Main.Database,MissingBlockList,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetMissingBlockSources,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand(m_transaction.Parent))                      foreach(var rd in cmd.ExecuteReaderEnumerable(string.Format(@"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size"" FROM ""RemoteVolume""' ""Block""' ""{0}"" WHERE ""Block"".""Hash"" = ""{0}"".""Hash"" AND ""Block"".""Size"" = ""{0}"".""Size"" AND ""Block"".""VolumeID"" = ""RemoteVolume"".""ID"" AND ""Remotevolume"".""Name"" != ? "' m_tablename)' m_volumename))                          yield return new RemoteVolume(rd.GetString(0)' rd.ConvertValueToString(1)' rd.ConvertValueToInt64(2));
Magic Number,Duplicati.Library.Main.Database,FileSets,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListDatabase.cs,GetLargestPrefix,The following statement contains a magic number: using(var tmpnames = new FilteredFilenameTable(m_connection' filter' null))                  using(var cmd = m_connection.CreateCommand())                                  {                      //First we trim the filelist to exclude filenames not found in any of the filesets                      cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT DISTINCT ""Path"" FROM ""File""' ""FilesetEntry"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""FilesetEntry"".""FilesetID"" IN (SELECT ""FilesetID"" FROM ""{1}"") ) "' tmpnames.Tablename' m_tablename));                        //If we have a prefix rule' apply it                      if (!string.IsNullOrWhiteSpace(prefixrule))                          cmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" WHERE SUBSTR(""Path""' 1' 1) != ?"' tmpnames.Tablename)' prefixrule);                        // Then we recursively find the largest prefix                      cmd.CommandText = string.Format(@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' tmpnames.Tablename);                      var v0 = cmd.ExecuteScalar();                      string maxpath = "";                      if (v0 != null)                          maxpath = v0.ToString();                        var dirsep = Duplicati.Library.Utility.Utility.GuessDirSeparator(maxpath);                            cmd.CommandText = string.Format(@"SELECT COUNT(*) FROM ""{0}"""' tmpnames.Tablename);                      var filecount = cmd.ExecuteScalarInt64(0);                      long foundfiles = -1;                            //TODO: Handle FS case-sensitive?                      cmd.CommandText = string.Format(@"SELECT COUNT(*) FROM ""{0}"" WHERE SUBSTR(""Path""' 1' ?) = ?"' tmpnames.Tablename);                      cmd.AddParameter();                      cmd.AddParameter();                            while (filecount != foundfiles && maxpath.Length > 0)                      {                          var mp = Duplicati.Library.Utility.Utility.AppendDirSeparator(maxpath' dirsep);                          cmd.SetParameterValue(0' mp.Length);                          cmd.SetParameterValue(1' mp);                          foundfiles = cmd.ExecuteScalarInt64(0);                                if (filecount != foundfiles)                          {                              var oldlen = maxpath.Length;                              var lix = maxpath.LastIndexOf(dirsep' maxpath.Length - 2' StringComparison.Ordinal);                              maxpath = maxpath.Substring(0' lix + 1);                              if (string.IsNullOrWhiteSpace(maxpath) || maxpath.Length == oldlen || maxpath == "\\\\")                                  maxpath = "";                          }                      }                        // Special handling for Windows and multi-drive backups as they do not have a single common root                      if (string.IsNullOrWhiteSpace(maxpath) && string.IsNullOrWhiteSpace(prefixrule))                      {                          var roots = cmd.ExecuteReaderEnumerable(string.Format(@"SELECT DISTINCT SUBSTR(""Path""' 1' 1) FROM ""{0}"""' tmpnames.Tablename)).Select(x => x.ConvertValueToString(0)).ToArray();                          return roots.Select(x => GetLargestPrefix(filter' x).First()).Distinct().ToArray();                      }                            return                           new IFileversion[] {                              new FileversionFixed() { Path = maxpath == "" ? "" : Duplicati.Library.Utility.Utility.AppendDirSeparator(maxpath' dirsep) }                          };                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,StorageHelper,The following statement contains a magic number: m_insertPreviousElementCommand.AddParameters(5);
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,StorageHelper,The following statement contains a magic number: m_insertCurrentElementCommand.AddParameters(5);
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddFromDb,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())                  {                      cmd.Transaction = m_transaction;                      if (filter == null || filter.Empty)                      {                          // Simple case' select everything                          cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? "' tablename' combined)' filesetId);                      }                      else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                      {                          // File list based                          // unfortunately we cannot do this if the filesystem is case sensitive as                          // SQLite only supports ASCII compares                          var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                          var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                                                foreach(var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                                                cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") SELECT ""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"" FROM {1} A WHERE ""A"".""FilesetID"" = ? AND ""A"".""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{2}"") "' tablename' combined' filenamestable)' filesetId);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                      else                      {                          // Do row-wise iteration                          object[] values = new object[5];                          using(var cmd2 = m_connection.CreateCommand())                          {                              cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path""' ""FileHash""' ""MetaHash""' ""Size""' ""Type"") VALUES (?'?'?'?'?)"' tablename);                              cmd2.AddParameters(5);                              cmd2.Transaction = m_transaction;                                    using(var rd = cmd.ExecuteReader(string.Format(@"SELECT ""A"".""Path""' ""A"".""FileHash""' ""A"".""MetaHash""' ""A"".""Size""' ""A"".""Type"" FROM {0} A WHERE ""A"".""FilesetID"" = ?"' combined)' filesetId))                                  while (rd.Read())                                  {                                      rd.GetValues(values);                                      if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                      {                                          cmd2.SetParameterValue(0' values[0]);                                          cmd2.SetParameterValue(1' values[1]);                                          cmd2.SetParameterValue(2' values[2]);                                          cmd2.SetParameterValue(3' values[3]);                                          cmd2.SetParameterValue(4' values[4]);                                          cmd2.ExecuteNonQuery();                                      }                                  }                          }                      }                  }
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddElement,The following statement contains a magic number: cmd.SetParameterValue(2' metahash);
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddElement,The following statement contains a magic number: cmd.SetParameterValue(3' size);
Magic Number,Duplicati.Library.Main.Database,StorageHelper,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListChangesDatabase.cs,AddElement,The following statement contains a magic number: cmd.SetParameterValue(4' (int)type);
Magic Number,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Add,The following statement contains a magic number: m_insertCommand.SetParameterValue(2' hash);
Magic Number,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Add,The following statement contains a magic number: m_insertCommand.SetParameterValue(3' metasize);
Magic Number,Duplicati.Library.Main.Database,Filelist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,Add,The following statement contains a magic number: m_insertCommand.SetParameterValue(4' metahash);
Magic Number,Duplicati.Library.Main.Database,Indexlist,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,AddBlockLink,The following statement contains a magic number: m_insertCommand.SetParameterValue(2' length);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertFileCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertFilesetEntryCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlocksetCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlocklistHashCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_updateBlockVolumeCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlockset.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertSmallBlockset.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findBlocksetCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findMetadatasetCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findFilesetCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findHashBlockCommand.AddParameters(2);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlockCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertDuplicateBlockCommand.AddParameters(3);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: if (m_filesetLookup != null)              {                  PathEntryKeeper e;                  if (m_filesetLookup.TryFind(path' out e))                      fileid = e.GetFilesetID(blocksetid' metadataid);              }              else              {                  m_findFilesetCommand.Transaction = transaction;                  m_findFilesetCommand.SetParameterValue(0' path);                  m_findFilesetCommand.SetParameterValue(1' blocksetid);                  m_findFilesetCommand.SetParameterValue(2' metadataid);                  fileid = m_findFilesetCommand.ExecuteScalarInt64(-1);              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: if (fileid < 0)              {                  m_insertFileCommand.Transaction = transaction;                  m_insertFileCommand.SetParameterValue(0' path);                  m_insertFileCommand.SetParameterValue(1' blocksetid);                  m_insertFileCommand.SetParameterValue(2' metadataid);                  fileid = m_insertFileCommand.ExecuteScalarInt64(-1);                  if (m_filesetLookup != null)                  {                      PathEntryKeeper e;                      if (m_filesetLookup.TryFind(path' out e))                          e.AddFilesetID(blocksetid' metadataid' fileid);                      else                      {                          e = new PathEntryKeeper();                          e.AddFilesetID(blocksetid' metadataid' fileid);                          m_filesetLookup.Insert(path' e);                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: m_insertFilesetEntryCommand.SetParameterValue(2' time.ToUniversalTime().Ticks);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The following statement contains a magic number: if (blocklisthashes != null)              {                  var index = 0L;                  m_insertBlocklistHashCommand.Transaction = transaction;                  m_insertBlocklistHashCommand.SetParameterValue(0' blocksetid);                    foreach(var hash in blocklisthashes)                  {                      if (!string.IsNullOrEmpty(hash))                      {                          c++;                          if (c <= expectedblocklisthashes)                          {                              m_insertBlocklistHashCommand.SetParameterValue(1' index++);                              m_insertBlocklistHashCommand.SetParameterValue(2' hash);                              m_insertBlocklistHashCommand.ExecuteNonQuery();                          }                      }                  }              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: var currentVolumeId = m_findHashBlockCommand.ExecuteScalarInt64(-2);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2)              {                  //Insert                  m_insertBlockCommand.Transaction = transaction;                  m_insertBlockCommand.SetParameterValue(0' hash);                  m_insertBlockCommand.SetParameterValue(1' size);                  m_insertBlockCommand.SetParameterValue(2' volumeID);                  m_insertBlockCommand.ExecuteNonQuery();                                    return true;              }              else if (currentVolumeId == -1)              {                  //Update                  m_updateBlockVolumeCommand.Transaction = transaction;                  m_updateBlockVolumeCommand.SetParameterValue(0' volumeID);                  m_updateBlockVolumeCommand.SetParameterValue(1' hash);                  m_updateBlockVolumeCommand.SetParameterValue(2' size);                  var c = m_updateBlockVolumeCommand.ExecuteNonQuery();                  if (c != 1)                      throw new Exception(string.Format("Failed to update table' found {0} entries for key {1} with size {2}"' c 'hash' size));                                        return true;              }              else              {                  m_insertDuplicateBlockCommand.Transaction = transaction;                  m_insertDuplicateBlockCommand.SetParameterValue(0' hash);                  m_insertDuplicateBlockCommand.SetParameterValue(1' size);                  m_insertDuplicateBlockCommand.SetParameterValue(2' volumeID);                  m_insertDuplicateBlockCommand.ExecuteNonQuery();                    return false;              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2)              {                  //Insert                  m_insertBlockCommand.Transaction = transaction;                  m_insertBlockCommand.SetParameterValue(0' hash);                  m_insertBlockCommand.SetParameterValue(1' size);                  m_insertBlockCommand.SetParameterValue(2' volumeID);                  m_insertBlockCommand.ExecuteNonQuery();                                    return true;              }              else if (currentVolumeId == -1)              {                  //Update                  m_updateBlockVolumeCommand.Transaction = transaction;                  m_updateBlockVolumeCommand.SetParameterValue(0' volumeID);                  m_updateBlockVolumeCommand.SetParameterValue(1' hash);                  m_updateBlockVolumeCommand.SetParameterValue(2' size);                  var c = m_updateBlockVolumeCommand.ExecuteNonQuery();                  if (c != 1)                      throw new Exception(string.Format("Failed to update table' found {0} entries for key {1} with size {2}"' c 'hash' size));                                        return true;              }              else              {                  m_insertDuplicateBlockCommand.Transaction = transaction;                  m_insertDuplicateBlockCommand.SetParameterValue(0' hash);                  m_insertDuplicateBlockCommand.SetParameterValue(1' size);                  m_insertDuplicateBlockCommand.SetParameterValue(2' volumeID);                  m_insertDuplicateBlockCommand.ExecuteNonQuery();                    return false;              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2)              {                  //Insert                  m_insertBlockCommand.Transaction = transaction;                  m_insertBlockCommand.SetParameterValue(0' hash);                  m_insertBlockCommand.SetParameterValue(1' size);                  m_insertBlockCommand.SetParameterValue(2' volumeID);                  m_insertBlockCommand.ExecuteNonQuery();                                    return true;              }              else if (currentVolumeId == -1)              {                  //Update                  m_updateBlockVolumeCommand.Transaction = transaction;                  m_updateBlockVolumeCommand.SetParameterValue(0' volumeID);                  m_updateBlockVolumeCommand.SetParameterValue(1' hash);                  m_updateBlockVolumeCommand.SetParameterValue(2' size);                  var c = m_updateBlockVolumeCommand.ExecuteNonQuery();                  if (c != 1)                      throw new Exception(string.Format("Failed to update table' found {0} entries for key {1} with size {2}"' c 'hash' size));                                        return true;              }              else              {                  m_insertDuplicateBlockCommand.Transaction = transaction;                  m_insertDuplicateBlockCommand.SetParameterValue(0' hash);                  m_insertDuplicateBlockCommand.SetParameterValue(1' size);                  m_insertDuplicateBlockCommand.SetParameterValue(2' volumeID);                  m_insertDuplicateBlockCommand.ExecuteNonQuery();                    return false;              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2)              {                  //Insert                  m_insertBlockCommand.Transaction = transaction;                  m_insertBlockCommand.SetParameterValue(0' hash);                  m_insertBlockCommand.SetParameterValue(1' size);                  m_insertBlockCommand.SetParameterValue(2' volumeID);                  m_insertBlockCommand.ExecuteNonQuery();                                    return true;              }              else if (currentVolumeId == -1)              {                  //Update                  m_updateBlockVolumeCommand.Transaction = transaction;                  m_updateBlockVolumeCommand.SetParameterValue(0' volumeID);                  m_updateBlockVolumeCommand.SetParameterValue(1' hash);                  m_updateBlockVolumeCommand.SetParameterValue(2' size);                  var c = m_updateBlockVolumeCommand.ExecuteNonQuery();                  if (c != 1)                      throw new Exception(string.Format("Failed to update table' found {0} entries for key {1} with size {2}"' c 'hash' size));                                        return true;              }              else              {                  m_insertDuplicateBlockCommand.Transaction = transaction;                  m_insertDuplicateBlockCommand.SetParameterValue(0' hash);                  m_insertDuplicateBlockCommand.SetParameterValue(1' size);                  m_insertDuplicateBlockCommand.SetParameterValue(2' volumeID);                  m_insertDuplicateBlockCommand.ExecuteNonQuery();                    return false;              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddSmallBlocksetLink,The following statement contains a magic number: m_insertSmallBlockset.SetParameterValue(2' blocksize);
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlockset,The following statement contains a magic number: foreach(var s in blocklisthashes)              {                  m_insertBlockset.SetParameterValue(1' s);                  m_insertBlockset.SetParameterValue(2' index++);                  m_insertBlockset.ExecuteNonQuery();              }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              {                  var selectCommand = @"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size""' ""RemoteVolume"".""ID"" FROM ""RemoteVolume""";                                var missingBlocklistEntries =                       string.Format(                          @"SELECT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash"" LEFT OUTER JOIN ""BlocksetEntry"" ON ""BlocksetEntry"".""Index"" = (""BlocklistHash"".""Index"" * {0}) AND ""BlocksetEntry"".""BlocksetID"" = ""BlocklistHash"".""BlocksetID"" WHERE ""BlocksetEntry"".""BlocksetID"" IS NULL"'                          blocksize / hashsize                      );                    var missingBlockInfo =                       @"SELECT ""VolumeID"" FROM ""Block"" WHERE ""VolumeID"" < 0 ";                                var missingBlocklistVolumes = string.Format(                      @"SELECT ""VolumeID"" FROM ""Block""' (" +                      missingBlocklistEntries +                       @") A WHERE ""A"".""Hash"" = ""Block"".""Hash"" "                  );                                    var countMissingInformation = string.Format(                      @"SELECT COUNT(*) FROM (SELECT DISTINCT ""VolumeID"" FROM ({0} UNION {1}))"'                      missingBlockInfo'                      missingBlocklistEntries);                                            if (passNo == 0)                  {                      // On the first pass' we select all the volumes we know we need'                      // which may be an empty list                      cmd.CommandText = string.Format(selectCommand + @" WHERE ""ID"" IN ({0})"' missingBlocklistVolumes);                                            // Reset the list                      m_proccessedVolumes = new Dictionary<long' long>();                  }                  else                  {                      //On anything but the first pass' we check if we are done                      var r = cmd.ExecuteScalarInt64(countMissingInformation' 0);                      if (r == 0)                          yield break;                                            if (passNo == 1)                      {                          // On the second pass' we select all volumes that are not mentioned in the db                                                    var mentionedVolumes =                              @"SELECT DISTINCT ""VolumeID"" FROM ""Block"" ";                                                    cmd.CommandText = string.Format(selectCommand + @" WHERE ""ID"" NOT IN ({0}) AND ""Type"" = ? "' mentionedVolumes);                          cmd.AddParameter(RemoteVolumeType.Blocks.ToString());                      }                      else                      {                          // On the final pass' we select all volumes                          // the filter will ensure that we do not download anything twice                          cmd.CommandText = selectCommand + @" WHERE ""Type"" = ?";                          cmd.AddParameter(RemoteVolumeType.Blocks.ToString());                      }                  }                                    using(var rd = cmd.ExecuteReader())                  {                      while (rd.Read())                      {                            var volumeID = rd.GetInt64(3);                                                    // Guard against multiple downloads of the same file                          if (!m_proccessedVolumes.ContainsKey(volumeID))                          {                              m_proccessedVolumes.Add(volumeID' volumeID);                                                            yield return new RemoteVolume(                                  rd.GetString(0)'                                  rd.ConvertValueToString(1)'                                  rd.ConvertValueToInt64(2' -1)                              );                          }                      }                  }                                                  }
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: using(var cmd = m_connection.CreateCommand())              {                  var selectCommand = @"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size""' ""RemoteVolume"".""ID"" FROM ""RemoteVolume""";                                var missingBlocklistEntries =                       string.Format(                          @"SELECT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash"" LEFT OUTER JOIN ""BlocksetEntry"" ON ""BlocksetEntry"".""Index"" = (""BlocklistHash"".""Index"" * {0}) AND ""BlocksetEntry"".""BlocksetID"" = ""BlocklistHash"".""BlocksetID"" WHERE ""BlocksetEntry"".""BlocksetID"" IS NULL"'                          blocksize / hashsize                      );                    var missingBlockInfo =                       @"SELECT ""VolumeID"" FROM ""Block"" WHERE ""VolumeID"" < 0 ";                                var missingBlocklistVolumes = string.Format(                      @"SELECT ""VolumeID"" FROM ""Block""' (" +                      missingBlocklistEntries +                       @") A WHERE ""A"".""Hash"" = ""Block"".""Hash"" "                  );                                    var countMissingInformation = string.Format(                      @"SELECT COUNT(*) FROM (SELECT DISTINCT ""VolumeID"" FROM ({0} UNION {1}))"'                      missingBlockInfo'                      missingBlocklistEntries);                                            if (passNo == 0)                  {                      // On the first pass' we select all the volumes we know we need'                      // which may be an empty list                      cmd.CommandText = string.Format(selectCommand + @" WHERE ""ID"" IN ({0})"' missingBlocklistVolumes);                                            // Reset the list                      m_proccessedVolumes = new Dictionary<long' long>();                  }                  else                  {                      //On anything but the first pass' we check if we are done                      var r = cmd.ExecuteScalarInt64(countMissingInformation' 0);                      if (r == 0)                          yield break;                                            if (passNo == 1)                      {                          // On the second pass' we select all volumes that are not mentioned in the db                                                    var mentionedVolumes =                              @"SELECT DISTINCT ""VolumeID"" FROM ""Block"" ";                                                    cmd.CommandText = string.Format(selectCommand + @" WHERE ""ID"" NOT IN ({0}) AND ""Type"" = ? "' mentionedVolumes);                          cmd.AddParameter(RemoteVolumeType.Blocks.ToString());                      }                      else                      {                          // On the final pass' we select all volumes                          // the filter will ensure that we do not download anything twice                          cmd.CommandText = selectCommand + @" WHERE ""Type"" = ?";                          cmd.AddParameter(RemoteVolumeType.Blocks.ToString());                      }                  }                                    using(var rd = cmd.ExecuteReader())                  {                      while (rd.Read())                      {                            var volumeID = rd.GetInt64(3);                                                    // Guard against multiple downloads of the same file                          if (!m_proccessedVolumes.ContainsKey(volumeID))                          {                              m_proccessedVolumes.Add(volumeID' volumeID);                                                            yield return new RemoteVolume(                                  rd.GetString(0)'                                  rd.ConvertValueToString(1)'                                  rd.ConvertValueToInt64(2' -1)                              );                          }                      }                  }                                                  }
Magic Number,Duplicati.Library.Main.Database,PathLookupHelper<T>,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\PathLookupHelper.cs,PathLookupHelper,The following statement contains a magic number: m_lookup = useHotPath ? new List<KeyValuePair<string' FolderEntry>>(128) : null;
Magic Number,Duplicati.Library.Main.Database,TemporaryFileset,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,ApplyFilter,The following statement contains a magic number: if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple)                  {                      // File list based                      // unfortunately we cannot do this if the filesystem is case sensitive as                      // SQLite only supports ASCII compares                      var p = (filter as Library.Utility.FilterExpression).GetSimpleList();                      var filenamestable = "Filenames-" + Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                      using (var cmd = m_connection.CreateCommand(m_transaction))                      {                          cmd.ExecuteNonQuery(string.Format(@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' filenamestable));                          cmd.CommandText = string.Format(@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' filenamestable);                          cmd.AddParameter();                            foreach (var s in p)                          {                              cmd.SetParameterValue(0' s);                              cmd.ExecuteNonQuery();                          }                            cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""FileID"") SELECT DISTINCT ""A"".""FileID"" FROM ""FilesetEntry"" A' ""File"" B WHERE ""A"".""FilesetID"" = ? AND ""A"".""FileID"" = ""B"".""ID"" AND ""B"".""Path"" NOT IN ""{1}"""' m_tablename' filenamestable)' ParentID);                          cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' filenamestable));                      }                  }                  else                  {                      // Do row-wise iteration                      object[] values = new object[2];                      using (var cmd = m_connection.CreateCommand(m_transaction))                      using (var cmd2 = m_connection.CreateCommand(m_transaction))                      {                          cmd2.CommandText = string.Format(@"INSERT INTO ""{0}"" (""FileID"") VALUES (?)"' m_tablename);                          cmd2.AddParameters(1);                            using (var rd = cmd.ExecuteReader(@"SELECT ""B"".""Path""' ""A"".""FileID"" FROM ""FilesetEntry"" A' ""File"" B WHERE ""A"".""FilesetID"" = ? AND ""A"".""FileID"" = ""B"".""ID"" "' ParentID))                              while (rd.Read())                              {                                  rd.GetValues(values);                                  if (values[0] != null && values[0] != DBNull.Value && Library.Utility.FilterExpression.Matches(filter' values[0].ToString()))                                  {                                      cmd2.SetParameterValue(0' values[1]);                                      cmd2.ExecuteNonQuery();                                  }                              }                      }                  }
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilesets,The following statement contains a magic number: using (var cmd = Connection.CreateCommand(transaction))                   foreach (var rd in cmd.ExecuteReaderEnumerable(query' clause.Item2))                      if (!rd.IsDBNull(0))                          yield return new Tuple<DateTime' long' long>(ParseFromEpochSeconds(rd.ConvertValueToInt64(0' 0))' rd.ConvertValueToInt64(1' -1)' rd.ConvertValueToInt64(2' 0));
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The following statement contains a magic number: using (var deletecmd = m_connection.CreateCommand(transaction))              {                  string temptransguid = Library.Utility.Utility.ByteArrayAsHexString(Guid.NewGuid().ToByteArray());                  var volidstable = "DelVolSetIds-" + temptransguid;                    // Create and fill a temp table with the volids to delete. We avoid using too many parameters that way.                  deletecmd.ExecuteNonQuery(string.Format(@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' volidstable));                  deletecmd.CommandText = string.Format(@"INSERT OR IGNORE INTO ""{0}"" (""ID"") VALUES (?)"' volidstable);                  deletecmd.Parameters.Clear();                  deletecmd.AddParameters(1);                  foreach (var name in names)                  {                      var volumeid = GetRemoteVolumeID(name' transaction);                      deletecmd.SetParameterValue(0' volumeid);                      deletecmd.ExecuteNonQuery();                  }                  var volIdsSubQuery = string.Format(@"SELECT ""ID"" FROM ""{0}"" "' volidstable);                  deletecmd.Parameters.Clear();                    deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery));                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""Block"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));                    // Clean up temp tables for subqueries. We truncate content and then try to delete.                  // Drop in try-block' as it fails in nested transactions (SQLite problem)                  // System.Data.SQLite.SQLiteException (0x80004005): database table is locked                  deletecmd.ExecuteNonQuery(string.Format(@"DELETE FROM ""{0}"" "' volidstable));                  try                  {                      deletecmd.CommandTimeout = 2;                      deletecmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));                  }                  catch { /* Ignore' will be deleted on close anyway. */ }              }
Magic Number,Duplicati.Library.Main.Volumes,IndexBlocklistEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeReader.cs,IsValidBase64Hash,The following statement contains a magic number: if (value.Length != ((hashsize + 2) / 3) * 4)                          return false;
Magic Number,Duplicati.Library.Main.Volumes,IndexBlocklistEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeReader.cs,IsValidBase64Hash,The following statement contains a magic number: if (value.Length != ((hashsize + 2) / 3) * 4)                          return false;
Magic Number,Duplicati.Library.Main.Volumes,IndexBlocklistEnumerator,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeReader.cs,IsValidBase64Hash,The following statement contains a magic number: if (value.Length != ((hashsize + 2) / 3) * 4)                          return false;
Missing Default,Duplicati.Library.Main.Operation,TestHandler,C:\repos\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The following switch statement is missing a default case: switch (parsedInfo.FileType)              {                  case RemoteVolumeType.Files:                      //Compare with db and see if all files are accounted for                       // with correct file hashes and blocklist hashes                      using (var fl = db.CreateFilelist(vol.Name))                      {                          using (var rd = new Volumes.FilesetVolumeReader(parsedInfo.CompressionModule' tf' options))                              foreach (var f in rd.Files)                                  fl.Add(f.Path' f.Size' f.Hash' f.Metasize' f.Metahash' f.BlocklistHashes' f.Type' f.Time);                            return new KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>>(vol.Name' fl.Compare().ToList());                      }                    case RemoteVolumeType.Index:                      var blocklinks = new List<Tuple<string' string' long>>();                      IEnumerable<KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>> combined = new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[0];                        //Compare with db and see that all hashes and volumes are listed                      using (var rd = new Volumes.IndexVolumeReader(parsedInfo.CompressionModule' tf' options' hashsize))                          foreach (var v in rd.Volumes)                          {                              blocklinks.Add(new Tuple<string' string' long>(v.Filename' v.Hash' v.Length));                              using (var bl = db.CreateBlocklist(v.Filename))                              {                                  foreach (var h in v.Blocks)                                      bl.AddBlock(h.Key' h.Value);                                    combined = combined.Union(bl.Compare().ToArray());                              }                          }                        using (var il = db.CreateIndexlist(vol.Name))                      {                          foreach (var t in blocklinks)                              il.AddBlockLink(t.Item1' t.Item2' t.Item3);                            combined = combined.Union(il.Compare()).ToList();                      }                        return new KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>>(vol.Name' combined.ToList());                  case RemoteVolumeType.Blocks:                      using (var bl = db.CreateBlocklist(vol.Name))                      using (var rd = new Volumes.BlockVolumeReader(parsedInfo.CompressionModule' tf' options))                      {                          //Verify that all blocks are in the file                          foreach (var b in rd.Blocks)                              bl.AddBlock(b.Key' b.Value);                            //Select random blocks and verify their hashes match the filename and size                          var hashsamples = new List<KeyValuePair<string' long>>(rd.Blocks);                          var sampleCount = Math.Min(Math.Max(0' (int)(hashsamples.Count * sample_percent))' hashsamples.Count - 1);                          var rnd = new Random();                            while (hashsamples.Count > sampleCount)                              hashsamples.RemoveAt(rnd.Next(hashsamples.Count));                            var blockbuffer = new byte[options.Blocksize];                          var changes = new List<KeyValuePair<Library.Interface.TestEntryStatus' string>>();                          foreach (var s in hashsamples)                          {                              var size = rd.ReadBlock(s.Key' blockbuffer);                              if (size != s.Value)                                  changes.Add(new KeyValuePair<Library.Interface.TestEntryStatus' string>(Library.Interface.TestEntryStatus.Modified' s.Key));                              else                              {                                  var hash = Convert.ToBase64String(blockhasher.ComputeHash(blockbuffer' 0' size));                                  if (hash != s.Key)                                      changes.Add(new KeyValuePair<Library.Interface.TestEntryStatus' string>(Library.Interface.TestEntryStatus.Modified' s.Key));                              }                          }                            return new KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>>(vol.Name' changes.Union(bl.Compare().ToList()));                      }              }
Missing Default,Duplicati.Library.Main,BackendManager,C:\repos\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following switch statement is missing a default case: switch (item.Operation)                                  {                                      case OperationType.Put:                                          DoPut(item);                                          // We do not auto create folders'                                          // because we know the folder exists                                          uploadSuccess = true;                                          break;                                      case OperationType.Get:                                          DoGet(item);                                          break;                                      case OperationType.List:                                          DoList(item);                                          break;                                      case OperationType.Delete:                                          DoDelete(item);                                          break;                                      case OperationType.CreateFolder:                                          DoCreateFolder(item);                                          break;                                      case OperationType.Terminate:                                          m_queue.SetCompleted();                                          break;                                      case OperationType.Nothing:                                          item.SignalComplete();                                          break;                                  }
Missing Default,Duplicati.Library.Main,BackendWriter,C:\repos\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,SendEvent,The following switch statement is missing a default case: switch (action)                  {                      case BackendActionType.CreateFolder:                          System.Threading.Interlocked.Increment(ref m_foldersCreated);                          break;                      case BackendActionType.List:                          break;                      case BackendActionType.Delete:                          System.Threading.Interlocked.Increment(ref m_filesDeleted);                          break;                      case BackendActionType.Get:                          System.Threading.Interlocked.Increment(ref m_filesDownloaded);                          System.Threading.Interlocked.Add(ref m_bytesDownloaded' size);                          break;                      case BackendActionType.Put:                          System.Threading.Interlocked.Increment(ref m_filesUploaded);                          System.Threading.Interlocked.Add(ref m_bytesUploaded' size);                          break;                  }
