Implementation smell,Namespace,Class,File,Method,Description
Long Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The method has 120 lines of code.
Long Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The method has 129 lines of code.
Long Method,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The method has 101 lines of code.
Long Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The method has 149 lines of code.
Long Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The method has 142 lines of code.
Long Method,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The method has 101 lines of code.
Long Method,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The method has 299 lines of code.
Long Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The method has 130 lines of code.
Long Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The method has 160 lines of code.
Long Method,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The method has 136 lines of code.
Long Method,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The method has 261 lines of code.
Long Method,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The method has 127 lines of code.
Long Method,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has 141 lines of code.
Long Method,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The method has 112 lines of code.
Complex Method,Duplicati.Library.Main,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Options.cs,GetFilesetsToDelete,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,Cyclomatic complexity of the method is 25
Complex Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,Cyclomatic complexity of the method is 39
Complex Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,Cyclomatic complexity of the method is 16
Complex Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetSequential,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,Cyclomatic complexity of the method is 11
Complex Method,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Put,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,Cyclomatic complexity of the method is 16
Complex Method,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,Cyclomatic complexity of the method is 17
Complex Method,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,Cyclomatic complexity of the method is 29
Complex Method,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,Cyclomatic complexity of the method is 35
Complex Method,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptionValue,Cyclomatic complexity of the method is 18
Complex Method,Duplicati.Library.Main,BackendWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,SendEvent,Cyclomatic complexity of the method is 19
Complex Method,Duplicati.Library.Main,BasicResults,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,WriteMessage,Cyclomatic complexity of the method is 13
Complex Method,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetFilelistWhereClause,Cyclomatic complexity of the method is 11
Complex Method,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetFilesetIDs,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,Cyclomatic complexity of the method is 15
Complex Method,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,Cyclomatic complexity of the method is 14
Complex Method,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,Cyclomatic complexity of the method is 23
Complex Method,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,DropRestoreTable,Cyclomatic complexity of the method is 13
Complex Method,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main.Database,ExtensionMethods,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\ExtensionMethods.cs,DumpSQL,Cyclomatic complexity of the method is 13
Complex Method,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,Cyclomatic complexity of the method is 11
Complex Method,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,Cyclomatic complexity of the method is 15
Complex Method,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,Cyclomatic complexity of the method is 22
Complex Method,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,Cyclomatic complexity of the method is 12
Complex Method,Duplicati.Library.Main.Database,LocalTestDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,FilterByVerificationCount,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main.Database,LocalTestDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,Cyclomatic complexity of the method is 23
Complex Method,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RecreateMissingIndexFiles,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RunMainOperation,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FinalizeRemoteVolumes,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadRealFileList,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,Cyclomatic complexity of the method is 38
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,GenerateMetadata,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,Cyclomatic complexity of the method is 30
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,ProcessStream,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,Cyclomatic complexity of the method is 15
Complex Method,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,Cyclomatic complexity of the method is 86
Complex Method,Duplicati.Library.Main.Operation,RestoreControlFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreControlFilesHandler.cs,Run,Cyclomatic complexity of the method is 20
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,Run,Cyclomatic complexity of the method is 13
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,Cyclomatic complexity of the method is 22
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,Cyclomatic complexity of the method is 38
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ApplyMetadata,Cyclomatic complexity of the method is 11
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,Cyclomatic complexity of the method is 20
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,Cyclomatic complexity of the method is 21
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PrepareBlockAndFileList,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,CreateDirectoryStructure,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,Cyclomatic complexity of the method is 36
Complex Method,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,Cyclomatic complexity of the method is 18
Complex Method,Duplicati.Library.Main.Operation,DeleteHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,Cyclomatic complexity of the method is 17
Complex Method,Duplicati.Library.Main.Operation,CreateBugReportHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CreateBugReportHandler.cs,Run,Cyclomatic complexity of the method is 15
Complex Method,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,Cyclomatic complexity of the method is 75
Complex Method,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyLocalList,Cyclomatic complexity of the method is 15
Complex Method,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyRemoteList,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,Cyclomatic complexity of the method is 40
Complex Method,Duplicati.Library.Main.Operation,ListControlFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListControlFilesHandler.cs,Run,Cyclomatic complexity of the method is 16
Complex Method,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,Cyclomatic complexity of the method is 20
Complex Method,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,Cyclomatic complexity of the method is 19
Complex Method,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,Cyclomatic complexity of the method is 31
Complex Method,Duplicati.Library.Main.Operation,TestFilterHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,Cyclomatic complexity of the method is 42
Complex Method,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,GetBrokenFilesetsFromRemote,Cyclomatic complexity of the method is 9
Complex Method,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,DoRun,Cyclomatic complexity of the method is 10
Complex Method,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,Cyclomatic complexity of the method is 29
Complex Method,Duplicati.Library.Main.Volumes,VolumeReaderBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeReaderBase.cs,UpdateOptionsFromManifest,Cyclomatic complexity of the method is 9
Long Parameter List,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ListChanges,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main,ListChangesResults,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,SetResult,The method has 18 parameters.
Long Parameter List,Duplicati.Library.Main,IBackendProgress,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,Update,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main,BackendProgressUpdater,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,Update,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main,IOperationProgress,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,UpdateOverall,The method has 7 parameters.
Long Parameter List,Duplicati.Library.Main,OperationProgressUpdater,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ProgressClasses.cs,UpdateOverall,The method has 7 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The method has 7 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddMetadataset,The method has 7 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AppendFilesFromPreviousSet,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The method has 7 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Database,RemoteVolumeEntry,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\RemoteVolumeEntry.cs,RemoteVolumeEntry,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetCompactReport,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckBlocklistCorrect,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddDirectoryEntry,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddSymlinkEntry,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddFileEntry,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The method has 7 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddMetadataset,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,ProcessStream,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The method has 7 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddFileToOutput,The method has 8 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyRemoteList,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,UploadVerificationFile,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,SelectTime,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,GetBrokenFilesetsFromRemote,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,BlockVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\BlockVolumeWriter.cs,AddBlock,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddFile,The method has 11 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddAlternateStream,The method has 11 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddFileEntry,The method has 12 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddDirectory,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddMetaEntry,The method has 6 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddSymlink,The method has 5 parameters.
Long Parameter List,Duplicati.Library.Main.Volumes,VolumeBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The method has 6 parameters.
Long Identifier,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the parameter selectBlocklistBlocksetEntries is 30.
Long Statement,Duplicati.Library.Main,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Options.cs,GetFilesetsToDelete,The length of the statement  "		throw new Exception (string.Format ("List of backup timestamps contains duplicates: {0}"' string.Join ("' "' backups.Select (x => x.ToString ())))); " is 148.
Long Statement,Duplicati.Library.Main,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Options.cs,GetFilesetsToDelete,The length of the statement  "		throw new Exception (string.Format ("Too many entries {0} vs {1}' lists: {2} vs {3}"' removeCount' backups.Length' string.Join ("' "' filtered.Select (x => x.ToString ()))' string.Join ("' "' backups.Select (x => x.ToString ())))); " is 231.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "	var folder = System.IO.Path.Combine (System.Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' "Duplicati"); " is 128.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "		configs = Newtonsoft.Json.JsonConvert.DeserializeObject<List<BackendEntry>> (System.IO.File.ReadAllText (file' System.Text.Encoding.UTF8)); " is 139.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "				if (username == null && o.Aliases != null && o.Aliases.Contains ("auth-username"' StringComparer.InvariantCultureIgnoreCase) && ropts.ContainsKey (o.Name)) " is 155.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "				if (password == null && o.Aliases != null && o.Aliases.Contains ("auth-password"' StringComparer.InvariantCultureIgnoreCase) && ropts.ContainsKey (o.Name)) " is 155.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "				if (username == null && o.Name.Equals ("auth-username"' StringComparison.InvariantCultureIgnoreCase) && ropts.ContainsKey ("auth-username")) " is 140.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "				if (password == null && o.Name.Equals ("auth-password"' StringComparison.InvariantCultureIgnoreCase) && ropts.ContainsKey ("auth-password")) " is 140.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "		password = Library.Utility.Utility.ByteArrayAsHexString (System.Security.Cryptography.SHA256.Create ().ComputeHash (System.Text.Encoding.UTF8.GetBytes (password + "!" + uri.Scheme + "!" + uri.HostAndPath))); " is 207.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "		throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Multiple sources found for: {0}"' backend)); " is 124.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "			throw new Duplicati.Library.Interface.UserInformationException (String.Format ("Multiple sources found for \"{0}\"' try supplying --{1}"' backend' "auth-username")); " is 165.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "			throw new Duplicati.Library.Interface.UserInformationException ("Unable to find a unique name for the database' please use --dbpath"); " is 134.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The length of the statement  "		System.IO.File.WriteAllText (file' Newtonsoft.Json.JsonConvert.SerializeObject (configs' settings)' System.Text.Encoding.UTF8); " is 127.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,IsDatabasePathInUse,The length of the statement  "	var folder = System.IO.Path.Combine (System.Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' "Duplicati"); " is 128.
Long Statement,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,IsDatabasePathInUse,The length of the statement  "	return Newtonsoft.Json.JsonConvert.DeserializeObject<List<BackendEntry>> (System.IO.File.ReadAllText (file' System.Text.Encoding.UTF8)).Any (x => string.Equals (path' x.Databasepath' Library.Utility.Utility.ClientFilenameStringComparision)); " is 241.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,GetFileHasherStream,The length of the statement  "	System.Security.Cryptography.CryptoStream retHasherStream = new System.Security.Cryptography.CryptoStream (stream' hasher' mode); " is 129.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "					m_statwriter.AddRetryAttempt (string.Format ("Operation {0} with file {1} attempt {2} of {3} failed with message: {4}"' item.Operation' item.RemoteFilename' retries' m_options.NumberOfRetries' ex.Message)' ex); " is 210.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "					m_statwriter.SendEvent (item.BackendActionType' retries < m_options.NumberOfRetries ? BackendEventType.Retrying : BackendEventType.Failed' item.RemoteFilename' item.Size); " is 171.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "			if (lastException != null && !(lastException is Duplicati.Library.Interface.FileMissingException) && item.Operation == OperationType.Delete) { " is 142.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The length of the statement  "						m_statwriter.AddMessage (LC.L ("Recovered from problem with attempting to delete non-existing file {0}"' item.RemoteFilename)); " is 127.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,The length of the statement  "	Logging.Log.WriteMessage (string.Format ("Uploaded {0} in {1}' {2}/s"' Library.Utility.Utility.FormatSizeString (item.Size)' duration' Library.Utility.Utility.FormatSizeString ((long)(item.Size / duration.TotalSeconds)))' Duplicati.Library.Logging.LogMessageType.Profiling); " is 274.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,The length of the statement  "		var f = m_backend.List ().Where (n => n.Name.Equals (item.RemoteFilename' StringComparison.InvariantCultureIgnoreCase)).FirstOrDefault (); " is 138.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoPut,The length of the statement  "			throw new Exception (string.Format ("List verify failed for file: {0}' size was {1} but expected to be {2}"' f.Name' f.Size' item.Size)); " is 137.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "								m_statwriter.AddVerboseMessage ("Filename extension \"{0}\" does not match encryption module \"{1}\"' using matching encryption module"' ext' m_options.EncryptionModule); " is 170.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "								m_statwriter.AddVerboseMessage ("Filename extension \"{0}\" does not match encryption module \"{1}\"' guessing that it is not encrypted"' ext' m_options.EncryptionModule); " is 171.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "								m_statwriter.AddVerboseMessage ("Filename extension \"{0}\" does not match encryption module \"{1}\"' attempting to use specified encryption module as no others match"' ext' m_options.EncryptionModule); " is 202.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoGet,The length of the statement  "		Logging.Log.WriteMessage (string.Format ("Downloaded {3}{0} in {1}' {2}/s"' Library.Utility.Utility.FormatSizeString (dataSizeDownloaded)' duration' Library.Utility.Utility.FormatSizeString ((long)(dataSizeDownloaded / duration.TotalSeconds))' useDecrypter == null ? "" : "and decrypted ")' Duplicati.Library.Logging.LogMessageType.Profiling); " is 343.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoDelete,The length of the statement  "		var wr = ex as System.Net.WebException == null ? null : (ex as System.Net.WebException).Response as System.Net.HttpWebResponse; " is 127.
Long Statement,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoDelete,The length of the statement  "			m_statwriter.AddWarning (LC.L ("Delete operation failed for {0} with FileNotFound' listing contents"' item.RemoteFilename)' ex); " is 128.
Long Statement,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,UpdateOptionsFromDb,The length of the statement  "	if (opts.ContainsKey ("blocksize") && (!options.RawOptions.TryGetValue ("blocksize"' out n) || string.IsNullOrEmpty (n))) " is 121.
Long Statement,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,UpdateOptionsFromDb,The length of the statement  "	if (opts.ContainsKey ("blockhash") && (!options.RawOptions.TryGetValue ("block-hash-algorithm"' out n) || string.IsNullOrEmpty (n))) " is 132.
Long Statement,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,UpdateOptionsFromDb,The length of the statement  "	if (opts.ContainsKey ("filehash") && (!options.RawOptions.TryGetValue ("file-hash-algorithm"' out n) || string.IsNullOrEmpty (n))) " is 130.
Long Statement,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "		newDict.Add ("passphrase"' Library.Utility.Utility.ByteArrayAsHexString (Library.Utility.Utility.RepeatedHashWithSalt (options.Passphrase' salt' 1200))); " is 153.
Long Statement,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The length of the statement  "				throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Unsupported change of parameter \"{0}\" from \"{1}\" to \"{2}\""' k.Key' opts [k.Key]' k.Value)); " is 177.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The length of the statement  "				Win32.SetThreadExecutionState (Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0)); " is 129.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,Backup,The length of the statement  "				throw new Duplicati.Library.Interface.UserInformationException (Strings.Controller.InvalidPathError (sources [i]' ex.Message)' ex); " is 131.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,Backup,The length of the statement  "		var pathDuplicates = sources.GroupBy (x => x' Library.Utility.Utility.ClientFilenameStringComparer).Where (g => g.Count () > 1).Select (y => y.Key).ToList (); " is 158.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,Backup,The length of the statement  "							result.AddVerboseMessage ("Removing source \"{0}\" because it is a subfolder of \"{1}\"' and using it as an include filter"' sources [i]' sources [j]); " is 151.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,Backup,The length of the statement  "							result.AddVerboseMessage ("Removing source \"{0}\" because it is a subfolder or subfile of \"{1}\""' sources [i]' sources [j]); " is 127.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,Backup,The length of the statement  "						result.AddVerboseMessage ("Removing source \"{0}\" because it is a subfolder or subfile of \"{1}\""' sources [i]' sources [j]); " is 127.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,UpdateDatabaseWithVersions,The length of the statement  "	var filelistfilter = Operation.RestoreHandler.FilterNumberedFilelist (m_options.Time' m_options.Version' singleTimeMatch: true); " is 128.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SendMail,The length of the statement  "	m_options.RawOptions ["disable-module"] = string.Join ("'"' DynamicLoader.GenericLoader.Modules.Where (m => !(m is Library.Interface.IConnectionModule) && m.GetType ().FullName != "Duplicati.Library.Modules.Builtin.SendMail").Select (x => x.Key)); " is 247.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The length of the statement  "			result.WriteLogMessageDirect (Strings.Controller.StartingOperationMessage (m_options.MainAction)' Logging.LogMessageType.Information' null); " is 140.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The length of the statement  "			result.WriteLogMessageDirect (Strings.Controller.CompletedOperationMessage (m_options.MainAction)' Logging.LogMessageType.Information' null); " is 141.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The length of the statement  "			result.WriteLogMessageDirect (Strings.Controller.FailedOperationMessage (m_options.MainAction' ex.Message)' Logging.LogMessageType.Error' ex); " is 142.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,The length of the statement  "					Logging.Log.WriteMessage (string.Format ("OnFinish callback {0} failed: {1}"' mx.Key' ex.Message)' Duplicati.Library.Logging.LogMessageType.Warning' ex); " is 153.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,The length of the statement  "					Logging.Log.WriteMessage (string.Format ("Dispose for {0} failed: {1}"' mx.Key' ex.Message)' Duplicati.Library.Logging.LogMessageType.Warning' ex); " is 147.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "		m_options.LoadedModules.Add (new KeyValuePair<bool' Library.Interface.IGenericModule> (Array.IndexOf<string> (m_options.DisableModules' m.Key.ToLower ()) < 0 && (m.LoadAsDefault || Array.IndexOf<string> (m_options.EnableModules' m.Key.ToLower ()) >= 0)' m)); " is 258.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "	var pristinefilter = conopts ["filter"] = string.Join (System.IO.Path.PathSeparator.ToString ()' FilterExpression.Serialize (filter)); " is 134.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "				((Library.Interface.IGenericCallbackModule)mx.Value).OnStart (result.MainOperation.ToString ()' ref m_backend' ref paths); " is 122.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SetupCommonOptions,The length of the statement  "			Library.Logging.Log.WriteMessage (Strings.Controller.FailedForceLocaleError (ex.Message)' Logging.LogMessageType.Warning); " is 122.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The length of the statement  "		throw new Interface.UserInformationException (string.Format ("Setting both --{0} and --{1} is not permitted"' "keep-versions"' "keep-time")); " is 141.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The length of the statement  "	Dictionary<string' Library.Interface.ICommandLineArgument> supportedOptions = new Dictionary<string' Library.Interface.ICommandLineArgument> (); " is 144.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptions,The length of the statement  "	List<Library.Interface.ICommandLineArgument> moduleOptions = new List<Duplicati.Library.Interface.ICommandLineArgument> (); " is 123.
Long Statement,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,ValidateOptionValue,The length of the statement  "		if (!string.IsNullOrEmpty (value) && Library.Utility.Utility.ParseBool (value' true) != Library.Utility.Utility.ParseBool (value' false)) " is 137.
Long Statement,Duplicati.Library.Main,BasicResults,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,AddBackendEvent,The length of the statement  "				Logging.Log.WriteMessage (string.Format ("Backend event: {0} - {1}: {2} ({3})"' action' type' path' size <= 0 ? "" : Library.Utility.Utility.FormatSizeString (size))' Duplicati.Library.Logging.LogMessageType.Information' null); " is 227.
Long Statement,Duplicati.Library.Main,BasicResults,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,ToString,The length of the statement  "	return Library.Utility.Utility.PrintSerializeObject (this' filter: (prop' item) => !typeof(IBackendProgressUpdater).IsAssignableFrom (prop.PropertyType) && !typeof(IMessageSink).IsAssignableFrom (prop.PropertyType) && !typeof(ILogWriter).IsAssignableFrom (prop.PropertyType) && prop.Name != "VerboseOutput" && prop.Name != "VerboseErrors" && !(prop.Name == "MainOperation" && item is BackendWriter) && !(prop.Name == "EndTime" && item is BackendWriter) && !(prop.Name == "Duration" && item is BackendWriter) && !(prop.Name == "BeginTime" && item is BackendWriter)' recurseobjects: true).ToString (); " is 599.
Long Statement,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The length of the statement  "	return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL); " is 331.
Long Statement,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The length of the statement  "	return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0; " is 520.
Long Statement,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The length of the statement  "	return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f); " is 389.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "		var scantableDefinition = @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A1"" LEFT JOIN " + @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " + @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " + @" WHERE ""A2"".""Path"" IS NULL " + @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " + @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " + @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" "; " is 1239.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "				using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition))) " is 201.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "					using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" "))) " is 127.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The length of the statement  "		var tc = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString ()' RemoteVolumeState.Uploading.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ()); " is 337.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The length of the statement  "				m_result.AddError (string.Format ("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null); " is 249.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The length of the statement  "						m_result.AddError (string.Format ("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64 (0' -1))' null); " is 134.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetPreviousFilesetID,The length of the statement  "	var lastFilesetId = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""Fileset"" WHERE ""Timestamp"" < ? AND ""ID"" != ? ORDER BY ""Timestamp"" DESC "' -1' NormalizeDateTimeToEpochSeconds (timestamp)' filesetid); " is 208.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "		results.AddedFolders = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' m_filesetId' FOLDER_BLOCKSET_ID' lastFilesetId); " is 461.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "		results.AddedSymlinks = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' m_filesetId' SYMLINK_BLOCKSET_ID' lastFilesetId); " is 463.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "		results.DeletedFolders = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' lastFilesetId' FOLDER_BLOCKSET_ID' m_filesetId); " is 463.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "		results.DeletedSymlinks = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" = ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' 0' lastFilesetId' SYMLINK_BLOCKSET_ID' m_filesetId); " is 465.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "		var subqueryNonFiles = @"SELECT ""File"".""Path""' ""Blockset"".""Fullhash"" FROM ""File""' ""FilesetEntry""' ""Metadataset""' ""Blockset"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""Metadataset"".""ID"" = ""File"".""MetadataID"" AND ""File"".""BlocksetID"" = ? AND ""Metadataset"".""BlocksetID"" = ""Blockset"".""ID"" AND ""FilesetEntry"".""FilesetID"" = ? "; " is 375.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "		results.ModifiedFolders = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM (" + subqueryNonFiles + @") A' (" + subqueryNonFiles + @") B WHERE ""A"".""Path"" = ""B"".""Path"" AND ""A"".""Fullhash"" != ""B"".""Fullhash"" "' 0' lastFilesetId' FOLDER_BLOCKSET_ID' m_filesetId' FOLDER_BLOCKSET_ID); " is 291.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "		results.ModifiedSymlinks = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM (" + subqueryNonFiles + @") A' (" + subqueryNonFiles + @") B WHERE ""A"".""Path"" = ""B"".""Path"" AND ""A"".""Fullhash"" != ""B"".""Fullhash"" "' 0' lastFilesetId' SYMLINK_BLOCKSET_ID' m_filesetId' SYMLINK_BLOCKSET_ID); " is 294.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "			var subqueryFiles = @"SELECT ""File"".""Path""' ""A"".""Fullhash"" AS ""Filehash""' ""B"".""Fullhash"" AS ""Metahash"" FROM ""File""' ""FilesetEntry""' ""Blockset"" A' ""Blockset"" B' ""Metadataset""  WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""A"".""ID"" = ""File"".""BlocksetID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""MetadataID"" = ""Metadataset"".""ID"" AND ""Metadataset"".""BlocksetID"" = ""B"".""ID"" "; " is 440.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "			results.AddedFiles = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ? AND NOT ""File"".""Path"" IN (SELECT ""Path"" FROM ""{0}"")"' tmpName1)' 0' m_filesetId' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID); " is 406.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "			results.DeletedFiles = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""{0}"" WHERE ""{0}"".""Path"" NOT IN (SELECT ""Path"" FROM ""File"" INNER JOIN ""FilesetEntry"" ON ""File"".""ID"" = ""FilesetEntry"".""FileID"" WHERE ""FilesetEntry"".""FilesetID"" = ?)"' tmpName1)' 0' m_filesetId); " is 302.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,UpdateChangeStatistics,The length of the statement  "			results.ModifiedFiles = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""{0}"" A' ""{1}"" B WHERE ""A"".""Path"" = ""B"".""Path"" AND (""A"".""Filehash"" != ""B"".""Filehash"" OR ""A"".""Metahash"" != ""B"".""Metahash"")"' tmpName1' tmpName2)' 0); " is 262.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AppendFilesFromPreviousSet,The length of the statement  "			cmd.ExecuteNonQuery (@"INSERT INTO ""FilesetEntry"" (""FilesetID""' ""FileID""' ""Lastmodified"") SELECT ? AS ""FilesetID""' ""FileID""' ""Lastmodified"" FROM (SELECT DISTINCT ""FilesetID""' ""FileID""' ""Lastmodified"" FROM ""FilesetEntry"" WHERE ""FilesetID"" = ? AND ""FileID"" NOT IN (SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" = ?)) "' filesetid' lastFilesetId' filesetid); " is 395.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AppendFilesFromPreviousSet,The length of the statement  "				cmd.CommandText = @"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" = ? AND ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ?) "; " is 142.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetIncompleteFilesets,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT DISTINCT ""Fileset"".""ID""' ""Fileset"".""Timestamp"" FROM ""Fileset""' ""RemoteVolume"" WHERE ""RemoteVolume"".""ID"" = ""Fileset"".""VolumeID"" AND ""Fileset"".""ID"" IN (SELECT ""FilesetID"" FROM ""FilesetEntry"")  AND (""RemoteVolume"".""State"" = ""Uploading"" OR ""RemoteVolume"".""State"" = ""Temporary"")")) " is 360.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetIncompleteFilesets,The length of the statement  "				yield return new KeyValuePair<long' DateTime> (rd.GetInt64 (0)' ParseFromEpochSeconds (rd.GetInt64 (1)).ToLocalTime ()); " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromName,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' name)) " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id)) " is 160.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The length of the statement  "				return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc)); " is 428.
Long Statement,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetMissingIndexFiles,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""Name"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND NOT ""ID"" IN (SELECT ""BlockVolumeID"" FROM ""IndexBlockLink"") AND ""State"" IN (?'?)"' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ())) " is 305.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The length of the statement  "			if ((c = cmd.ExecuteNonQuery (@"UPDATE ""RemoteVolume"" SET ""DeleteGraceTime"" = ? WHERE ""Name"" = ? "' (DateTime.UtcNow + deleteGraceTime).Ticks' name)) != 1) " is 161.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,DuplicateRemoteVolumes,The length of the statement  "		yield return new KeyValuePair<string' RemoteVolumeState> (rd.GetValue (0).ToString ()' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (1).ToString ())); " is 175.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The length of the statement  "			yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc)); " is 434.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UnlinkRemoteVolume,The length of the statement  "			var c = cmd.ExecuteNonQuery (@"DELETE FROM ""RemoteVolume"" WHERE ""Name"" = ? AND ""State"" = ? "' name' state.ToString ()); " is 125.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery)); " is 157.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" IN (SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery)); " is 176.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			var bsIdsSubQuery = string.Format (@"SELECT ""BlocksetEntry"".""BlocksetID"" FROM ""BlocksetEntry""' ""Block"" " + @" WHERE ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Block"".""VolumeID"" IN ({0}) " + @"UNION ALL " + @"SELECT ""BlocksetID"" FROM ""BlocklistHash"" " + @"WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery); " is 379.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' blocksetidstable)); " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"INSERT OR IGNORE INTO ""{0}"" (""ID"") {1}"' blocksetidstable' bsIdsSubQuery)); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""BlocksetID"" IN ({0}) OR ""MetadataID"" IN ({0})"' bsIdsSubQuery)); " is 140.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery)); " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery)); " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""BlocklistHash"" WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery)); " is 172.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The length of the statement  "			deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""DeletedBlock"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery)); " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetFilesetIDs,The length of the statement  "				m_result.AddWarning (string.Format ("Restore time or version did not match any existing backups' selecting newest backup")' null); " is 130.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetFiles,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""A"".""Path""' ""B"".""Length""' ""B"".""FullHash""' ""D"".""FullHash"" FROM ""File"" A' ""Blockset"" B' ""Metadataset"" C' ""Blockset"" D' ""FilesetEntry"" E WHERE ""A"".""BlocksetID"" = ""B"".""ID"" AND ""A"".""MetadataID"" = ""C"".""ID"" AND ""C"".""BlocksetID"" = ""D"".""ID"" AND ""A"".""ID"" = ""E"".""FileID"" AND ""E"".""FilesetID"" = ? "' filesetId)) " is 404.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "		var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" "; " is 235.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "						sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine); " is 162.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "		var unique_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0); " is 138.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "			throw new InvalidDataException (string.Format ("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count)); " is 152.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "		var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0); " is 754.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "			throw new InvalidDataException (string.Format ("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash)); " is 125.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "		if (cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0) " is 234.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "				foreach (var filesetid in cmd.ExecuteReaderEnumerable (@"SELECT ""ID"" FROM ""Fileset"" ").Select (x => x.ConvertValueToInt64 (0' -1))) { " is 137.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "					var expandedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid); " is 301.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "					//var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID); " is 326.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "					var storedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid); " is 155.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The length of the statement  "						throw new Exception (string.Format ("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist)); " is 151.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetBlocks,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT DISTINCT ""Hash""' ""Size"" FROM ""Block"" WHERE ""VolumeID"" = ?"' volumeid)) " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The length of the statement  "					filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] { " is 140.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The length of the statement  "					filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] { " is 138.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The length of the statement  "					filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] { " is 191.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RenameRemoteFile,The length of the statement  "				throw new Exception (string.Format ("Unexpected result from renaming \"{0}\" to \"{1}\"' expected {2} got {3}"' oldname' newname' 1' c)); " is 137.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RenameRemoteFile,The length of the statement  "			var type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' cmd.ExecuteScalar (@"SELECT ""Type"" FROM ""Remotevolume"" WHERE ""Name"" = ?"' newname).ToString ()' true); " is 175.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,CreateFileset,The length of the statement  "			var id = cmd.ExecuteScalarInt64 (@"INSERT INTO ""Fileset"" (""OperationID""' ""Timestamp""' ""VolumeID"") VALUES (?' ?' ?); SELECT last_insert_rowid();"' -1' m_operationid' NormalizeDateTimeToEpochSeconds (timestamp)' volumeid); " is 228.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetBlocklists,The length of the statement  "		var sql = string.Format (@"SELECT ""A"".""Hash""' ""C"".""Hash"" FROM " + @"(SELECT ""BlocklistHash"".""BlocksetID""' ""Block"".""Hash""' * FROM  ""BlocklistHash""'""Block"" WHERE  ""BlocklistHash"".""Hash"" = ""Block"".""Hash"" AND ""Block"".""VolumeID"" = ?) A' " + @" ""BlocksetEntry"" B' ""Block"" C WHERE ""B"".""BlocksetID"" = ""A"".""BlocksetID"" AND " + @" ""B"".""Index"" >= (""A"".""Index"" * {0}) AND ""B"".""Index"" < ((""A"".""Index"" + 1) * {0}) AND ""C"".""ID"" = ""B"".""BlockID"" " + @" ORDER BY ""A"".""BlocksetID""' ""B"".""Index"""' blocksize / hashsize); " is 575.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,DisposeAllFields,The length of the statement  "	var fields = typechain.SelectMany (x => x.GetFields (System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.FlattenHierarchy)).Distinct ().Where (x => x.FieldType.IsAssignableFrom (typeof(T))); " is 294.
Long Statement,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteResults,The length of the statement  "		LogMessage ("Result"' Library.Utility.Utility.PrintSerializeObject (m_result' (StringBuilder)null' (prop' item) => !typeof(IBackendProgressUpdater).IsAssignableFrom (prop.PropertyType) && !typeof(IMessageSink).IsAssignableFrom (prop.PropertyType) && !typeof(ILogWriter).IsAssignableFrom (prop.PropertyType) && prop.Name != "VerboseOutput" && prop.Name != "VerboseErrors" && !(prop.Name == "MainOperation" && item is BackendWriter) && !(prop.Name == "EndTime" && item is BackendWriter) && !(prop.Name == "Duration" && item is BackendWriter) && !(prop.Name == "BeginTime" && item is BackendWriter)' recurseobjects: true' collectionlimit: 5).ToString ()' null' null); " is 664.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (" + @"  ""FileId"" INTEGER PRIMARY KEY " + @"' ""TotalBlocks"" INTEGER NOT NULL' ""TotalSize"" INTEGER NOT NULL " + @"' ""BlocksRestored"" INTEGER NOT NULL' ""SizeRestored"" INTEGER NOT NULL " + @")"' m_fileprogtable)); " is 289.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (" + @"  ""TotalFiles"" INTEGER NOT NULL' ""TotalBlocks"" INTEGER NOT NULL' ""TotalSize"" INTEGER NOT NULL " + @"' ""FilesFullyRestored"" INTEGER NOT NULL' ""FilesPartiallyRestored"" INTEGER NOT NULL " + @"' ""BlocksRestored"" INTEGER NOT NULL' ""SizeRestored"" INTEGER NOT NULL " + @")"' m_totalprogtable)); " is 377.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (" + @"  ""ID"" INTEGER PRIMARY KEY " + @")"' m_filesnewlydonetable)); " is 139.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "			sql = string.Format (@" INSERT INTO ""{0}"" (""FileId""' ""TotalBlocks""' ""TotalSize""' ""BlocksRestored""' ""SizeRestored"") " + @" SELECT   ""F"".""ID""' IFNULL(COUNT(""B"".""ID"")' 0)' IFNULL(SUM(""B"".""Size"")' 0)" + @"        ' IFNULL(COUNT(CASE ""B"".""Restored"" WHEN 1 THEN ""B"".""ID"" ELSE NULL END)' 0) " + @"        ' IFNULL(SUM(CASE ""B"".""Restored"" WHEN 1 THEN ""B"".""Size"" ELSE 0 END)' 0) " + @"   FROM ""{1}"" ""F"" LEFT JOIN ""{2}"" ""B""" // allow for emtpy files (no data Blocks) " is 504.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "			+ @"        ON  ""B"".""FileID"" = ""F"".""ID"" " + @"  WHERE ""B"".""Metadata"" IS NOT 1 " // Use "IS" because of Left Join " is 124.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "			sql = string.Format (@"INSERT INTO ""{0}"" (" + @"  ""TotalFiles""' ""TotalBlocks""' ""TotalSize"" " + @"' ""FilesFullyRestored""' ""FilesPartiallyRestored""' ""BlocksRestored""' ""SizeRestored""" + @" ) " + @" SELECT   IFNULL(COUNT(""P"".""FileId"")' 0)' IFNULL(SUM(""P"".""TotalBlocks"")' 0)' IFNULL(SUM(""P"".""TotalSize"")' 0) " + @"        ' IFNULL(COUNT(CASE WHEN ""P"".""BlocksRestored"" = ""P"".""TotalBlocks"" THEN 1 ELSE NULL END)' 0) " + @"        ' IFNULL(COUNT(CASE WHEN ""P"".""BlocksRestored"" BETWEEN 1 AND ""P"".""TotalBlocks"" - 1 THEN 1 ELSE NULL END)' 0) " + @"        ' IFNULL(SUM(""P"".""BlocksRestored"")' 0)' IFNULL(SUM(""P"".""SizeRestored"")' 0) " + @"   FROM ""{1}"" ""P"" "' m_totalprogtable' m_fileprogtable); " is 738.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "			sql = string.Format (@"CREATE TEMPORARY TRIGGER ""TrackRestoredBlocks_{1}"" AFTER UPDATE OF ""Restored"" ON ""{1}"" " + @"  WHEN OLD.""Restored"" != NEW.""Restored"" AND NEW.""Metadata"" = 0 " + @"  BEGIN UPDATE ""{0}"" " + @"     SET ""BlocksRestored"" = ""{0}"".""BlocksRestored"" + (NEW.""Restored"" - OLD.""Restored"") " + @"       ' ""SizeRestored"" = ""{0}"".""SizeRestored"" + ((NEW.""Restored"" - OLD.""Restored"") * NEW.Size) " + @"   WHERE ""{0}"".""FileId"" = NEW.""FileID"" " + @"  ; END "' m_fileprogtable' m_tempblocktable); " is 538.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "			sql = string.Format (@"CREATE TEMPORARY TRIGGER ""UpdateTotalStats_{1}"" AFTER UPDATE ON ""{1}"" " + @"  BEGIN UPDATE ""{0}"" " + @"     SET ""FilesFullyRestored"" = ""{0}"".""FilesFullyRestored"" " + @"                 + (CASE WHEN NEW.""BlocksRestored"" = NEW.""TotalBlocks"" THEN 1 ELSE 0 END) " + @"                 - (CASE WHEN OLD.""BlocksRestored"" = OLD.""TotalBlocks"" THEN 1 ELSE 0 END) " + @"       ' ""FilesPartiallyRestored"" = ""{0}"".""FilesPartiallyRestored"" " + @"                 + (CASE WHEN NEW.""BlocksRestored"" BETWEEN 1 AND NEW.""TotalBlocks"" - 1 THEN 1 ELSE 0 END) " + @"                 - (CASE WHEN OLD.""BlocksRestored"" BETWEEN 1 AND OLD.""TotalBlocks"" - 1 THEN 1 ELSE 0 END) " + @"       ' ""BlocksRestored"" = ""{0}"".""BlocksRestored"" + NEW.""BlocksRestored"" - OLD.""BlocksRestored"" " // simple delta " is 838.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "			+ @"       ' ""SizeRestored"" = ""{0}"".""SizeRestored"" + NEW.""SizeRestored"" - OLD.""SizeRestored"" " // simple delta " is 120.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,CreateProgressTracker,The length of the statement  "				sql = string.Format (@"CREATE TEMPORARY TRIGGER ""UpdateFilesNewlyDone_{1}"" AFTER UPDATE OF ""BlocksRestored""' ""TotalBlocks"" ON ""{1}"" " + @"  WHEN NEW.""BlocksRestored"" = NEW.""TotalBlocks""  " + @"  BEGIN " + @"     INSERT OR IGNORE INTO ""{0}"" (""ID"") VALUES (NEW.""FileId""); " + @"  END "' m_filesnewlydonetable' m_fileprogtable); " is 343.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "			m_restoreTime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId)); " is 137.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable)); " is 270.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable)); " is 289.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable)); " is 126.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable)); " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "				cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable); " is 337.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "			} else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) { " is 201.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "					cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable); " is 411.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "						using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable))) " is 172.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "						var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId)); " is 145.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "						log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null); " is 182.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "				cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?"); " is 218.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "					cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable); " is 153.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "							if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) { " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) { " is 223.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The length of the statement  "					log.AddVerboseMessage ("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString (filesize)); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFirstPath,The length of the statement  "		cmd.CommandText = string.Format (@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' m_tempfiletable); " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetLargestPrefix,The length of the statement  "		cmd.CommandText = string.Format (@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' m_tempfiletable); " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "	var dirsep = Duplicati.Library.Utility.Utility.GuessDirSeparator (string.IsNullOrWhiteSpace (largest_prefix) ? GetFirstPath () : largest_prefix); " is 145.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""Targetpath"" = CASE WHEN SUBSTR(""Path""' 2' 1) == "":"" THEN ""\\"" || SUBSTR(""Path""' 1' 1) || SUBSTR(""Path""' 3) ELSE ""Path"" END"' m_tempfiletable)); " is 215.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""Targetpath"" = CASE WHEN SUBSTR(""Path""' 1' 2) == ""\\"" THEN ""\\"" || SUBSTR(""Path""' 2) ELSE ""Path"" END"' m_tempfiletable)); " is 190.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""Targetpath"" = CASE WHEN SUBSTR(""Path""' 1' 1) == ""/"" THEN ? || SUBSTR(""Path""' 2) ELSE ""Path"" END"' m_tempfiletable)' Library.Utility.Utility.AppendDirSeparator (System.IO.Path.GetPathRoot (Library.Utility.TempFolder.SystemTempPath)).Replace ("\\"' "/")); " is 321.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""TargetPath"" = CASE WHEN SUBSTR(""Path""' 2' 1) == "":"" THEN SUBSTR(""Path""' 1' 1) || SUBSTR(""Path""' 3) ELSE ""Path"" END"' m_tempfiletable)); " is 205.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""TargetPath"" = CASE WHEN SUBSTR(""Path""' 1' 2) == ""\\"" THEN SUBSTR(""Path""' 2) ELSE ""TargetPath"" END"' m_tempfiletable)); " is 186.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""TargetPath"" = SUBSTR(""Path""' ?)"' m_tempfiletable)' largest_prefix.Length + 1); " is 141.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""TargetPath"" = REPLACE(""TargetPath""' ""\""' ""/"")"' m_tempfiletable)); " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""TargetPath"" = REPLACE(REPLACE(""TargetPath""' ""\""' ""_"")' ""/""' ""\"")"' m_tempfiletable)); " is 155.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,SetTargetPaths,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""TargetPath"" = ? || ""TargetPath"" "' m_tempfiletable)' Library.Utility.Utility.AppendDirSeparator (destination)); " is 173.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FindMissingBlocks,The length of the statement  "		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""FileID""' ""Index""' ""Hash""' ""Size""' ""Restored""' ""Metadata"") SELECT DISTINCT ""{1}"".""ID""' ""BlocksetEntry"".""Index""' ""Block"".""Hash""' ""Block"".""Size""' 0' 0 FROM ""{1}""' ""BlocksetEntry""' ""Block"" WHERE ""{1}"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" "' m_tempblocktable' m_tempfiletable); " is 431.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FindMissingBlocks,The length of the statement  "			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""FileID""' ""Index""' ""Hash""' ""Size""' ""Restored""' ""Metadata"") SELECT DISTINCT ""{1}"".""ID""' ""BlocksetEntry"".""Index""' ""Block"".""Hash""' ""Block"".""Size""' 0' 1 FROM ""{1}""' ""BlocksetEntry""' ""Block""' ""Metadataset"" WHERE ""{1}"".""MetadataID"" = ""Metadataset"".""ID"" AND ""Metadataset"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" "' m_tempblocktable' m_tempfiletable); " is 508.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,FindMissingBlocks,The length of the statement  "			log.AddVerboseMessage ("Restore list contains {0} blocks with a total size of {1}"' p1 + p2' Library.Utility.Utility.FormatSizeString (size)); " is 142.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,UpdateTargetPath,The length of the statement  "		cmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""TargetPath"" = ? WHERE ""ID"" = ?"' m_tempfiletable)' newname' ID); " is 126.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocks,The length of the statement  "	return LocalBlockSource.GetFilesAndSourceBlocks (m_connection' m_tempfiletable' m_tempblocktable' blocksize' skipMetadata); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The length of the statement  "		// If the end of very large files (e.g. iso's) is restored before the beginning' most OS write out zeros to fill the file. " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The length of the statement  "		// We just order all volumes by the maximum block index they contain. This query is slow' but should be worth the effort. " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The length of the statement  "		cmd.CommandText = string.Format (@"SELECT ""RV"".""Name""' ""RV"".""Hash""' ""RV"".""Size""' ""BB"".""MaxIndex"" " + @"  FROM ""RemoteVolume"" ""RV"" INNER JOIN " + @"        (SELECT ""B"".""VolumeID""' MAX(""TB"".""Index"") as ""MaxIndex"" " + @"           FROM ""Block"" ""B""' ""{0}"" ""TB"" " + @"          WHERE ""TB"".""Restored"" = 0 " + @"            AND ""B"".""Hash"" = ""TB"".""Hash"" " + @"            AND ""B"".""Size"" = ""TB"".""Size"" " + @"          GROUP BY  ""B"".""VolumeID"" " + @"        ) as ""BB"" ON ""RV"".""ID"" = ""BB"".""VolumeID"" " + @"  ORDER BY ""BB"".""MaxIndex"" "' m_tempblocktable); " is 619.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The length of the statement  "				yield return new RemoteVolume (rd.ConvertValueToString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1)); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The length of the statement  "		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable))) " is 281.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The length of the statement  "				yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3)); " is 146.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetTargetFolders,The length of the statement  "		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""TargetPath"" FROM ""{0}"" WHERE ""BlocksetID"" == ?"' m_tempfiletable)' FOLDER_BLOCKSET_ID)) " is 153.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "	var whereclause = string.Format (@" ""{0}"".""ID"" = ""{1}"".""FileID"" AND ""{1}"".""Restored"" = 0 AND ""{1}"".""Metadata"" = 0 AND ""{0}"".""TargetPath"" != ""{0}"".""Path"" "' m_tempfiletable' m_tempblocktable); " is 215.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "	var sourepaths = string.Format (@"SELECT DISTINCT ""{0}"".""Path"" FROM ""{0}""' ""{1}"" WHERE " + whereclause' m_tempfiletable' m_tempblocktable); " is 147.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "	var latestBlocksetIds = @"SELECT ""File"".""Path""' ""File"".""BlocksetID""' MAX(""Fileset"".""Timestamp"") FROM ""Fileset""' ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""FilesetEntry"".""FilesetID"" = ""Fileset"".""ID"" AND ""File"".""Path"" IN (" + sourepaths + @") GROUP BY ""File"".""Path"" "; " is 337.
Long Statement,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesAndSourceBlocksFast,The length of the statement  "	var sources = string.Format (@"SELECT DISTINCT ""{0}"".""TargetPath""' ""{0}"".""Path""' ""{0}"".""ID""' ""{1}"".""Index""' ""{1}"".""Hash""' ""{1}"".""Size"" FROM ""{0}""' ""{1}""' ""File""' (" + latestBlocksetIds + @") S' ""Block""' ""BlocksetEntry"" WHERE ""BlocksetEntry"".""BlocksetID"" = ""S"".""BlocksetID"" AND ""BlocksetEntry"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""{1}"".""Index"" = ""BlocksetEntry"".""Index"" AND ""{1}"".""Hash"" = ""Block"".""Hash"" AND ""{1}"".""Size"" = ""Block"".""Size"" AND ""S"".""Path"" = ""{0}"".""Path"" AND " + whereclause + @" ORDER BY ""{0}"".""ID""' ""{1}"".""Index"" "' m_tempfiletable' m_tempblocktable); " is 711.
Long Statement,Duplicati.Library.Main.Database,ExtensionMethods,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\ExtensionMethods.cs,GetSQLiteExecutionPlan,The length of the statement  "		string plan = String.Join ("\t"' dt.Columns.Cast<System.Data.DataColumn> ().Select (c => c.ColumnName).ToArray ()) + "\n" + string.Join ("\n"' dt.Rows.Cast<System.Data.DataRow> ().Select (r => String.Join ("\t"' r.ItemArray.Select (o => o == null ? "" : o.ToString ()).ToArray ())).ToArray ()); " is 294.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,InitializeCommands,The length of the statement  "	m_moveBlockToNewVolumeCommand.CommandText = @"UPDATE ""Block"" SET ""VolumeID"" = ? WHERE ""Hash"" = ? AND ""Size"" = ?"; " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		var deleted = cmd.ExecuteNonQuery (@"DELETE FROM ""Fileset"" WHERE ""Timestamp"" IN (" + q + @") "' toDelete.Select (x => NormalizeDateTimeToEpochSeconds (x)).Cast<object> ().ToArray ()); " is 187.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		cmd.ExecuteNonQuery (@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" NOT IN (SELECT DISTINCT ""ID"" FROM ""Fileset"")"); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		cmd.ExecuteNonQuery (@"DELETE FROM ""Metadataset"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""MetadataID"" FROM ""File"") "); " is 121.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		cmd.ExecuteNonQuery (@"DELETE FROM ""Blockset"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""BlocksetID"" FROM ""File"" UNION SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") "); " is 176.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		cmd.ExecuteNonQuery (@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" NOT IN (SELECT DISTINCT ""ID"" FROM ""Blockset"") "); " is 127.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		cmd.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" NOT IN (SELECT DISTINCT ""ID"" FROM ""Blockset"") "); " is 127.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		cmd.ExecuteNonQuery (@"INSERT INTO ""DeletedBlock"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""Block"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""BlockID"" AS ""BlockID"" FROM ""BlocksetEntry"" UNION SELECT DISTINCT ""ID"" FROM ""Block""' ""BlocklistHash"" WHERE ""Block"".""Hash"" = ""BlocklistHash"".""Hash"") "); " is 350.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		cmd.ExecuteNonQuery (@"DELETE FROM ""Block"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""BlockID"" FROM ""BlocksetEntry"" UNION SELECT DISTINCT ""ID"" FROM ""Block""' ""BlocklistHash"" WHERE ""Block"".""Hash"" = ""BlocklistHash"".""Hash"") "); " is 238.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		var updated = cmd.ExecuteNonQuery (@"UPDATE ""RemoteVolume"" SET ""State"" = ? WHERE ""Type"" = ? AND ""State"" IN (?' ?) AND ""ID"" NOT IN (SELECT ""VolumeID"" FROM ""Fileset"") "' RemoteVolumeState.Deleting.ToString ()' RemoteVolumeType.Files.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ()); " is 338.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "			throw new Exception (string.Format ("Unexpected number of remote volumes marked as deleted. Found {0} filesets' but {1} volumes"' deleted' updated)); " is 149.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,DropFilesetsFromTable,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Size"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND ""State"" = ? "' RemoteVolumeType.Files.ToString ()' RemoteVolumeState.Deleting.ToString ())) " is 201.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var usedBlocks = @"SELECT SUM(""Block"".""Size"") AS ""ActiveSize""' ""Block"".""VolumeID"" AS ""VolumeID"" FROM ""Block""' ""Remotevolume"" WHERE ""Block"".""VolumeID"" = ""Remotevolume"".""ID"" AND ""Block"".""ID"" NOT IN (SELECT ""Block"".""ID"" FROM ""Block""'""DeletedBlock"" WHERE ""Block"".""Hash"" = ""DeletedBlock"".""Hash"" AND ""Block"".""Size"" = ""DeletedBlock"".""Size"") GROUP BY ""Block"".""VolumeID"" "; " is 420.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var lastmodifiedFile = @"SELECT ""Block"".""VolumeID"" AS ""VolumeID""' ""Fileset"".""Timestamp"" AS ""Sorttime"" FROM ""Fileset""' ""FilesetEntry""' ""File""' ""BlocksetEntry""' ""Block"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""File"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" "; " is 415.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var lastmodifiedMetadata = @"SELECT ""Block"".""VolumeID"" AS ""VolumeID""' ""Fileset"".""Timestamp"" AS ""Sorttime"" FROM ""Fileset""' ""FilesetEntry""' ""File""' ""BlocksetEntry""' ""Block""' ""Metadataset"" WHERE ""FilesetEntry"".""FileID"" = ""File"".""ID"" AND ""File"".""MetadataID"" = ""Metadataset"".""ID"" AND ""Metadataset"".""BlocksetID"" = ""BlocksetEntry"".""BlocksetID"" AND ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" "; " is 496.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var scantime = @"SELECT ""VolumeID"" AS ""VolumeID""' MIN(""Sorttime"") AS ""Sorttime"" FROM (" + lastmodifiedFile + @" UNION " + lastmodifiedMetadata + @") GROUP BY ""VolumeID"" "; " is 181.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var active = @"SELECT ""A"".""ActiveSize"" AS ""ActiveSize""'  0 AS ""InactiveSize""' ""A"".""VolumeID"" AS ""VolumeID""' CASE WHEN ""B"".""Sorttime"" IS NULL THEN 0 ELSE ""B"".""Sorttime"" END AS ""Sorttime"" FROM (" + usedBlocks + @") A LEFT OUTER JOIN (" + scantime + @") B ON ""B"".""VolumeID"" = ""A"".""VolumeID"" "; " is 322.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var inactive = @"SELECT 0 AS ""ActiveSize""' SUM(""Size"") AS ""InactiveSize""' ""VolumeID"" AS ""VolumeID""' 0 AS ""SortScantime"" FROM ""DeletedBlock"" GROUP BY ""VolumeID"" "; " is 178.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var empty = @"SELECT 0 AS ""ActiveSize""' 0 AS ""InactiveSize""' ""Remotevolume"".""ID"" AS ""VolumeID""' 0 AS ""SortScantime"" FROM ""Remotevolume"" WHERE ""Remotevolume"".""Type"" = ? AND ""Remotevolume"".""State"" IN (?' ?) AND ""Remotevolume"".""ID"" NOT IN (SELECT ""VolumeID"" FROM ""Block"") "; " is 301.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "	var collected = @"SELECT ""VolumeID"" AS ""VolumeID""' SUM(""ActiveSize"") AS ""ActiveSize""' SUM(""InactiveSize"") AS ""InactiveSize""' MAX(""Sortime"") AS ""Sorttime"" FROM (" + combined + @") GROUP BY ""VolumeID"" "; " is 219.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "			cmd.ExecuteNonQuery (createtable' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ()); " is 151.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename))) " is 261.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The length of the statement  "					yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0)); " is 184.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetCompactReport,The length of the statement  "	return new CompactReport (volsize' wastethreshold' smallfilesize' maxsmallfilecount' GetWastedSpaceReport (transaction).ToList ()); " is 131.
Long Statement,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL ")) " is 326.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "				upcmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""RealPath"" TEXT NOT NULL' ""Obfuscated"" TEXT NULL)"' tablename)); " is 168.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "				upcmd.ExecuteNonQuery (string.Format (@"INSERT INTO ""{0}"" (""RealPath"") SELECT DISTINCT ""Path"" FROM ""File"" ORDER BY ""Path"" "' tablename)); " is 147.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "				upcmd.ExecuteNonQuery (string.Format (@"UPDATE ""{0}"" SET ""Obfuscated"" = ? || length(""RealPath"") || ? || ""ID"" || (CASE WHEN substr(""RealPath""' length(""RealPath"")) = ? THEN ? ELSE ? END) "' tablename)' Library.Utility.Utility.IsClientLinux ? "/" : "X:\\"' Library.Utility.Utility.DirectorySeparatorString' Library.Utility.Utility.DirectorySeparatorString' Library.Utility.Utility.DirectorySeparatorString' ".bin"); " is 424.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "                            upcmd.ExecuteNonQuery(@"UPDATE ""LogData"" SET ""Message"" = replace(""Message""' ?' ?)' ""Exception"" = replace(""Exception""' ?' ?)"' rd.GetValue(0)' rd.GetValue(1)' rd.GetValue(0)' rd.GetValue(1) );" is 201.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "			cmd.ExecuteNonQuery (@"UPDATE ""LogData"" SET ""Message"" = ""ERASED!"" WHERE ""Message"" LIKE ""%/%"" OR ""Message"" LIKE ""%:\%"" "); " is 135.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "			cmd.ExecuteNonQuery (@"UPDATE ""LogData"" SET ""Exception"" = ""ERASED!"" WHERE ""Exception"" LIKE ""%/%"" OR ""Exception"" LIKE ""%:\%"" "); " is 141.
Long Statement,Duplicati.Library.Main.Database,LocalBugReportDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBugReportDatabase.cs,Fix,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""Path"" = (SELECT ""Obfuscated"" FROM ""{0}"" WHERE ""Path"" = ""RealPath"") "' tablename)); " is 151.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetFilesetIdFromRemotename,The length of the statement  "		var filesetid = cmd.ExecuteScalarInt64 (@"SELECT ""Fileset"".""ID"" FROM ""Fileset""'""RemoteVolume"" WHERE ""Fileset"".""VolumeID"" = ""RemoteVolume"".""ID"" AND ""RemoteVolume"".""Name"" = ?"' -1' filelist); " is 209.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetBlockVolumesFromIndexName,The length of the statement  "		foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""ID"" IN (SELECT ""BlockVolumeID"" FROM ""IndexBlockLink"" WHERE ""IndexVolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?))"' name)) " is 267.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "			var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")"; " is 232.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "				var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID"""; " is 261.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "					c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename); " is 171.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "                            SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")  " is 159.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "					c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename); " is 204.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "					c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename); " is 151.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "						c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0)); " is 162.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename)); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "				cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename)); " is 166.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The length of the statement  "					throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!"); " is 124.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "			var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1"; " is 207.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "                            SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")  " is 160.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "					c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"; " is 178.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "					c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"; " is 125.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "						c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0)); " is 162.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The length of the statement  "					throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!"); " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "	var sql = string.Format (@"SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"""' blocksize / hashsize); " is 682.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "									c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))"; " is 206.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "									c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;"; " is 212.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "										foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) { " is 225.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "													var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ()); " is 182.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "												var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ()); " is 187.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The length of the statement  "					throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash)); " is 173.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "			var dup_sql = @"SELECT * FROM (SELECT ""BlocksetID""' ""Index""' COUNT(*) AS ""EC"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID""' ""Index"") WHERE ""EC"" > 1"; " is 161.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "				var unique_count = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0); " is 138.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "					c2.CommandText = @"DELETE FROM ""BlocklistHash"" WHERE rowid IN (SELECT rowid FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ? AND ""Index"" = ? LIMIT ?)"; " is 154.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "							throw new Exception (string.Format ("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected)); " is 122.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "					throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' result should have been {0} blocklist hashes' but result was {1} blocklist hashes"' unique_count' real_count)); " is 209.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The length of the statement  "					throw new Duplicati.Library.Interface.UserInformationException ("Repaired blocklisthashes' but the database was broken afterwards' rolled back changes"' ex); " is 157.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The length of the statement  "			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL)"' tablename)); " is 135.
Long Statement,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The length of the statement  "			var aliens = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT ""A"".""VolumeID"" FROM ""{0}"" B LEFT OUTER JOIN ""Block"" A ON ""A"".""Hash"" = ""B"".""Hash"" AND ""A"".""Size"" = ""B"".""Size"") WHERE ""VolumeID"" != ? "' tablename)' 0' id); " is 263.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,UpdateVerificationCount,The length of the statement  "		cmd.ExecuteNonQuery (@"UPDATE ""RemoteVolume"" SET ""VerificationCount"" = MAX(1' CASE WHEN ""VerificationCount"" <= 0 THEN (SELECT MAX(""VerificationCount"") FROM ""RemoteVolume"") ELSE ""VerificationCount"" + 1 END) WHERE ""Name"" = ?"' name); " is 245.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""ID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE (""State"" = ? OR ""State"" = ?) AND (""Hash"" = """" OR ""Hash"" IS NULL OR ""Size"" <= 0) "' RemoteVolumeState.Verified.ToString ()' RemoteVolumeState.Uploaded.ToString ())) " is 307.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""A"".""VolumeID""' ""A"".""Name""' ""A"".""Size""' ""A"".""Hash""' ""A"".""VerificationCount"" FROM (SELECT ""ID"" AS ""VolumeID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE ""State"" IN (?' ?)) A' ""Fileset"" " + whereClause + @" ""A"".""VolumeID"" = ""Fileset"".""VolumeID"" ORDER BY ""Fileset"".""Timestamp"" "' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ()' tp.Item2)) " is 488.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""ID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE ""Type"" = ? AND ""State"" IN (?' ?)"' RemoteVolumeType.Index.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ())) " is 287.
Long Statement,Duplicati.Library.Main.Database,LocalTestDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalTestDatabase.cs,SelectTestTargets,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT ""ID""' ""Name""' ""Size""' ""Hash""' ""VerificationCount"" FROM ""Remotevolume"" WHERE ""Type"" = ? AND ""State"" IN (?' ?)"' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ())) " is 288.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		var selectBlockHashes = string.Format (@"SELECT ""BlockHash"" AS ""FullHash""' ""BlockSize"" AS ""Length"" FROM ( " + SELECT_BLOCKLIST_ENTRIES + @" )"' blocksize' hashsize' m_tempblocklist' blocksize / hashsize); " is 212.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		var selectAllBlocks = @"SELECT DISTINCT ""FullHash""' ""Length"" FROM (" + selectBlockHashes + " UNION " + selectSmallBlocks + " )"; " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		var selectNewBlocks = string.Format (@"SELECT ""FullHash"" AS ""Hash""' ""Length"" AS ""Size""' -1 AS ""VolumeID"" " + @" FROM (SELECT ""A"".""FullHash""' ""A"".""Length""' CASE WHEN ""B"".""Hash"" IS NULL THEN '' ELSE ""B"".""Hash"" END AS ""Hash""' CASE WHEN ""B"".""Size"" is NULL THEN -1 ELSE ""B"".""Size"" END AS ""Size"" FROM ({0}) A" + @" LEFT OUTER JOIN ""Block"" B ON ""B"".""Hash"" =  ""A"".""FullHash"" AND ""B"".""Size"" = ""A"".""Length"" )" + @" WHERE ""FullHash"" != ""Hash"" AND ""Length"" != ""Size"" "' selectAllBlocks); " is 539.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		var selectBlocklistBlocksetEntries = string.Format (@"SELECT ""E"".""BlocksetID"" AS ""BlocksetID""' ""D"".""FullIndex"" AS ""Index""' ""F"".""ID"" AS ""BlockID"" FROM ( " + SELECT_BLOCKLIST_ENTRIES + @") D' ""BlocklistHash"" E' ""Block"" F' ""Block"" G WHERE ""D"".""BlocksetID"" = ""E"".""BlocksetID"" AND ""D"".""BlocklistHash"" = ""E"".""Hash"" AND ""D"".""BlocklistSize"" = ""G"".""Size"" AND ""D"".""BlocklistHash"" = ""G"".""Hash"" AND ""D"".""Blockhash"" = ""F"".""Hash"" AND ""D"".""BlockSize"" = ""F"".""Size"" "' // TODO: The BlocklistHash join seems to be unnecessary' but the join might be required to work around a from really old versions of Duplicati " is 666.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		//@") D' ""Block"" WHERE  ""BlockQuery"".""BlockHash"" = ""Block"".""Hash"" AND ""BlockQuery"".""BlockSize"" = ""Block"".""Size"" "; " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		var selectBlocksetEntries = string.Format (@"SELECT ""Blockset"".""ID"" AS ""BlocksetID""' 0 AS ""Index""' ""Block"".""ID"" AS ""BlockID"" FROM ""Blockset""' ""Block""' ""{1}"" S WHERE ""Blockset"".""Fullhash"" = ""S"".""FileHash"" AND ""S"".""BlockHash"" = ""Block"".""Hash"" AND ""S"".""BlockSize"" = ""Block"".""Size"" AND ""Blockset"".""Length"" = ""S"".""BlockSize"" AND ""Blockset"".""Length"" <= {0} "' blocksize' m_tempsmalllist); " is 438.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		var selectFiltered = @"SELECT DISTINCT ""H"".""BlocksetID""' ""H"".""Index""' ""H"".""BlockID"" FROM (" + selectAllBlocksetEntries + @") H WHERE (""H"".""BlocksetID"" || ':' || ""H"".""Index"") NOT IN (SELECT (""ExistingBlocksetEntries"".""BlocksetID"" || ':' || ""ExistingBlocksetEntries"".""Index"") FROM ""BlocksetEntry"" ""ExistingBlocksetEntries"" )"; " is 356.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "		var insertBlocksetEntriesCommand = @"INSERT INTO ""BlocksetEntry"" (""BlocksetID""' ""Index""' ""BlockID"") " + selectFiltered; " is 127.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,FindMissingBlocklistHashes,The length of the statement  "			throw new Exception ("The recreate failed' please create a bug-report from this database and send it to the developers for further analysis"); " is 142.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The length of the statement  "		m_result.AddWarning (string.Format ("Mismatching number of blocklist hashes detected on blockset {2}. Expected {0} blocklist hashes' but found {1}"' expectedblocklisthashes' c' blocksetid)' null); " is 196.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The length of the statement  "			throw new Exception (string.Format ("Failed to update table' found {0} entries for key {1} with size {2}"' c' hash' size)); " is 123.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetBlockLists,The length of the statement  "		cmd.CommandText = string.Format (@"SELECT DISTINCT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash""' ""Block"" WHERE ""Block"".""Hash"" = ""BlocklistHash"".""Hash"" AND ""Block"".""VolumeID"" = ?"); " is 199.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The length of the statement  "		var selectCommand = @"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size""' ""RemoteVolume"".""ID"" FROM ""RemoteVolume"""; " is 166.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The length of the statement  "		var missingBlocklistEntries = string.Format (@"SELECT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash"" LEFT OUTER JOIN ""BlocksetEntry"" ON ""BlocksetEntry"".""Index"" = (""BlocklistHash"".""Index"" * {0}) AND ""BlocksetEntry"".""BlocksetID"" = ""BlocklistHash"".""BlocksetID"" WHERE ""BlocksetEntry"".""BlocksetID"" IS NULL"' blocksize / hashsize); " is 350.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The length of the statement  "		var missingBlocklistVolumes = string.Format (@"SELECT ""VolumeID"" FROM ""Block""' (" + missingBlocklistEntries + @") A WHERE ""A"".""Hash"" = ""Block"".""Hash"" "); " is 165.
Long Statement,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The length of the statement  "		var countMissingInformation = string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""VolumeID"" FROM ({0} UNION {1}))"' missingBlockInfo' missingBlocklistEntries); " is 165.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetFilesets,The length of the statement  "	var sql = string.Format (@"SELECT DISTINCT ""FilesetID"" FROM (" + @"SELECT ""FilesetID"" FROM ""FilesetEntry"" WHERE ""FileID"" IN ( SELECT ""ID"" FROM ""File"" WHERE ""BlocksetID"" IN ( SELECT ""BlocksetID"" FROM ""BlocksetEntry"" WHERE ""BlockID"" IN ( SELECT ""ID"" From ""Block"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0})))))" + " UNION " + @"SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))" + ")"' string.Join ("'"' items.Select (x => "?"))); " is 558.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetFiles,The length of the statement  "	var sql = string.Format (@"SELECT DISTINCT ""Path"" FROM (" + @"SELECT ""Path"" FROM ""File"" WHERE ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"" WHERE ""BlockID"" IN (SELECT ""ID"" FROM ""Block"" WHERE ""VolumeID"" IN (SELECT ""ID"" from ""RemoteVolume"" WHERE ""Name"" IN ({0}))))" + @" UNION " + @"SELECT ""Path"" FROM ""File"" WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"" WHERE ""BlockID"" IN (SELECT ""ID"" FROM ""Block"" WHERE ""VolumeID"" IN (SELECT ""ID"" from ""RemoteVolume"" WHERE ""Name"" IN ({0})))))" + @" UNION " + @"SELECT ""Path"" FROM ""File"" WHERE ""ID"" IN ( SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" IN ( SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))))" + @") ORDER BY ""Path"" "' string.Join ("'"' items.Select (x => "?"))); " is 938.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetLogLines,The length of the statement  "	var sql = string.Format (@"SELECT ""TimeStamp""' ""Message"" || "" "" || CASE WHEN ""Exception"" IS NULL THEN """" ELSE ""Exception"" END FROM ""LogData"" WHERE {0}" + @" UNION " + @"SELECT ""Timestamp""' ""Data"" FROM ""RemoteOperation"" WHERE ""Path"" IN ({1})"' string.Join (" OR "' items.Select (x => @"""Message"" LIKE ?"))' string.Join ("'"' items.Select (x => "?"))); " is 374.
Long Statement,Duplicati.Library.Main.Database,LocalListAffectedDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListAffectedDatabase.cs,GetVolumes,The length of the statement  "	var sql = string.Format (@"SELECT DISTINCT ""Name"" FROM ( " + @" SELECT ""Name"" FROM ""Remotevolume"" WHERE ""ID"" IN ( SELECT ""VolumeID"" FROM ""Block"" WHERE ""ID"" IN ( SELECT ""BlockID"" FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ( SELECT ""BlocksetID"" FROM ""File"" WHERE ""ID"" IN ( SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" IN ( SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))))))) " + @" UNION " + @" SELECT ""Name"" FROM ""Remotevolume"" WHERE ""ID"" IN ( SELECT ""VolumeID"" FROM ""Block"" WHERE ""ID"" IN ( SELECT ""BlockID"" FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ( SELECT ""BlocksetID"" FROM ""Metadataset"" WHERE ""ID"" IN ( SELECT ""MetadataID"" FROM ""File"" WHERE ""ID"" IN ( SELECT ""FileID"" FROM ""FilesetEntry"" WHERE ""FilesetID"" IN ( SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ( SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" IN ({0}))))))))" + @")"' string.Join ("'"' items.Select (x => "?"))); " is 1035.
Long Statement,Duplicati.Library.Main.Database,LocalPurgeDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,GetRemoteVolumeNameForFileset,The length of the statement  "		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""B"".""Name"" FROM ""Fileset"" A' ""RemoteVolume"" B WHERE ""A"".""VolumeID"" = ""B"".""ID"" AND ""A"".""ID"" = ? ")' id)) " is 182.
Long Statement,Duplicati.Library.Main.Database,LocalPurgeDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalPurgeDatabase.cs,CountOrphanFiles,The length of the statement  "		using (var rd = cmd.ExecuteReader (@"SELECT COUNT(*) FROM ""File"" WHERE ""ID"" NOT IN (SELECT DISTINCT ""FileID"" FROM ""FilesetEntry"")")) " is 140.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilesets,The length of the statement  "				yield return new Tuple<DateTime' long' long> (ParseFromEpochSeconds (rd.ConvertValueToInt64 (0' 0))' rd.ConvertValueToInt64 (1' -1)' rd.ConvertValueToInt64 (2' 0)); " is 164.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilenames,The length of the statement  "		foreach (var rd in cmd.ExecuteReaderEnumerable (string.Format (BROKEN_FILE_NAMES' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID)' filesetid)) " is 135.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,InsertBrokenFileIDsIntoTable,The length of the statement  "		cmd.ExecuteNonQuery (string.Format (INSERT_BROKEN_IDS' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' tablename' IDfieldname)' filesetid); " is 132.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The length of the statement  "		throw new Exception ("This function cannot be called when not in a transaction' as it leaves the database in an inconsistent state"); " is 133.
Long Statement,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The length of the statement  "		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery)); " is 157.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,GetSnapshot,The length of the statement  "	return Library.Utility.Utility.IsClientLinux ? (Library.Snapshots.ISnapshotService)new Duplicati.Library.Snapshots.NoSnapshotLinux (sources' options.RawOptions) : (Library.Snapshots.ISnapshotService)new Duplicati.Library.Snapshots.NoSnapshotWindows (sources' options.RawOptions); " is 279.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CountFilesThread,The length of the statement  "	foreach (var path in new FilterHandler (snapshot' m_attributeFilter' m_sourceFilter' m_filter' m_symlinkPolicy' m_options.HardlinkPolicy' null).EnumerateFilesAndFolders ()) { " is 174.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The length of the statement  "				var id = m_database.GetRemoteVolumeID (VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' fileTime)); " is 120.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The length of the statement  "			fsw.VolumeID = m_database.RegisterRemoteVolume (fsw.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction); " is 136.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The length of the statement  "				m_result.AddDryrunMessage (string.Format ("Would upload fileset: {0}' size: {1}"' fsw.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (fsw.LocalFilename).Length))); " is 187.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RecreateMissingIndexFiles,The length of the statement  "			w.VolumeID = m_database.RegisterRemoteVolume (w.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' null); " is 123.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RecreateMissingIndexFiles,The length of the statement  "				m_result.AddDryrunMessage (string.Format ("would upload new index file {0}' with size {1}' previous size {2}"' w.RemoteFilename' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (w.Filesize))); " is 277.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RunMainOperation,The length of the statement  "	var filterhandler = new FilterHandler (snapshot' m_attributeFilter' m_sourceFilter' m_filter' m_symlinkPolicy' m_options.HardlinkPolicy' m_result); " is 147.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FinalizeRemoteVolumes,The length of the statement  "				m_result.AddDryrunMessage (string.Format ("Would upload block volume: {0}' size: {1}"' m_blockvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (m_blockvolume.LocalFilename).Length))); " is 212.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FinalizeRemoteVolumes,The length of the statement  "					m_indexvolume.FinishVolume (Library.Utility.Utility.CalculateHash (m_blockvolume.LocalFilename)' new FileInfo (m_blockvolume.LocalFilename).Length); " is 148.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,FinalizeRemoteVolumes,The length of the statement  "					m_result.AddDryrunMessage (string.Format ("Would upload index volume: {0}' size: {1}"' m_indexvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (m_indexvolume.LocalFilename).Length))); " is 212.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadRealFileList,The length of the statement  "	var changeCount = m_result.AddedFiles + m_result.ModifiedFiles + m_result.DeletedFiles + m_result.AddedFolders + m_result.ModifiedFolders + m_result.DeletedFolders + m_result.AddedSymlinks + m_result.ModifiedSymlinks + m_result.DeletedSymlinks; " is 244.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadRealFileList,The length of the statement  "				m_result.AddDryrunMessage (string.Format ("Would upload fileset volume: {0}' size: {1}"' filesetvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (filesetvolume.LocalFilename).Length))); " is 214.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CompactIfRequired,The length of the statement  "			new DeleteHandler (backend.BackendUrl' m_options' (DeleteResults)m_result.DeleteResults).DoRun (db' ref m_transaction' true' currentIsSmall); " is 141.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CompactIfRequired,The length of the statement  "			new CompactHandler (backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact (db' true' ref m_transaction); " is 132.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,PostBackupVerification,The length of the statement  "				new TestHandler (m_backendurl' m_options' (TestResults)m_result.TestResults).DoRun (m_options.BackupTestSampleCount' testdb' backend); " is 134.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "		if (probe_path != null && Duplicati.Library.Utility.Utility.GuessDirSeparator (probe_path) != System.IO.Path.DirectorySeparatorChar.ToString ()) " is 144.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "			throw new UserInformationException (string.Format ("The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems' which is not supported. To proceed without losing remote data' delete all filesets and make sure the --{0} option is set' then run the backup again to re-use the existing data on the remote store."' "no-auto-compact")); " is 443.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "			throw new UserInformationException ("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss."); " is 209.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "			throw new UserInformationException ("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the backup process cannot continue. You may delete the local database and attempt to repair it again."); " is 247.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "							if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) { " is 128.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "									m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name)); " is 122.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "								m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null); " is 176.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "							throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ())); " is 234.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "						var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction); " is 153.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "						m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction); " is 120.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The length of the statement  "						FilelistProcessor.UploadVerificationFile (backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction); " is 124.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,GenerateMetadata,The length of the statement  "			metadata = snapshot.GetMetadata (path' attributes.HasFlag (System.IO.FileAttributes.ReparsePoint)' m_symlinkPolicy == Options.SymlinkStrategy.Follow); " is 150.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "		IMetahash metahashandsize = m_options.StoreMetadata ? Utility.WrapMetadata (GenerateMetadata (snapshot' path' attributes)' m_options) : EMPTY_METADATA; " is 151.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "			oldId = m_database.GetFileEntry (path' m_lastfilesetid' out oldModified' out lastFileSize' out oldMetahash' out oldMetasize); " is 125.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "		var tooLargeFile = m_options.SkipFilesLargerThan != long.MaxValue && m_options.SkipFilesLargerThan != 0 && filestatsize >= 0 && filestatsize > m_options.SkipFilesLargerThan; " is 173.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "		var metadatachanged = !m_options.SkipMetadata && (metahashandsize.Blob.Length != oldMetasize || metahashandsize.FileHash != oldMetahash); " is 137.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "		if ((oldId < 0 || m_options.DisableFiletimeCheck || timestampChanged || filesizeChanged || metadatachanged) && !tooLargeFile) { " is 127.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "			m_result.AddVerboseMessage ("Checking file for changes {0}' new: {1}' timestamp changed: {2}' size changed: {3}' metadatachanged: {4}' {5} vs {6}"' path' oldId <= 0' timestampChanged' filesizeChanged' metadatachanged' lastwrite' oldModified); " is 242.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "								m_result.AddDryrunMessage (string.Format ("Would add new file {0}' size {1}"' path' Library.Utility.Utility.FormatSizeString (filesize))); " is 138.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "								m_result.AddDryrunMessage (string.Format ("Would add changed file {0}' size {1}"' path' Library.Utility.Utility.FormatSizeString (filesize))); " is 142.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The length of the statement  "				m_result.AddVerboseMessage ("Excluding file because the size {0} exceeds limit ({1}): {2}"' Library.Utility.Utility.FormatSizeString (filestatsize)' Library.Utility.Utility.FormatSizeString (m_options.SkipFilesLargerThan)' path); " is 229.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "		m_blockvolume.VolumeID = m_database.RegisterRemoteVolume (m_blockvolume.RemoteFilename' RemoteVolumeType.Blocks' RemoteVolumeState.Temporary' m_transaction); " is 157.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "			m_indexvolume.VolumeID = m_database.RegisterRemoteVolume (m_indexvolume.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' m_transaction); " is 156.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "				m_result.AddDryrunMessage (string.Format ("Would upload block volume: {0}' size: {1}"' m_blockvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (m_blockvolume.LocalFilename).Length))); " is 212.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "					m_indexvolume.FinishVolume (Library.Utility.Utility.CalculateHash (m_blockvolume.LocalFilename)' new FileInfo (m_blockvolume.LocalFilename).Length); " is 148.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddBlockToOutput,The length of the statement  "					m_result.AddDryrunMessage (string.Format ("Would upload index volume: {0}' size: {1}"' m_indexvolume.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (m_indexvolume.LocalFilename).Length))); " is 212.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddMetadataToOutput,The length of the statement  "		m_result.AddWarning (string.Format ("Metadata size is {0}' but the largest accepted size is {1}' recording empty metadata"' meta.Blob.Length' m_maxmetadatasize)' null); " is 168.
Long Statement,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,AddMetadataToOutput,The length of the statement  "			m_database.AddMetadataset (meta.FileHash' meta.Blob.Length' m_blocksize' hashcollector' blocklisthashes' out metadataid' m_transaction); " is 136.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "	var simpleList = !((filter is Library.Utility.FilterExpression && ((Library.Utility.FilterExpression)filter).Type == Library.Utility.FilterType.Simple) || m_options.AllVersions); " is 178.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "					m_result.SetResult (filesets.QuickSets.Select (x => new ListResultFileset (x.Version' x.Time' x.FileCount' x.FileSizes)).ToArray ()' null); " is 139.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "					m_result.SetResult (filesets.Sets.Select (x => new ListResultFileset (x.Version' x.Time' x.FileCount' x.FileSizes)).ToArray ()' files == null ? null : (from n in files " is 167.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "		throw new UserInformationException ("Listing folder contents is not supported without a local database' consider using the \"repair\" option to rebuild the database."); " is 168.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "		throw new UserInformationException ("Listing prefixes is not supported without a local database' consider using the \"repair\" option to rebuild the database."); " is 161.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "					using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (firstEntry.File.Name)' tmpfile' m_options)) " is 129.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,Run,The length of the statement  "					using (var tmpfile = backend.Get (flentry.Value.File.Name' flentry.Value.File == null ? -1 : flentry.Value.File.Size' null)) " is 124.
Long Statement,Duplicati.Library.Main.Operation,ListFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListFilesHandler.cs,CreateResultSequence,The length of the statement  "	select (Library.Interface.IListResultFileset)(new ListResultFileset (n.Key' n.Value.Time.ToLocalTime ()' -1' -1))).ToArray (); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,RunUpdate,The length of the statement  "		throw new UserInformationException (string.Format ("Can only update with paths' try setting {0}"' "--repair-only-paths")); " is 122.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "					throw new UserInformationException ("No files were found at the remote location' perhaps the target url is incorrect?"); " is 120.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "						throw new UserInformationException (string.Format ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count)); " is 139.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "						throw new UserInformationException (string.Format ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0])); " is 167.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "						throw new UserInformationException (string.Format ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types))); " is 222.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "				volumeIds [fl.File.Name] = updating ? restoredb.GetRemoteVolumeID (fl.File.Name) : restoredb.RegisterRemoteVolume (fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded); " is 184.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "							volumeIds [n.File.Name] = restoredb.RegisterRemoteVolume (n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan (0)' tr); " is 146.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "							m_result.OperationProgressUpdater.UpdateProgress (((float)progress / filelistWork.Count ()) * (m_options.RepairOnlyPaths ? 1f : 0.2f)); " is 135.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "											var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "											var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "											var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "										if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)) { " is 149.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "											m_result.AddError (string.Format ("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null); " is 142.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "								m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name))); " is 135.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "								m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name))); " is 133.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "								m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name))); " is 142.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The length of the statement  "						throw new UserInformationException (string.Format ("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files")); " is 266.
Long Statement,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,ProbeForMatchingFilename,The length of the statement  "					m_result.AddWarning (string.Format ("Unable to find volume {0}' but mapping to matching file {1}"' filename' testfilename)' null); " is 130.
Long Statement,Duplicati.Library.Main.Operation,RestoreControlFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreControlFilesHandler.cs,Run,The length of the statement  "		using (var db = new Database.LocalDatabase (System.IO.File.Exists (m_options.Dbpath) ? m_options.Dbpath : (string)tmpdb' "RestoreControlFiles"' true)) " is 150.
Long Statement,Duplicati.Library.Main.Operation,RestoreControlFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreControlFilesHandler.cs,Run,The length of the statement  "				var filter = Library.Utility.JoinedFilterExpression.Join (new Library.Utility.FilterExpression (filterstrings)' compositefilter); " is 129.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,FilterNumberedFilelist,The length of the statement  "		time = Library.Utility.Utility.DeserializeDateTime (Library.Utility.Utility.SerializeDateTime (time)).ToUniversalTime (); " is 121.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,FilterNumberedFilelist,The length of the statement  "		var numbers = lst.Zip (Enumerable.Range (0' lst.Length)' (a' b) => new KeyValuePair<long' IParsedVolume> (b' a)).ToList (); " is 123.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,Run,The length of the statement  "		RecreateDatabaseHandler.NumberedFilterFilelistDelegate filelistfilter = FilterNumberedFilelist (m_options.Time' m_options.Version); " is 131.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,Run,The length of the statement  "					new RecreateDatabaseHandler (m_backendurl' m_options' (RecreateDatabaseResults)m_result.RecreateDatabaseResults).DoRun (database' false' filter' filelistfilter' /*localpatcher*/null); " is 183.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,Run,The length of the statement  "				m_options.RawOptions ["version"] = string.Join ("'"' Enumerable.Range (0' m_options.Version.Length).Select (x => x.ToString ())); " is 129.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "	var blockhasher = fullblockverification ? System.Security.Cryptography.HashAlgorithm.Create (options.BlockHashAlgorithm) : null; " is 128.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "											result.AddWarning (string.Format ("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null); " is 147.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "									result.AddWarning (string.Format ("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null); " is 143.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "						result.AddWarning (string.Format ("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The length of the statement  "						result.AddWarning (string.Format ("Failed to record metadata for file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ApplyStoredMetadata,The length of the statement  "				result.AddWarning (string.Format ("Failed to apply metadata to file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex); " is 122.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The length of the statement  "						result.AddError (string.Format ("Failed to patch with remote file: \"{0}\"' message: {1}"' blockvolume.Name' ex.Message)' ex); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The length of the statement  "									throw new Exception (string.Format ("Failed to restore file: \"{0}\". File hash is {1}' expected hash is {2}"' file.Path' key' file.Hash)); " is 139.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,DoRun,The length of the statement  "					m_result.AddMessage (string.Format ("Failed to restore {0} files' additionally the following files failed to download' which may be the cause:{1}{2}"' fileErrors' Environment.NewLine' string.Join (Environment.NewLine' brokenFiles))); " is 233.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The length of the statement  "							result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' sourcepath' ex.Message)' ex); " is 156.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The length of the statement  "				result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The length of the statement  "								result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' source.Path' ex.Message)' ex); " is 157.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The length of the statement  "				result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PrepareBlockAndFileList,The length of the statement  "			result.AddVerboseMessage ("Mapping restore path prefix to \"{0}\" to \"{1}\""' largest_prefix' Library.Utility.Utility.AppendDirSeparator (options.Restorepath)); " is 161.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The length of the statement  "							result.AddDryrunMessage (string.Format ("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength)); " is 126.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The length of the statement  "											calcFileHashTask = System.Threading.Tasks.Task.Run (() => filehasher.TransformBlock (blockbuffer' 0' size' blockbuffer' 0)); " is 124.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The length of the statement  "							result.AddVerboseMessage ("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : ""); " is 135.
Long Statement,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The length of the statement  "				var newname = m_systemIO.PathChangeExtension (targetpath' null) + "." + database.RestoreTime.ToLocalTime ().ToString ("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture); " is 183.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "	var report = db.GetCompactReport (m_options.VolumeSize' m_options.Threshold' m_options.SmallFileSize' m_options.SmallFileMaxCount' transaction); " is 144.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "			newvol.VolumeID = db.RegisterRemoteVolume (newvol.RemoteFilename' RemoteVolumeType.Blocks' RemoteVolumeState.Temporary' transaction); " is 133.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "				newvolindex.VolumeID = db.RegisterRemoteVolume (newvolindex.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' transaction); " is 142.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "			var remoteList = db.GetRemoteVolumes ().Where (n => n.State == RemoteVolumeState.Uploaded || n.State == RemoteVolumeState.Verified).ToArray (); " is 143.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "											uploadedVolumes.Add (new KeyValuePair<string' long> (newvol.RemoteFilename' new System.IO.FileInfo (newvol.LocalFilename).Length)); " is 131.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "												uploadedVolumes.Add (new KeyValuePair<string' long> (newvolindex.RemoteFilename' new System.IO.FileInfo (newvolindex.LocalFilename).Length)); " is 141.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "												m_result.AddDryrunMessage (string.Format ("Would upload generated blockset of size {0}"' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (newvol.LocalFilename).Length))); " is 187.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "											newvol.VolumeID = db.RegisterRemoteVolume (newvol.RemoteFilename' RemoteVolumeType.Blocks' RemoteVolumeState.Temporary' transaction); " is 133.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "												newvolindex.VolumeID = db.RegisterRemoteVolume (newvolindex.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' transaction); " is 142.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "						uploadedVolumes.Add (new KeyValuePair<string' long> (newvol.RemoteFilename' new System.IO.FileInfo (newvol.LocalFilename).Length)); " is 131.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "							uploadedVolumes.Add (new KeyValuePair<string' long> (newvolindex.RemoteFilename' new System.IO.FileInfo (newvolindex.LocalFilename).Length)); " is 141.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "							m_result.AddDryrunMessage (string.Format ("Would upload generated blockset of size {0}"' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (newvol.LocalFilename).Length))); " is 187.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "					m_result.AddDryrunMessage (string.Format ("Would delete {0} files' which would reduce storage by {1}"' m_result.DeletedFileCount' Library.Utility.Utility.FormatSizeString (m_result.DeletedFileSize))); " is 200.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "					m_result.AddDryrunMessage (string.Format ("Would download {0} file(s) with a total size of {1}' delete {2} file(s) with a total size of {3}' and compact to {4} file(s) with a size of {5}' which would reduce storage by {6} file(s) and {7}"' m_result.DownloadedFileCount' Library.Utility.Utility.FormatSizeString (m_result.DownloadedFileSize)' m_result.DeletedFileCount' Library.Utility.Utility.FormatSizeString (m_result.DeletedFileSize)' m_result.UploadedFileCount' Library.Utility.Utility.FormatSizeString (m_result.UploadedFileSize)' m_result.DeletedFileCount - m_result.UploadedFileCount' Library.Utility.Utility.FormatSizeString (m_result.DeletedFileSize - m_result.UploadedFileSize))); " is 690.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "					m_result.AddMessage (string.Format ("Deleted {0} files' which reduced storage by {1}"' m_result.DeletedFileCount' Library.Utility.Utility.FormatSizeString (m_result.DeletedFileSize))); " is 184.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,DoCompact,The length of the statement  "					m_result.AddMessage (string.Format ("Downloaded {0} file(s) with a total size of {1}' deleted {2} file(s) with a total size of {3}' and compacted to {4} file(s) with a size of {5}' which reduced storage by {6} file(s) and {7}"' m_result.DownloadedFileCount' Library.Utility.Utility.FormatSizeString (downloadSize)' m_result.DeletedFileCount' Library.Utility.Utility.FormatSizeString (m_result.DeletedFileSize)' m_result.UploadedFileCount' Library.Utility.Utility.FormatSizeString (m_result.UploadedFileSize)' m_result.DeletedFileCount - m_result.UploadedFileCount' Library.Utility.Utility.FormatSizeString (m_result.DeletedFileSize - m_result.UploadedFileSize))); " is 663.
Long Statement,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,PerformDelete,The length of the statement  "			m_result.AddDryrunMessage (string.Format ("Would delete remote file: {0}' size: {1}"' f.Name' Library.Utility.Utility.FormatSizeString (f.Size))); " is 146.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The length of the statement  "		var filesetNumbers = db.FilesetTimes.Zip (Enumerable.Range (0' db.FilesetTimes.Count ())' (a' b) => new Tuple<long' DateTime> (b' a.Value)).ToList (); " is 150.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The length of the statement  "			m_result.AddMessage (string.Format ("Preventing removal of last fileset' use --{0} to allow removal ..."' "allow-full-removal")); " is 129.
Long Statement,Duplicati.Library.Main.Operation,DeleteHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The length of the statement  "			new CompactHandler (m_backendurl' m_options' (CompactResults)m_result.CompactResults).DoCompact (db' true' ref transaction); " is 124.
Long Statement,Duplicati.Library.Main.Operation,CreateBugReportHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CreateBugReportHandler.cs,Run,The length of the statement  "			using (var cs = cm.CreateFile ("log-database.sqlite"' Duplicati.Library.Interface.CompressionHint.Compressible' DateTime.UtcNow)) " is 129.
Long Statement,Duplicati.Library.Main.Operation,CreateBugReportHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CreateBugReportHandler.cs,Run,The length of the statement  "				using (var fs = System.IO.File.Open (tmp' System.IO.FileMode.Open' System.IO.FileAccess.Read' System.IO.FileShare.ReadWrite)) " is 125.
Long Statement,Duplicati.Library.Main.Operation,CreateBugReportHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CreateBugReportHandler.cs,Run,The length of the statement  "			using (var cs = new System.IO.StreamWriter (cm.CreateFile ("system-info.txt"' Duplicati.Library.Interface.CompressionHint.Compressible' DateTime.UtcNow))) " is 154.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairLocal,The length of the statement  "			new RecreateDatabaseHandler (m_backendurl' m_options' (RecreateDatabaseResults)m_result.RecreateDatabaseResults).Run (m_options.Dryrun ? (string)f : m_options.Dbpath' filter' filelistfilter); " is 191.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "				throw new UserInformationException ("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss."); " is 209.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "				throw new UserInformationException ("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss."); " is 236.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "						throw new UserInformationException (string.Format ("Found no backup files with prefix {0}' but files with prefix {1}' did you forget to set the backup-prefix?"' m_options.Prefix' tp.BackupPrefixes [0])); " is 203.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "						throw new UserInformationException (string.Format ("Found no backup files with prefix {0}' but files with prefixes {1}' did you forget to set the backup-prefix?"' m_options.Prefix' string.Join ("' "' tp.BackupPrefixes))); " is 221.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "					throw new UserInformationException (string.Format ("No files were missing' but {0} remote files were' found' did you mean to run recreate-database?"' tp.ExtraVolumes.Count ())); " is 177.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "								m_result.AddError (string.Format ("Failed to perform verification for file: {0}' please run verify; message: {1}"' n.Name' ex.Message)' ex); " is 140.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "												throw new Exception (string.Format ("Volume {0} hash/size mismatch ({1} - {2}) vs ({3} - {4})"' rv.Filename' cmphash' cmpsize' rv.Hash' rv.Length)); " is 148.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "								m_result.AddError (string.Format ("Failed to accept new index file: {0}' message: {1}"' n.File.Name' rex.Message)' rex); " is 120.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "						m_result.AddError (string.Format ("Failed to perform cleanup for extra file: {0}' message: {1}"' n.File.Name' ex.Message)' ex); " is 127.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "								m_result.AddDryrunMessage (string.Format ("would re-upload fileset {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size))); " is 259.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "											throw new Exception (string.Format ("Internal consistency check failed' generated index block has wrong hash' {0} vs {1}"' bh' b.Item1)); " is 137.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "								m_result.AddDryrunMessage (string.Format ("would re-upload index file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size))); " is 262.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "									m_result.AddMessage (string.Format ("Repair cannot acquire {0} required blocks for volume {1}' which are required by the following filesets: "' missingBlocks' n.Name)); " is 168.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "									var recoverymsg = string.Format ("If you want to continue working with the database' you can use the \"{0}\" and \"{1}\" commands to purge the missing data from the database and the remote storage."' "list-broken-files"' "purge-broken-files"); " is 243.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "										throw new UserInformationException (string.Format ("Repair not possible' missing {0} blocks.\n" + recoverymsg' missingBlocks)); " is 127.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "										m_result.AddDryrunMessage (string.Format ("would re-upload block file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size))); " is 262.
Long Statement,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The length of the statement  "						m_result.AddError (string.Format ("Failed to perform cleanup for missing file: {0}' message: {1}"' n.Name' ex.Message)' ex); " is 124.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyRemoteList,The length of the statement  "		var s = string.Format ("Found remote files reported as duplicates' either the backend module is broken or you need to manually remove the extra copies.\nThe following files were found multiple times: {0}"' string.Join ("' "' doubles.Keys)); " is 240.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,VerifyRemoteList,The length of the statement  "			s = string.Format ("Found {0} files that are missing from the remote storage' and no files with the backup prefix {1}' but found the following backup prefixes: {2}"' missingCount' options.Prefix' string.Join ("' "' tp.BackupPrefixes)); " is 235.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,CreateVerificationFile,The length of the statement  "	s.Serialize (stream' db.GetRemoteVolumes ().Where (x => x.State != RemoteVolumeState.Temporary).Cast<IRemoteVolume> ().ToArray ()); " is 131.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,UploadVerificationFile,The length of the statement  "				result.AddDryrunMessage (string.Format ("Would upload verification file: {0}' size: {1}"' remotename' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (tempfile).Length))); " is 188.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The length of the statement  "			throw new Exception (string.Format ("The remote volume {0} appears in the database with state {1} and a deleted state' cannot continue"' e.Key' e.Value.ToString ())); " is 166.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The length of the statement  "					log.AddMessage (string.Format ("keeping delete request for {0} until {1}"' i.Name' i.deleteGracePeriod.ToLocalTime ())); " is 120.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The length of the statement  "				log.AddMessage (string.Format ("promoting uploaded complete file from {0} to {2}: {1}"' i.State' i.Name' RemoteVolumeState.Uploaded)); " is 134.
Long Statement,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The length of the statement  "		log.AddWarning (string.Format ("remote file {1} is listed as {0} with size {2} but should be {3}' please verify the sha256 hash \"{4}\""' i.Item2.State' i.Item2.Name' i.Item1' i.Item2.Size' i.Item2.Hash)' null); " is 211.
Long Statement,Duplicati.Library.Main.Operation,ListControlFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListControlFilesHandler.cs,Run,The length of the statement  "		using (var db = new Database.LocalDatabase (System.IO.File.Exists (m_options.Dbpath) ? m_options.Dbpath : (string)tmpdb' "ListControlFiles"' true)) " is 147.
Long Statement,Duplicati.Library.Main.Operation,ListControlFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListControlFilesHandler.cs,Run,The length of the statement  "				var filter = Library.Utility.JoinedFilterExpression.Join (new Library.Utility.FilterExpression (filterstrings)' compositefilter); " is 129.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "	var filter = Library.Utility.JoinedFilterExpression.Join (new Library.Utility.FilterExpression (filterstrings)' compositefilter); " is 129.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "							throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count)); " is 147.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "						var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList (); " is 135.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "						var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList (); " is 161.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "							throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count)); " is 152.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "							using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options)) " is 127.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "							using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options)) " is 130.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "					var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport () " is 127.
Long Statement,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The length of the statement  "					m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ()); " is 440.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The length of the statement  "									m_results.AddDryrunMessage (string.Format ("Sucessfully captured hash and size for {0}' would update database"' vol.Name)); " is 123.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The length of the statement  "					new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string> (Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message) " is 133.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The length of the statement  "								m_results.AddDryrunMessage (string.Format ("Sucessfully captured hash and size for {0}' would update database"' f.Name)); " is 121.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The length of the statement  "					new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string> (Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message) " is 133.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "			return new KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> (vol.Name' fl.Compare ().ToList ()); " is 120.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "		IEnumerable<KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>> combined = new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[0]; " is 163.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "						changes.Add (new KeyValuePair<Library.Interface.TestEntryStatus' string> (Library.Interface.TestEntryStatus.Modified' s.Key)); " is 126.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "							changes.Add (new KeyValuePair<Library.Interface.TestEntryStatus' string> (Library.Interface.TestEntryStatus.Modified' s.Key)); " is 126.
Long Statement,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The length of the statement  "				return new KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> (vol.Name' changes.Union (bl.Compare ().ToList ())); " is 136.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "		foreach (var path in new BackupHandler.FilterHandler (snapshot' m_options.FileAttributeFilter' sourcefilter' filter' m_options.SymlinkPolicy' m_options.HardlinkPolicy' m_result).EnumerateFilesAndFolders ()) { " is 208.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "				if (m_options.SkipFilesLargerThan == long.MaxValue || m_options.SkipFilesLargerThan == 0 || size < m_options.SkipFilesLargerThan) " is 129.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "					m_result.AddVerboseMessage ("Including file: {0} ({1})"' path' size <= 0 ? "unknown" : Duplicati.Library.Utility.Utility.FormatSizeString (size)); " is 146.
Long Statement,Duplicati.Library.Main.Operation,TestFilterHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The length of the statement  "					m_result.AddVerboseMessage ("Excluding file due to size: {0} ({1})"' path' size <= 0 ? "unknown" : Duplicati.Library.Utility.Utility.FormatSizeString (size)); " is 158.
Long Statement,Duplicati.Library.Main.Operation,ListAffected,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListAffected.cs,Run,The length of the statement  "			m_result.SetResult (db.GetFilesets (args).OrderByDescending (x => x.Time).ToArray ()' db.GetFiles (args).ToArray ()' db.GetLogLines (args).ToArray ()' db.GetVolumes (args).ToArray ()); " is 184.
Long Statement,Duplicati.Library.Main.Operation,ListAffected,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListAffected.cs,Run,The length of the statement  "			m_result.SetResult (db.GetFilesets (args).OrderByDescending (x => x.Time)' db.GetFiles (args)' db.GetLogLines (args)' db.GetVolumes (args)); " is 140.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "	yield return string.Format ("Duplicati: {0} ({1})"' Duplicati.Library.Utility.Utility.getEntryAssembly ().FullName' System.Reflection.Assembly.GetExecutingAssembly ().FullName); " is 177.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "	yield return string.Format ("Autoupdate urls: {0}"' string.Join (";"' Duplicati.Library.AutoUpdater.AutoUpdateSettings.URLs)); " is 126.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "	yield return string.Format ("Version name: \"{0}\" ({1})"' Duplicati.Library.AutoUpdater.UpdaterManager.SelfVersion.Displayname' System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version' System.IO.Path.GetDirectoryName (System.Reflection.Assembly.GetExecutingAssembly ().Location)); " is 295.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "	yield return string.Format ("Current Version folder {0}"' System.IO.Path.GetDirectoryName (System.Reflection.Assembly.GetExecutingAssembly ().Location)); " is 153.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "	yield return string.Format ("Mono: {0} ({1}) ({2})"' Duplicati.Library.Utility.Utility.IsMono' Duplicati.Library.Utility.Utility.MonoVersion' Duplicati.Library.Utility.Utility.MonoDisplayVersion); " is 196.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "	yield return string.Format ("Locale: {0}' {1}' {2}"' System.Threading.Thread.CurrentThread.CurrentCulture' System.Threading.Thread.CurrentThread.CurrentUICulture' System.Globalization.CultureInfo.InstalledUICulture); " is 216.
Long Statement,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The length of the statement  "	yield return string.Format ("Date/time strings: {0} - {1}"' System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongDatePattern' System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongTimePattern); " is 230.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,Run,The length of the statement  "		throw new UserInformationException ("Cannot purge with an empty filter' as that would cause all files to be removed.\nTo remove an entire backup set' use the \"delete\" command."); " is 180.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "			throw new UserInformationException (string.Format ("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files")); " is 159.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "			throw new UserInformationException (string.Format ("Unable to start the purge process as there are {0} orphan file(s)"' orphans)); " is 130.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "					throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid)); " is 123.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "					var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs)); " is 127.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "					throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts)); " is 162.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "					throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value)); " is 196.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "								m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize))); " is 248.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "									m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount)); " is 231.
Long Statement,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The length of the statement  "						new CompactHandler (backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact (cdb' true' ref tr); " is 122.
Long Statement,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,GetBrokenFilesetsFromRemote,The length of the statement  "			throw new UserInformationException ("Cannot continue because the database is marked as being under repair' but does not have broken files."); " is 141.
Long Statement,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,GetBrokenFilesetsFromRemote,The length of the statement  "				result.AddMessage ("Skipping operation because no files were found to be missing' and no filesets were recorded as broken."); " is 125.
Long Statement,Duplicati.Library.Main.Operation,ListBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListBrokenFilesHandler.cs,DoRun,The length of the statement  "	m_result.BrokenFiles = brokenfilesets.Select (x => new Tuple<long' DateTime' IEnumerable<Tuple<string' long>>> (x.Version' x.Timestamp' callbackhandler == null && !m_options.ListSetsOnly ? db.GetBrokenFilenames (x.FilesetID' transaction).ToArray ().AsEnumerable () : new MockList<Tuple<string' long>> ((int)x.BrokenCount))).ToArray (); " is 335.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "					throw new UserInformationException (string.Format ("Found no broken filesets' but {0} missing remote files"' sets.Length)); " is 123.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "			m_result.AddMessage (string.Format ("Found {0} broken filesets with {1} affected files' purging files"' sets.Length' sets.Sum (x => x.Item3))); " is 143.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "					m_result.AddMessage (string.Format ("Removing entire fileset {1} as all {0} file(s) are broken"' fully_emptied.First ().Timestamp' fully_emptied.First ().RemoveCount)); " is 168.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "					m_result.AddMessage (string.Format ("Removing {0} filesets where all file(s) are broken: {1}"' fully_emptied.Length' string.Join ("' "' fully_emptied.Select (x => x.Timestamp.ToLocalTime ().ToString ())))); " is 206.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "					m_result.AddMessage (string.Format ("Purging {0} file(s) from fileset {1}"' bs.RemoveCount' bs.Timestamp.ToLocalTime ())); " is 122.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "							throw new Exception (string.Format ("Failed to find match for {0} ({1}) in {2}"' bs.FilesetID' bs.Timestamp.ToLocalTime ()' string.Join ("' "' filesets.Select (x => x.ToString ())))); " is 183.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "						new PurgeFilesHandler (m_backendurl' opts' (PurgeFilesResults)m_result.PurgeResults).Run (pgdb' pgoffset' pgspan' (cmd' filesetid' tablename) => { " is 146.
Long Statement,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The length of the statement  "							m_result.AddDryrunMessage (string.Format ("Would delete remote file: {0}' size: {1}"' f.Name' Library.Utility.Utility.FormatSizeString (f.Size))); " is 146.
Long Statement,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddFile,The length of the statement  "	AddFileEntry (FilelistEntryType.File' name' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blocklisthashes' metablocklisthashes); " is 169.
Long Statement,Duplicati.Library.Main.Volumes,FilesetVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\FilesetVolumeWriter.cs,AddAlternateStream,The length of the statement  "	AddFileEntry (FilelistEntryType.AlternateStream' name' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blocklisthashes' metablocklisthashes); " is 180.
Long Statement,Duplicati.Library.Main.Volumes,VolumeBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The length of the statement  "	return GenerateFilename (filetype' options.Prefix' guid' timestamp' options.CompressionModule' options.NoEncryption ? null : options.EncryptionModule); " is 151.
Long Statement,Duplicati.Library.Main.Volumes,VolumeBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The length of the statement  "		volumename = prefix + "-" + Library.Utility.Utility.SerializeDateTime (timestamp) + "." + (ParsedVolume.REMOTE_TYPENAME_MAP [filetype]) + "." + compressionmodule; " is 162.
Long Statement,Duplicati.Library.Main.Volumes,VolumeBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeBase.cs,GenerateFilename,The length of the statement  "		volumename = prefix + "-" + (filetype == RemoteVolumeType.Blocks ? "b" : "i") + guid + "." + (ParsedVolume.REMOTE_TYPENAME_MAP [filetype]) + "." + compressionmodule; " is 165.
Long Statement,Duplicati.Library.Main.Volumes,VolumeReaderBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeReaderBase.cs,SkipJsonToken,The length of the statement  "		throw new InvalidDataException (string.Format ("Invalid JSON' expected \"{0}\"' but got {1}' {2}"' type' reader.TokenType' reader.Value)); " is 138.
Long Statement,Duplicati.Library.Main.Volumes,VolumeReaderBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeReaderBase.cs,ReadJsonProperty,The length of the statement  "		throw new InvalidDataException (string.Format ("Invalid JSON' expected property \"{0}\"' but got {1}' {2}"' propertyname' reader.TokenType' reader.Value)); " is 155.
Long Statement,Duplicati.Library.Main.Volumes,VolumeWriterBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeWriterBase.cs,ResetRemoteFilename,The length of the statement  "	m_volumename = GenerateFilename (this.FileType' options.Prefix' GenerateGuid (options)' timestamp' options.CompressionModule' options.NoEncryption ? null : options.EncryptionModule); " is 182.
Long Statement,Duplicati.Library.Main.Volumes,VolumeWriterBase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\VolumeWriterBase.cs,AddManifestfile,The length of the statement  "	using (var sr = new StreamWriter (m_compression.CreateFile (MANIFEST_FILENAME' CompressionHint.Compressible' DateTime.UtcNow)' ENCODING)) " is 137.
Long Statement,Duplicati.Library.Main.Volumes,IndexVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeWriter.cs,StartVolume,The length of the statement  "	m_streamwriter = new StreamWriter (m_compression.CreateFile (INDEX_VOLUME_FOLDER + filename' CompressionHint.Compressible' DateTime.UtcNow)); " is 141.
Long Statement,Duplicati.Library.Main.Volumes,IndexVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeWriter.cs,WriteBlocklist,The length of the statement  "	using (var s = m_compression.CreateFile (INDEX_BLOCKLIST_FOLDER + Library.Utility.Utility.Base64PlainToBase64Url (hash)' CompressionHint.Noncompressible' DateTime.UtcNow)) " is 171.
Long Statement,Duplicati.Library.Main.Volumes,IndexVolumeWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Volumes\IndexVolumeWriter.cs,WriteBlocklist,The length of the statement  "	using (var s = m_compression.CreateFile (INDEX_BLOCKLIST_FOLDER + Library.Utility.Utility.Base64PlainToBase64Url (hash)' CompressionHint.Noncompressible' DateTime.UtcNow)) " is 171.
Long Statement,Duplicati.Library.Main.Strings,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,HashMismatchError,The length of the statement  "	return LC.L (@"Hash mismatch on file ""{0}""' recorded hash: {1}' actual hash {2}"' filename' recordedhash' actualhash); " is 120.
Long Statement,Duplicati.Library.Main.Strings,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,DownloadedFileSizeError,The length of the statement  "	return LC.L (@"The file {0} was downloaded and had size {1} but the size was expected to be {2}"' filename' actualsize' expectedsize); " is 134.
Long Statement,Duplicati.Library.Main.Strings,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedBooleanValue,The length of the statement  "	return LC.L (@"The value ""{1}"" supplied to --{0} does not parse into a valid boolean' this will be treated as if it was set to ""true"""' optionname' value); " is 159.
Long Statement,Duplicati.Library.Main.Strings,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedEnumerationValue,The length of the statement  "	return LC.L (@"The option --{0} does not support the value ""{1}""' supported values are: {2}"' optionname' value' string.Join ("' "' values)); " is 143.
Long Statement,Duplicati.Library.Main.Strings,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedFlagsValue,The length of the statement  "	return LC.L (@"The option --{0} does not support the value ""{1}""' supported flag values are: {2}"' optionname' value' string.Join ("' "' values)); " is 148.
Long Statement,Duplicati.Library.Main.Strings,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,UnsupportedOptionDisabledModuleWarning,The length of the statement  "	return LC.L (@"The option --{0} is not supported because the module {1} is not currently loaded"' optionname' modulename); " is 122.
Long Statement,Duplicati.Library.Main.Strings,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,FailedForceLocaleError,The length of the statement  "	return LC.L (@"Failed to apply 'force-locale' setting. Please try to update .NET-Framework. Exception was: ""{0}"" "' exMsg); " is 125.
Long Statement,Duplicati.Library.Main.Strings,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,SymlinkpolicyLong,The length of the statement  "	return LC.L (@"Use this option to handle symlinks differently. The ""{0}"" option will simply record a symlink with its name and destination' and a restore will recreate the symlink as a link. Use the option ""{1}"" to ignore all symlinks and not store any information about them. Previous versions of Duplicati used the setting ""{2}""' which will cause symlinked files to be included and restore as normal files."' store' ignore' follow); " is 440.
Long Statement,Duplicati.Library.Main.Strings,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,HardlinkpolicyLong,The length of the statement  "	return LC.L (@"Use this option to handle hardlinks (only works on Linux/OSX). The ""{0}"" option will record a hardlink ID for each hardlink to avoid storing hardlinked paths multiple times. The option ""{1}"" will ignore hardlink information' and treat each hardlink as a unique path. The option ""{2}"" will ignore all hardlinks with more than one link."' first' all' none); " is 376.
Long Statement,Duplicati.Library.Main.Strings,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,ExcludefilesattributesLong,The length of the statement  "	return LC.L (@"Use this option to exclude files with certain attributes. Use a comma separated list of attribute names to specify more than one. Possible values are: {0}"' string.Join ("' "' attributes)); " is 204.
Long Statement,Duplicati.Library.Main.Strings,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,CompressionextensionfileLong,The length of the statement  "	return LC.L (@"This property can be used to point to a text file where each line contains a file extension that indicates a non-compressible file. Files that have an extension found in the file will not be compressed' but simply stored in the archive. The file format ignores any lines that do not start with a period' and considers a space to indicate the end of the extension. A default file is supplied' that also serves as an example. The default file is placed in {0}."' path); " is 482.
Long Statement,Duplicati.Library.Main.Strings,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,DeletedfilesLong,The length of the statement  "	return LC.L (@"This option can be used to supply a list of deleted files. This option will be ignored unless the option --{0} is also set."' optionname); " is 153.
Long Statement,Duplicati.Library.Main.Strings,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,BackendtestsamplesLong,The length of the statement  "	return LC.L (@"After a backup is completed' some files are selected for verification on the remote backend. Use this option to change how many. If this value is set to 0 or the option --{0} is set' no remote files are verified"' optionname); " is 241.
Long Statement,Duplicati.Library.Main.Strings,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Strings.cs,FullremoteverificationLong,The length of the statement  "	return LC.L (@"After a backup is completed' some files are selected for verification on the remote backend. Use this option to turn on full verification' which will decrypt the files and examine the insides of each volume' instead of simply verifying the external hash' If the option --{0} is set' no remote files are verified. This option is automatically set when then verification is performed directly."' optionname); " is 421.
Complex Conditional,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The conditional expression  "username == null && o.Aliases != null && o.Aliases.Contains ("auth-username"' StringComparer.InvariantCultureIgnoreCase) && ropts.ContainsKey (o.Name)"  is complex.
Complex Conditional,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The conditional expression  "password == null && o.Aliases != null && o.Aliases.Contains ("auth-password"' StringComparer.InvariantCultureIgnoreCase) && ropts.ContainsKey (o.Name)"  is complex.
Complex Conditional,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Put,The conditional expression  "req2 != null && m_queue.Enqueue (req2) && (m_options.SynchronousUpload || synchronous)"  is complex.
Complex Conditional,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The conditional expression  "(oldId < 0 || m_options.DisableFiletimeCheck || timestampChanged || filesizeChanged || metadatachanged) && !tooLargeFile"  is complex.
Complex Conditional,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The conditional expression  "fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)"  is complex.
Complex Conditional,Duplicati.Library.Main.Operation,DeleteHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,DoRun,The conditional expression  "!m_options.NoAutoCompact && (forceCompact || (toDelete != null && toDelete.Length > 0))"  is complex.
Empty Catch Block,Duplicati.Library.Main,Options,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Options.cs,GetSupportedHashes,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,BackendManager,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,RenameFileAfterError,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,DoDelete,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,RunAction,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OnOperationComplete,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,ExtensionMethods,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\ExtensionMethods.cs,ConvertValueToInt64,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CountFilesThread,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,CountFilesThread,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RunMainOperation,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,HandleFilesystemEntry,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,CompactHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\CompactHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,DeleteHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\DeleteHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,TestFilterHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,TestFilterHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestFilterHandler.cs,Run,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,RestoreHandlerMetadataStorage,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandlerMetadataStorage.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,RestoreHandlerMetadataStorage,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandlerMetadataStorage.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,SystemInfoHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\SystemInfoHandler.cs,GetSystemInfo,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The method has an empty catch block.
Empty Catch Block,Duplicati.Library.Main.Operation,PurgeBrokenFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeBrokenFilesHandler.cs,Run,The method has an empty catch block.
Magic Number,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GetDatabasePath,The following statement contains a magic number: if (matches.Count == 0) {  	var backupname = options.BackupName;  	if (string.IsNullOrEmpty (backupname) || backupname == Options.DefaultBackupName)  		backupname = GenerateRandomName ();  	else {  		foreach (var c in System.IO.Path.GetInvalidFileNameChars ())  			backupname = backupname.Replace (c.ToString ()' "");  	}  	var newpath = System.IO.Path.Combine (folder' backupname + ".sqlite");  	int max_tries = 100;  	while (System.IO.File.Exists (newpath) && max_tries-- > 0)  		newpath = System.IO.Path.Combine (folder' GenerateRandomName ());  	if (System.IO.File.Exists (newpath))  		throw new Duplicati.Library.Interface.UserInformationException ("Unable to find a unique name for the database' please use --dbpath");  	//Create a new one' add it to the list' and save it  	configs.Add (new BackendEntry () {  		Type = type'  		Server = server'  		Path = path'  		Prefix = prefix'  		Username = username'  		//Passwordhash = password'  		Port = port'  		Databasepath = newpath'  		ParameterFile = null  	});  	var settings = new Newtonsoft.Json.JsonSerializerSettings ();  	settings.Formatting = Newtonsoft.Json.Formatting.Indented;  	System.IO.File.WriteAllText (file' Newtonsoft.Json.JsonConvert.SerializeObject (configs' settings)' System.Text.Encoding.UTF8);  	return newpath;  } else {  	return matches [0].Databasepath;  }  
Magic Number,Duplicati.Library.Main,DatabaseLocator,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\DatabaseLocator.cs,GenerateRandomName,The following statement contains a magic number: for (var i = 0; i < 10; i++)  	backupname += (char)rnd.Next ('A'' 'Z' + 1);  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: while (!m_queue.Completed) {  	var item = m_queue.Dequeue ();  	if (item != null) {  		int retries = 0;  		Exception lastException = null;  		do {  			try {  				if (m_taskControl != null)  					m_taskControl.TaskControlRendevouz ();  				if (m_options.NoConnectionReuse && m_backend != null) {  					m_backend.Dispose ();  					m_backend = null;  				}  				if (m_backend == null)  					m_backend = DynamicLoader.BackendLoader.GetBackend (m_backendurl' m_options.RawOptions);  				if (m_backend == null)  					throw new Exception ("Backend failed to re-load");  				using (new Logging.Timer (string.Format ("RemoteOperation{0}"' item.Operation)))  					switch (item.Operation) {  					case OperationType.Put:  						DoPut (item);  						// We do not auto create folders'  						// because we know the folder exists  						uploadSuccess = true;  						break;  					case OperationType.Get:  						DoGet (item);  						break;  					case OperationType.List:  						DoList (item);  						break;  					case OperationType.Delete:  						DoDelete (item);  						break;  					case OperationType.CreateFolder:  						DoCreateFolder (item);  						break;  					case OperationType.Terminate:  						m_queue.SetCompleted ();  						break;  					case OperationType.Nothing:  						item.SignalComplete ();  						break;  					}  				lastException = null;  				retries = m_options.NumberOfRetries;  			} catch (Exception ex) {  				retries++;  				lastException = ex;  				m_statwriter.AddRetryAttempt (string.Format ("Operation {0} with file {1} attempt {2} of {3} failed with message: {4}"' item.Operation' item.RemoteFilename' retries' m_options.NumberOfRetries' ex.Message)' ex);  				// If the thread is aborted' we exit here  				if (ex is System.Threading.ThreadAbortException) {  					m_queue.SetCompleted ();  					item.Exception = ex;  					item.SignalComplete ();  					throw;  				}  				m_statwriter.SendEvent (item.BackendActionType' retries < m_options.NumberOfRetries ? BackendEventType.Retrying : BackendEventType.Failed' item.RemoteFilename' item.Size);  				bool recovered = false;  				if (!uploadSuccess && ex is Duplicati.Library.Interface.FolderMissingException && m_options.AutocreateFolders) {  					try {  						// If we successfully create the folder' we can re-use the connection  						m_backend.CreateFolder ();  						recovered = true;  					} catch (Exception dex) {  						m_statwriter.AddWarning (string.Format ("Failed to create folder: {0}"' ex.Message)' dex);  					}  				}  				// To work around the Apache WEBDAV issue' we rename the file here  				if (item.Operation == OperationType.Put && retries < m_options.NumberOfRetries && !item.NotTrackedInDb)  					RenameFileAfterError (item);  				if (!recovered) {  					try {  						m_backend.Dispose ();  					} catch (Exception dex) {  						m_statwriter.AddWarning (LC.L ("Failed to dispose backend instance: {0}"' ex.Message)' dex);  					}  					m_backend = null;  					if (retries < m_options.NumberOfRetries && m_options.RetryDelay.Ticks != 0) {  						var target = DateTime.Now.AddTicks (m_options.RetryDelay.Ticks);  						while (target > DateTime.Now) {  							if (m_taskControl != null && m_taskControl.IsAbortRequested ())  								break;  							System.Threading.Thread.Sleep (500);  						}  					}  				}  			}  		} while (retries < m_options.NumberOfRetries);  		if (lastException != null && !(lastException is Duplicati.Library.Interface.FileMissingException) && item.Operation == OperationType.Delete) {  			m_statwriter.AddMessage (LC.L ("Failed to delete file {0}' testing if file exists"' item.RemoteFilename));  			try {  				if (!m_backend.List ().Select (x => x.Name).Contains (item.RemoteFilename)) {  					lastException = null;  					m_statwriter.AddMessage (LC.L ("Recovered from problem with attempting to delete non-existing file {0}"' item.RemoteFilename));  				}  			} catch (Exception ex) {  				m_statwriter.AddWarning (LC.L ("Failed to recover from error deleting file {0}"' item.RemoteFilename)' ex);  			}  		}  		if (lastException != null) {  			item.Exception = lastException;  			if (item.Operation == OperationType.Put)  				item.DeleteLocalFile (m_statwriter);  			if (item.ExceptionKillsHandler) {  				m_lastException = lastException;  				//TODO: If there are temp files in the queue' we must delete them  				m_queue.SetCompleted ();  			}  		}  		item.SignalComplete ();  	}  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: if (item != null) {  	int retries = 0;  	Exception lastException = null;  	do {  		try {  			if (m_taskControl != null)  				m_taskControl.TaskControlRendevouz ();  			if (m_options.NoConnectionReuse && m_backend != null) {  				m_backend.Dispose ();  				m_backend = null;  			}  			if (m_backend == null)  				m_backend = DynamicLoader.BackendLoader.GetBackend (m_backendurl' m_options.RawOptions);  			if (m_backend == null)  				throw new Exception ("Backend failed to re-load");  			using (new Logging.Timer (string.Format ("RemoteOperation{0}"' item.Operation)))  				switch (item.Operation) {  				case OperationType.Put:  					DoPut (item);  					// We do not auto create folders'  					// because we know the folder exists  					uploadSuccess = true;  					break;  				case OperationType.Get:  					DoGet (item);  					break;  				case OperationType.List:  					DoList (item);  					break;  				case OperationType.Delete:  					DoDelete (item);  					break;  				case OperationType.CreateFolder:  					DoCreateFolder (item);  					break;  				case OperationType.Terminate:  					m_queue.SetCompleted ();  					break;  				case OperationType.Nothing:  					item.SignalComplete ();  					break;  				}  			lastException = null;  			retries = m_options.NumberOfRetries;  		} catch (Exception ex) {  			retries++;  			lastException = ex;  			m_statwriter.AddRetryAttempt (string.Format ("Operation {0} with file {1} attempt {2} of {3} failed with message: {4}"' item.Operation' item.RemoteFilename' retries' m_options.NumberOfRetries' ex.Message)' ex);  			// If the thread is aborted' we exit here  			if (ex is System.Threading.ThreadAbortException) {  				m_queue.SetCompleted ();  				item.Exception = ex;  				item.SignalComplete ();  				throw;  			}  			m_statwriter.SendEvent (item.BackendActionType' retries < m_options.NumberOfRetries ? BackendEventType.Retrying : BackendEventType.Failed' item.RemoteFilename' item.Size);  			bool recovered = false;  			if (!uploadSuccess && ex is Duplicati.Library.Interface.FolderMissingException && m_options.AutocreateFolders) {  				try {  					// If we successfully create the folder' we can re-use the connection  					m_backend.CreateFolder ();  					recovered = true;  				} catch (Exception dex) {  					m_statwriter.AddWarning (string.Format ("Failed to create folder: {0}"' ex.Message)' dex);  				}  			}  			// To work around the Apache WEBDAV issue' we rename the file here  			if (item.Operation == OperationType.Put && retries < m_options.NumberOfRetries && !item.NotTrackedInDb)  				RenameFileAfterError (item);  			if (!recovered) {  				try {  					m_backend.Dispose ();  				} catch (Exception dex) {  					m_statwriter.AddWarning (LC.L ("Failed to dispose backend instance: {0}"' ex.Message)' dex);  				}  				m_backend = null;  				if (retries < m_options.NumberOfRetries && m_options.RetryDelay.Ticks != 0) {  					var target = DateTime.Now.AddTicks (m_options.RetryDelay.Ticks);  					while (target > DateTime.Now) {  						if (m_taskControl != null && m_taskControl.IsAbortRequested ())  							break;  						System.Threading.Thread.Sleep (500);  					}  				}  			}  		}  	} while (retries < m_options.NumberOfRetries);  	if (lastException != null && !(lastException is Duplicati.Library.Interface.FileMissingException) && item.Operation == OperationType.Delete) {  		m_statwriter.AddMessage (LC.L ("Failed to delete file {0}' testing if file exists"' item.RemoteFilename));  		try {  			if (!m_backend.List ().Select (x => x.Name).Contains (item.RemoteFilename)) {  				lastException = null;  				m_statwriter.AddMessage (LC.L ("Recovered from problem with attempting to delete non-existing file {0}"' item.RemoteFilename));  			}  		} catch (Exception ex) {  			m_statwriter.AddWarning (LC.L ("Failed to recover from error deleting file {0}"' item.RemoteFilename)' ex);  		}  	}  	if (lastException != null) {  		item.Exception = lastException;  		if (item.Operation == OperationType.Put)  			item.DeleteLocalFile (m_statwriter);  		if (item.ExceptionKillsHandler) {  			m_lastException = lastException;  			//TODO: If there are temp files in the queue' we must delete them  			m_queue.SetCompleted ();  		}  	}  	item.SignalComplete ();  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: do {  	try {  		if (m_taskControl != null)  			m_taskControl.TaskControlRendevouz ();  		if (m_options.NoConnectionReuse && m_backend != null) {  			m_backend.Dispose ();  			m_backend = null;  		}  		if (m_backend == null)  			m_backend = DynamicLoader.BackendLoader.GetBackend (m_backendurl' m_options.RawOptions);  		if (m_backend == null)  			throw new Exception ("Backend failed to re-load");  		using (new Logging.Timer (string.Format ("RemoteOperation{0}"' item.Operation)))  			switch (item.Operation) {  			case OperationType.Put:  				DoPut (item);  				// We do not auto create folders'  				// because we know the folder exists  				uploadSuccess = true;  				break;  			case OperationType.Get:  				DoGet (item);  				break;  			case OperationType.List:  				DoList (item);  				break;  			case OperationType.Delete:  				DoDelete (item);  				break;  			case OperationType.CreateFolder:  				DoCreateFolder (item);  				break;  			case OperationType.Terminate:  				m_queue.SetCompleted ();  				break;  			case OperationType.Nothing:  				item.SignalComplete ();  				break;  			}  		lastException = null;  		retries = m_options.NumberOfRetries;  	} catch (Exception ex) {  		retries++;  		lastException = ex;  		m_statwriter.AddRetryAttempt (string.Format ("Operation {0} with file {1} attempt {2} of {3} failed with message: {4}"' item.Operation' item.RemoteFilename' retries' m_options.NumberOfRetries' ex.Message)' ex);  		// If the thread is aborted' we exit here  		if (ex is System.Threading.ThreadAbortException) {  			m_queue.SetCompleted ();  			item.Exception = ex;  			item.SignalComplete ();  			throw;  		}  		m_statwriter.SendEvent (item.BackendActionType' retries < m_options.NumberOfRetries ? BackendEventType.Retrying : BackendEventType.Failed' item.RemoteFilename' item.Size);  		bool recovered = false;  		if (!uploadSuccess && ex is Duplicati.Library.Interface.FolderMissingException && m_options.AutocreateFolders) {  			try {  				// If we successfully create the folder' we can re-use the connection  				m_backend.CreateFolder ();  				recovered = true;  			} catch (Exception dex) {  				m_statwriter.AddWarning (string.Format ("Failed to create folder: {0}"' ex.Message)' dex);  			}  		}  		// To work around the Apache WEBDAV issue' we rename the file here  		if (item.Operation == OperationType.Put && retries < m_options.NumberOfRetries && !item.NotTrackedInDb)  			RenameFileAfterError (item);  		if (!recovered) {  			try {  				m_backend.Dispose ();  			} catch (Exception dex) {  				m_statwriter.AddWarning (LC.L ("Failed to dispose backend instance: {0}"' ex.Message)' dex);  			}  			m_backend = null;  			if (retries < m_options.NumberOfRetries && m_options.RetryDelay.Ticks != 0) {  				var target = DateTime.Now.AddTicks (m_options.RetryDelay.Ticks);  				while (target > DateTime.Now) {  					if (m_taskControl != null && m_taskControl.IsAbortRequested ())  						break;  					System.Threading.Thread.Sleep (500);  				}  			}  		}  	}  } while (retries < m_options.NumberOfRetries);  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: try {  	if (m_taskControl != null)  		m_taskControl.TaskControlRendevouz ();  	if (m_options.NoConnectionReuse && m_backend != null) {  		m_backend.Dispose ();  		m_backend = null;  	}  	if (m_backend == null)  		m_backend = DynamicLoader.BackendLoader.GetBackend (m_backendurl' m_options.RawOptions);  	if (m_backend == null)  		throw new Exception ("Backend failed to re-load");  	using (new Logging.Timer (string.Format ("RemoteOperation{0}"' item.Operation)))  		switch (item.Operation) {  		case OperationType.Put:  			DoPut (item);  			// We do not auto create folders'  			// because we know the folder exists  			uploadSuccess = true;  			break;  		case OperationType.Get:  			DoGet (item);  			break;  		case OperationType.List:  			DoList (item);  			break;  		case OperationType.Delete:  			DoDelete (item);  			break;  		case OperationType.CreateFolder:  			DoCreateFolder (item);  			break;  		case OperationType.Terminate:  			m_queue.SetCompleted ();  			break;  		case OperationType.Nothing:  			item.SignalComplete ();  			break;  		}  	lastException = null;  	retries = m_options.NumberOfRetries;  } catch (Exception ex) {  	retries++;  	lastException = ex;  	m_statwriter.AddRetryAttempt (string.Format ("Operation {0} with file {1} attempt {2} of {3} failed with message: {4}"' item.Operation' item.RemoteFilename' retries' m_options.NumberOfRetries' ex.Message)' ex);  	// If the thread is aborted' we exit here  	if (ex is System.Threading.ThreadAbortException) {  		m_queue.SetCompleted ();  		item.Exception = ex;  		item.SignalComplete ();  		throw;  	}  	m_statwriter.SendEvent (item.BackendActionType' retries < m_options.NumberOfRetries ? BackendEventType.Retrying : BackendEventType.Failed' item.RemoteFilename' item.Size);  	bool recovered = false;  	if (!uploadSuccess && ex is Duplicati.Library.Interface.FolderMissingException && m_options.AutocreateFolders) {  		try {  			// If we successfully create the folder' we can re-use the connection  			m_backend.CreateFolder ();  			recovered = true;  		} catch (Exception dex) {  			m_statwriter.AddWarning (string.Format ("Failed to create folder: {0}"' ex.Message)' dex);  		}  	}  	// To work around the Apache WEBDAV issue' we rename the file here  	if (item.Operation == OperationType.Put && retries < m_options.NumberOfRetries && !item.NotTrackedInDb)  		RenameFileAfterError (item);  	if (!recovered) {  		try {  			m_backend.Dispose ();  		} catch (Exception dex) {  			m_statwriter.AddWarning (LC.L ("Failed to dispose backend instance: {0}"' ex.Message)' dex);  		}  		m_backend = null;  		if (retries < m_options.NumberOfRetries && m_options.RetryDelay.Ticks != 0) {  			var target = DateTime.Now.AddTicks (m_options.RetryDelay.Ticks);  			while (target > DateTime.Now) {  				if (m_taskControl != null && m_taskControl.IsAbortRequested ())  					break;  				System.Threading.Thread.Sleep (500);  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: if (!recovered) {  	try {  		m_backend.Dispose ();  	} catch (Exception dex) {  		m_statwriter.AddWarning (LC.L ("Failed to dispose backend instance: {0}"' ex.Message)' dex);  	}  	m_backend = null;  	if (retries < m_options.NumberOfRetries && m_options.RetryDelay.Ticks != 0) {  		var target = DateTime.Now.AddTicks (m_options.RetryDelay.Ticks);  		while (target > DateTime.Now) {  			if (m_taskControl != null && m_taskControl.IsAbortRequested ())  				break;  			System.Threading.Thread.Sleep (500);  		}  	}  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: if (retries < m_options.NumberOfRetries && m_options.RetryDelay.Ticks != 0) {  	var target = DateTime.Now.AddTicks (m_options.RetryDelay.Ticks);  	while (target > DateTime.Now) {  		if (m_taskControl != null && m_taskControl.IsAbortRequested ())  			break;  		System.Threading.Thread.Sleep (500);  	}  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: while (target > DateTime.Now) {  	if (m_taskControl != null && m_taskControl.IsAbortRequested ())  		break;  	System.Threading.Thread.Sleep (500);  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following statement contains a magic number: System.Threading.Thread.Sleep (500);  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,RenameFileAfterError,The following statement contains a magic number: if (item.Indexfile != null) {  	if (!item.IndexfileUpdated) {  		item.Indexfile.Item1.FinishVolume (item.Hash' item.Size);  		item.Indexfile.Item1.Close ();  		item.IndexfileUpdated = true;  	}  	IndexVolumeWriter wr = null;  	try {  		var hashsize = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm).HashSize / 8;  		wr = new IndexVolumeWriter (m_options);  		using (var rd = new IndexVolumeReader (p.CompressionModule' item.Indexfile.Item2.LocalFilename' m_options' hashsize))  			wr.CopyFrom (rd' x => x == oldname ? newname : x);  		item.Indexfile.Item1.Dispose ();  		item.Indexfile = new Tuple<IndexVolumeWriter' FileEntryItem> (wr' item.Indexfile.Item2);  		item.Indexfile.Item2.LocalTempfile.Dispose ();  		item.Indexfile.Item2.LocalTempfile = wr.TempFile;  		wr.Close ();  	} catch {  		if (wr != null)  			try {  				wr.Dispose ();  			} catch {  			} finally {  				wr = null;  			}  		throw;  	}  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,RenameFileAfterError,The following statement contains a magic number: try {  	var hashsize = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm).HashSize / 8;  	wr = new IndexVolumeWriter (m_options);  	using (var rd = new IndexVolumeReader (p.CompressionModule' item.Indexfile.Item2.LocalFilename' m_options' hashsize))  		wr.CopyFrom (rd' x => x == oldname ? newname : x);  	item.Indexfile.Item1.Dispose ();  	item.Indexfile = new Tuple<IndexVolumeWriter' FileEntryItem> (wr' item.Indexfile.Item2);  	item.Indexfile.Item2.LocalTempfile.Dispose ();  	item.Indexfile.Item2.LocalTempfile = wr.TempFile;  	wr.Close ();  } catch {  	if (wr != null)  		try {  			wr.Dispose ();  		} catch {  		} finally {  			wr = null;  		}  	throw;  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The following statement contains a magic number: try {  	System.IO.Stream nextTierWriter = null;  	// target of our stacked streams  	if (!enableStreaming)  		// we will always need dlTarget if not streaming...  		dlTarget = new TempFile ();  	else if (enableStreaming && useDecrypter == null) {  		dlTarget = new TempFile ();  		dlToStream = System.IO.File.OpenWrite (dlTarget);  		nextTierWriter = dlToStream;  		// actually write through to file.  	}  	// setup decryption: fork off a StreamLink from stack' and setup decryptor task  	if (useDecrypter != null) {  		linkForkDecryptor = new DirectStreamLink (1 << 16' false' false' nextTierWriter);  		nextTierWriter = linkForkDecryptor.WriterStream;  		linkForkDecryptor.SetKnownLength (item.Size' false);  		// Set length to allow AES-decryption (not streamable yet)  		decryptTarget = new TempFile ();  		decryptToStream = System.IO.File.OpenWrite (decryptTarget);  		taskDecrypter = new System.Threading.Tasks.Task (() => {  			using (var input = linkForkDecryptor.ReaderStream)  				using (var output = decryptToStream)  					lock (m_encryptionLock) {  						useDecrypter.Decrypt (input' output);  					}  		});  	}  	// setup hashing: fork off a StreamLink from stack' then task computes hash  	linkForkHasher = new DirectStreamLink (1 << 16' false' false' nextTierWriter);  	nextTierWriter = linkForkHasher.WriterStream;  	taskHasher = new System.Threading.Tasks.Task<string> (() => {  		using (var input = linkForkHasher.ReaderStream)  			return CalculateFileHash (input);  	});  	// OK' forks with tasks are set up' so let's do the download which is performed in main thread.  	bool hadException = false;  	try {  		if (enableStreaming) {  			using (var ss = new ShaderStream (nextTierWriter' false)) {  				using (var ts = new ThrottledStream (ss' m_options.MaxUploadPrSecond' m_options.MaxDownloadPrSecond))  					using (var pgs = new Library.Utility.ProgressReportingStream (ts' item.Size' HandleProgress)) {  						taskHasher.Start ();  						// We do not start tasks earlier to be sure the input always gets closed.   						if (taskDecrypter != null)  							taskDecrypter.Start ();  						((Library.Interface.IStreamingBackend)m_backend).Get (item.RemoteFilename' pgs);  					}  				retDownloadSize = ss.TotalBytesWritten;  			}  		} else {  			m_backend.Get (item.RemoteFilename' dlTarget);  			retDownloadSize = new System.IO.FileInfo (dlTarget).Length;  			using (dlToStream = System.IO.File.OpenRead (dlTarget)) {  				taskHasher.Start ();  				// We do not start tasks earlier to be sure the input always gets closed.   				if (taskDecrypter != null)  					taskDecrypter.Start ();  				new DirectStreamLink.DataPump (dlToStream' nextTierWriter).Run ();  			}  		}  	} catch (Exception) {  		hadException = true;  		throw;  	} finally {  		// This nested try-catch-finally blocks will make sure we do not miss any exceptions ans all started tasks  		// are properly ended and tidied up. For what is thrown: If exceptions in main thread occured (download) it is thrown'  		// then hasher task is checked and last decryption. This resembles old logic.  		try {  			retHashcode = taskHasher.Result;  		} catch (AggregateException ex) {  			if (!hadException) {  				hadException = true;  				throw ex.InnerExceptions [0];  			}  		} finally {  			if (taskDecrypter != null) {  				try {  					taskDecrypter.Wait ();  				} catch (AggregateException ex) {  					if (!hadException) {  						hadException = true;  						if (ex.InnerExceptions [0] is System.Security.Cryptography.CryptographicException)  							throw ex.InnerExceptions [0];  						else  							throw new System.Security.Cryptography.CryptographicException (ex.InnerExceptions [0].Message' ex.InnerExceptions [0]);  					}  				}  			}  		}  	}  	if (useDecrypter != null)// return decrypted temp file  	 {  		retTarget = decryptTarget;  		decryptTarget = null;  	} else// return downloaded file  	 {  		retTarget = dlTarget;  		dlTarget = null;  	}  } finally {  	// Be tidy: manually do some cleanup to temp files' as we could not use using's.  	// Unclosed streams should only occur if we failed even before tasks were started.  	if (dlToStream != null)  		dlToStream.Dispose ();  	if (dlTarget != null)  		dlTarget.Dispose ();  	if (decryptToStream != null)  		decryptToStream.Dispose ();  	if (decryptTarget != null)  		decryptTarget.Dispose ();  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The following statement contains a magic number: try {  	System.IO.Stream nextTierWriter = null;  	// target of our stacked streams  	if (!enableStreaming)  		// we will always need dlTarget if not streaming...  		dlTarget = new TempFile ();  	else if (enableStreaming && useDecrypter == null) {  		dlTarget = new TempFile ();  		dlToStream = System.IO.File.OpenWrite (dlTarget);  		nextTierWriter = dlToStream;  		// actually write through to file.  	}  	// setup decryption: fork off a StreamLink from stack' and setup decryptor task  	if (useDecrypter != null) {  		linkForkDecryptor = new DirectStreamLink (1 << 16' false' false' nextTierWriter);  		nextTierWriter = linkForkDecryptor.WriterStream;  		linkForkDecryptor.SetKnownLength (item.Size' false);  		// Set length to allow AES-decryption (not streamable yet)  		decryptTarget = new TempFile ();  		decryptToStream = System.IO.File.OpenWrite (decryptTarget);  		taskDecrypter = new System.Threading.Tasks.Task (() => {  			using (var input = linkForkDecryptor.ReaderStream)  				using (var output = decryptToStream)  					lock (m_encryptionLock) {  						useDecrypter.Decrypt (input' output);  					}  		});  	}  	// setup hashing: fork off a StreamLink from stack' then task computes hash  	linkForkHasher = new DirectStreamLink (1 << 16' false' false' nextTierWriter);  	nextTierWriter = linkForkHasher.WriterStream;  	taskHasher = new System.Threading.Tasks.Task<string> (() => {  		using (var input = linkForkHasher.ReaderStream)  			return CalculateFileHash (input);  	});  	// OK' forks with tasks are set up' so let's do the download which is performed in main thread.  	bool hadException = false;  	try {  		if (enableStreaming) {  			using (var ss = new ShaderStream (nextTierWriter' false)) {  				using (var ts = new ThrottledStream (ss' m_options.MaxUploadPrSecond' m_options.MaxDownloadPrSecond))  					using (var pgs = new Library.Utility.ProgressReportingStream (ts' item.Size' HandleProgress)) {  						taskHasher.Start ();  						// We do not start tasks earlier to be sure the input always gets closed.   						if (taskDecrypter != null)  							taskDecrypter.Start ();  						((Library.Interface.IStreamingBackend)m_backend).Get (item.RemoteFilename' pgs);  					}  				retDownloadSize = ss.TotalBytesWritten;  			}  		} else {  			m_backend.Get (item.RemoteFilename' dlTarget);  			retDownloadSize = new System.IO.FileInfo (dlTarget).Length;  			using (dlToStream = System.IO.File.OpenRead (dlTarget)) {  				taskHasher.Start ();  				// We do not start tasks earlier to be sure the input always gets closed.   				if (taskDecrypter != null)  					taskDecrypter.Start ();  				new DirectStreamLink.DataPump (dlToStream' nextTierWriter).Run ();  			}  		}  	} catch (Exception) {  		hadException = true;  		throw;  	} finally {  		// This nested try-catch-finally blocks will make sure we do not miss any exceptions ans all started tasks  		// are properly ended and tidied up. For what is thrown: If exceptions in main thread occured (download) it is thrown'  		// then hasher task is checked and last decryption. This resembles old logic.  		try {  			retHashcode = taskHasher.Result;  		} catch (AggregateException ex) {  			if (!hadException) {  				hadException = true;  				throw ex.InnerExceptions [0];  			}  		} finally {  			if (taskDecrypter != null) {  				try {  					taskDecrypter.Wait ();  				} catch (AggregateException ex) {  					if (!hadException) {  						hadException = true;  						if (ex.InnerExceptions [0] is System.Security.Cryptography.CryptographicException)  							throw ex.InnerExceptions [0];  						else  							throw new System.Security.Cryptography.CryptographicException (ex.InnerExceptions [0].Message' ex.InnerExceptions [0]);  					}  				}  			}  		}  	}  	if (useDecrypter != null)// return decrypted temp file  	 {  		retTarget = decryptTarget;  		decryptTarget = null;  	} else// return downloaded file  	 {  		retTarget = dlTarget;  		dlTarget = null;  	}  } finally {  	// Be tidy: manually do some cleanup to temp files' as we could not use using's.  	// Unclosed streams should only occur if we failed even before tasks were started.  	if (dlToStream != null)  		dlToStream.Dispose ();  	if (dlTarget != null)  		dlTarget.Dispose ();  	if (decryptToStream != null)  		decryptToStream.Dispose ();  	if (decryptTarget != null)  		decryptTarget.Dispose ();  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The following statement contains a magic number: if (useDecrypter != null) {  	linkForkDecryptor = new DirectStreamLink (1 << 16' false' false' nextTierWriter);  	nextTierWriter = linkForkDecryptor.WriterStream;  	linkForkDecryptor.SetKnownLength (item.Size' false);  	// Set length to allow AES-decryption (not streamable yet)  	decryptTarget = new TempFile ();  	decryptToStream = System.IO.File.OpenWrite (decryptTarget);  	taskDecrypter = new System.Threading.Tasks.Task (() => {  		using (var input = linkForkDecryptor.ReaderStream)  			using (var output = decryptToStream)  				lock (m_encryptionLock) {  					useDecrypter.Decrypt (input' output);  				}  	});  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The following statement contains a magic number: linkForkDecryptor = new DirectStreamLink (1 << 16' false' false' nextTierWriter);  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,coreDoGetPiping,The following statement contains a magic number: linkForkHasher = new DirectStreamLink (1 << 16' false' false' nextTierWriter);  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Dispose,The following statement contains a magic number: if (m_thread != null) {  	if (!m_thread.Join (TimeSpan.FromSeconds (10))) {  		m_thread.Abort ();  		m_thread.Join (TimeSpan.FromSeconds (10));  	}  	m_thread = null;  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Dispose,The following statement contains a magic number: if (m_thread != null) {  	if (!m_thread.Join (TimeSpan.FromSeconds (10))) {  		m_thread.Abort ();  		m_thread.Join (TimeSpan.FromSeconds (10));  	}  	m_thread = null;  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Dispose,The following statement contains a magic number: if (!m_thread.Join (TimeSpan.FromSeconds (10))) {  	m_thread.Abort ();  	m_thread.Join (TimeSpan.FromSeconds (10));  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Dispose,The following statement contains a magic number: if (!m_thread.Join (TimeSpan.FromSeconds (10))) {  	m_thread.Abort ();  	m_thread.Join (TimeSpan.FromSeconds (10));  }  
Magic Number,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,Dispose,The following statement contains a magic number: m_thread.Join (TimeSpan.FromSeconds (10));  
Magic Number,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The following statement contains a magic number: if (options.NoEncryption) {  	newDict.Add ("passphrase"' "no-encryption");  } else {  	string salt;  	opts.TryGetValue ("passphrase-salt"' out salt);  	if (string.IsNullOrEmpty (salt)) {  		// Not Crypto-class PRNG salts  		var buf = new byte[32];  		new Random ().NextBytes (buf);  		//Add version so we can detect and change the algorithm  		salt = "v1:" + Library.Utility.Utility.ByteArrayAsHexString (buf);  	}  	newDict ["passphrase-salt"] = salt;  	// We avoid storing the passphrase directly'   	// instead we salt and rehash repeatedly  	newDict.Add ("passphrase"' Library.Utility.Utility.ByteArrayAsHexString (Library.Utility.Utility.RepeatedHashWithSalt (options.Passphrase' salt' 1200)));  }  
Magic Number,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The following statement contains a magic number: if (options.NoEncryption) {  	newDict.Add ("passphrase"' "no-encryption");  } else {  	string salt;  	opts.TryGetValue ("passphrase-salt"' out salt);  	if (string.IsNullOrEmpty (salt)) {  		// Not Crypto-class PRNG salts  		var buf = new byte[32];  		new Random ().NextBytes (buf);  		//Add version so we can detect and change the algorithm  		salt = "v1:" + Library.Utility.Utility.ByteArrayAsHexString (buf);  	}  	newDict ["passphrase-salt"] = salt;  	// We avoid storing the passphrase directly'   	// instead we salt and rehash repeatedly  	newDict.Add ("passphrase"' Library.Utility.Utility.ByteArrayAsHexString (Library.Utility.Utility.RepeatedHashWithSalt (options.Passphrase' salt' 1200)));  }  
Magic Number,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The following statement contains a magic number: if (string.IsNullOrEmpty (salt)) {  	// Not Crypto-class PRNG salts  	var buf = new byte[32];  	new Random ().NextBytes (buf);  	//Add version so we can detect and change the algorithm  	salt = "v1:" + Library.Utility.Utility.ByteArrayAsHexString (buf);  }  
Magic Number,Duplicati.Library.Main,Utility,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Utility.cs,VerifyParameters,The following statement contains a magic number: newDict.Add ("passphrase"' Library.Utility.Utility.ByteArrayAsHexString (Library.Utility.Utility.RepeatedHashWithSalt (options.Passphrase' salt' 1200)));  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (m_options != null && !m_options.AllowSleep) {  	if (Duplicati.Library.Utility.Utility.IsClientWindows) {  		try {  			Win32.SetThreadExecutionState (Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0));  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	} else if (Duplicati.Library.Utility.Utility.IsClientOSX) {  		if (isRunning) {  			try {  				if (m_caffeinate == null) {  					// -s prevents sleep on AC' -i prevents sleep generally  					var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  					psi.RedirectStandardInput = true;  					psi.UseShellExecute = false;  					m_caffeinate = System.Diagnostics.Process.Start (psi);  				}  			} catch (Exception ex) {  				Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  			}  		} else {  			try {  				if (m_caffeinate != null && !m_caffeinate.HasExited) {  					// Send CTRL+C  					m_caffeinate.StandardInput.Write ("\x3");  					m_caffeinate.StandardInput.Flush ();  					m_caffeinate.WaitForExit (500);  					if (!m_caffeinate.HasExited) {  						m_caffeinate.Kill ();  						m_caffeinate.WaitForExit (500);  						if (!m_caffeinate.HasExited)  							throw new Exception ("Failed to kill the caffeinate process");  					}  				}  			} catch (Exception ex) {  				Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (m_options != null && !m_options.AllowSleep) {  	if (Duplicati.Library.Utility.Utility.IsClientWindows) {  		try {  			Win32.SetThreadExecutionState (Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0));  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	} else if (Duplicati.Library.Utility.Utility.IsClientOSX) {  		if (isRunning) {  			try {  				if (m_caffeinate == null) {  					// -s prevents sleep on AC' -i prevents sleep generally  					var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  					psi.RedirectStandardInput = true;  					psi.UseShellExecute = false;  					m_caffeinate = System.Diagnostics.Process.Start (psi);  				}  			} catch (Exception ex) {  				Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  			}  		} else {  			try {  				if (m_caffeinate != null && !m_caffeinate.HasExited) {  					// Send CTRL+C  					m_caffeinate.StandardInput.Write ("\x3");  					m_caffeinate.StandardInput.Flush ();  					m_caffeinate.WaitForExit (500);  					if (!m_caffeinate.HasExited) {  						m_caffeinate.Kill ();  						m_caffeinate.WaitForExit (500);  						if (!m_caffeinate.HasExited)  							throw new Exception ("Failed to kill the caffeinate process");  					}  				}  			} catch (Exception ex) {  				Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (Duplicati.Library.Utility.Utility.IsClientWindows) {  	try {  		Win32.SetThreadExecutionState (Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0));  	} catch (Exception ex) {  		Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  	}  } else if (Duplicati.Library.Utility.Utility.IsClientOSX) {  	if (isRunning) {  		try {  			if (m_caffeinate == null) {  				// -s prevents sleep on AC' -i prevents sleep generally  				var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  				psi.RedirectStandardInput = true;  				psi.UseShellExecute = false;  				m_caffeinate = System.Diagnostics.Process.Start (psi);  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	} else {  		try {  			if (m_caffeinate != null && !m_caffeinate.HasExited) {  				// Send CTRL+C  				m_caffeinate.StandardInput.Write ("\x3");  				m_caffeinate.StandardInput.Flush ();  				m_caffeinate.WaitForExit (500);  				if (!m_caffeinate.HasExited) {  					m_caffeinate.Kill ();  					m_caffeinate.WaitForExit (500);  					if (!m_caffeinate.HasExited)  						throw new Exception ("Failed to kill the caffeinate process");  				}  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (Duplicati.Library.Utility.Utility.IsClientWindows) {  	try {  		Win32.SetThreadExecutionState (Win32.EXECUTION_STATE.ES_CONTINUOUS | (isRunning ? Win32.EXECUTION_STATE.ES_SYSTEM_REQUIRED : 0));  	} catch (Exception ex) {  		Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  	}  } else if (Duplicati.Library.Utility.Utility.IsClientOSX) {  	if (isRunning) {  		try {  			if (m_caffeinate == null) {  				// -s prevents sleep on AC' -i prevents sleep generally  				var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  				psi.RedirectStandardInput = true;  				psi.UseShellExecute = false;  				m_caffeinate = System.Diagnostics.Process.Start (psi);  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	} else {  		try {  			if (m_caffeinate != null && !m_caffeinate.HasExited) {  				// Send CTRL+C  				m_caffeinate.StandardInput.Write ("\x3");  				m_caffeinate.StandardInput.Flush ();  				m_caffeinate.WaitForExit (500);  				if (!m_caffeinate.HasExited) {  					m_caffeinate.Kill ();  					m_caffeinate.WaitForExit (500);  					if (!m_caffeinate.HasExited)  						throw new Exception ("Failed to kill the caffeinate process");  				}  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (Duplicati.Library.Utility.Utility.IsClientOSX) {  	if (isRunning) {  		try {  			if (m_caffeinate == null) {  				// -s prevents sleep on AC' -i prevents sleep generally  				var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  				psi.RedirectStandardInput = true;  				psi.UseShellExecute = false;  				m_caffeinate = System.Diagnostics.Process.Start (psi);  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	} else {  		try {  			if (m_caffeinate != null && !m_caffeinate.HasExited) {  				// Send CTRL+C  				m_caffeinate.StandardInput.Write ("\x3");  				m_caffeinate.StandardInput.Flush ();  				m_caffeinate.WaitForExit (500);  				if (!m_caffeinate.HasExited) {  					m_caffeinate.Kill ();  					m_caffeinate.WaitForExit (500);  					if (!m_caffeinate.HasExited)  						throw new Exception ("Failed to kill the caffeinate process");  				}  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (Duplicati.Library.Utility.Utility.IsClientOSX) {  	if (isRunning) {  		try {  			if (m_caffeinate == null) {  				// -s prevents sleep on AC' -i prevents sleep generally  				var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  				psi.RedirectStandardInput = true;  				psi.UseShellExecute = false;  				m_caffeinate = System.Diagnostics.Process.Start (psi);  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	} else {  		try {  			if (m_caffeinate != null && !m_caffeinate.HasExited) {  				// Send CTRL+C  				m_caffeinate.StandardInput.Write ("\x3");  				m_caffeinate.StandardInput.Flush ();  				m_caffeinate.WaitForExit (500);  				if (!m_caffeinate.HasExited) {  					m_caffeinate.Kill ();  					m_caffeinate.WaitForExit (500);  					if (!m_caffeinate.HasExited)  						throw new Exception ("Failed to kill the caffeinate process");  				}  			}  		} catch (Exception ex) {  			Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  		}  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (isRunning) {  	try {  		if (m_caffeinate == null) {  			// -s prevents sleep on AC' -i prevents sleep generally  			var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  			psi.RedirectStandardInput = true;  			psi.UseShellExecute = false;  			m_caffeinate = System.Diagnostics.Process.Start (psi);  		}  	} catch (Exception ex) {  		Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  	}  } else {  	try {  		if (m_caffeinate != null && !m_caffeinate.HasExited) {  			// Send CTRL+C  			m_caffeinate.StandardInput.Write ("\x3");  			m_caffeinate.StandardInput.Flush ();  			m_caffeinate.WaitForExit (500);  			if (!m_caffeinate.HasExited) {  				m_caffeinate.Kill ();  				m_caffeinate.WaitForExit (500);  				if (!m_caffeinate.HasExited)  					throw new Exception ("Failed to kill the caffeinate process");  			}  		}  	} catch (Exception ex) {  		Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (isRunning) {  	try {  		if (m_caffeinate == null) {  			// -s prevents sleep on AC' -i prevents sleep generally  			var psi = new System.Diagnostics.ProcessStartInfo ("caffeinate"' "-s");  			psi.RedirectStandardInput = true;  			psi.UseShellExecute = false;  			m_caffeinate = System.Diagnostics.Process.Start (psi);  		}  	} catch (Exception ex) {  		Logging.Log.WriteMessage ("Failed to set sleep prevention"' Logging.LogMessageType.Warning' ex);  	}  } else {  	try {  		if (m_caffeinate != null && !m_caffeinate.HasExited) {  			// Send CTRL+C  			m_caffeinate.StandardInput.Write ("\x3");  			m_caffeinate.StandardInput.Flush ();  			m_caffeinate.WaitForExit (500);  			if (!m_caffeinate.HasExited) {  				m_caffeinate.Kill ();  				m_caffeinate.WaitForExit (500);  				if (!m_caffeinate.HasExited)  					throw new Exception ("Failed to kill the caffeinate process");  			}  		}  	} catch (Exception ex) {  		Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: try {  	if (m_caffeinate != null && !m_caffeinate.HasExited) {  		// Send CTRL+C  		m_caffeinate.StandardInput.Write ("\x3");  		m_caffeinate.StandardInput.Flush ();  		m_caffeinate.WaitForExit (500);  		if (!m_caffeinate.HasExited) {  			m_caffeinate.Kill ();  			m_caffeinate.WaitForExit (500);  			if (!m_caffeinate.HasExited)  				throw new Exception ("Failed to kill the caffeinate process");  		}  	}  } catch (Exception ex) {  	Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: try {  	if (m_caffeinate != null && !m_caffeinate.HasExited) {  		// Send CTRL+C  		m_caffeinate.StandardInput.Write ("\x3");  		m_caffeinate.StandardInput.Flush ();  		m_caffeinate.WaitForExit (500);  		if (!m_caffeinate.HasExited) {  			m_caffeinate.Kill ();  			m_caffeinate.WaitForExit (500);  			if (!m_caffeinate.HasExited)  				throw new Exception ("Failed to kill the caffeinate process");  		}  	}  } catch (Exception ex) {  	Logging.Log.WriteMessage ("Failed to unset sleep prevention"' Logging.LogMessageType.Warning' ex);  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (m_caffeinate != null && !m_caffeinate.HasExited) {  	// Send CTRL+C  	m_caffeinate.StandardInput.Write ("\x3");  	m_caffeinate.StandardInput.Flush ();  	m_caffeinate.WaitForExit (500);  	if (!m_caffeinate.HasExited) {  		m_caffeinate.Kill ();  		m_caffeinate.WaitForExit (500);  		if (!m_caffeinate.HasExited)  			throw new Exception ("Failed to kill the caffeinate process");  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (m_caffeinate != null && !m_caffeinate.HasExited) {  	// Send CTRL+C  	m_caffeinate.StandardInput.Write ("\x3");  	m_caffeinate.StandardInput.Flush ();  	m_caffeinate.WaitForExit (500);  	if (!m_caffeinate.HasExited) {  		m_caffeinate.Kill ();  		m_caffeinate.WaitForExit (500);  		if (!m_caffeinate.HasExited)  			throw new Exception ("Failed to kill the caffeinate process");  	}  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: m_caffeinate.WaitForExit (500);  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: if (!m_caffeinate.HasExited) {  	m_caffeinate.Kill ();  	m_caffeinate.WaitForExit (500);  	if (!m_caffeinate.HasExited)  		throw new Exception ("Failed to kill the caffeinate process");  }  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,OperationRunning,The following statement contains a magic number: m_caffeinate.WaitForExit (500);  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SendMail,The following statement contains a magic number: return RunAction (new SendMailResults ()' result => {  	result.Lines = new string[0];  	System.Threading.Thread.Sleep (5);  });  
Magic Number,Duplicati.Library.Main,Controller,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Controller.cs,SendMail,The following statement contains a magic number: System.Threading.Thread.Sleep (5);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: m_entries = Math.Max (16' maxmemory / (ulong)IntPtr.Size);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 10; i++)  	HEXTB ['0' + i] = i;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 6; i++) {  	//Case insensitive support  	HEXTB ['A' + i] = (byte)(i + 10);  	HEXTB ['a' + i] = (byte)(i + 10);  }  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 6; i++) {  	//Case insensitive support  	HEXTB ['A' + i] = (byte)(i + 10);  	HEXTB ['a' + i] = (byte)(i + 10);  }  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 6; i++) {  	//Case insensitive support  	HEXTB ['A' + i] = (byte)(i + 10);  	HEXTB ['a' + i] = (byte)(i + 10);  }  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: HEXTB ['A' + i] = (byte)(i + 10);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: HEXTB ['a' + i] = (byte)(i + 10);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 26; i++)  	BAS64TB ['A' + i] = i;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 26; i++)  	BAS64TB ['a' + i] = (byte)(i + 26);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 26; i++)  	BAS64TB ['a' + i] = (byte)(i + 26);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB ['a' + i] = (byte)(i + 26);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 10; i++)  	BAS64TB ['0' + i] = (byte)(i + 52);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: for (byte i = 0; i < 10; i++)  	BAS64TB ['0' + i] = (byte)(i + 52);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB ['0' + i] = (byte)(i + 52);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB ['+'] = 62;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB ['/'] = 63;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB ['-'] = 62;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,HashLookupHelper,The following statement contains a magic number: BAS64TB ['_'] = 63;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,ConvertEndianness,The following statement contains a magic number: return ((value << 56) & 0xff00000000000000uL) | ((value << 40) & 0x00ff000000000000uL) | ((value << 24) & 0x0000ff0000000000uL) | ((value << 8) & 0x000000ff00000000uL) | ((value >> 8) & 0x00000000ff000000uL) | ((value >> 24) & 0x0000000000ff0000uL) | ((value >> 40) & 0x000000000000ff00uL) | ((value >> 56) & 0x00000000000000ffuL);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeHexHash,The following statement contains a magic number: return (ulong)HEXTB [hash [0]] << 60 | (ulong)HEXTB [hash [1]] << 56 | (ulong)HEXTB [hash [2]] << 52 | (ulong)HEXTB [hash [3]] << 48 | (ulong)HEXTB [hash [4]] << 44 | (ulong)HEXTB [hash [5]] << 40 | (ulong)HEXTB [hash [6]] << 36 | (ulong)HEXTB [hash [7]] << 32 | (ulong)HEXTB [hash [8]] << 28 | (ulong)HEXTB [hash [9]] << 24 | (ulong)HEXTB [hash [10]] << 20 | (ulong)HEXTB [hash [11]] << 16 | (ulong)HEXTB [hash [12]] << 12 | (ulong)HEXTB [hash [13]] << 8 | (ulong)HEXTB [hash [14]] << 4 | (ulong)HEXTB [hash [15]] << 0;  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main,HashLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\HashLookupHelper.cs,DecodeBase64Hash,The following statement contains a magic number: return (ulong)BAS64TB [hash [0]] << 58 | (ulong)BAS64TB [hash [1]] << 52 | (ulong)BAS64TB [hash [2]] << 46 | (ulong)BAS64TB [hash [3]] << 40 | (ulong)BAS64TB [hash [4]] << 34 | (ulong)BAS64TB [hash [5]] << 28 | (ulong)BAS64TB [hash [6]] << 22 | (ulong)BAS64TB [hash [7]] << 16 | (ulong)BAS64TB [hash [8]] << 10 | (ulong)BAS64TB [hash [9]] << 4 | (((ulong)BAS64TB [hash [10]] >> 2) & 0x0f);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findblockCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findblocksetCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findmetadatasetCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_findfilesetCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblockCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertfileOperationCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertfileCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocksetCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocksetentryFastCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocksetentryCommand.AddParameters (4);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_insertblocklistHashesCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,LocalBackupDatabase,The following statement contains a magic number: m_selectfilelastmodifiedCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	//Need a temporary table with path/lastmodified lookups  	var scantableDefinition = @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A1"" LEFT JOIN " + @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " + @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " + @" WHERE ""A2"".""Path"" IS NULL " + @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " + @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " + @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";  	if (m_pathLookup != null)  		using (new Logging.Timer ("Build path lastmodified lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  				while (rd.Read ()) {  					var id = rd.GetInt64 (0);  					var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  					var filesize = rd.GetInt64 (2);  					var path = rd.GetString (3);  					var metahash = rd.GetString (4);  					var metasize = rd.GetInt64 (5);  					m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  				}  	if (m_pathLookup != null)  		try {  			using (new Logging.Timer ("Build path lookup table"))  				using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  					while (rd.Read ()) {  						var path = rd.GetValue (0).ToString ();  						var blocksetid = rd.GetInt64 (1);  						var metadataid = rd.GetInt64 (2);  						var filesetid = rd.GetInt64 (3);  						PathEntryKeeper r;  						if (!m_pathLookup.TryFind (path' out r)) {  							r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  							r.AddFilesetID (blocksetid' metadataid' filesetid);  							m_pathLookup.Insert (path' r);  						} else  							r.AddFilesetID (blocksetid' metadataid' filesetid);  					}  		} catch (Exception ex) {  			throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  		}  	var tc = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString ()' RemoteVolumeState.Uploading.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (tc > 0)  		throw new InvalidDataException ("Detected blocks that are not reachable in the block table");  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	//Need a temporary table with path/lastmodified lookups  	var scantableDefinition = @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A1"" LEFT JOIN " + @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " + @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " + @" WHERE ""A2"".""Path"" IS NULL " + @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " + @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " + @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";  	if (m_pathLookup != null)  		using (new Logging.Timer ("Build path lastmodified lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  				while (rd.Read ()) {  					var id = rd.GetInt64 (0);  					var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  					var filesize = rd.GetInt64 (2);  					var path = rd.GetString (3);  					var metahash = rd.GetString (4);  					var metasize = rd.GetInt64 (5);  					m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  				}  	if (m_pathLookup != null)  		try {  			using (new Logging.Timer ("Build path lookup table"))  				using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  					while (rd.Read ()) {  						var path = rd.GetValue (0).ToString ();  						var blocksetid = rd.GetInt64 (1);  						var metadataid = rd.GetInt64 (2);  						var filesetid = rd.GetInt64 (3);  						PathEntryKeeper r;  						if (!m_pathLookup.TryFind (path' out r)) {  							r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  							r.AddFilesetID (blocksetid' metadataid' filesetid);  							m_pathLookup.Insert (path' r);  						} else  							r.AddFilesetID (blocksetid' metadataid' filesetid);  					}  		} catch (Exception ex) {  			throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  		}  	var tc = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString ()' RemoteVolumeState.Uploading.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (tc > 0)  		throw new InvalidDataException ("Detected blocks that are not reachable in the block table");  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	//Need a temporary table with path/lastmodified lookups  	var scantableDefinition = @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A1"" LEFT JOIN " + @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " + @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " + @" WHERE ""A2"".""Path"" IS NULL " + @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " + @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " + @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";  	if (m_pathLookup != null)  		using (new Logging.Timer ("Build path lastmodified lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  				while (rd.Read ()) {  					var id = rd.GetInt64 (0);  					var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  					var filesize = rd.GetInt64 (2);  					var path = rd.GetString (3);  					var metahash = rd.GetString (4);  					var metasize = rd.GetInt64 (5);  					m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  				}  	if (m_pathLookup != null)  		try {  			using (new Logging.Timer ("Build path lookup table"))  				using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  					while (rd.Read ()) {  						var path = rd.GetValue (0).ToString ();  						var blocksetid = rd.GetInt64 (1);  						var metadataid = rd.GetInt64 (2);  						var filesetid = rd.GetInt64 (3);  						PathEntryKeeper r;  						if (!m_pathLookup.TryFind (path' out r)) {  							r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  							r.AddFilesetID (blocksetid' metadataid' filesetid);  							m_pathLookup.Insert (path' r);  						} else  							r.AddFilesetID (blocksetid' metadataid' filesetid);  					}  		} catch (Exception ex) {  			throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  		}  	var tc = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString ()' RemoteVolumeState.Uploading.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (tc > 0)  		throw new InvalidDataException ("Detected blocks that are not reachable in the block table");  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	//Need a temporary table with path/lastmodified lookups  	var scantableDefinition = @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A1"" LEFT JOIN " + @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " + @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " + @" WHERE ""A2"".""Path"" IS NULL " + @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " + @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " + @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";  	if (m_pathLookup != null)  		using (new Logging.Timer ("Build path lastmodified lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  				while (rd.Read ()) {  					var id = rd.GetInt64 (0);  					var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  					var filesize = rd.GetInt64 (2);  					var path = rd.GetString (3);  					var metahash = rd.GetString (4);  					var metasize = rd.GetInt64 (5);  					m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  				}  	if (m_pathLookup != null)  		try {  			using (new Logging.Timer ("Build path lookup table"))  				using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  					while (rd.Read ()) {  						var path = rd.GetValue (0).ToString ();  						var blocksetid = rd.GetInt64 (1);  						var metadataid = rd.GetInt64 (2);  						var filesetid = rd.GetInt64 (3);  						PathEntryKeeper r;  						if (!m_pathLookup.TryFind (path' out r)) {  							r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  							r.AddFilesetID (blocksetid' metadataid' filesetid);  							m_pathLookup.Insert (path' r);  						} else  							r.AddFilesetID (blocksetid' metadataid' filesetid);  					}  		} catch (Exception ex) {  			throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  		}  	var tc = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString ()' RemoteVolumeState.Uploading.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (tc > 0)  		throw new InvalidDataException ("Detected blocks that are not reachable in the block table");  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	//Need a temporary table with path/lastmodified lookups  	var scantableDefinition = @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A1"" LEFT JOIN " + @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " + @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " + @" WHERE ""A2"".""Path"" IS NULL " + @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " + @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " + @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";  	if (m_pathLookup != null)  		using (new Logging.Timer ("Build path lastmodified lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  				while (rd.Read ()) {  					var id = rd.GetInt64 (0);  					var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  					var filesize = rd.GetInt64 (2);  					var path = rd.GetString (3);  					var metahash = rd.GetString (4);  					var metasize = rd.GetInt64 (5);  					m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  				}  	if (m_pathLookup != null)  		try {  			using (new Logging.Timer ("Build path lookup table"))  				using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  					while (rd.Read ()) {  						var path = rd.GetValue (0).ToString ();  						var blocksetid = rd.GetInt64 (1);  						var metadataid = rd.GetInt64 (2);  						var filesetid = rd.GetInt64 (3);  						PathEntryKeeper r;  						if (!m_pathLookup.TryFind (path' out r)) {  							r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  							r.AddFilesetID (blocksetid' metadataid' filesetid);  							m_pathLookup.Insert (path' r);  						} else  							r.AddFilesetID (blocksetid' metadataid' filesetid);  					}  		} catch (Exception ex) {  			throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  		}  	var tc = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString ()' RemoteVolumeState.Uploading.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (tc > 0)  		throw new InvalidDataException ("Detected blocks that are not reachable in the block table");  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	//Need a temporary table with path/lastmodified lookups  	var scantableDefinition = @"SELECT ""A1"".""ID"" AS ""FileID""' ""A1"".""Lastmodified"" AS ""Lastmodified""' ""A1"".""Path"" AS ""Path""' ""C"".""Length"" AS ""Length""' ""F"".""Fullhash"" AS ""Metahash""' ""F"".""Length"" AS ""Metasize""' ""A1"".""BlocksetID"" " + @"  FROM (SELECT ""File"".""ID""' ""File"".""BlocksetID""' ""File"".""MetadataID""' ""FilesetEntry"".""Lastmodified""' ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"          FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A1"" LEFT JOIN " + @"       (SELECT ""File"".""Path""' ""Fileset"".""Timestamp"" " + @"           FROM ""FilesetEntry""' ""Fileset""' ""File"" WHERE ""Fileset"".""ID"" = ""FilesetEntry"".""FilesetID"" AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" " + @"       ) ""A2"" ON ""A1"".""Path"" = ""A2"".""Path"" AND ""A1"".""Timestamp"" < ""A2"".""Timestamp"" " + @"       ' ""Blockset"" ""C""' ""Metadataset"" ""E""' ""Blockset"" ""F"" " + @" WHERE ""A2"".""Path"" IS NULL " + @"   AND ""C"".""ID"" = ""A1"".""BlocksetID"" " + @"   AND ""A1"".""MetadataID"" = ""E"".""ID"" " + @"   AND ""F"".""ID"" = ""E"".""BlocksetID"" ";  	if (m_pathLookup != null)  		using (new Logging.Timer ("Build path lastmodified lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  				while (rd.Read ()) {  					var id = rd.GetInt64 (0);  					var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  					var filesize = rd.GetInt64 (2);  					var path = rd.GetString (3);  					var metahash = rd.GetString (4);  					var metasize = rd.GetInt64 (5);  					m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  				}  	if (m_pathLookup != null)  		try {  			using (new Logging.Timer ("Build path lookup table"))  				using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  					while (rd.Read ()) {  						var path = rd.GetValue (0).ToString ();  						var blocksetid = rd.GetInt64 (1);  						var metadataid = rd.GetInt64 (2);  						var filesetid = rd.GetInt64 (3);  						PathEntryKeeper r;  						if (!m_pathLookup.TryFind (path' out r)) {  							r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  							r.AddFilesetID (blocksetid' metadataid' filesetid);  							m_pathLookup.Insert (path' r);  						} else  							r.AddFilesetID (blocksetid' metadataid' filesetid);  					}  		} catch (Exception ex) {  			throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  		}  	var tc = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""Remotevolume"" WHERE ""ID"" IN (SELECT DISTINCT ""VolumeID"" FROM ""Block"") AND ""State"" NOT IN (?' ?' ?' ?);"' 0' RemoteVolumeState.Temporary.ToString ()' RemoteVolumeState.Uploading.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (tc > 0)  		throw new InvalidDataException ("Detected blocks that are not reachable in the block table");  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: if (m_pathLookup != null)  	using (new Logging.Timer ("Build path lastmodified lookup table"))  		using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  			while (rd.Read ()) {  				var id = rd.GetInt64 (0);  				var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  				var filesize = rd.GetInt64 (2);  				var path = rd.GetString (3);  				var metahash = rd.GetString (4);  				var metasize = rd.GetInt64 (5);  				m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  			}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: if (m_pathLookup != null)  	using (new Logging.Timer ("Build path lastmodified lookup table"))  		using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  			while (rd.Read ()) {  				var id = rd.GetInt64 (0);  				var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  				var filesize = rd.GetInt64 (2);  				var path = rd.GetString (3);  				var metahash = rd.GetString (4);  				var metasize = rd.GetInt64 (5);  				m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  			}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: if (m_pathLookup != null)  	using (new Logging.Timer ("Build path lastmodified lookup table"))  		using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  			while (rd.Read ()) {  				var id = rd.GetInt64 (0);  				var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  				var filesize = rd.GetInt64 (2);  				var path = rd.GetString (3);  				var metahash = rd.GetString (4);  				var metasize = rd.GetInt64 (5);  				m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  			}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: if (m_pathLookup != null)  	using (new Logging.Timer ("Build path lastmodified lookup table"))  		using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  			while (rd.Read ()) {  				var id = rd.GetInt64 (0);  				var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  				var filesize = rd.GetInt64 (2);  				var path = rd.GetString (3);  				var metahash = rd.GetString (4);  				var metasize = rd.GetInt64 (5);  				m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  			}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (new Logging.Timer ("Build path lastmodified lookup table"))  	using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  		while (rd.Read ()) {  			var id = rd.GetInt64 (0);  			var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  			var filesize = rd.GetInt64 (2);  			var path = rd.GetString (3);  			var metahash = rd.GetString (4);  			var metasize = rd.GetInt64 (5);  			m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  		}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (new Logging.Timer ("Build path lastmodified lookup table"))  	using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  		while (rd.Read ()) {  			var id = rd.GetInt64 (0);  			var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  			var filesize = rd.GetInt64 (2);  			var path = rd.GetString (3);  			var metahash = rd.GetString (4);  			var metasize = rd.GetInt64 (5);  			m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  		}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (new Logging.Timer ("Build path lastmodified lookup table"))  	using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  		while (rd.Read ()) {  			var id = rd.GetInt64 (0);  			var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  			var filesize = rd.GetInt64 (2);  			var path = rd.GetString (3);  			var metahash = rd.GetString (4);  			var metasize = rd.GetInt64 (5);  			m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  		}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (new Logging.Timer ("Build path lastmodified lookup table"))  	using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  		while (rd.Read ()) {  			var id = rd.GetInt64 (0);  			var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  			var filesize = rd.GetInt64 (2);  			var path = rd.GetString (3);  			var metahash = rd.GetString (4);  			var metasize = rd.GetInt64 (5);  			m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  		}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  	while (rd.Read ()) {  		var id = rd.GetInt64 (0);  		var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  		var filesize = rd.GetInt64 (2);  		var path = rd.GetString (3);  		var metahash = rd.GetString (4);  		var metasize = rd.GetInt64 (5);  		m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  	while (rd.Read ()) {  		var id = rd.GetInt64 (0);  		var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  		var filesize = rd.GetInt64 (2);  		var path = rd.GetString (3);  		var metahash = rd.GetString (4);  		var metasize = rd.GetInt64 (5);  		m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  	while (rd.Read ()) {  		var id = rd.GetInt64 (0);  		var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  		var filesize = rd.GetInt64 (2);  		var path = rd.GetString (3);  		var metahash = rd.GetString (4);  		var metasize = rd.GetInt64 (5);  		m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""FileID""' ""Lastmodified""' ""Length""' ""Path""' ""Metahash""' ""Metasize"" FROM ({0}) WHERE ""BlocksetID"" >= 0 "' scantableDefinition)))  	while (rd.Read ()) {  		var id = rd.GetInt64 (0);  		var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  		var filesize = rd.GetInt64 (2);  		var path = rd.GetString (3);  		var metahash = rd.GetString (4);  		var metasize = rd.GetInt64 (5);  		m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: while (rd.Read ()) {  	var id = rd.GetInt64 (0);  	var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  	var filesize = rd.GetInt64 (2);  	var path = rd.GetString (3);  	var metahash = rd.GetString (4);  	var metasize = rd.GetInt64 (5);  	m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: while (rd.Read ()) {  	var id = rd.GetInt64 (0);  	var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  	var filesize = rd.GetInt64 (2);  	var path = rd.GetString (3);  	var metahash = rd.GetString (4);  	var metasize = rd.GetInt64 (5);  	m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: while (rd.Read ()) {  	var id = rd.GetInt64 (0);  	var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  	var filesize = rd.GetInt64 (2);  	var path = rd.GetString (3);  	var metahash = rd.GetString (4);  	var metasize = rd.GetInt64 (5);  	m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: while (rd.Read ()) {  	var id = rd.GetInt64 (0);  	var lastmodified = new DateTime (rd.GetInt64 (1)' DateTimeKind.Utc);  	var filesize = rd.GetInt64 (2);  	var path = rd.GetString (3);  	var metahash = rd.GetString (4);  	var metasize = rd.GetInt64 (5);  	m_pathLookup.Insert (path' new PathEntryKeeper (id' lastmodified' filesize' metahash' metasize));  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: if (m_pathLookup != null)  	try {  		using (new Logging.Timer ("Build path lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  				while (rd.Read ()) {  					var path = rd.GetValue (0).ToString ();  					var blocksetid = rd.GetInt64 (1);  					var metadataid = rd.GetInt64 (2);  					var filesetid = rd.GetInt64 (3);  					PathEntryKeeper r;  					if (!m_pathLookup.TryFind (path' out r)) {  						r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  						r.AddFilesetID (blocksetid' metadataid' filesetid);  						m_pathLookup.Insert (path' r);  					} else  						r.AddFilesetID (blocksetid' metadataid' filesetid);  				}  	} catch (Exception ex) {  		throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: if (m_pathLookup != null)  	try {  		using (new Logging.Timer ("Build path lookup table"))  			using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  				while (rd.Read ()) {  					var path = rd.GetValue (0).ToString ();  					var blocksetid = rd.GetInt64 (1);  					var metadataid = rd.GetInt64 (2);  					var filesetid = rd.GetInt64 (3);  					PathEntryKeeper r;  					if (!m_pathLookup.TryFind (path' out r)) {  						r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  						r.AddFilesetID (blocksetid' metadataid' filesetid);  						m_pathLookup.Insert (path' r);  					} else  						r.AddFilesetID (blocksetid' metadataid' filesetid);  				}  	} catch (Exception ex) {  		throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: try {  	using (new Logging.Timer ("Build path lookup table"))  		using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  			while (rd.Read ()) {  				var path = rd.GetValue (0).ToString ();  				var blocksetid = rd.GetInt64 (1);  				var metadataid = rd.GetInt64 (2);  				var filesetid = rd.GetInt64 (3);  				PathEntryKeeper r;  				if (!m_pathLookup.TryFind (path' out r)) {  					r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  					r.AddFilesetID (blocksetid' metadataid' filesetid);  					m_pathLookup.Insert (path' r);  				} else  					r.AddFilesetID (blocksetid' metadataid' filesetid);  			}  } catch (Exception ex) {  	throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: try {  	using (new Logging.Timer ("Build path lookup table"))  		using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  			while (rd.Read ()) {  				var path = rd.GetValue (0).ToString ();  				var blocksetid = rd.GetInt64 (1);  				var metadataid = rd.GetInt64 (2);  				var filesetid = rd.GetInt64 (3);  				PathEntryKeeper r;  				if (!m_pathLookup.TryFind (path' out r)) {  					r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  					r.AddFilesetID (blocksetid' metadataid' filesetid);  					m_pathLookup.Insert (path' r);  				} else  					r.AddFilesetID (blocksetid' metadataid' filesetid);  			}  } catch (Exception ex) {  	throw new InvalidDataException ("Duplicate file entries detected' run repair to fix it"' ex);  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (new Logging.Timer ("Build path lookup table"))  	using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  		while (rd.Read ()) {  			var path = rd.GetValue (0).ToString ();  			var blocksetid = rd.GetInt64 (1);  			var metadataid = rd.GetInt64 (2);  			var filesetid = rd.GetInt64 (3);  			PathEntryKeeper r;  			if (!m_pathLookup.TryFind (path' out r)) {  				r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  				r.AddFilesetID (blocksetid' metadataid' filesetid);  				m_pathLookup.Insert (path' r);  			} else  				r.AddFilesetID (blocksetid' metadataid' filesetid);  		}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (new Logging.Timer ("Build path lookup table"))  	using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  		while (rd.Read ()) {  			var path = rd.GetValue (0).ToString ();  			var blocksetid = rd.GetInt64 (1);  			var metadataid = rd.GetInt64 (2);  			var filesetid = rd.GetInt64 (3);  			PathEntryKeeper r;  			if (!m_pathLookup.TryFind (path' out r)) {  				r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  				r.AddFilesetID (blocksetid' metadataid' filesetid);  				m_pathLookup.Insert (path' r);  			} else  				r.AddFilesetID (blocksetid' metadataid' filesetid);  		}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  	while (rd.Read ()) {  		var path = rd.GetValue (0).ToString ();  		var blocksetid = rd.GetInt64 (1);  		var metadataid = rd.GetInt64 (2);  		var filesetid = rd.GetInt64 (3);  		PathEntryKeeper r;  		if (!m_pathLookup.TryFind (path' out r)) {  			r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  			r.AddFilesetID (blocksetid' metadataid' filesetid);  			m_pathLookup.Insert (path' r);  		} else  			r.AddFilesetID (blocksetid' metadataid' filesetid);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@" SELECT ""Path""' ""BlocksetID""' ""MetadataID""' ""ID"" FROM ""File"" ")))  	while (rd.Read ()) {  		var path = rd.GetValue (0).ToString ();  		var blocksetid = rd.GetInt64 (1);  		var metadataid = rd.GetInt64 (2);  		var filesetid = rd.GetInt64 (3);  		PathEntryKeeper r;  		if (!m_pathLookup.TryFind (path' out r)) {  			r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  			r.AddFilesetID (blocksetid' metadataid' filesetid);  			m_pathLookup.Insert (path' r);  		} else  			r.AddFilesetID (blocksetid' metadataid' filesetid);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: while (rd.Read ()) {  	var path = rd.GetValue (0).ToString ();  	var blocksetid = rd.GetInt64 (1);  	var metadataid = rd.GetInt64 (2);  	var filesetid = rd.GetInt64 (3);  	PathEntryKeeper r;  	if (!m_pathLookup.TryFind (path' out r)) {  		r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  		r.AddFilesetID (blocksetid' metadataid' filesetid);  		m_pathLookup.Insert (path' r);  	} else  		r.AddFilesetID (blocksetid' metadataid' filesetid);  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,BuildLookupTable,The following statement contains a magic number: while (rd.Read ()) {  	var path = rd.GetValue (0).ToString ();  	var blocksetid = rd.GetInt64 (1);  	var metadataid = rd.GetInt64 (2);  	var filesetid = rd.GetInt64 (3);  	PathEntryKeeper r;  	if (!m_pathLookup.TryFind (path' out r)) {  		r = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  		r.AddFilesetID (blocksetid' metadataid' filesetid);  		m_pathLookup.Insert (path' r);  	} else  		r.AddFilesetID (blocksetid' metadataid' filesetid);  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlock,The following statement contains a magic number: if (r == -1L) {  	m_insertblockCommand.Transaction = transaction;  	m_insertblockCommand.SetParameterValue (0' key);  	m_insertblockCommand.SetParameterValue (1' volumeid);  	m_insertblockCommand.SetParameterValue (2' size);  	r = m_insertblockCommand.ExecuteScalarInt64 ();  	return true;  } else {  	//Update lookup cache if required  	return false;  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlock,The following statement contains a magic number: m_insertblockCommand.SetParameterValue (2' size);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_insertblocksetCommand.Transaction = tr.Parent;  	m_insertblocksetCommand.SetParameterValue (0' size);  	m_insertblocksetCommand.SetParameterValue (1' filehash);  	blocksetid = m_insertblocksetCommand.ExecuteScalarInt64 ();  	long ix = 0;  	if (blocklistHashes != null) {  		m_insertblocklistHashesCommand.SetParameterValue (0' blocksetid);  		m_insertblocklistHashesCommand.Transaction = tr.Parent;  		foreach (var bh in blocklistHashes) {  			m_insertblocklistHashesCommand.SetParameterValue (1' ix);  			m_insertblocklistHashesCommand.SetParameterValue (2' bh);  			m_insertblocklistHashesCommand.ExecuteNonQuery ();  			ix++;  		}  	}  	m_insertblocksetentryCommand.SetParameterValue (0' blocksetid);  	m_insertblocksetentryCommand.Transaction = tr.Parent;  	m_insertblocksetentryFastCommand.SetParameterValue (0' blocksetid);  	m_insertblocksetentryFastCommand.Transaction = tr.Parent;  	ix = 0;  	long remainsize = size;  	foreach (var h in hashes) {  		var exsize = remainsize < blocksize ? remainsize : blocksize;  		m_insertblocksetentryCommand.SetParameterValue (1' ix);  		m_insertblocksetentryCommand.SetParameterValue (2' h);  		m_insertblocksetentryCommand.SetParameterValue (3' exsize);  		var c = m_insertblocksetentryCommand.ExecuteNonQuery ();  		if (c != 1) {  			m_result.AddError (string.Format ("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);  			using (var cmd = m_connection.CreateCommand (tr.Parent)) {  				var bid = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);  				if (bid == -1)  					throw new Exception (string.Format ("Could not find any blocks with the given hash: {0}"' h));  				foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))  					m_result.AddError (string.Format ("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64 (0' -1))' null);  			}  			throw new Exception (string.Format ("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));  		}  		ix++;  		remainsize -= blocksize;  	}  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_insertblocksetCommand.Transaction = tr.Parent;  	m_insertblocksetCommand.SetParameterValue (0' size);  	m_insertblocksetCommand.SetParameterValue (1' filehash);  	blocksetid = m_insertblocksetCommand.ExecuteScalarInt64 ();  	long ix = 0;  	if (blocklistHashes != null) {  		m_insertblocklistHashesCommand.SetParameterValue (0' blocksetid);  		m_insertblocklistHashesCommand.Transaction = tr.Parent;  		foreach (var bh in blocklistHashes) {  			m_insertblocklistHashesCommand.SetParameterValue (1' ix);  			m_insertblocklistHashesCommand.SetParameterValue (2' bh);  			m_insertblocklistHashesCommand.ExecuteNonQuery ();  			ix++;  		}  	}  	m_insertblocksetentryCommand.SetParameterValue (0' blocksetid);  	m_insertblocksetentryCommand.Transaction = tr.Parent;  	m_insertblocksetentryFastCommand.SetParameterValue (0' blocksetid);  	m_insertblocksetentryFastCommand.Transaction = tr.Parent;  	ix = 0;  	long remainsize = size;  	foreach (var h in hashes) {  		var exsize = remainsize < blocksize ? remainsize : blocksize;  		m_insertblocksetentryCommand.SetParameterValue (1' ix);  		m_insertblocksetentryCommand.SetParameterValue (2' h);  		m_insertblocksetentryCommand.SetParameterValue (3' exsize);  		var c = m_insertblocksetentryCommand.ExecuteNonQuery ();  		if (c != 1) {  			m_result.AddError (string.Format ("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);  			using (var cmd = m_connection.CreateCommand (tr.Parent)) {  				var bid = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);  				if (bid == -1)  					throw new Exception (string.Format ("Could not find any blocks with the given hash: {0}"' h));  				foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))  					m_result.AddError (string.Format ("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64 (0' -1))' null);  			}  			throw new Exception (string.Format ("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));  		}  		ix++;  		remainsize -= blocksize;  	}  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_insertblocksetCommand.Transaction = tr.Parent;  	m_insertblocksetCommand.SetParameterValue (0' size);  	m_insertblocksetCommand.SetParameterValue (1' filehash);  	blocksetid = m_insertblocksetCommand.ExecuteScalarInt64 ();  	long ix = 0;  	if (blocklistHashes != null) {  		m_insertblocklistHashesCommand.SetParameterValue (0' blocksetid);  		m_insertblocklistHashesCommand.Transaction = tr.Parent;  		foreach (var bh in blocklistHashes) {  			m_insertblocklistHashesCommand.SetParameterValue (1' ix);  			m_insertblocklistHashesCommand.SetParameterValue (2' bh);  			m_insertblocklistHashesCommand.ExecuteNonQuery ();  			ix++;  		}  	}  	m_insertblocksetentryCommand.SetParameterValue (0' blocksetid);  	m_insertblocksetentryCommand.Transaction = tr.Parent;  	m_insertblocksetentryFastCommand.SetParameterValue (0' blocksetid);  	m_insertblocksetentryFastCommand.Transaction = tr.Parent;  	ix = 0;  	long remainsize = size;  	foreach (var h in hashes) {  		var exsize = remainsize < blocksize ? remainsize : blocksize;  		m_insertblocksetentryCommand.SetParameterValue (1' ix);  		m_insertblocksetentryCommand.SetParameterValue (2' h);  		m_insertblocksetentryCommand.SetParameterValue (3' exsize);  		var c = m_insertblocksetentryCommand.ExecuteNonQuery ();  		if (c != 1) {  			m_result.AddError (string.Format ("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);  			using (var cmd = m_connection.CreateCommand (tr.Parent)) {  				var bid = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);  				if (bid == -1)  					throw new Exception (string.Format ("Could not find any blocks with the given hash: {0}"' h));  				foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))  					m_result.AddError (string.Format ("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64 (0' -1))' null);  			}  			throw new Exception (string.Format ("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));  		}  		ix++;  		remainsize -= blocksize;  	}  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: if (blocklistHashes != null) {  	m_insertblocklistHashesCommand.SetParameterValue (0' blocksetid);  	m_insertblocklistHashesCommand.Transaction = tr.Parent;  	foreach (var bh in blocklistHashes) {  		m_insertblocklistHashesCommand.SetParameterValue (1' ix);  		m_insertblocklistHashesCommand.SetParameterValue (2' bh);  		m_insertblocklistHashesCommand.ExecuteNonQuery ();  		ix++;  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: foreach (var bh in blocklistHashes) {  	m_insertblocklistHashesCommand.SetParameterValue (1' ix);  	m_insertblocklistHashesCommand.SetParameterValue (2' bh);  	m_insertblocklistHashesCommand.ExecuteNonQuery ();  	ix++;  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: m_insertblocklistHashesCommand.SetParameterValue (2' bh);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: foreach (var h in hashes) {  	var exsize = remainsize < blocksize ? remainsize : blocksize;  	m_insertblocksetentryCommand.SetParameterValue (1' ix);  	m_insertblocksetentryCommand.SetParameterValue (2' h);  	m_insertblocksetentryCommand.SetParameterValue (3' exsize);  	var c = m_insertblocksetentryCommand.ExecuteNonQuery ();  	if (c != 1) {  		m_result.AddError (string.Format ("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);  		using (var cmd = m_connection.CreateCommand (tr.Parent)) {  			var bid = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);  			if (bid == -1)  				throw new Exception (string.Format ("Could not find any blocks with the given hash: {0}"' h));  			foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))  				m_result.AddError (string.Format ("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64 (0' -1))' null);  		}  		throw new Exception (string.Format ("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));  	}  	ix++;  	remainsize -= blocksize;  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: foreach (var h in hashes) {  	var exsize = remainsize < blocksize ? remainsize : blocksize;  	m_insertblocksetentryCommand.SetParameterValue (1' ix);  	m_insertblocksetentryCommand.SetParameterValue (2' h);  	m_insertblocksetentryCommand.SetParameterValue (3' exsize);  	var c = m_insertblocksetentryCommand.ExecuteNonQuery ();  	if (c != 1) {  		m_result.AddError (string.Format ("Checking errors' related to #1400. Unexpected result count: {0}' expected {1}' hash: {2}' size: {3}' blocksetid: {4}' ix: {5}' fullhash: {6}' fullsize: {7}"' c' 1' h' exsize' blocksetid' ix' filehash' size)' null);  		using (var cmd = m_connection.CreateCommand (tr.Parent)) {  			var bid = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?"' -1' h);  			if (bid == -1)  				throw new Exception (string.Format ("Could not find any blocks with the given hash: {0}"' h));  			foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?"' h))  				m_result.AddError (string.Format ("Found block with ID {0} and hash {1} and size {2}"' bid' h' rd.ConvertValueToInt64 (0' -1))' null);  		}  		throw new Exception (string.Format ("Unexpected result count: {0}' expected {1}' check log for more messages"' c' 1));  	}  	ix++;  	remainsize -= blocksize;  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: m_insertblocksetentryCommand.SetParameterValue (2' h);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddBlockset,The following statement contains a magic number: m_insertblocksetentryCommand.SetParameterValue (3' exsize);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddMetadataset,The following statement contains a magic number: metadataid = -2;  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: if (m_pathLookup != null) {  	if (entryFound = (m_pathLookup.TryFind (filename' out entry) && entry != null)) {  		var fid = entry.GetFilesetID (blocksetID' metadataID);  		if (fid >= 0)  			fileidobj = fid;  	}  } else {  	m_findfilesetCommand.Transaction = transaction;  	m_findfilesetCommand.SetParameterValue (0' blocksetID);  	m_findfilesetCommand.SetParameterValue (1' metadataID);  	m_findfilesetCommand.SetParameterValue (2' filename);  	fileidobj = m_findfilesetCommand.ExecuteScalarInt64 ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: m_findfilesetCommand.SetParameterValue (2' filename);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: if (fileidobj == -1) {  	using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  		m_insertfileCommand.Transaction = tr.Parent;  		m_insertfileCommand.SetParameterValue (0' filename);  		m_insertfileCommand.SetParameterValue (1' blocksetID);  		m_insertfileCommand.SetParameterValue (2' metadataID);  		fileidobj = m_insertfileCommand.ExecuteScalarInt64 ();  		tr.Commit ();  		// We do not need to update this' because we will not ask for the same file twice  		if (m_pathLookup != null) {  			if (!entryFound) {  				entry = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  				entry.AddFilesetID (blocksetID' metadataID' fileidobj);  				m_pathLookup.Insert (filename' entry);  			} else  				entry.AddFilesetID (blocksetID' metadataID' fileidobj);  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_insertfileCommand.Transaction = tr.Parent;  	m_insertfileCommand.SetParameterValue (0' filename);  	m_insertfileCommand.SetParameterValue (1' blocksetID);  	m_insertfileCommand.SetParameterValue (2' metadataID);  	fileidobj = m_insertfileCommand.ExecuteScalarInt64 ();  	tr.Commit ();  	// We do not need to update this' because we will not ask for the same file twice  	if (m_pathLookup != null) {  		if (!entryFound) {  			entry = new PathEntryKeeper (-1' new DateTime (0' DateTimeKind.Utc)' -1' null' -1);  			entry.AddFilesetID (blocksetID' metadataID' fileidobj);  			m_pathLookup.Insert (filename' entry);  		} else  			entry.AddFilesetID (blocksetID' metadataID' fileidobj);  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: m_insertfileCommand.SetParameterValue (2' metadataID);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddFile,The following statement contains a magic number: m_insertfileOperationCommand.SetParameterValue (2' lastmodified.ToUniversalTime ().Ticks);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,AddUnmodifiedFile,The following statement contains a magic number: m_insertfileOperationCommand.SetParameterValue (2' lastmodified.ToUniversalTime ().Ticks);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (m_pathLookup != null) {  	PathEntryKeeper tmp;  	if (m_pathLookup.TryFind (path' out tmp) && tmp != null && tmp.FileID >= 0) {  		oldModified = tmp.Lastmodified;  		lastFileSize = tmp.Filesize;  		oldMetahash = tmp.Metahash;  		oldMetasize = tmp.Metasize;  		return tmp.FileID;  	} else {  		oldModified = new DateTime (0' DateTimeKind.Utc);  		lastFileSize = -1;  		oldMetahash = null;  		oldMetasize = -1;  		return -1;  	}  } else {  	m_findfileCommand.SetParameterValue (0' path);  	using (var rd = m_findfileCommand.ExecuteReader ())  		if (rd.Read ()) {  			oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  			lastFileSize = rd.GetInt64 (2);  			oldMetahash = rd.GetString (3);  			oldMetasize = rd.GetInt64 (4);  			return rd.ConvertValueToInt64 (0);  		} else {  			oldModified = new DateTime (0' DateTimeKind.Utc);  			lastFileSize = -1;  			oldMetahash = null;  			oldMetasize = -1;  			return -1;  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (m_pathLookup != null) {  	PathEntryKeeper tmp;  	if (m_pathLookup.TryFind (path' out tmp) && tmp != null && tmp.FileID >= 0) {  		oldModified = tmp.Lastmodified;  		lastFileSize = tmp.Filesize;  		oldMetahash = tmp.Metahash;  		oldMetasize = tmp.Metasize;  		return tmp.FileID;  	} else {  		oldModified = new DateTime (0' DateTimeKind.Utc);  		lastFileSize = -1;  		oldMetahash = null;  		oldMetasize = -1;  		return -1;  	}  } else {  	m_findfileCommand.SetParameterValue (0' path);  	using (var rd = m_findfileCommand.ExecuteReader ())  		if (rd.Read ()) {  			oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  			lastFileSize = rd.GetInt64 (2);  			oldMetahash = rd.GetString (3);  			oldMetasize = rd.GetInt64 (4);  			return rd.ConvertValueToInt64 (0);  		} else {  			oldModified = new DateTime (0' DateTimeKind.Utc);  			lastFileSize = -1;  			oldMetahash = null;  			oldMetasize = -1;  			return -1;  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (m_pathLookup != null) {  	PathEntryKeeper tmp;  	if (m_pathLookup.TryFind (path' out tmp) && tmp != null && tmp.FileID >= 0) {  		oldModified = tmp.Lastmodified;  		lastFileSize = tmp.Filesize;  		oldMetahash = tmp.Metahash;  		oldMetasize = tmp.Metasize;  		return tmp.FileID;  	} else {  		oldModified = new DateTime (0' DateTimeKind.Utc);  		lastFileSize = -1;  		oldMetahash = null;  		oldMetasize = -1;  		return -1;  	}  } else {  	m_findfileCommand.SetParameterValue (0' path);  	using (var rd = m_findfileCommand.ExecuteReader ())  		if (rd.Read ()) {  			oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  			lastFileSize = rd.GetInt64 (2);  			oldMetahash = rd.GetString (3);  			oldMetasize = rd.GetInt64 (4);  			return rd.ConvertValueToInt64 (0);  		} else {  			oldModified = new DateTime (0' DateTimeKind.Utc);  			lastFileSize = -1;  			oldMetahash = null;  			oldMetasize = -1;  			return -1;  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: using (var rd = m_findfileCommand.ExecuteReader ())  	if (rd.Read ()) {  		oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  		lastFileSize = rd.GetInt64 (2);  		oldMetahash = rd.GetString (3);  		oldMetasize = rd.GetInt64 (4);  		return rd.ConvertValueToInt64 (0);  	} else {  		oldModified = new DateTime (0' DateTimeKind.Utc);  		lastFileSize = -1;  		oldMetahash = null;  		oldMetasize = -1;  		return -1;  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: using (var rd = m_findfileCommand.ExecuteReader ())  	if (rd.Read ()) {  		oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  		lastFileSize = rd.GetInt64 (2);  		oldMetahash = rd.GetString (3);  		oldMetasize = rd.GetInt64 (4);  		return rd.ConvertValueToInt64 (0);  	} else {  		oldModified = new DateTime (0' DateTimeKind.Utc);  		lastFileSize = -1;  		oldMetahash = null;  		oldMetasize = -1;  		return -1;  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: using (var rd = m_findfileCommand.ExecuteReader ())  	if (rd.Read ()) {  		oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  		lastFileSize = rd.GetInt64 (2);  		oldMetahash = rd.GetString (3);  		oldMetasize = rd.GetInt64 (4);  		return rd.ConvertValueToInt64 (0);  	} else {  		oldModified = new DateTime (0' DateTimeKind.Utc);  		lastFileSize = -1;  		oldMetahash = null;  		oldMetasize = -1;  		return -1;  	}  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (rd.Read ()) {  	oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  	lastFileSize = rd.GetInt64 (2);  	oldMetahash = rd.GetString (3);  	oldMetasize = rd.GetInt64 (4);  	return rd.ConvertValueToInt64 (0);  } else {  	oldModified = new DateTime (0' DateTimeKind.Utc);  	lastFileSize = -1;  	oldMetahash = null;  	oldMetasize = -1;  	return -1;  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (rd.Read ()) {  	oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  	lastFileSize = rd.GetInt64 (2);  	oldMetahash = rd.GetString (3);  	oldMetasize = rd.GetInt64 (4);  	return rd.ConvertValueToInt64 (0);  } else {  	oldModified = new DateTime (0' DateTimeKind.Utc);  	lastFileSize = -1;  	oldMetahash = null;  	oldMetasize = -1;  	return -1;  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: if (rd.Read ()) {  	oldModified = new DateTime (rd.ConvertValueToInt64 (1)' DateTimeKind.Utc);  	lastFileSize = rd.GetInt64 (2);  	oldMetahash = rd.GetString (3);  	oldMetasize = rd.GetInt64 (4);  	return rd.ConvertValueToInt64 (0);  } else {  	oldModified = new DateTime (0' DateTimeKind.Utc);  	lastFileSize = -1;  	oldMetahash = null;  	oldMetasize = -1;  	return -1;  }  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: lastFileSize = rd.GetInt64 (2);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: oldMetahash = rd.GetString (3);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetFileEntry,The following statement contains a magic number: oldMetasize = rd.GetInt64 (4);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromName,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' name))  		if (rd.Read ())  			return new RemoteVolume (rd.GetValue (0).ToString ()' rd.GetValue (1).ToString ()' rd.ConvertValueToInt64 (2));  		else  			return null;  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromName,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' name))  	if (rd.Read ())  		return new RemoteVolume (rd.GetValue (0).ToString ()' rd.GetValue (1).ToString ()' rd.ConvertValueToInt64 (2));  	else  		return null;  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromName,The following statement contains a magic number: if (rd.Read ())  	return new RemoteVolume (rd.GetValue (0).ToString ()' rd.GetValue (1).ToString ()' rd.ConvertValueToInt64 (2));  else  	return null;  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromName,The following statement contains a magic number: return new RemoteVolume (rd.GetValue (0).ToString ()' rd.GetValue (1).ToString ()' rd.ConvertValueToInt64 (2));  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  		if (rd.Read ())  			return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  		else  			return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  		if (rd.Read ())  			return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  		else  			return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  		if (rd.Read ())  			return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  		else  			return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  		if (rd.Read ())  			return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  		else  			return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  		if (rd.Read ())  			return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  		else  			return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  		if (rd.Read ())  			return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  		else  			return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  	if (rd.Read ())  		return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	else  		return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  	if (rd.Read ())  		return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	else  		return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  	if (rd.Read ())  		return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	else  		return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  	if (rd.Read ())  		return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	else  		return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  	if (rd.Read ())  		return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	else  		return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""Name""' ""Type""' ""Size""' ""Hash""' ""State""' ""DeleteGraceTime"" FROM ""RemoteVolume"" WHERE ""ID"" = ?"' id))  	if (rd.Read ())  		return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	else  		return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: if (rd.Read ())  	return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  else  	return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: if (rd.Read ())  	return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  else  	return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: if (rd.Read ())  	return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  else  	return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: if (rd.Read ())  	return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  else  	return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: if (rd.Read ())  	return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  else  	return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: if (rd.Read ())  	return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  else  	return default(RemoteVolumeEntry);  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalBackupDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalBackupDatabase.cs,GetRemoteVolumeFromID,The following statement contains a magic number: return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_insertlogCommand.AddParameters (5);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_insertremotelogCommand.AddParameters (5);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_updateremotevolumeCommand.AddParameters (5);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_createremotevolumeCommand.AddParameters (7);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LocalDatabase,The following statement contains a magic number: m_insertIndexBlockLink.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The following statement contains a magic number: m_updateremotevolumeCommand.SetParameterValue (2' hash);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The following statement contains a magic number: m_updateremotevolumeCommand.SetParameterValue (3' size);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,UpdateRemoteVolume,The following statement contains a magic number: m_updateremotevolumeCommand.SetParameterValue (4' name);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader ())  	if (rd.Read ()) {  		type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  		size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  		hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  		state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  		return true;  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader ())  	if (rd.Read ()) {  		type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  		size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  		hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  		state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  		return true;  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader ())  	if (rd.Read ()) {  		type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  		size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  		hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  		state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  		return true;  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: using (var rd = m_selectremotevolumeCommand.ExecuteReader ())  	if (rd.Read ()) {  		type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  		size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  		hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  		state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  		return true;  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: if (rd.Read ()) {  	type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  	size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  	hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  	state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  	return true;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: if (rd.Read ()) {  	type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  	size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  	hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  	state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  	return true;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: if (rd.Read ()) {  	type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  	size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  	hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  	state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  	return true;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: if (rd.Read ()) {  	type = (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (0).ToString ());  	size = (rd.GetValue (1) == null || rd.GetValue (1) == DBNull.Value) ? -1 : rd.GetInt64 (1);  	hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  	state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  	return true;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: hash = (rd.GetValue (2) == null || rd.GetValue (2) == DBNull.Value) ? null : rd.GetValue (2).ToString ();  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolume,The following statement contains a magic number: state = (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (3).ToString ());  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader ()) {  	while (rd.Read ()) {  		yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader ()) {  	while (rd.Read ()) {  		yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader ()) {  	while (rd.Read ()) {  		yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader ()) {  	while (rd.Read ()) {  		yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader ()) {  	while (rd.Read ()) {  		yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: using (var rd = m_selectremotevolumesCommand.ExecuteReader ()) {  	while (rd.Read ()) {  		yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: while (rd.Read ()) {  	yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: while (rd.Read ()) {  	yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: while (rd.Read ()) {  	yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: while (rd.Read ()) {  	yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: while (rd.Read ()) {  	yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: while (rd.Read ()) {  	yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,GetRemoteVolumes,The following statement contains a magic number: yield return new RemoteVolumeEntry (rd.GetValue (0).ToString ()' (rd.GetValue (3) == null || rd.GetValue (3) == DBNull.Value) ? null : rd.GetValue (3).ToString ()' rd.ConvertValueToInt64 (2' -1)' (RemoteVolumeType)Enum.Parse (typeof(RemoteVolumeType)' rd.GetValue (1).ToString ())' (RemoteVolumeState)Enum.Parse (typeof(RemoteVolumeState)' rd.GetValue (4).ToString ())' new DateTime (rd.ConvertValueToInt64 (5' 0)' DateTimeKind.Utc));  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogRemoteOperation,The following statement contains a magic number: m_insertremotelogCommand.SetParameterValue (2' operation);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogRemoteOperation,The following statement contains a magic number: m_insertremotelogCommand.SetParameterValue (3' path);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogRemoteOperation,The following statement contains a magic number: m_insertremotelogCommand.SetParameterValue (4' data);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogMessage,The following statement contains a magic number: m_insertlogCommand.SetParameterValue (2' type);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogMessage,The following statement contains a magic number: m_insertlogCommand.SetParameterValue (3' message);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,LogMessage,The following statement contains a magic number: m_insertlogCommand.SetParameterValue (4' exception == null ? null : exception.ToString ());  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction))  	using (var deletecmd = m_connection.CreateCommand ()) {  		deletecmd.Transaction = tr.Parent;  		string temptransguid = Library.Utility.Utility.ByteArrayAsHexString (Guid.NewGuid ().ToByteArray ());  		var volidstable = "DelVolSetIds-" + temptransguid;  		var blocksetidstable = "DelBlockSetIds-" + temptransguid;  		// Create and fill a temp table with the volids to delete. We avoid using too many parameters that way.  		deletecmd.ExecuteNonQuery (string.Format (@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' volidstable));  		deletecmd.CommandText = string.Format (@"INSERT OR IGNORE INTO ""{0}"" (""ID"") VALUES (?)"' volidstable);  		deletecmd.Parameters.Clear ();  		deletecmd.AddParameters (1);  		foreach (var name in names) {  			var volumeid = GetRemoteVolumeID (name' tr.Parent);  			deletecmd.SetParameterValue (0' volumeid);  			deletecmd.ExecuteNonQuery ();  		}  		var volIdsSubQuery = string.Format (@"SELECT ""ID"" FROM ""{0}"" "' volidstable);  		deletecmd.Parameters.Clear ();  		// If the volume is a block or index volume' this will update the crosslink table' otherwise nothing will happen  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery));  		// If the volume is a fileset' this will remove the fileset' otherwise nothing will happen  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" IN (SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Fileset"" WHERE ""VolumeID""  IN ({0})"' volIdsSubQuery));  		var bsIdsSubQuery = string.Format (@"SELECT ""BlocksetEntry"".""BlocksetID"" FROM ""BlocksetEntry""' ""Block"" " + @" WHERE ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Block"".""VolumeID"" IN ({0}) " + @"UNION ALL " + @"SELECT ""BlocksetID"" FROM ""BlocklistHash"" " + @"WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery);  		// Create a temporary table to cache subquery result' as it might take long (SQLite does not cache at all).   		deletecmd.ExecuteNonQuery (string.Format (@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' blocksetidstable));  		deletecmd.ExecuteNonQuery (string.Format (@"INSERT OR IGNORE INTO ""{0}"" (""ID"") {1}"' blocksetidstable' bsIdsSubQuery));  		bsIdsSubQuery = string.Format (@"SELECT ""ID"" FROM ""{0}"" "' blocksetidstable);  		deletecmd.Parameters.Clear ();  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""BlocksetID"" IN ({0}) OR ""MetadataID"" IN ({0})"' bsIdsSubQuery));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Blockset"" WHERE ""ID"" IN ({0})"' bsIdsSubQuery));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""BlocklistHash"" WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Block"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""DeletedBlock"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));  		// Clean up temp tables for subqueries. We truncate content and then try to delete.  		// Drop in try-block' as it fails in nested transactions (SQLite problem)  		// System.Data.SQLite.SQLiteException (0x80004005): database table is locked  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""{0}"" "' blocksetidstable));  		deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""{0}"" "' volidstable));  		try {  			deletecmd.CommandTimeout = 2;  			deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' blocksetidstable));  			deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));  		} catch {  			/* Ignore' will be deleted on close anyway. */}  		foreach (var name in names) {  			m_removeremotevolumeCommand.SetParameterValue (0' name);  			m_removeremotevolumeCommand.Transaction = tr.Parent;  			m_removeremotevolumeCommand.ExecuteNonQuery ();  		}  		tr.Commit ();  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The following statement contains a magic number: using (var deletecmd = m_connection.CreateCommand ()) {  	deletecmd.Transaction = tr.Parent;  	string temptransguid = Library.Utility.Utility.ByteArrayAsHexString (Guid.NewGuid ().ToByteArray ());  	var volidstable = "DelVolSetIds-" + temptransguid;  	var blocksetidstable = "DelBlockSetIds-" + temptransguid;  	// Create and fill a temp table with the volids to delete. We avoid using too many parameters that way.  	deletecmd.ExecuteNonQuery (string.Format (@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' volidstable));  	deletecmd.CommandText = string.Format (@"INSERT OR IGNORE INTO ""{0}"" (""ID"") VALUES (?)"' volidstable);  	deletecmd.Parameters.Clear ();  	deletecmd.AddParameters (1);  	foreach (var name in names) {  		var volumeid = GetRemoteVolumeID (name' tr.Parent);  		deletecmd.SetParameterValue (0' volumeid);  		deletecmd.ExecuteNonQuery ();  	}  	var volIdsSubQuery = string.Format (@"SELECT ""ID"" FROM ""{0}"" "' volidstable);  	deletecmd.Parameters.Clear ();  	// If the volume is a block or index volume' this will update the crosslink table' otherwise nothing will happen  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery));  	// If the volume is a fileset' this will remove the fileset' otherwise nothing will happen  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" IN (SELECT ""ID"" FROM ""Fileset"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Fileset"" WHERE ""VolumeID""  IN ({0})"' volIdsSubQuery));  	var bsIdsSubQuery = string.Format (@"SELECT ""BlocksetEntry"".""BlocksetID"" FROM ""BlocksetEntry""' ""Block"" " + @" WHERE ""BlocksetEntry"".""BlockID"" = ""Block"".""ID"" AND ""Block"".""VolumeID"" IN ({0}) " + @"UNION ALL " + @"SELECT ""BlocksetID"" FROM ""BlocklistHash"" " + @"WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery);  	// Create a temporary table to cache subquery result' as it might take long (SQLite does not cache at all).   	deletecmd.ExecuteNonQuery (string.Format (@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' blocksetidstable));  	deletecmd.ExecuteNonQuery (string.Format (@"INSERT OR IGNORE INTO ""{0}"" (""ID"") {1}"' blocksetidstable' bsIdsSubQuery));  	bsIdsSubQuery = string.Format (@"SELECT ""ID"" FROM ""{0}"" "' blocksetidstable);  	deletecmd.Parameters.Clear ();  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""BlocksetID"" IN ({0}) OR ""MetadataID"" IN ({0})"' bsIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Blockset"" WHERE ""ID"" IN ({0})"' bsIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""BlocksetEntry"" WHERE ""BlocksetID"" IN ({0})"' bsIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""BlocklistHash"" WHERE ""Hash"" IN (SELECT ""Hash"" FROM ""Block"" WHERE ""VolumeID"" IN ({0}))"' volIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Block"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""DeletedBlock"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));  	// Clean up temp tables for subqueries. We truncate content and then try to delete.  	// Drop in try-block' as it fails in nested transactions (SQLite problem)  	// System.Data.SQLite.SQLiteException (0x80004005): database table is locked  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""{0}"" "' blocksetidstable));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""{0}"" "' volidstable));  	try {  		deletecmd.CommandTimeout = 2;  		deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' blocksetidstable));  		deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));  	} catch {  		/* Ignore' will be deleted on close anyway. */}  	foreach (var name in names) {  		m_removeremotevolumeCommand.SetParameterValue (0' name);  		m_removeremotevolumeCommand.Transaction = tr.Parent;  		m_removeremotevolumeCommand.ExecuteNonQuery ();  	}  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The following statement contains a magic number: try {  	deletecmd.CommandTimeout = 2;  	deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' blocksetidstable));  	deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));  } catch {  	/* Ignore' will be deleted on close anyway. */}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RemoveRemoteVolumes,The following statement contains a magic number: deletecmd.CommandTimeout = 2;  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_createremotevolumeCommand.SetParameterValue (0' m_operationid);  	m_createremotevolumeCommand.SetParameterValue (1' name);  	m_createremotevolumeCommand.SetParameterValue (2' type.ToString ());  	m_createremotevolumeCommand.SetParameterValue (3' state.ToString ());  	m_createremotevolumeCommand.SetParameterValue (4' size);  	m_createremotevolumeCommand.SetParameterValue (5' 0);  	if (deleteGraceTime.Ticks <= 0)  		m_createremotevolumeCommand.SetParameterValue (6' 0);  	else  		m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  	m_createremotevolumeCommand.Transaction = tr.Parent;  	var r = m_createremotevolumeCommand.ExecuteScalarInt64 ();  	tr.Commit ();  	return r;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_createremotevolumeCommand.SetParameterValue (0' m_operationid);  	m_createremotevolumeCommand.SetParameterValue (1' name);  	m_createremotevolumeCommand.SetParameterValue (2' type.ToString ());  	m_createremotevolumeCommand.SetParameterValue (3' state.ToString ());  	m_createremotevolumeCommand.SetParameterValue (4' size);  	m_createremotevolumeCommand.SetParameterValue (5' 0);  	if (deleteGraceTime.Ticks <= 0)  		m_createremotevolumeCommand.SetParameterValue (6' 0);  	else  		m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  	m_createremotevolumeCommand.Transaction = tr.Parent;  	var r = m_createremotevolumeCommand.ExecuteScalarInt64 ();  	tr.Commit ();  	return r;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_createremotevolumeCommand.SetParameterValue (0' m_operationid);  	m_createremotevolumeCommand.SetParameterValue (1' name);  	m_createremotevolumeCommand.SetParameterValue (2' type.ToString ());  	m_createremotevolumeCommand.SetParameterValue (3' state.ToString ());  	m_createremotevolumeCommand.SetParameterValue (4' size);  	m_createremotevolumeCommand.SetParameterValue (5' 0);  	if (deleteGraceTime.Ticks <= 0)  		m_createremotevolumeCommand.SetParameterValue (6' 0);  	else  		m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  	m_createremotevolumeCommand.Transaction = tr.Parent;  	var r = m_createremotevolumeCommand.ExecuteScalarInt64 ();  	tr.Commit ();  	return r;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_createremotevolumeCommand.SetParameterValue (0' m_operationid);  	m_createremotevolumeCommand.SetParameterValue (1' name);  	m_createremotevolumeCommand.SetParameterValue (2' type.ToString ());  	m_createremotevolumeCommand.SetParameterValue (3' state.ToString ());  	m_createremotevolumeCommand.SetParameterValue (4' size);  	m_createremotevolumeCommand.SetParameterValue (5' 0);  	if (deleteGraceTime.Ticks <= 0)  		m_createremotevolumeCommand.SetParameterValue (6' 0);  	else  		m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  	m_createremotevolumeCommand.Transaction = tr.Parent;  	var r = m_createremotevolumeCommand.ExecuteScalarInt64 ();  	tr.Commit ();  	return r;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_createremotevolumeCommand.SetParameterValue (0' m_operationid);  	m_createremotevolumeCommand.SetParameterValue (1' name);  	m_createremotevolumeCommand.SetParameterValue (2' type.ToString ());  	m_createremotevolumeCommand.SetParameterValue (3' state.ToString ());  	m_createremotevolumeCommand.SetParameterValue (4' size);  	m_createremotevolumeCommand.SetParameterValue (5' 0);  	if (deleteGraceTime.Ticks <= 0)  		m_createremotevolumeCommand.SetParameterValue (6' 0);  	else  		m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  	m_createremotevolumeCommand.Transaction = tr.Parent;  	var r = m_createremotevolumeCommand.ExecuteScalarInt64 ();  	tr.Commit ();  	return r;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: using (var tr = new TemporaryTransactionWrapper (m_connection' transaction)) {  	m_createremotevolumeCommand.SetParameterValue (0' m_operationid);  	m_createremotevolumeCommand.SetParameterValue (1' name);  	m_createremotevolumeCommand.SetParameterValue (2' type.ToString ());  	m_createremotevolumeCommand.SetParameterValue (3' state.ToString ());  	m_createremotevolumeCommand.SetParameterValue (4' size);  	m_createremotevolumeCommand.SetParameterValue (5' 0);  	if (deleteGraceTime.Ticks <= 0)  		m_createremotevolumeCommand.SetParameterValue (6' 0);  	else  		m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  	m_createremotevolumeCommand.Transaction = tr.Parent;  	var r = m_createremotevolumeCommand.ExecuteScalarInt64 ();  	tr.Commit ();  	return r;  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: m_createremotevolumeCommand.SetParameterValue (2' type.ToString ());  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: m_createremotevolumeCommand.SetParameterValue (3' state.ToString ());  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: m_createremotevolumeCommand.SetParameterValue (4' size);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: m_createremotevolumeCommand.SetParameterValue (5' 0);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: if (deleteGraceTime.Ticks <= 0)  	m_createremotevolumeCommand.SetParameterValue (6' 0);  else  	m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: if (deleteGraceTime.Ticks <= 0)  	m_createremotevolumeCommand.SetParameterValue (6' 0);  else  	m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: m_createremotevolumeCommand.SetParameterValue (6' 0);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,RegisterRemoteVolume,The following statement contains a magic number: m_createremotevolumeCommand.SetParameterValue (6' (DateTime.UtcNow + deleteGraceTime).Ticks);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (transaction)) {  	// Calculate the lengths for each blockset                  	var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";  	// For each blockset with wrong lengths' fetch the file path  	var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";  	using (var rd = cmd.ExecuteReader (reportDetails))  		if (rd.Read ()) {  			var sb = new StringBuilder ();  			sb.AppendLine ("Found inconsistency in the following files while validating database: ");  			var c = 0;  			do {  				if (c < 5)  					sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  				c++;  			} while (rd.Read ());  			c -= 5;  			if (c > 0)  				sb.AppendFormat ("... and {0} more"' c);  			sb.Append (". Run repair to fix it.");  			throw new InvalidDataException (sb.ToString ());  		}  	var real_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM ""BlocklistHash"""' 0);  	var unique_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);  	if (real_count != unique_count)  		throw new InvalidDataException (string.Format ("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));  	var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);  	if (itemswithnoblocklisthash != 0)  		throw new InvalidDataException (string.Format ("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));  	if (cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)  		throw new Exception ("Detected file entries with not associated blocks");  	if (verifyfilelists) {  		using (var cmd2 = m_connection.CreateCommand (transaction))  			foreach (var filesetid in cmd.ExecuteReaderEnumerable (@"SELECT ""ID"" FROM ""Fileset"" ").Select (x => x.ConvertValueToInt64 (0' -1))) {  				var expandedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);  				//var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);  				var storedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);  				if (expandedlist != storedlist)  					throw new Exception (string.Format ("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (transaction)) {  	// Calculate the lengths for each blockset                  	var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";  	// For each blockset with wrong lengths' fetch the file path  	var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";  	using (var rd = cmd.ExecuteReader (reportDetails))  		if (rd.Read ()) {  			var sb = new StringBuilder ();  			sb.AppendLine ("Found inconsistency in the following files while validating database: ");  			var c = 0;  			do {  				if (c < 5)  					sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  				c++;  			} while (rd.Read ());  			c -= 5;  			if (c > 0)  				sb.AppendFormat ("... and {0} more"' c);  			sb.Append (". Run repair to fix it.");  			throw new InvalidDataException (sb.ToString ());  		}  	var real_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM ""BlocklistHash"""' 0);  	var unique_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);  	if (real_count != unique_count)  		throw new InvalidDataException (string.Format ("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));  	var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);  	if (itemswithnoblocklisthash != 0)  		throw new InvalidDataException (string.Format ("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));  	if (cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)  		throw new Exception ("Detected file entries with not associated blocks");  	if (verifyfilelists) {  		using (var cmd2 = m_connection.CreateCommand (transaction))  			foreach (var filesetid in cmd.ExecuteReaderEnumerable (@"SELECT ""ID"" FROM ""Fileset"" ").Select (x => x.ConvertValueToInt64 (0' -1))) {  				var expandedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);  				//var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);  				var storedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);  				if (expandedlist != storedlist)  					throw new Exception (string.Format ("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (transaction)) {  	// Calculate the lengths for each blockset                  	var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";  	// For each blockset with wrong lengths' fetch the file path  	var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";  	using (var rd = cmd.ExecuteReader (reportDetails))  		if (rd.Read ()) {  			var sb = new StringBuilder ();  			sb.AppendLine ("Found inconsistency in the following files while validating database: ");  			var c = 0;  			do {  				if (c < 5)  					sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  				c++;  			} while (rd.Read ());  			c -= 5;  			if (c > 0)  				sb.AppendFormat ("... and {0} more"' c);  			sb.Append (". Run repair to fix it.");  			throw new InvalidDataException (sb.ToString ());  		}  	var real_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM ""BlocklistHash"""' 0);  	var unique_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);  	if (real_count != unique_count)  		throw new InvalidDataException (string.Format ("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));  	var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);  	if (itemswithnoblocklisthash != 0)  		throw new InvalidDataException (string.Format ("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));  	if (cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)  		throw new Exception ("Detected file entries with not associated blocks");  	if (verifyfilelists) {  		using (var cmd2 = m_connection.CreateCommand (transaction))  			foreach (var filesetid in cmd.ExecuteReaderEnumerable (@"SELECT ""ID"" FROM ""Fileset"" ").Select (x => x.ConvertValueToInt64 (0' -1))) {  				var expandedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);  				//var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);  				var storedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);  				if (expandedlist != storedlist)  					throw new Exception (string.Format ("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (transaction)) {  	// Calculate the lengths for each blockset                  	var combinedLengths = @"  SELECT       ""A"".""ID"" AS ""BlocksetID""'       IFNULL(""B"".""CalcLen""' 0) AS ""CalcLen""'       ""A"".""Length""  FROM      ""Blockset"" A  LEFT OUTER JOIN      (          SELECT               ""BlocksetEntry"".""BlocksetID""'              SUM(""Block"".""Size"") AS ""CalcLen""          FROM              ""BlocksetEntry""          LEFT OUTER JOIN              ""Block""          ON              ""Block"".""ID"" = ""BlocksetEntry"".""BlockID""          GROUP BY ""BlocksetEntry"".""BlocksetID""      ) B  ON      ""A"".""ID"" = ""B"".""BlocksetID""    ";  	// For each blockset with wrong lengths' fetch the file path  	var reportDetails = @"SELECT ""CalcLen""' ""Length""' ""A"".""BlocksetID""' ""File"".""Path"" FROM (" + combinedLengths + @") A' ""File"" WHERE ""A"".""BlocksetID"" = ""File"".""BlocksetID"" AND ""A"".""CalcLen"" != ""A"".""Length"" ";  	using (var rd = cmd.ExecuteReader (reportDetails))  		if (rd.Read ()) {  			var sb = new StringBuilder ();  			sb.AppendLine ("Found inconsistency in the following files while validating database: ");  			var c = 0;  			do {  				if (c < 5)  					sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  				c++;  			} while (rd.Read ());  			c -= 5;  			if (c > 0)  				sb.AppendFormat ("... and {0} more"' c);  			sb.Append (". Run repair to fix it.");  			throw new InvalidDataException (sb.ToString ());  		}  	var real_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM ""BlocklistHash"""' 0);  	var unique_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);  	if (real_count != unique_count)  		throw new InvalidDataException (string.Format ("Found {0} blocklist hashes' but there should be {1}. Run repair to fix it."' real_count' unique_count));  	var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID""' ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected""' CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID""' COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID""' COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")"' blocksize / hashsize)' 0);  	if (itemswithnoblocklisthash != 0)  		throw new InvalidDataException (string.Format ("Found {0} file(s) with missing blocklist hashes"' itemswithnoblocklisthash));  	if (cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM ""File"" WHERE ""BlocksetID"" != ? AND ""BlocksetID"" != ? AND NOT ""BlocksetID"" IN (SELECT ""BlocksetID"" FROM ""BlocksetEntry"")"' 0' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID) != 0)  		throw new Exception ("Detected file entries with not associated blocks");  	if (verifyfilelists) {  		using (var cmd2 = m_connection.CreateCommand (transaction))  			foreach (var filesetid in cmd.ExecuteReaderEnumerable (@"SELECT ""ID"" FROM ""Fileset"" ").Select (x => x.ConvertValueToInt64 (0' -1))) {  				var expandedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""Path"" FROM ({0}) UNION SELECT DISTINCT ""Path"" FROM ({1}))"' LocalDatabase.LIST_FILESETS' LocalDatabase.LIST_FOLDERS_AND_SYMLINKS)' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID' filesetid);  				//var storedfilelist = cmd2.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry""' ""File"" WHERE ""FilesetEntry"".""FilesetID"" = ? AND ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""File"".""BlocksetID"" != ? AND ""File"".""BlocksetID"" != ?")' 0' filesetid' FOLDER_BLOCKSET_ID' SYMLINK_BLOCKSET_ID);  				var storedlist = cmd2.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetEntry"".""FilesetID"" = ?")' 0' filesetid);  				if (expandedlist != storedlist)  					throw new Exception (string.Format ("Unexpected difference in fileset {0}' found {1} entries' but expected {2}"' filesetid' expandedlist' storedlist));  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (reportDetails))  	if (rd.Read ()) {  		var sb = new StringBuilder ();  		sb.AppendLine ("Found inconsistency in the following files while validating database: ");  		var c = 0;  		do {  			if (c < 5)  				sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  			c++;  		} while (rd.Read ());  		c -= 5;  		if (c > 0)  			sb.AppendFormat ("... and {0} more"' c);  		sb.Append (". Run repair to fix it.");  		throw new InvalidDataException (sb.ToString ());  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (reportDetails))  	if (rd.Read ()) {  		var sb = new StringBuilder ();  		sb.AppendLine ("Found inconsistency in the following files while validating database: ");  		var c = 0;  		do {  			if (c < 5)  				sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  			c++;  		} while (rd.Read ());  		c -= 5;  		if (c > 0)  			sb.AppendFormat ("... and {0} more"' c);  		sb.Append (". Run repair to fix it.");  		throw new InvalidDataException (sb.ToString ());  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (reportDetails))  	if (rd.Read ()) {  		var sb = new StringBuilder ();  		sb.AppendLine ("Found inconsistency in the following files while validating database: ");  		var c = 0;  		do {  			if (c < 5)  				sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  			c++;  		} while (rd.Read ());  		c -= 5;  		if (c > 0)  			sb.AppendFormat ("... and {0} more"' c);  		sb.Append (". Run repair to fix it.");  		throw new InvalidDataException (sb.ToString ());  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (reportDetails))  	if (rd.Read ()) {  		var sb = new StringBuilder ();  		sb.AppendLine ("Found inconsistency in the following files while validating database: ");  		var c = 0;  		do {  			if (c < 5)  				sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  			c++;  		} while (rd.Read ());  		c -= 5;  		if (c > 0)  			sb.AppendFormat ("... and {0} more"' c);  		sb.Append (". Run repair to fix it.");  		throw new InvalidDataException (sb.ToString ());  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: if (rd.Read ()) {  	var sb = new StringBuilder ();  	sb.AppendLine ("Found inconsistency in the following files while validating database: ");  	var c = 0;  	do {  		if (c < 5)  			sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  		c++;  	} while (rd.Read ());  	c -= 5;  	if (c > 0)  		sb.AppendFormat ("... and {0} more"' c);  	sb.Append (". Run repair to fix it.");  	throw new InvalidDataException (sb.ToString ());  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: if (rd.Read ()) {  	var sb = new StringBuilder ();  	sb.AppendLine ("Found inconsistency in the following files while validating database: ");  	var c = 0;  	do {  		if (c < 5)  			sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  		c++;  	} while (rd.Read ());  	c -= 5;  	if (c > 0)  		sb.AppendFormat ("... and {0} more"' c);  	sb.Append (". Run repair to fix it.");  	throw new InvalidDataException (sb.ToString ());  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: if (rd.Read ()) {  	var sb = new StringBuilder ();  	sb.AppendLine ("Found inconsistency in the following files while validating database: ");  	var c = 0;  	do {  		if (c < 5)  			sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  		c++;  	} while (rd.Read ());  	c -= 5;  	if (c > 0)  		sb.AppendFormat ("... and {0} more"' c);  	sb.Append (". Run repair to fix it.");  	throw new InvalidDataException (sb.ToString ());  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: if (rd.Read ()) {  	var sb = new StringBuilder ();  	sb.AppendLine ("Found inconsistency in the following files while validating database: ");  	var c = 0;  	do {  		if (c < 5)  			sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  		c++;  	} while (rd.Read ());  	c -= 5;  	if (c > 0)  		sb.AppendFormat ("... and {0} more"' c);  	sb.Append (". Run repair to fix it.");  	throw new InvalidDataException (sb.ToString ());  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: do {  	if (c < 5)  		sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  	c++;  } while (rd.Read ());  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: do {  	if (c < 5)  		sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  	c++;  } while (rd.Read ());  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: do {  	if (c < 5)  		sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  	c++;  } while (rd.Read ());  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: if (c < 5)  	sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: if (c < 5)  	sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: if (c < 5)  	sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: sb.AppendFormat ("{0}' actual size {1}' dbsize {2}' blocksetid: {3}{4}"' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (0)' rd.GetValue (2)' Environment.NewLine);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,VerifyConsistency,The following statement contains a magic number: c -= 5;  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	cmd.CommandText = LIST_FOLDERS_AND_SYMLINKS;  	cmd.AddParameter (FOLDER_BLOCKSET_ID);  	cmd.AddParameter (SYMLINK_BLOCKSET_ID);  	cmd.AddParameter (filesetId);  	string lastpath = null;  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			var blocksetID = rd.ConvertValueToInt64 (0' -1);  			var path = rd.GetValue (2).ToString ();  			var metalength = rd.ConvertValueToInt64 (3' -1);  			var metahash = rd.GetValue (4).ToString ();  			var metablockhash = rd.GetValue (6).ToString ();  			var metablocklisthash = rd.GetValue (7).ToString ();  			if (path == lastpath)  				m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  			lastpath = path;  			if (blocksetID == FOLDER_BLOCKSET_ID)  				filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  			else if (blocksetID == SYMLINK_BLOCKSET_ID)  				filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  		}  	// TODO: Perhaps run the above query after recreate and compare count(*) with count(*) from filesetentry where id = x  	cmd.CommandText = LIST_FILESETS;  	cmd.Parameters.Clear ();  	cmd.AddParameter (filesetId);  	using (var rd = cmd.ExecuteReader ())  		if (rd.Read ()) {  			var more = false;  			do {  				var path = rd.GetValue (0).ToString ();  				var filehash = rd.GetValue (3).ToString ();  				var size = rd.ConvertValueToInt64 (2);  				var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  				var metahash = rd.GetValue (4).ToString ();  				var metasize = rd.ConvertValueToInt64 (5' -1);  				var p = rd.GetValue (6);  				var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  				var blockhash = rd.GetValue (7).ToString ();  				var blocksize = rd.ConvertValueToInt64 (8' -1);  				var metablockhash = rd.GetValue (9).ToString ();  				//var metablocksize = rd.ConvertValueToInt64(10' -1);  				var metablocklisthash = rd.GetValue (11).ToString ();  				if (blockhash == filehash)  					blockhash = null;  				if (metablockhash == metahash)  					metablockhash = null;  				filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  					metablocklisthash  				});  				if (blrd == null)  					more = rd.Read ();  				else  					more = blrd.MoreData;  			} while (more);  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	while (rd.Read ()) {  		var blocksetID = rd.ConvertValueToInt64 (0' -1);  		var path = rd.GetValue (2).ToString ();  		var metalength = rd.ConvertValueToInt64 (3' -1);  		var metahash = rd.GetValue (4).ToString ();  		var metablockhash = rd.GetValue (6).ToString ();  		var metablocklisthash = rd.GetValue (7).ToString ();  		if (path == lastpath)  			m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  		lastpath = path;  		if (blocksetID == FOLDER_BLOCKSET_ID)  			filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  		else if (blocksetID == SYMLINK_BLOCKSET_ID)  			filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	while (rd.Read ()) {  		var blocksetID = rd.ConvertValueToInt64 (0' -1);  		var path = rd.GetValue (2).ToString ();  		var metalength = rd.ConvertValueToInt64 (3' -1);  		var metahash = rd.GetValue (4).ToString ();  		var metablockhash = rd.GetValue (6).ToString ();  		var metablocklisthash = rd.GetValue (7).ToString ();  		if (path == lastpath)  			m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  		lastpath = path;  		if (blocksetID == FOLDER_BLOCKSET_ID)  			filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  		else if (blocksetID == SYMLINK_BLOCKSET_ID)  			filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	while (rd.Read ()) {  		var blocksetID = rd.ConvertValueToInt64 (0' -1);  		var path = rd.GetValue (2).ToString ();  		var metalength = rd.ConvertValueToInt64 (3' -1);  		var metahash = rd.GetValue (4).ToString ();  		var metablockhash = rd.GetValue (6).ToString ();  		var metablocklisthash = rd.GetValue (7).ToString ();  		if (path == lastpath)  			m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  		lastpath = path;  		if (blocksetID == FOLDER_BLOCKSET_ID)  			filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  		else if (blocksetID == SYMLINK_BLOCKSET_ID)  			filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	while (rd.Read ()) {  		var blocksetID = rd.ConvertValueToInt64 (0' -1);  		var path = rd.GetValue (2).ToString ();  		var metalength = rd.ConvertValueToInt64 (3' -1);  		var metahash = rd.GetValue (4).ToString ();  		var metablockhash = rd.GetValue (6).ToString ();  		var metablocklisthash = rd.GetValue (7).ToString ();  		if (path == lastpath)  			m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  		lastpath = path;  		if (blocksetID == FOLDER_BLOCKSET_ID)  			filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  		else if (blocksetID == SYMLINK_BLOCKSET_ID)  			filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	while (rd.Read ()) {  		var blocksetID = rd.ConvertValueToInt64 (0' -1);  		var path = rd.GetValue (2).ToString ();  		var metalength = rd.ConvertValueToInt64 (3' -1);  		var metahash = rd.GetValue (4).ToString ();  		var metablockhash = rd.GetValue (6).ToString ();  		var metablocklisthash = rd.GetValue (7).ToString ();  		if (path == lastpath)  			m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  		lastpath = path;  		if (blocksetID == FOLDER_BLOCKSET_ID)  			filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  		else if (blocksetID == SYMLINK_BLOCKSET_ID)  			filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: while (rd.Read ()) {  	var blocksetID = rd.ConvertValueToInt64 (0' -1);  	var path = rd.GetValue (2).ToString ();  	var metalength = rd.ConvertValueToInt64 (3' -1);  	var metahash = rd.GetValue (4).ToString ();  	var metablockhash = rd.GetValue (6).ToString ();  	var metablocklisthash = rd.GetValue (7).ToString ();  	if (path == lastpath)  		m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  	lastpath = path;  	if (blocksetID == FOLDER_BLOCKSET_ID)  		filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  	else if (blocksetID == SYMLINK_BLOCKSET_ID)  		filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: while (rd.Read ()) {  	var blocksetID = rd.ConvertValueToInt64 (0' -1);  	var path = rd.GetValue (2).ToString ();  	var metalength = rd.ConvertValueToInt64 (3' -1);  	var metahash = rd.GetValue (4).ToString ();  	var metablockhash = rd.GetValue (6).ToString ();  	var metablocklisthash = rd.GetValue (7).ToString ();  	if (path == lastpath)  		m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  	lastpath = path;  	if (blocksetID == FOLDER_BLOCKSET_ID)  		filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  	else if (blocksetID == SYMLINK_BLOCKSET_ID)  		filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: while (rd.Read ()) {  	var blocksetID = rd.ConvertValueToInt64 (0' -1);  	var path = rd.GetValue (2).ToString ();  	var metalength = rd.ConvertValueToInt64 (3' -1);  	var metahash = rd.GetValue (4).ToString ();  	var metablockhash = rd.GetValue (6).ToString ();  	var metablocklisthash = rd.GetValue (7).ToString ();  	if (path == lastpath)  		m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  	lastpath = path;  	if (blocksetID == FOLDER_BLOCKSET_ID)  		filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  	else if (blocksetID == SYMLINK_BLOCKSET_ID)  		filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: while (rd.Read ()) {  	var blocksetID = rd.ConvertValueToInt64 (0' -1);  	var path = rd.GetValue (2).ToString ();  	var metalength = rd.ConvertValueToInt64 (3' -1);  	var metahash = rd.GetValue (4).ToString ();  	var metablockhash = rd.GetValue (6).ToString ();  	var metablocklisthash = rd.GetValue (7).ToString ();  	if (path == lastpath)  		m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  	lastpath = path;  	if (blocksetID == FOLDER_BLOCKSET_ID)  		filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  	else if (blocksetID == SYMLINK_BLOCKSET_ID)  		filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: while (rd.Read ()) {  	var blocksetID = rd.ConvertValueToInt64 (0' -1);  	var path = rd.GetValue (2).ToString ();  	var metalength = rd.ConvertValueToInt64 (3' -1);  	var metahash = rd.GetValue (4).ToString ();  	var metablockhash = rd.GetValue (6).ToString ();  	var metablocklisthash = rd.GetValue (7).ToString ();  	if (path == lastpath)  		m_result.AddWarning (string.Format ("Duplicate path detected: {0}!"' path)' null);  	lastpath = path;  	if (blocksetID == FOLDER_BLOCKSET_ID)  		filesetvolume.AddDirectory (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  	else if (blocksetID == SYMLINK_BLOCKSET_ID)  		filesetvolume.AddSymlink (path' metahash' metalength' metablockhash' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	if (rd.Read ()) {  		var more = false;  		do {  			var path = rd.GetValue (0).ToString ();  			var filehash = rd.GetValue (3).ToString ();  			var size = rd.ConvertValueToInt64 (2);  			var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  			var metahash = rd.GetValue (4).ToString ();  			var metasize = rd.ConvertValueToInt64 (5' -1);  			var p = rd.GetValue (6);  			var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  			var blockhash = rd.GetValue (7).ToString ();  			var blocksize = rd.ConvertValueToInt64 (8' -1);  			var metablockhash = rd.GetValue (9).ToString ();  			//var metablocksize = rd.ConvertValueToInt64(10' -1);  			var metablocklisthash = rd.GetValue (11).ToString ();  			if (blockhash == filehash)  				blockhash = null;  			if (metablockhash == metahash)  				metablockhash = null;  			filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  				metablocklisthash  			});  			if (blrd == null)  				more = rd.Read ();  			else  				more = blrd.MoreData;  		} while (more);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: if (rd.Read ()) {  	var more = false;  	do {  		var path = rd.GetValue (0).ToString ();  		var filehash = rd.GetValue (3).ToString ();  		var size = rd.ConvertValueToInt64 (2);  		var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  		var metahash = rd.GetValue (4).ToString ();  		var metasize = rd.ConvertValueToInt64 (5' -1);  		var p = rd.GetValue (6);  		var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  		var blockhash = rd.GetValue (7).ToString ();  		var blocksize = rd.ConvertValueToInt64 (8' -1);  		var metablockhash = rd.GetValue (9).ToString ();  		//var metablocksize = rd.ConvertValueToInt64(10' -1);  		var metablocklisthash = rd.GetValue (11).ToString ();  		if (blockhash == filehash)  			blockhash = null;  		if (metablockhash == metahash)  			metablockhash = null;  		filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  			metablocklisthash  		});  		if (blrd == null)  			more = rd.Read ();  		else  			more = blrd.MoreData;  	} while (more);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteFileset,The following statement contains a magic number: do {  	var path = rd.GetValue (0).ToString ();  	var filehash = rd.GetValue (3).ToString ();  	var size = rd.ConvertValueToInt64 (2);  	var lastmodified = new DateTime (rd.ConvertValueToInt64 (1' 0)' DateTimeKind.Utc);  	var metahash = rd.GetValue (4).ToString ();  	var metasize = rd.ConvertValueToInt64 (5' -1);  	var p = rd.GetValue (6);  	var blrd = (p == null || p == DBNull.Value) ? null : new BlocklistHashEnumerable (rd);  	var blockhash = rd.GetValue (7).ToString ();  	var blocksize = rd.ConvertValueToInt64 (8' -1);  	var metablockhash = rd.GetValue (9).ToString ();  	//var metablocksize = rd.ConvertValueToInt64(10' -1);  	var metablocklisthash = rd.GetValue (11).ToString ();  	if (blockhash == filehash)  		blockhash = null;  	if (metablockhash == metahash)  		metablockhash = null;  	filesetvolume.AddFile (path' filehash' size' lastmodified' metahash' metasize' metablockhash' blockhash' blocksize' blrd' string.IsNullOrWhiteSpace (metablocklisthash) ? null : new string[] {  		metablocklisthash  	});  	if (blrd == null)  		more = rd.Read ();  	else  		more = blrd.MoreData;  } while (more);  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteResults,The following statement contains a magic number: if (m_connection != null && m_result != null) {  	m_result.FlushLog ();  	if (m_result.EndTime.Ticks == 0)  		m_result.EndTime = DateTime.UtcNow;  	LogMessage ("Result"' Library.Utility.Utility.PrintSerializeObject (m_result' (StringBuilder)null' (prop' item) => !typeof(IBackendProgressUpdater).IsAssignableFrom (prop.PropertyType) && !typeof(IMessageSink).IsAssignableFrom (prop.PropertyType) && !typeof(ILogWriter).IsAssignableFrom (prop.PropertyType) && prop.Name != "VerboseOutput" && prop.Name != "VerboseErrors" && !(prop.Name == "MainOperation" && item is BackendWriter) && !(prop.Name == "EndTime" && item is BackendWriter) && !(prop.Name == "Duration" && item is BackendWriter) && !(prop.Name == "BeginTime" && item is BackendWriter)' recurseobjects: true' collectionlimit: 5).ToString ()' null' null);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDatabase.cs,WriteResults,The following statement contains a magic number: LogMessage ("Result"' Library.Utility.Utility.PrintSerializeObject (m_result' (StringBuilder)null' (prop' item) => !typeof(IBackendProgressUpdater).IsAssignableFrom (prop.PropertyType) && !typeof(IMessageSink).IsAssignableFrom (prop.PropertyType) && !typeof(ILogWriter).IsAssignableFrom (prop.PropertyType) && prop.Name != "VerboseOutput" && prop.Name != "VerboseErrors" && !(prop.Name == "MainOperation" && item is BackendWriter) && !(prop.Name == "EndTime" && item is BackendWriter) && !(prop.Name == "Duration" && item is BackendWriter) && !(prop.Name == "BeginTime" && item is BackendWriter)' recurseobjects: true' collectionlimit: 5).ToString ()' null' null);  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	var filesetIds = GetFilesetIDs (NormalizeDateTime (restoretime)' versions).ToList ();  	while (filesetIds.Count > 0) {  		var filesetId = filesetIds [0];  		filesetIds.RemoveAt (0);  		m_restoreTime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  		var ix = this.FilesetTimes.Select ((value' index) => new {  			value.Key'  			index  		}).Where (n => n.Key == filesetId).Select (pair => pair.index + 1).FirstOrDefault () - 1;  		log.AddMessage (string.Format ("Searching backup {0} ({1}) ..."' ix' m_restoreTime));  		cmd.Parameters.Clear ();  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));  		// better suited to speed up commit on UpdateBlocks  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));  		if (filter == null || filter.Empty) {  			// Simple case' restore everything  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  			cmd.AddParameter (filesetId);  			cmd.ExecuteNonQuery ();  		} else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  			// If we get a list of filenames' the lookup table is faster  			// unfortunately we cannot do this if the filesystem is case sensitive as  			// SQLite only supports ASCII compares  			using (var tr = m_connection.BeginTransaction ()) {  				var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  				var m_filenamestable = "Filenames-" + guid;  				cmd.Transaction = tr;  				cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  				cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  				cmd.AddParameter ();  				foreach (var s in p) {  					cmd.SetParameterValue (0' s);  					cmd.ExecuteNonQuery ();  				}  				cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  				cmd.SetParameterValue (0' filesetId);  				var c = cmd.ExecuteNonQuery ();  				cmd.Parameters.Clear ();  				if (c != p.Length && c != 0) {  					var sb = new StringBuilder ();  					sb.AppendLine ();  					using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  						while (rd.Read ())  							sb.AppendLine (rd.GetValue (0).ToString ());  					var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  					log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  					cmd.Parameters.Clear ();  				}  				cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  				using (new Logging.Timer ("CommitPrepareFileset"))  					tr.Commit ();  			}  		} else {  			// Restore but filter elements based on the filter expression  			// If this is too slow' we could add a special handler for wildcard searches too  			cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  			cmd.AddParameter (filesetId);  			object[] values = new object[3];  			using (var cmd2 = m_connection.CreateCommand ()) {  				cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  				cmd2.AddParameter ();  				cmd2.AddParameter ();  				cmd2.AddParameter ();  				using (var rd = cmd.ExecuteReader ())  					while (rd.Read ()) {  						rd.GetValues (values);  						if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  							cmd2.SetParameterValue (0' values [0]);  							cmd2.SetParameterValue (1' values [1]);  							cmd2.SetParameterValue (2' values [2]);  							cmd2.ExecuteNonQuery ();  						}  					}  			}  		}  		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) {  			var filecount = 0L;  			var filesize = 0L;  			if (rd.Read ()) {  				filecount = rd.ConvertValueToInt64 (0' 0);  				filesize = rd.ConvertValueToInt64 (1' 0);  			}  			if (filecount > 0) {  				log.AddVerboseMessage ("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString (filesize));  				return new Tuple<long' long> (filecount' filesize);  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	var filesetIds = GetFilesetIDs (NormalizeDateTime (restoretime)' versions).ToList ();  	while (filesetIds.Count > 0) {  		var filesetId = filesetIds [0];  		filesetIds.RemoveAt (0);  		m_restoreTime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  		var ix = this.FilesetTimes.Select ((value' index) => new {  			value.Key'  			index  		}).Where (n => n.Key == filesetId).Select (pair => pair.index + 1).FirstOrDefault () - 1;  		log.AddMessage (string.Format ("Searching backup {0} ({1}) ..."' ix' m_restoreTime));  		cmd.Parameters.Clear ();  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));  		// better suited to speed up commit on UpdateBlocks  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));  		if (filter == null || filter.Empty) {  			// Simple case' restore everything  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  			cmd.AddParameter (filesetId);  			cmd.ExecuteNonQuery ();  		} else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  			// If we get a list of filenames' the lookup table is faster  			// unfortunately we cannot do this if the filesystem is case sensitive as  			// SQLite only supports ASCII compares  			using (var tr = m_connection.BeginTransaction ()) {  				var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  				var m_filenamestable = "Filenames-" + guid;  				cmd.Transaction = tr;  				cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  				cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  				cmd.AddParameter ();  				foreach (var s in p) {  					cmd.SetParameterValue (0' s);  					cmd.ExecuteNonQuery ();  				}  				cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  				cmd.SetParameterValue (0' filesetId);  				var c = cmd.ExecuteNonQuery ();  				cmd.Parameters.Clear ();  				if (c != p.Length && c != 0) {  					var sb = new StringBuilder ();  					sb.AppendLine ();  					using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  						while (rd.Read ())  							sb.AppendLine (rd.GetValue (0).ToString ());  					var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  					log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  					cmd.Parameters.Clear ();  				}  				cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  				using (new Logging.Timer ("CommitPrepareFileset"))  					tr.Commit ();  			}  		} else {  			// Restore but filter elements based on the filter expression  			// If this is too slow' we could add a special handler for wildcard searches too  			cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  			cmd.AddParameter (filesetId);  			object[] values = new object[3];  			using (var cmd2 = m_connection.CreateCommand ()) {  				cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  				cmd2.AddParameter ();  				cmd2.AddParameter ();  				cmd2.AddParameter ();  				using (var rd = cmd.ExecuteReader ())  					while (rd.Read ()) {  						rd.GetValues (values);  						if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  							cmd2.SetParameterValue (0' values [0]);  							cmd2.SetParameterValue (1' values [1]);  							cmd2.SetParameterValue (2' values [2]);  							cmd2.ExecuteNonQuery ();  						}  					}  			}  		}  		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) {  			var filecount = 0L;  			var filesize = 0L;  			if (rd.Read ()) {  				filecount = rd.ConvertValueToInt64 (0' 0);  				filesize = rd.ConvertValueToInt64 (1' 0);  			}  			if (filecount > 0) {  				log.AddVerboseMessage ("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString (filesize));  				return new Tuple<long' long> (filecount' filesize);  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	var filesetIds = GetFilesetIDs (NormalizeDateTime (restoretime)' versions).ToList ();  	while (filesetIds.Count > 0) {  		var filesetId = filesetIds [0];  		filesetIds.RemoveAt (0);  		m_restoreTime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  		var ix = this.FilesetTimes.Select ((value' index) => new {  			value.Key'  			index  		}).Where (n => n.Key == filesetId).Select (pair => pair.index + 1).FirstOrDefault () - 1;  		log.AddMessage (string.Format ("Searching backup {0} ({1}) ..."' ix' m_restoreTime));  		cmd.Parameters.Clear ();  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));  		// better suited to speed up commit on UpdateBlocks  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));  		if (filter == null || filter.Empty) {  			// Simple case' restore everything  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  			cmd.AddParameter (filesetId);  			cmd.ExecuteNonQuery ();  		} else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  			// If we get a list of filenames' the lookup table is faster  			// unfortunately we cannot do this if the filesystem is case sensitive as  			// SQLite only supports ASCII compares  			using (var tr = m_connection.BeginTransaction ()) {  				var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  				var m_filenamestable = "Filenames-" + guid;  				cmd.Transaction = tr;  				cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  				cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  				cmd.AddParameter ();  				foreach (var s in p) {  					cmd.SetParameterValue (0' s);  					cmd.ExecuteNonQuery ();  				}  				cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  				cmd.SetParameterValue (0' filesetId);  				var c = cmd.ExecuteNonQuery ();  				cmd.Parameters.Clear ();  				if (c != p.Length && c != 0) {  					var sb = new StringBuilder ();  					sb.AppendLine ();  					using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  						while (rd.Read ())  							sb.AppendLine (rd.GetValue (0).ToString ());  					var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  					log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  					cmd.Parameters.Clear ();  				}  				cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  				using (new Logging.Timer ("CommitPrepareFileset"))  					tr.Commit ();  			}  		} else {  			// Restore but filter elements based on the filter expression  			// If this is too slow' we could add a special handler for wildcard searches too  			cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  			cmd.AddParameter (filesetId);  			object[] values = new object[3];  			using (var cmd2 = m_connection.CreateCommand ()) {  				cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  				cmd2.AddParameter ();  				cmd2.AddParameter ();  				cmd2.AddParameter ();  				using (var rd = cmd.ExecuteReader ())  					while (rd.Read ()) {  						rd.GetValues (values);  						if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  							cmd2.SetParameterValue (0' values [0]);  							cmd2.SetParameterValue (1' values [1]);  							cmd2.SetParameterValue (2' values [2]);  							cmd2.ExecuteNonQuery ();  						}  					}  			}  		}  		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) {  			var filecount = 0L;  			var filesize = 0L;  			if (rd.Read ()) {  				filecount = rd.ConvertValueToInt64 (0' 0);  				filesize = rd.ConvertValueToInt64 (1' 0);  			}  			if (filecount > 0) {  				log.AddVerboseMessage ("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString (filesize));  				return new Tuple<long' long> (filecount' filesize);  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: while (filesetIds.Count > 0) {  	var filesetId = filesetIds [0];  	filesetIds.RemoveAt (0);  	m_restoreTime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  	var ix = this.FilesetTimes.Select ((value' index) => new {  		value.Key'  		index  	}).Where (n => n.Key == filesetId).Select (pair => pair.index + 1).FirstOrDefault () - 1;  	log.AddMessage (string.Format ("Searching backup {0} ({1}) ..."' ix' m_restoreTime));  	cmd.Parameters.Clear ();  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));  	// better suited to speed up commit on UpdateBlocks  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));  	if (filter == null || filter.Empty) {  		// Simple case' restore everything  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  		cmd.AddParameter (filesetId);  		cmd.ExecuteNonQuery ();  	} else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  		// If we get a list of filenames' the lookup table is faster  		// unfortunately we cannot do this if the filesystem is case sensitive as  		// SQLite only supports ASCII compares  		using (var tr = m_connection.BeginTransaction ()) {  			var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  			var m_filenamestable = "Filenames-" + guid;  			cmd.Transaction = tr;  			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  			cmd.AddParameter ();  			foreach (var s in p) {  				cmd.SetParameterValue (0' s);  				cmd.ExecuteNonQuery ();  			}  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  			cmd.SetParameterValue (0' filesetId);  			var c = cmd.ExecuteNonQuery ();  			cmd.Parameters.Clear ();  			if (c != p.Length && c != 0) {  				var sb = new StringBuilder ();  				sb.AppendLine ();  				using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  					while (rd.Read ())  						sb.AppendLine (rd.GetValue (0).ToString ());  				var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  				log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  				cmd.Parameters.Clear ();  			}  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  			using (new Logging.Timer ("CommitPrepareFileset"))  				tr.Commit ();  		}  	} else {  		// Restore but filter elements based on the filter expression  		// If this is too slow' we could add a special handler for wildcard searches too  		cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  		cmd.AddParameter (filesetId);  		object[] values = new object[3];  		using (var cmd2 = m_connection.CreateCommand ()) {  			cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  			cmd2.AddParameter ();  			cmd2.AddParameter ();  			cmd2.AddParameter ();  			using (var rd = cmd.ExecuteReader ())  				while (rd.Read ()) {  					rd.GetValues (values);  					if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  						cmd2.SetParameterValue (0' values [0]);  						cmd2.SetParameterValue (1' values [1]);  						cmd2.SetParameterValue (2' values [2]);  						cmd2.ExecuteNonQuery ();  					}  				}  		}  	}  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) {  		var filecount = 0L;  		var filesize = 0L;  		if (rd.Read ()) {  			filecount = rd.ConvertValueToInt64 (0' 0);  			filesize = rd.ConvertValueToInt64 (1' 0);  		}  		if (filecount > 0) {  			log.AddVerboseMessage ("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString (filesize));  			return new Tuple<long' long> (filecount' filesize);  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: while (filesetIds.Count > 0) {  	var filesetId = filesetIds [0];  	filesetIds.RemoveAt (0);  	m_restoreTime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  	var ix = this.FilesetTimes.Select ((value' index) => new {  		value.Key'  		index  	}).Where (n => n.Key == filesetId).Select (pair => pair.index + 1).FirstOrDefault () - 1;  	log.AddMessage (string.Format ("Searching backup {0} ({1}) ..."' ix' m_restoreTime));  	cmd.Parameters.Clear ();  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));  	// better suited to speed up commit on UpdateBlocks  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));  	if (filter == null || filter.Empty) {  		// Simple case' restore everything  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  		cmd.AddParameter (filesetId);  		cmd.ExecuteNonQuery ();  	} else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  		// If we get a list of filenames' the lookup table is faster  		// unfortunately we cannot do this if the filesystem is case sensitive as  		// SQLite only supports ASCII compares  		using (var tr = m_connection.BeginTransaction ()) {  			var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  			var m_filenamestable = "Filenames-" + guid;  			cmd.Transaction = tr;  			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  			cmd.AddParameter ();  			foreach (var s in p) {  				cmd.SetParameterValue (0' s);  				cmd.ExecuteNonQuery ();  			}  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  			cmd.SetParameterValue (0' filesetId);  			var c = cmd.ExecuteNonQuery ();  			cmd.Parameters.Clear ();  			if (c != p.Length && c != 0) {  				var sb = new StringBuilder ();  				sb.AppendLine ();  				using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  					while (rd.Read ())  						sb.AppendLine (rd.GetValue (0).ToString ());  				var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  				log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  				cmd.Parameters.Clear ();  			}  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  			using (new Logging.Timer ("CommitPrepareFileset"))  				tr.Commit ();  		}  	} else {  		// Restore but filter elements based on the filter expression  		// If this is too slow' we could add a special handler for wildcard searches too  		cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  		cmd.AddParameter (filesetId);  		object[] values = new object[3];  		using (var cmd2 = m_connection.CreateCommand ()) {  			cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  			cmd2.AddParameter ();  			cmd2.AddParameter ();  			cmd2.AddParameter ();  			using (var rd = cmd.ExecuteReader ())  				while (rd.Read ()) {  					rd.GetValues (values);  					if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  						cmd2.SetParameterValue (0' values [0]);  						cmd2.SetParameterValue (1' values [1]);  						cmd2.SetParameterValue (2' values [2]);  						cmd2.ExecuteNonQuery ();  					}  				}  		}  	}  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) {  		var filecount = 0L;  		var filesize = 0L;  		if (rd.Read ()) {  			filecount = rd.ConvertValueToInt64 (0' 0);  			filesize = rd.ConvertValueToInt64 (1' 0);  		}  		if (filecount > 0) {  			log.AddVerboseMessage ("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString (filesize));  			return new Tuple<long' long> (filecount' filesize);  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: while (filesetIds.Count > 0) {  	var filesetId = filesetIds [0];  	filesetIds.RemoveAt (0);  	m_restoreTime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  	var ix = this.FilesetTimes.Select ((value' index) => new {  		value.Key'  		index  	}).Where (n => n.Key == filesetId).Select (pair => pair.index + 1).FirstOrDefault () - 1;  	log.AddMessage (string.Format ("Searching backup {0} ({1}) ..."' ix' m_restoreTime));  	cmd.Parameters.Clear ();  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_tempblocktable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""Path"" TEXT NOT NULL' ""BlocksetID"" INTEGER NOT NULL' ""MetadataID"" INTEGER NOT NULL' ""TargetPath"" TEXT NULL' ""DataVerified"" BOOLEAN NOT NULL) "' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY' ""FileID"" INTEGER NOT NULL' ""Index"" INTEGER NOT NULL' ""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL' ""Restored"" BOOLEAN NOT NULL' ""Metadata"" BOOLEAN NOT NULL)"' m_tempblocktable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_Index"" ON ""{0}"" (""TargetPath"")"' m_tempfiletable));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_HashSizeIndex"" ON ""{0}"" (""Hash""' ""Size"")"' m_tempblocktable));  	// better suited to speed up commit on UpdateBlocks  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}_FileIdIndexIndex"" ON ""{0}"" (""FileId""' ""Index"")"' m_tempblocktable));  	if (filter == null || filter.Empty) {  		// Simple case' restore everything  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  		cmd.AddParameter (filesetId);  		cmd.ExecuteNonQuery ();  	} else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  		// If we get a list of filenames' the lookup table is faster  		// unfortunately we cannot do this if the filesystem is case sensitive as  		// SQLite only supports ASCII compares  		using (var tr = m_connection.BeginTransaction ()) {  			var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  			var m_filenamestable = "Filenames-" + guid;  			cmd.Transaction = tr;  			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  			cmd.AddParameter ();  			foreach (var s in p) {  				cmd.SetParameterValue (0' s);  				cmd.ExecuteNonQuery ();  			}  			cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  			cmd.SetParameterValue (0' filesetId);  			var c = cmd.ExecuteNonQuery ();  			cmd.Parameters.Clear ();  			if (c != p.Length && c != 0) {  				var sb = new StringBuilder ();  				sb.AppendLine ();  				using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  					while (rd.Read ())  						sb.AppendLine (rd.GetValue (0).ToString ());  				var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  				log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  				cmd.Parameters.Clear ();  			}  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  			using (new Logging.Timer ("CommitPrepareFileset"))  				tr.Commit ();  		}  	} else {  		// Restore but filter elements based on the filter expression  		// If this is too slow' we could add a special handler for wildcard searches too  		cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  		cmd.AddParameter (filesetId);  		object[] values = new object[3];  		using (var cmd2 = m_connection.CreateCommand ()) {  			cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  			cmd2.AddParameter ();  			cmd2.AddParameter ();  			cmd2.AddParameter ();  			using (var rd = cmd.ExecuteReader ())  				while (rd.Read ()) {  					rd.GetValues (values);  					if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  						cmd2.SetParameterValue (0' values [0]);  						cmd2.SetParameterValue (1' values [1]);  						cmd2.SetParameterValue (2' values [2]);  						cmd2.ExecuteNonQuery ();  					}  				}  		}  	}  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT COUNT(DISTINCT ""{0}"".""Path"")' SUM(""Blockset"".""Length"") FROM ""{0}""' ""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" "' m_tempfiletable))) {  		var filecount = 0L;  		var filesize = 0L;  		if (rd.Read ()) {  			filecount = rd.ConvertValueToInt64 (0' 0);  			filesize = rd.ConvertValueToInt64 (1' 0);  		}  		if (filecount > 0) {  			log.AddVerboseMessage ("Needs to restore {0} files ({1})"' filecount' Library.Utility.Utility.FormatSizeString (filesize));  			return new Tuple<long' long> (filecount' filesize);  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (filter == null || filter.Empty) {  	// Simple case' restore everything  	cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  	cmd.AddParameter (filesetId);  	cmd.ExecuteNonQuery ();  } else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  	// If we get a list of filenames' the lookup table is faster  	// unfortunately we cannot do this if the filesystem is case sensitive as  	// SQLite only supports ASCII compares  	using (var tr = m_connection.BeginTransaction ()) {  		var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  		var m_filenamestable = "Filenames-" + guid;  		cmd.Transaction = tr;  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  		cmd.AddParameter ();  		foreach (var s in p) {  			cmd.SetParameterValue (0' s);  			cmd.ExecuteNonQuery ();  		}  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  		cmd.SetParameterValue (0' filesetId);  		var c = cmd.ExecuteNonQuery ();  		cmd.Parameters.Clear ();  		if (c != p.Length && c != 0) {  			var sb = new StringBuilder ();  			sb.AppendLine ();  			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  				while (rd.Read ())  					sb.AppendLine (rd.GetValue (0).ToString ());  			var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  			log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  			cmd.Parameters.Clear ();  		}  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  		using (new Logging.Timer ("CommitPrepareFileset"))  			tr.Commit ();  	}  } else {  	// Restore but filter elements based on the filter expression  	// If this is too slow' we could add a special handler for wildcard searches too  	cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  	cmd.AddParameter (filesetId);  	object[] values = new object[3];  	using (var cmd2 = m_connection.CreateCommand ()) {  		cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		using (var rd = cmd.ExecuteReader ())  			while (rd.Read ()) {  				rd.GetValues (values);  				if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  					cmd2.SetParameterValue (0' values [0]);  					cmd2.SetParameterValue (1' values [1]);  					cmd2.SetParameterValue (2' values [2]);  					cmd2.ExecuteNonQuery ();  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (filter == null || filter.Empty) {  	// Simple case' restore everything  	cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  	cmd.AddParameter (filesetId);  	cmd.ExecuteNonQuery ();  } else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  	// If we get a list of filenames' the lookup table is faster  	// unfortunately we cannot do this if the filesystem is case sensitive as  	// SQLite only supports ASCII compares  	using (var tr = m_connection.BeginTransaction ()) {  		var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  		var m_filenamestable = "Filenames-" + guid;  		cmd.Transaction = tr;  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  		cmd.AddParameter ();  		foreach (var s in p) {  			cmd.SetParameterValue (0' s);  			cmd.ExecuteNonQuery ();  		}  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  		cmd.SetParameterValue (0' filesetId);  		var c = cmd.ExecuteNonQuery ();  		cmd.Parameters.Clear ();  		if (c != p.Length && c != 0) {  			var sb = new StringBuilder ();  			sb.AppendLine ();  			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  				while (rd.Read ())  					sb.AppendLine (rd.GetValue (0).ToString ());  			var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  			log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  			cmd.Parameters.Clear ();  		}  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  		using (new Logging.Timer ("CommitPrepareFileset"))  			tr.Commit ();  	}  } else {  	// Restore but filter elements based on the filter expression  	// If this is too slow' we could add a special handler for wildcard searches too  	cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  	cmd.AddParameter (filesetId);  	object[] values = new object[3];  	using (var cmd2 = m_connection.CreateCommand ()) {  		cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		using (var rd = cmd.ExecuteReader ())  			while (rd.Read ()) {  				rd.GetValues (values);  				if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  					cmd2.SetParameterValue (0' values [0]);  					cmd2.SetParameterValue (1' values [1]);  					cmd2.SetParameterValue (2' values [2]);  					cmd2.ExecuteNonQuery ();  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (filter == null || filter.Empty) {  	// Simple case' restore everything  	cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? "' m_tempfiletable);  	cmd.AddParameter (filesetId);  	cmd.ExecuteNonQuery ();  } else if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  	// If we get a list of filenames' the lookup table is faster  	// unfortunately we cannot do this if the filesystem is case sensitive as  	// SQLite only supports ASCII compares  	using (var tr = m_connection.BeginTransaction ()) {  		var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  		var m_filenamestable = "Filenames-" + guid;  		cmd.Transaction = tr;  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  		cmd.AddParameter ();  		foreach (var s in p) {  			cmd.SetParameterValue (0' s);  			cmd.ExecuteNonQuery ();  		}  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  		cmd.SetParameterValue (0' filesetId);  		var c = cmd.ExecuteNonQuery ();  		cmd.Parameters.Clear ();  		if (c != p.Length && c != 0) {  			var sb = new StringBuilder ();  			sb.AppendLine ();  			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  				while (rd.Read ())  					sb.AppendLine (rd.GetValue (0).ToString ());  			var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  			log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  			cmd.Parameters.Clear ();  		}  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  		using (new Logging.Timer ("CommitPrepareFileset"))  			tr.Commit ();  	}  } else {  	// Restore but filter elements based on the filter expression  	// If this is too slow' we could add a special handler for wildcard searches too  	cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  	cmd.AddParameter (filesetId);  	object[] values = new object[3];  	using (var cmd2 = m_connection.CreateCommand ()) {  		cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		using (var rd = cmd.ExecuteReader ())  			while (rd.Read ()) {  				rd.GetValues (values);  				if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  					cmd2.SetParameterValue (0' values [0]);  					cmd2.SetParameterValue (1' values [1]);  					cmd2.SetParameterValue (2' values [2]);  					cmd2.ExecuteNonQuery ();  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  	// If we get a list of filenames' the lookup table is faster  	// unfortunately we cannot do this if the filesystem is case sensitive as  	// SQLite only supports ASCII compares  	using (var tr = m_connection.BeginTransaction ()) {  		var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  		var m_filenamestable = "Filenames-" + guid;  		cmd.Transaction = tr;  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  		cmd.AddParameter ();  		foreach (var s in p) {  			cmd.SetParameterValue (0' s);  			cmd.ExecuteNonQuery ();  		}  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  		cmd.SetParameterValue (0' filesetId);  		var c = cmd.ExecuteNonQuery ();  		cmd.Parameters.Clear ();  		if (c != p.Length && c != 0) {  			var sb = new StringBuilder ();  			sb.AppendLine ();  			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  				while (rd.Read ())  					sb.AppendLine (rd.GetValue (0).ToString ());  			var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  			log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  			cmd.Parameters.Clear ();  		}  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  		using (new Logging.Timer ("CommitPrepareFileset"))  			tr.Commit ();  	}  } else {  	// Restore but filter elements based on the filter expression  	// If this is too slow' we could add a special handler for wildcard searches too  	cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  	cmd.AddParameter (filesetId);  	object[] values = new object[3];  	using (var cmd2 = m_connection.CreateCommand ()) {  		cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		using (var rd = cmd.ExecuteReader ())  			while (rd.Read ()) {  				rd.GetValues (values);  				if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  					cmd2.SetParameterValue (0' values [0]);  					cmd2.SetParameterValue (1' values [1]);  					cmd2.SetParameterValue (2' values [2]);  					cmd2.ExecuteNonQuery ();  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  	// If we get a list of filenames' the lookup table is faster  	// unfortunately we cannot do this if the filesystem is case sensitive as  	// SQLite only supports ASCII compares  	using (var tr = m_connection.BeginTransaction ()) {  		var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  		var m_filenamestable = "Filenames-" + guid;  		cmd.Transaction = tr;  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  		cmd.AddParameter ();  		foreach (var s in p) {  			cmd.SetParameterValue (0' s);  			cmd.ExecuteNonQuery ();  		}  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  		cmd.SetParameterValue (0' filesetId);  		var c = cmd.ExecuteNonQuery ();  		cmd.Parameters.Clear ();  		if (c != p.Length && c != 0) {  			var sb = new StringBuilder ();  			sb.AppendLine ();  			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  				while (rd.Read ())  					sb.AppendLine (rd.GetValue (0).ToString ());  			var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  			log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  			cmd.Parameters.Clear ();  		}  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  		using (new Logging.Timer ("CommitPrepareFileset"))  			tr.Commit ();  	}  } else {  	// Restore but filter elements based on the filter expression  	// If this is too slow' we could add a special handler for wildcard searches too  	cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  	cmd.AddParameter (filesetId);  	object[] values = new object[3];  	using (var cmd2 = m_connection.CreateCommand ()) {  		cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		using (var rd = cmd.ExecuteReader ())  			while (rd.Read ()) {  				rd.GetValues (values);  				if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  					cmd2.SetParameterValue (0' values [0]);  					cmd2.SetParameterValue (1' values [1]);  					cmd2.SetParameterValue (2' values [2]);  					cmd2.ExecuteNonQuery ();  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (Library.Utility.Utility.IsFSCaseSensitive && filter is Library.Utility.FilterExpression && (filter as Library.Utility.FilterExpression).Type == Duplicati.Library.Utility.FilterType.Simple) {  	// If we get a list of filenames' the lookup table is faster  	// unfortunately we cannot do this if the filesystem is case sensitive as  	// SQLite only supports ASCII compares  	using (var tr = m_connection.BeginTransaction ()) {  		var p = (filter as Library.Utility.FilterExpression).GetSimpleList ();  		var m_filenamestable = "Filenames-" + guid;  		cmd.Transaction = tr;  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Path"" TEXT NOT NULL) "' m_filenamestable));  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path"") VALUES (?)"' m_filenamestable);  		cmd.AddParameter ();  		foreach (var s in p) {  			cmd.SetParameterValue (0' s);  			cmd.ExecuteNonQuery ();  		}  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID""' 0 FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetEntry"".""FilesetID"" = ? AND ""Path"" IN (SELECT DISTINCT ""Path"" FROM ""{1}"") "' m_tempfiletable' m_filenamestable);  		cmd.SetParameterValue (0' filesetId);  		var c = cmd.ExecuteNonQuery ();  		cmd.Parameters.Clear ();  		if (c != p.Length && c != 0) {  			var sb = new StringBuilder ();  			sb.AppendLine ();  			using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""Path"" FROM ""{0}"" WHERE ""Path"" NOT IN (SELECT ""Path"" FROM ""{1}"")"' m_filenamestable' m_tempfiletable)))  				while (rd.Read ())  					sb.AppendLine (rd.GetValue (0).ToString ());  			var actualrestoretime = ParseFromEpochSeconds (cmd.ExecuteScalarInt64 (@"SELECT ""Timestamp"" FROM ""Fileset"" WHERE ""ID"" = ?"' 0' filesetId));  			log.AddWarning (string.Format ("{0} File(s) were not found in list of files for backup at {1}' will not be restored: {2}"' p.Length - c' actualrestoretime.ToLocalTime ()' sb)' null);  			cmd.Parameters.Clear ();  		}  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' m_filenamestable));  		using (new Logging.Timer ("CommitPrepareFileset"))  			tr.Commit ();  	}  } else {  	// Restore but filter elements based on the filter expression  	// If this is too slow' we could add a special handler for wildcard searches too  	cmd.CommandText = string.Format (@"SELECT ""File"".""Path""' ""File"".""BlocksetID""' ""File"".""MetadataID"" FROM ""File""' ""FilesetEntry"" WHERE ""File"".""ID"" = ""FilesetEntry"".""FileID"" AND ""FilesetID"" = ?");  	cmd.AddParameter (filesetId);  	object[] values = new object[3];  	using (var cmd2 = m_connection.CreateCommand ()) {  		cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		cmd2.AddParameter ();  		using (var rd = cmd.ExecuteReader ())  			while (rd.Read ()) {  				rd.GetValues (values);  				if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  					cmd2.SetParameterValue (0' values [0]);  					cmd2.SetParameterValue (1' values [1]);  					cmd2.SetParameterValue (2' values [2]);  					cmd2.ExecuteNonQuery ();  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using (var cmd2 = m_connection.CreateCommand ()) {  	cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  	cmd2.AddParameter ();  	cmd2.AddParameter ();  	cmd2.AddParameter ();  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			rd.GetValues (values);  			if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  				cmd2.SetParameterValue (0' values [0]);  				cmd2.SetParameterValue (1' values [1]);  				cmd2.SetParameterValue (2' values [2]);  				cmd2.ExecuteNonQuery ();  			}  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using (var cmd2 = m_connection.CreateCommand ()) {  	cmd2.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Path""' ""BlocksetID""' ""MetadataID""' ""DataVerified"") VALUES (?'?'?'0)"' m_tempfiletable);  	cmd2.AddParameter ();  	cmd2.AddParameter ();  	cmd2.AddParameter ();  	using (var rd = cmd.ExecuteReader ())  		while (rd.Read ()) {  			rd.GetValues (values);  			if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  				cmd2.SetParameterValue (0' values [0]);  				cmd2.SetParameterValue (1' values [1]);  				cmd2.SetParameterValue (2' values [2]);  				cmd2.ExecuteNonQuery ();  			}  		}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	while (rd.Read ()) {  		rd.GetValues (values);  		if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  			cmd2.SetParameterValue (0' values [0]);  			cmd2.SetParameterValue (1' values [1]);  			cmd2.SetParameterValue (2' values [2]);  			cmd2.ExecuteNonQuery ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ())  	while (rd.Read ()) {  		rd.GetValues (values);  		if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  			cmd2.SetParameterValue (0' values [0]);  			cmd2.SetParameterValue (1' values [1]);  			cmd2.SetParameterValue (2' values [2]);  			cmd2.ExecuteNonQuery ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: while (rd.Read ()) {  	rd.GetValues (values);  	if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  		cmd2.SetParameterValue (0' values [0]);  		cmd2.SetParameterValue (1' values [1]);  		cmd2.SetParameterValue (2' values [2]);  		cmd2.ExecuteNonQuery ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: while (rd.Read ()) {  	rd.GetValues (values);  	if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  		cmd2.SetParameterValue (0' values [0]);  		cmd2.SetParameterValue (1' values [1]);  		cmd2.SetParameterValue (2' values [2]);  		cmd2.ExecuteNonQuery ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  	cmd2.SetParameterValue (0' values [0]);  	cmd2.SetParameterValue (1' values [1]);  	cmd2.SetParameterValue (2' values [2]);  	cmd2.ExecuteNonQuery ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: if (values [0] != null && values [0] != DBNull.Value && Library.Utility.FilterExpression.Matches (filter' values [0].ToString ())) {  	cmd2.SetParameterValue (0' values [0]);  	cmd2.SetParameterValue (1' values [1]);  	cmd2.SetParameterValue (2' values [2]);  	cmd2.ExecuteNonQuery ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: cmd2.SetParameterValue (2' values [2]);  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,PrepareRestoreFilelist,The following statement contains a magic number: cmd2.SetParameterValue (2' values [2]);  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetLargestPrefix,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.CommandText = string.Format (@"SELECT ""Path"" FROM ""{0}"" ORDER BY LENGTH(""Path"") DESC LIMIT 1"' m_tempfiletable);  	var v0 = cmd.ExecuteScalar ();  	string maxpath = "";  	if (v0 != null && v0 != DBNull.Value)  		maxpath = v0.ToString ();  	var dirsep = Duplicati.Library.Utility.Utility.GuessDirSeparator (maxpath);  	cmd.CommandText = string.Format (@"SELECT COUNT(*) FROM ""{0}"""' m_tempfiletable);  	var filecount = cmd.ExecuteScalarInt64 (-1);  	long foundfiles = -1;  	//TODO: Handle FS case-sensitive?  	cmd.CommandText = string.Format (@"SELECT COUNT(*) FROM ""{0}"" WHERE SUBSTR(""Path""' 1' ?) = ?"' m_tempfiletable);  	cmd.AddParameter ();  	cmd.AddParameter ();  	while (filecount != foundfiles && maxpath.Length > 0) {  		var mp = Library.Utility.Utility.AppendDirSeparator (maxpath' dirsep);  		cmd.SetParameterValue (0' mp.Length);  		cmd.SetParameterValue (1' mp);  		foundfiles = cmd.ExecuteScalarInt64 (-1);  		if (filecount != foundfiles) {  			var oldlen = maxpath.Length;  			var lix = maxpath.LastIndexOf (dirsep' maxpath.Length - 2' StringComparison.Ordinal);  			maxpath = maxpath.Substring (0' lix + 1);  			if (string.IsNullOrWhiteSpace (maxpath) || maxpath.Length == oldlen)  				maxpath = "";  		}  	}  	return maxpath == "" ? "" : Library.Utility.Utility.AppendDirSeparator (maxpath' dirsep);  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetLargestPrefix,The following statement contains a magic number: while (filecount != foundfiles && maxpath.Length > 0) {  	var mp = Library.Utility.Utility.AppendDirSeparator (maxpath' dirsep);  	cmd.SetParameterValue (0' mp.Length);  	cmd.SetParameterValue (1' mp);  	foundfiles = cmd.ExecuteScalarInt64 (-1);  	if (filecount != foundfiles) {  		var oldlen = maxpath.Length;  		var lix = maxpath.LastIndexOf (dirsep' maxpath.Length - 2' StringComparison.Ordinal);  		maxpath = maxpath.Substring (0' lix + 1);  		if (string.IsNullOrWhiteSpace (maxpath) || maxpath.Length == oldlen)  			maxpath = "";  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetLargestPrefix,The following statement contains a magic number: if (filecount != foundfiles) {  	var oldlen = maxpath.Length;  	var lix = maxpath.LastIndexOf (dirsep' maxpath.Length - 2' StringComparison.Ordinal);  	maxpath = maxpath.Substring (0' lix + 1);  	if (string.IsNullOrWhiteSpace (maxpath) || maxpath.Length == oldlen)  		maxpath = "";  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	// Return order from SQLite-DISTINCT is likely to be sorted by Name' which is bad for restore.  	// If the end of very large files (e.g. iso's) is restored before the beginning' most OS write out zeros to fill the file.  	// If we manage to get the volumes in an order restoring front blocks first' this can save time.  	// An optimal algorithm would build a depency net with cycle resolution to find the best near topological  	// order of volumes' but this is a bit too fancy here.  	// We will just put a very simlpe heuristic to work' that will try to prefer volumes containing lower block indexes:  	// We just order all volumes by the maximum block index they contain. This query is slow' but should be worth the effort.  	// Now it is likely to restore all files from front to back. Large files will always be done last.  	// One could also use like the average block number in a volume' that needs to be measured.  	cmd.CommandText = string.Format (@"SELECT ""RV"".""Name""' ""RV"".""Hash""' ""RV"".""Size""' ""BB"".""MaxIndex"" " + @"  FROM ""RemoteVolume"" ""RV"" INNER JOIN " + @"        (SELECT ""B"".""VolumeID""' MAX(""TB"".""Index"") as ""MaxIndex"" " + @"           FROM ""Block"" ""B""' ""{0}"" ""TB"" " + @"          WHERE ""TB"".""Restored"" = 0 " + @"            AND ""B"".""Hash"" = ""TB"".""Hash"" " + @"            AND ""B"".""Size"" = ""TB"".""Size"" " + @"          GROUP BY  ""B"".""VolumeID"" " + @"        ) as ""BB"" ON ""RV"".""ID"" = ""BB"".""VolumeID"" " + @"  ORDER BY ""BB"".""MaxIndex"" "' m_tempblocktable);  	using (var rd = cmd.ExecuteReader ()) {  		object[] r = new object[3];  		while (rd.Read ()) {  			rd.GetValues (r);  			yield return new RemoteVolume (rd.ConvertValueToString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	// Return order from SQLite-DISTINCT is likely to be sorted by Name' which is bad for restore.  	// If the end of very large files (e.g. iso's) is restored before the beginning' most OS write out zeros to fill the file.  	// If we manage to get the volumes in an order restoring front blocks first' this can save time.  	// An optimal algorithm would build a depency net with cycle resolution to find the best near topological  	// order of volumes' but this is a bit too fancy here.  	// We will just put a very simlpe heuristic to work' that will try to prefer volumes containing lower block indexes:  	// We just order all volumes by the maximum block index they contain. This query is slow' but should be worth the effort.  	// Now it is likely to restore all files from front to back. Large files will always be done last.  	// One could also use like the average block number in a volume' that needs to be measured.  	cmd.CommandText = string.Format (@"SELECT ""RV"".""Name""' ""RV"".""Hash""' ""RV"".""Size""' ""BB"".""MaxIndex"" " + @"  FROM ""RemoteVolume"" ""RV"" INNER JOIN " + @"        (SELECT ""B"".""VolumeID""' MAX(""TB"".""Index"") as ""MaxIndex"" " + @"           FROM ""Block"" ""B""' ""{0}"" ""TB"" " + @"          WHERE ""TB"".""Restored"" = 0 " + @"            AND ""B"".""Hash"" = ""TB"".""Hash"" " + @"            AND ""B"".""Size"" = ""TB"".""Size"" " + @"          GROUP BY  ""B"".""VolumeID"" " + @"        ) as ""BB"" ON ""RV"".""ID"" = ""BB"".""VolumeID"" " + @"  ORDER BY ""BB"".""MaxIndex"" "' m_tempblocktable);  	using (var rd = cmd.ExecuteReader ()) {  		object[] r = new object[3];  		while (rd.Read ()) {  			rd.GetValues (r);  			yield return new RemoteVolume (rd.ConvertValueToString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ()) {  	object[] r = new object[3];  	while (rd.Read ()) {  		rd.GetValues (r);  		yield return new RemoteVolume (rd.ConvertValueToString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ()) {  	object[] r = new object[3];  	while (rd.Read ()) {  		rd.GetValues (r);  		yield return new RemoteVolume (rd.ConvertValueToString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: while (rd.Read ()) {  	rd.GetValues (r);  	yield return new RemoteVolume (rd.ConvertValueToString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetMissingVolumes,The following statement contains a magic number: yield return new RemoteVolume (rd.ConvertValueToString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.AddParameter (!onlyNonVerified);  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable)))  		while (rd.Read ())  			yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.AddParameter (!onlyNonVerified);  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable)))  		while (rd.Read ())  			yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable)))  	while (rd.Read ())  		yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""{0}"".""ID""' ""{0}"".""TargetPath""' ""Blockset"".""FullHash""' ""Blockset"".""Length"" FROM ""{0}""'""Blockset"" WHERE ""{0}"".""BlocksetID"" = ""Blockset"".""ID"" AND ""{0}"".""DataVerified"" <= ?"' m_tempfiletable)))  	while (rd.Read ())  		yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: while (rd.Read ())  	yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: while (rd.Read ())  	yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  
Magic Number,Duplicati.Library.Main.Database,LocalRestoreDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRestoreDatabase.cs,GetFilesToRestore,The following statement contains a magic number: yield return new FileToRestore (rd.ConvertValueToInt64 (0)' rd.ConvertValueToString (1)' rd.ConvertValueToString (2)' rd.ConvertValueToInt64 (3));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,InitializeCommands,The following statement contains a magic number: m_moveBlockToNewVolumeCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	try {  		cmd.ExecuteNonQuery (createtable' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  			while (rd.Read ())  				yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  	} finally {  		try {  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename));  		} catch {  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	try {  		cmd.ExecuteNonQuery (createtable' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  			while (rd.Read ())  				yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  	} finally {  		try {  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename));  		} catch {  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	cmd.Transaction = transaction;  	try {  		cmd.ExecuteNonQuery (createtable' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  		using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  			while (rd.Read ())  				yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  	} finally {  		try {  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename));  		} catch {  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: try {  	cmd.ExecuteNonQuery (createtable' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  		while (rd.Read ())  			yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  } finally {  	try {  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename));  	} catch {  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: try {  	cmd.ExecuteNonQuery (createtable' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  		while (rd.Read ())  			yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  } finally {  	try {  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename));  	} catch {  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: try {  	cmd.ExecuteNonQuery (createtable' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  		while (rd.Read ())  			yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  } finally {  	try {  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tmptablename));  	} catch {  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  	while (rd.Read ())  		yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  	while (rd.Read ())  		yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (string.Format (@"SELECT ""A"".""Name""' ""B"".""ActiveSize""' ""B"".""InactiveSize""' ""A"".""Size"" FROM ""Remotevolume"" A' ""{0}"" B WHERE ""A"".""ID"" = ""B"".""VolumeID"" ORDER BY ""B"".""Sorttime"" ASC "' tmptablename)))  	while (rd.Read ())  		yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: while (rd.Read ())  	yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: while (rd.Read ())  	yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: while (rd.Read ())  	yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetWastedSpaceReport,The following statement contains a magic number: yield return new VolumeUsage (rd.GetValue (0).ToString ()' rd.ConvertValueToInt64 (1' 0) + rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (2' 0)' rd.ConvertValueToInt64 (3' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,MoveBlockToNewVolume,The following statement contains a magic number: m_moveBlockToNewVolumeCommand.SetParameterValue (2' size);  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	// Although the generated index volumes are always in pairs'  	// this code handles many-to-many relations between  	// index files and block volumes' should this be added later  	var lookupBlock = new Dictionary<string' List<IRemoteVolume>> ();  	var lookupIndexfiles = new Dictionary<string' List<string>> ();  	cmd.Transaction = transaction;  	using (var rd = cmd.ExecuteReader (@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL "))  		while (rd.Read ()) {  			var name = rd.GetValue (0).ToString ();  			List<IRemoteVolume> indexfileList;  			if (!lookupBlock.TryGetValue (name' out indexfileList)) {  				indexfileList = new List<IRemoteVolume> ();  				lookupBlock.Add (name' indexfileList);  			}  			var v = new RemoteVolume (rd.GetString (1)' rd.GetString (2)' rd.GetInt64 (3));  			indexfileList.Add (v);  			List<string> blockList;  			if (!lookupIndexfiles.TryGetValue (v.Name' out blockList)) {  				blockList = new List<string> ();  				lookupIndexfiles.Add (v.Name' blockList);  			}  			blockList.Add (name);  		}  	foreach (var r in deleteableVolumes.Distinct ()) {  		// Return the input  		yield return r;  		List<IRemoteVolume> indexfileList;  		if (lookupBlock.TryGetValue (r.Name' out indexfileList))  			foreach (var sh in indexfileList) {  				List<string> backref;  				if (lookupIndexfiles.TryGetValue (sh.Name' out backref)) {  					//If this is the last reference'   					// remove the index file as well  					if (backref.Remove (r.Name) && backref.Count == 0)  						yield return sh;  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	// Although the generated index volumes are always in pairs'  	// this code handles many-to-many relations between  	// index files and block volumes' should this be added later  	var lookupBlock = new Dictionary<string' List<IRemoteVolume>> ();  	var lookupIndexfiles = new Dictionary<string' List<string>> ();  	cmd.Transaction = transaction;  	using (var rd = cmd.ExecuteReader (@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL "))  		while (rd.Read ()) {  			var name = rd.GetValue (0).ToString ();  			List<IRemoteVolume> indexfileList;  			if (!lookupBlock.TryGetValue (name' out indexfileList)) {  				indexfileList = new List<IRemoteVolume> ();  				lookupBlock.Add (name' indexfileList);  			}  			var v = new RemoteVolume (rd.GetString (1)' rd.GetString (2)' rd.GetInt64 (3));  			indexfileList.Add (v);  			List<string> blockList;  			if (!lookupIndexfiles.TryGetValue (v.Name' out blockList)) {  				blockList = new List<string> ();  				lookupIndexfiles.Add (v.Name' blockList);  			}  			blockList.Add (name);  		}  	foreach (var r in deleteableVolumes.Distinct ()) {  		// Return the input  		yield return r;  		List<IRemoteVolume> indexfileList;  		if (lookupBlock.TryGetValue (r.Name' out indexfileList))  			foreach (var sh in indexfileList) {  				List<string> backref;  				if (lookupIndexfiles.TryGetValue (sh.Name' out backref)) {  					//If this is the last reference'   					// remove the index file as well  					if (backref.Remove (r.Name) && backref.Count == 0)  						yield return sh;  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL "))  	while (rd.Read ()) {  		var name = rd.GetValue (0).ToString ();  		List<IRemoteVolume> indexfileList;  		if (!lookupBlock.TryGetValue (name' out indexfileList)) {  			indexfileList = new List<IRemoteVolume> ();  			lookupBlock.Add (name' indexfileList);  		}  		var v = new RemoteVolume (rd.GetString (1)' rd.GetString (2)' rd.GetInt64 (3));  		indexfileList.Add (v);  		List<string> blockList;  		if (!lookupIndexfiles.TryGetValue (v.Name' out blockList)) {  			blockList = new List<string> ();  			lookupIndexfiles.Add (v.Name' blockList);  		}  		blockList.Add (name);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: using (var rd = cmd.ExecuteReader (@"SELECT ""C"".""Name""' ""B"".""Name""' ""B"".""Hash""' ""B"".""Size"" FROM ""IndexBlockLink"" A' ""RemoteVolume"" B' ""RemoteVolume"" C WHERE ""A"".""IndexVolumeID"" = ""B"".""ID"" AND ""A"".""BlockVolumeID"" = ""C"".""ID"" AND ""B"".""Hash"" IS NOT NULL AND ""B"".""Size"" IS NOT NULL "))  	while (rd.Read ()) {  		var name = rd.GetValue (0).ToString ();  		List<IRemoteVolume> indexfileList;  		if (!lookupBlock.TryGetValue (name' out indexfileList)) {  			indexfileList = new List<IRemoteVolume> ();  			lookupBlock.Add (name' indexfileList);  		}  		var v = new RemoteVolume (rd.GetString (1)' rd.GetString (2)' rd.GetInt64 (3));  		indexfileList.Add (v);  		List<string> blockList;  		if (!lookupIndexfiles.TryGetValue (v.Name' out blockList)) {  			blockList = new List<string> ();  			lookupIndexfiles.Add (v.Name' blockList);  		}  		blockList.Add (name);  	}  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: while (rd.Read ()) {  	var name = rd.GetValue (0).ToString ();  	List<IRemoteVolume> indexfileList;  	if (!lookupBlock.TryGetValue (name' out indexfileList)) {  		indexfileList = new List<IRemoteVolume> ();  		lookupBlock.Add (name' indexfileList);  	}  	var v = new RemoteVolume (rd.GetString (1)' rd.GetString (2)' rd.GetInt64 (3));  	indexfileList.Add (v);  	List<string> blockList;  	if (!lookupIndexfiles.TryGetValue (v.Name' out blockList)) {  		blockList = new List<string> ();  		lookupIndexfiles.Add (v.Name' blockList);  	}  	blockList.Add (name);  }  
Magic Number,Duplicati.Library.Main.Database,LocalDeleteDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalDeleteDatabase.cs,GetDeletableVolumes,The following statement contains a magic number: while (rd.Read ()) {  	var name = rd.GetValue (0).ToString ();  	List<IRemoteVolume> indexfileList;  	if (!lookupBlock.TryGetValue (name' out indexfileList)) {  		indexfileList = new List<IRemoteVolume> ();  		lookupBlock.Add (name' indexfileList);  	}  	var v = new RemoteVolume (rd.GetString (1)' rd.GetString (2)' rd.GetInt64 (3));  	indexfileList.Add (v);  	List<string> blockList;  	if (!lookupIndexfiles.TryGetValue (v.Name' out blockList)) {  		blockList = new List<string> ();  		lookupIndexfiles.Add (v.Name' blockList);  	}  	blockList.Add (name);  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetBlockVolumesFromIndexName,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ())  	foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""ID"" IN (SELECT ""BlockVolumeID"" FROM ""IndexBlockLink"" WHERE ""IndexVolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?))"' name))  		yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetBlockVolumesFromIndexName,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (@"SELECT ""Name""' ""Hash""' ""Size"" FROM ""RemoteVolume"" WHERE ""ID"" IN (SELECT ""BlockVolumeID"" FROM ""IndexBlockLink"" WHERE ""IndexVolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?))"' name))  	yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,GetBlockVolumesFromIndexName,The following statement contains a magic number: yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		cmd.Transaction = tr;  		var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 1) {  			m_result.AddMessage ("Found duplicate metadatahashes' repairing");  			var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  			var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  				c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  				using (var rd = cmd.ExecuteReader (sql))  					while (rd.Read ())  						c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  			}  			sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  			using (var c2 = m_connection.CreateCommand ()) {  				c2.Transaction = tr;  				c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  				c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  			m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		cmd.Transaction = tr;  		var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 1) {  			m_result.AddMessage ("Found duplicate metadatahashes' repairing");  			var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  			var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  				c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  				using (var rd = cmd.ExecuteReader (sql))  					while (rd.Read ())  						c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  			}  			sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  			using (var c2 = m_connection.CreateCommand ()) {  				c2.Transaction = tr;  				c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  				c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  			m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		cmd.Transaction = tr;  		var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 1) {  			m_result.AddMessage ("Found duplicate metadatahashes' repairing");  			var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  			var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  				c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  				using (var rd = cmd.ExecuteReader (sql))  					while (rd.Read ())  						c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  			}  			sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  			using (var c2 = m_connection.CreateCommand ()) {  				c2.Transaction = tr;  				c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  				c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  			m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		cmd.Transaction = tr;  		var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 1) {  			m_result.AddMessage ("Found duplicate metadatahashes' repairing");  			var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  			cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  			var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  				c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  				using (var rd = cmd.ExecuteReader (sql))  					while (rd.Read ())  						c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  			}  			sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  			using (var c2 = m_connection.CreateCommand ()) {  				c2.Transaction = tr;  				c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  				c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  			cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  			cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  			m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	cmd.Transaction = tr;  	var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 1) {  		m_result.AddMessage ("Found duplicate metadatahashes' repairing");  		var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  		var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  			c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  			using (var rd = cmd.ExecuteReader (sql))  				while (rd.Read ())  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  		}  		sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  		using (var c2 = m_connection.CreateCommand ()) {  			c2.Transaction = tr;  			c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  			c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  		cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  		m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	cmd.Transaction = tr;  	var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 1) {  		m_result.AddMessage ("Found duplicate metadatahashes' repairing");  		var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  		var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  			c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  			using (var rd = cmd.ExecuteReader (sql))  				while (rd.Read ())  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  		}  		sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  		using (var c2 = m_connection.CreateCommand ()) {  			c2.Transaction = tr;  			c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  			c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  		cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  		m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	cmd.Transaction = tr;  	var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 1) {  		m_result.AddMessage ("Found duplicate metadatahashes' repairing");  		var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  		var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  			c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  			using (var rd = cmd.ExecuteReader (sql))  				while (rd.Read ())  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  		}  		sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  		using (var c2 = m_connection.CreateCommand ()) {  			c2.Transaction = tr;  			c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  			c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  		cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  		m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	cmd.Transaction = tr;  	var sql_count = @"SELECT COUNT(*) FROM (" + @" SELECT DISTINCT c1 FROM (" + @"SELECT COUNT(*) AS ""C1"" FROM (SELECT DISTINCT ""BlocksetID"" FROM ""Metadataset"") UNION SELECT COUNT(*) AS ""C1"" FROM ""Metadataset"" " + @")" + @")";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 1) {  		m_result.AddMessage ("Found duplicate metadatahashes' repairing");  		var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  		var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  			c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  			using (var rd = cmd.ExecuteReader (sql))  				while (rd.Read ())  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  		}  		sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  		using (var c2 = m_connection.CreateCommand ()) {  			c2.Transaction = tr;  			c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  			c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  		cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  		m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: if (x > 1) {  	m_result.AddMessage ("Found duplicate metadatahashes' repairing");  	var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  	var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  		c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  		using (var rd = cmd.ExecuteReader (sql))  			while (rd.Read ())  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  	}  	sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  	using (var c2 = m_connection.CreateCommand ()) {  		c2.Transaction = tr;  		c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  		c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  	cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  	m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: if (x > 1) {  	m_result.AddMessage ("Found duplicate metadatahashes' repairing");  	var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  	var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  		c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  		using (var rd = cmd.ExecuteReader (sql))  			while (rd.Read ())  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  	}  	sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  	using (var c2 = m_connection.CreateCommand ()) {  		c2.Transaction = tr;  		c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  		c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  	cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  	m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: if (x > 1) {  	m_result.AddMessage ("Found duplicate metadatahashes' repairing");  	var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  	var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  		c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  		using (var rd = cmd.ExecuteReader (sql))  			while (rd.Read ())  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  	}  	sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  	using (var c2 = m_connection.CreateCommand ()) {  		c2.Transaction = tr;  		c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  		c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  	cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  	m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: if (x > 1) {  	m_result.AddMessage ("Found duplicate metadatahashes' repairing");  	var tablename = "TmpFile-" + Guid.NewGuid ().ToString ("N");  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" AS SELECT * FROM ""File"""' tablename));  	var sql = @"SELECT ""A"".""ID""' ""B"".""BlocksetID"" FROM (SELECT MIN(""ID"") AS ""ID""' COUNT(""ID"") AS ""Duplicates"" FROM ""Metadataset"" GROUP BY ""BlocksetID"") ""A""' ""Metadataset"" ""B"" WHERE ""A"".""Duplicates"" > 1 AND ""A"".""ID"" = ""B"".""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = string.Format (@"UPDATE ""{0}"" SET ""MetadataID"" = ? WHERE ""MetadataID"" IN (SELECT ""ID"" FROM ""Metadataset"" WHERE ""BlocksetID"" = ?)"' tablename);  		c2.CommandText += @"; DELETE FROM ""Metadataset"" WHERE ""BlocksetID"" = ? AND ""ID"" != ?";  		using (var rd = cmd.ExecuteReader (sql))  			while (rd.Read ())  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (1)' rd.GetValue (0));  	}  	sql = string.Format (@"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""{0}"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID"""' tablename);  	using (var c2 = m_connection.CreateCommand ()) {  		c2.Transaction = tr;  		c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  		c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""File"" WHERE ""ID"" NOT IN (SELECT ""ID"" FROM ""{0}"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"CREATE INDEX ""{0}-Ix"" ON  ""{0}"" (""ID""' ""MetadataID"")"' tablename));  	cmd.ExecuteNonQuery (string.Format (@"UPDATE ""File"" SET ""MetadataID"" = (SELECT ""MetadataID"" FROM ""{0}"" A WHERE ""A"".""ID"" = ""File"".""ID"") "' tablename));  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE ""{0}"" "' tablename));  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate metadatahashes!");  	m_result.AddMessage ("Duplicate metadatahashes repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand ()) {  	c2.Transaction = tr;  	c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  	c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand ()) {  	c2.Transaction = tr;  	c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  	c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand ()) {  	c2.Transaction = tr;  	c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  	c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand ()) {  	c2.Transaction = tr;  	c2.CommandText = string.Format (@"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)"' tablename);  	c2.CommandText += string.Format (@"; DELETE FROM ""{0}"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?"' tablename);  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateMetahash,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 0) {  			m_result.AddMessage ("Found duplicate file entries' repairing");  			var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  				c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  			m_result.AddMessage ("Duplicate file entries repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 0) {  			m_result.AddMessage ("Found duplicate file entries' repairing");  			var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  				c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  			m_result.AddMessage ("Duplicate file entries repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 0) {  			m_result.AddMessage ("Found duplicate file entries' repairing");  			var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  				c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  			m_result.AddMessage ("Duplicate file entries repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 0) {  			m_result.AddMessage ("Found duplicate file entries' repairing");  			var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  				c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  				foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  					c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  			}  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 (0);  			if (x > 1)  				throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  			m_result.AddMessage ("Duplicate file entries repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 0) {  		m_result.AddMessage ("Found duplicate file entries' repairing");  		var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  			c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  		m_result.AddMessage ("Duplicate file entries repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 0) {  		m_result.AddMessage ("Found duplicate file entries' repairing");  		var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  			c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  		m_result.AddMessage ("Duplicate file entries repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 0) {  		m_result.AddMessage ("Found duplicate file entries' repairing");  		var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  			c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  		m_result.AddMessage ("Duplicate file entries repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var sql_count = @"SELECT COUNT(*) FROM (SELECT ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Duplicates"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"") WHERE ""Duplicates"" > 1";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 0) {  		m_result.AddMessage ("Found duplicate file entries' repairing");  		var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  			c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  			foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  				c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  		}  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 (0);  		if (x > 1)  			throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  		m_result.AddMessage ("Duplicate file entries repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: if (x > 0) {  	m_result.AddMessage ("Found duplicate file entries' repairing");  	var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  		c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  	m_result.AddMessage ("Duplicate file entries repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: if (x > 0) {  	m_result.AddMessage ("Found duplicate file entries' repairing");  	var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  		c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  	m_result.AddMessage ("Duplicate file entries repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: if (x > 0) {  	m_result.AddMessage ("Found duplicate file entries' repairing");  	var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  		c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  	m_result.AddMessage ("Duplicate file entries repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: if (x > 0) {  	m_result.AddMessage ("Found duplicate file entries' repairing");  	var sql = @"SELECT ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' ""Entries"" FROM (                              SELECT MIN(""ID"") AS ""ID""' ""Path""' ""BlocksetID""' ""MetadataID""' COUNT(*) as ""Entries"" FROM ""File"" GROUP BY ""Path""' ""BlocksetID""' ""MetadataID"")                               WHERE ""Entries"" > 1 ORDER BY ""ID""";  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  		c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  		foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  			c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  	}  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 (0);  	if (x > 1)  		throw new Duplicati.Library.Interface.UserInformationException ("Repair failed' there are still duplicate file entries!");  	m_result.AddMessage ("Duplicate file entries repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand (tr)) {  	c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  	c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand (tr)) {  	c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  	c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand (tr)) {  	c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  	c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand (tr)) {  	c2.CommandText = @"UPDATE ""FilesetEntry"" SET ""FileID"" = ? WHERE ""FileID"" IN (SELECT ""ID"" FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ?)";  	c2.CommandText += @"; DELETE FROM ""File"" WHERE ""Path"" = ? AND ""BlocksetID"" = ? AND ""MetadataID"" = ? AND ""ID"" != ?";  	foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  		c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (sql))  	c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateFileentries,The following statement contains a magic number: c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (1)' rd.GetValue (2)' rd.GetValue (3)' rd.GetValue (0));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  		if (itemswithnoblocklisthash != 0) {  			m_result.AddMessage (string.Format ("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));  			using (var c2 = m_connection.CreateCommand (tr))  				using (var c3 = m_connection.CreateCommand (tr))  					using (var c4 = m_connection.CreateCommand (tr))  						using (var c5 = m_connection.CreateCommand (tr))  							using (var c6 = m_connection.CreateCommand (tr)) {  								c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  								c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  								c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  								c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  								foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  									var blocksetid = e.ConvertValueToInt64 (0);  									var ix = 0L;  									c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  									foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  										var tmp = Convert.FromBase64String (h.GetString (0));  										if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  											var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  											// Ensure that the block exists in "blocks"  											if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  												var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  												if (c <= 0)  													throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  												else {  													var rc = c6.ExecuteNonQuery (null' c' c);  													if (rc != 2)  														throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  												}  											}  											// Add to table  											c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  											ix++;  											blocklistoffset = 0;  										}  										Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  										blocklistoffset += tmp.Length;  									}  									if (blocklistoffset != 0) {  										var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  										// Ensure that the block exists in "blocks"  										if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  											var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  											if (c == 0)  												throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  											else {  												var rc = c6.ExecuteNonQuery (null' c' c);  												if (rc != 2)  													throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  											}  										}  										// Add to table  										c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  										ix++;  									}  								}  							}  			itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  			if (itemswithnoblocklisthash != 0)  				throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));  			m_result.AddMessage ("Missing blocklisthashes repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  		if (itemswithnoblocklisthash != 0) {  			m_result.AddMessage (string.Format ("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));  			using (var c2 = m_connection.CreateCommand (tr))  				using (var c3 = m_connection.CreateCommand (tr))  					using (var c4 = m_connection.CreateCommand (tr))  						using (var c5 = m_connection.CreateCommand (tr))  							using (var c6 = m_connection.CreateCommand (tr)) {  								c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  								c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  								c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  								c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  								foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  									var blocksetid = e.ConvertValueToInt64 (0);  									var ix = 0L;  									c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  									foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  										var tmp = Convert.FromBase64String (h.GetString (0));  										if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  											var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  											// Ensure that the block exists in "blocks"  											if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  												var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  												if (c <= 0)  													throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  												else {  													var rc = c6.ExecuteNonQuery (null' c' c);  													if (rc != 2)  														throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  												}  											}  											// Add to table  											c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  											ix++;  											blocklistoffset = 0;  										}  										Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  										blocklistoffset += tmp.Length;  									}  									if (blocklistoffset != 0) {  										var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  										// Ensure that the block exists in "blocks"  										if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  											var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  											if (c == 0)  												throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  											else {  												var rc = c6.ExecuteNonQuery (null' c' c);  												if (rc != 2)  													throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  											}  										}  										// Add to table  										c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  										ix++;  									}  								}  							}  			itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  			if (itemswithnoblocklisthash != 0)  				throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));  			m_result.AddMessage ("Missing blocklisthashes repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  	if (itemswithnoblocklisthash != 0) {  		m_result.AddMessage (string.Format ("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));  		using (var c2 = m_connection.CreateCommand (tr))  			using (var c3 = m_connection.CreateCommand (tr))  				using (var c4 = m_connection.CreateCommand (tr))  					using (var c5 = m_connection.CreateCommand (tr))  						using (var c6 = m_connection.CreateCommand (tr)) {  							c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  							c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  							c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  							c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  							foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  								var blocksetid = e.ConvertValueToInt64 (0);  								var ix = 0L;  								c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  								foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  									var tmp = Convert.FromBase64String (h.GetString (0));  									if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  										var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  										// Ensure that the block exists in "blocks"  										if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  											var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  											if (c <= 0)  												throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  											else {  												var rc = c6.ExecuteNonQuery (null' c' c);  												if (rc != 2)  													throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  											}  										}  										// Add to table  										c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  										ix++;  										blocklistoffset = 0;  									}  									Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  									blocklistoffset += tmp.Length;  								}  								if (blocklistoffset != 0) {  									var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  									// Ensure that the block exists in "blocks"  									if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  										var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  										if (c == 0)  											throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  										else {  											var rc = c6.ExecuteNonQuery (null' c' c);  											if (rc != 2)  												throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  										}  									}  									// Add to table  									c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  									ix++;  								}  							}  						}  		itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  		if (itemswithnoblocklisthash != 0)  			throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));  		m_result.AddMessage ("Missing blocklisthashes repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  	if (itemswithnoblocklisthash != 0) {  		m_result.AddMessage (string.Format ("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));  		using (var c2 = m_connection.CreateCommand (tr))  			using (var c3 = m_connection.CreateCommand (tr))  				using (var c4 = m_connection.CreateCommand (tr))  					using (var c5 = m_connection.CreateCommand (tr))  						using (var c6 = m_connection.CreateCommand (tr)) {  							c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  							c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  							c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  							c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  							foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  								var blocksetid = e.ConvertValueToInt64 (0);  								var ix = 0L;  								c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  								foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  									var tmp = Convert.FromBase64String (h.GetString (0));  									if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  										var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  										// Ensure that the block exists in "blocks"  										if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  											var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  											if (c <= 0)  												throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  											else {  												var rc = c6.ExecuteNonQuery (null' c' c);  												if (rc != 2)  													throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  											}  										}  										// Add to table  										c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  										ix++;  										blocklistoffset = 0;  									}  									Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  									blocklistoffset += tmp.Length;  								}  								if (blocklistoffset != 0) {  									var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  									// Ensure that the block exists in "blocks"  									if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  										var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  										if (c == 0)  											throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  										else {  											var rc = c6.ExecuteNonQuery (null' c' c);  											if (rc != 2)  												throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  										}  									}  									// Add to table  									c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  									ix++;  								}  							}  						}  		itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  		if (itemswithnoblocklisthash != 0)  			throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));  		m_result.AddMessage ("Missing blocklisthashes repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (itemswithnoblocklisthash != 0) {  	m_result.AddMessage (string.Format ("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));  	using (var c2 = m_connection.CreateCommand (tr))  		using (var c3 = m_connection.CreateCommand (tr))  			using (var c4 = m_connection.CreateCommand (tr))  				using (var c5 = m_connection.CreateCommand (tr))  					using (var c6 = m_connection.CreateCommand (tr)) {  						c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  						c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  						c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  						c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  						foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  							var blocksetid = e.ConvertValueToInt64 (0);  							var ix = 0L;  							c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  							foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  								var tmp = Convert.FromBase64String (h.GetString (0));  								if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  									var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  									// Ensure that the block exists in "blocks"  									if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  										var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  										if (c <= 0)  											throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  										else {  											var rc = c6.ExecuteNonQuery (null' c' c);  											if (rc != 2)  												throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  										}  									}  									// Add to table  									c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  									ix++;  									blocklistoffset = 0;  								}  								Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  								blocklistoffset += tmp.Length;  							}  							if (blocklistoffset != 0) {  								var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  								// Ensure that the block exists in "blocks"  								if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  									var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  									if (c == 0)  										throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  									else {  										var rc = c6.ExecuteNonQuery (null' c' c);  										if (rc != 2)  											throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  									}  								}  								// Add to table  								c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  								ix++;  							}  						}  					}  	itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  	if (itemswithnoblocklisthash != 0)  		throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));  	m_result.AddMessage ("Missing blocklisthashes repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (itemswithnoblocklisthash != 0) {  	m_result.AddMessage (string.Format ("Found {0} missing blocklisthash entries' repairing"' itemswithnoblocklisthash));  	using (var c2 = m_connection.CreateCommand (tr))  		using (var c3 = m_connection.CreateCommand (tr))  			using (var c4 = m_connection.CreateCommand (tr))  				using (var c5 = m_connection.CreateCommand (tr))  					using (var c6 = m_connection.CreateCommand (tr)) {  						c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  						c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  						c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  						c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  						foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  							var blocksetid = e.ConvertValueToInt64 (0);  							var ix = 0L;  							c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  							foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  								var tmp = Convert.FromBase64String (h.GetString (0));  								if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  									var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  									// Ensure that the block exists in "blocks"  									if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  										var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  										if (c <= 0)  											throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  										else {  											var rc = c6.ExecuteNonQuery (null' c' c);  											if (rc != 2)  												throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  										}  									}  									// Add to table  									c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  									ix++;  									blocklistoffset = 0;  								}  								Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  								blocklistoffset += tmp.Length;  							}  							if (blocklistoffset != 0) {  								var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  								// Ensure that the block exists in "blocks"  								if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  									var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  									if (c == 0)  										throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  									else {  										var rc = c6.ExecuteNonQuery (null' c' c);  										if (rc != 2)  											throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  									}  								}  								// Add to table  								c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  								ix++;  							}  						}  					}  	itemswithnoblocklisthash = cmd.ExecuteScalarInt64 (countsql' 0);  	if (itemswithnoblocklisthash != 0)  		throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' after repair {0} blocklisthashes were missing"' itemswithnoblocklisthash));  	m_result.AddMessage ("Missing blocklisthashes repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand (tr))  	using (var c3 = m_connection.CreateCommand (tr))  		using (var c4 = m_connection.CreateCommand (tr))  			using (var c5 = m_connection.CreateCommand (tr))  				using (var c6 = m_connection.CreateCommand (tr)) {  					c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  					c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  					c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  					c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  					foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  						var blocksetid = e.ConvertValueToInt64 (0);  						var ix = 0L;  						c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  						foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  							var tmp = Convert.FromBase64String (h.GetString (0));  							if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  								var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  								// Ensure that the block exists in "blocks"  								if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  									var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  									if (c <= 0)  										throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  									else {  										var rc = c6.ExecuteNonQuery (null' c' c);  										if (rc != 2)  											throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  									}  								}  								// Add to table  								c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  								ix++;  								blocklistoffset = 0;  							}  							Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  							blocklistoffset += tmp.Length;  						}  						if (blocklistoffset != 0) {  							var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  							// Ensure that the block exists in "blocks"  							if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  								var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  								if (c == 0)  									throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  								else {  									var rc = c6.ExecuteNonQuery (null' c' c);  									if (rc != 2)  										throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  								}  							}  							// Add to table  							c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  							ix++;  						}  					}  				}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand (tr))  	using (var c3 = m_connection.CreateCommand (tr))  		using (var c4 = m_connection.CreateCommand (tr))  			using (var c5 = m_connection.CreateCommand (tr))  				using (var c6 = m_connection.CreateCommand (tr)) {  					c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  					c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  					c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  					c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  					foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  						var blocksetid = e.ConvertValueToInt64 (0);  						var ix = 0L;  						c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  						foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  							var tmp = Convert.FromBase64String (h.GetString (0));  							if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  								var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  								// Ensure that the block exists in "blocks"  								if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  									var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  									if (c <= 0)  										throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  									else {  										var rc = c6.ExecuteNonQuery (null' c' c);  										if (rc != 2)  											throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  									}  								}  								// Add to table  								c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  								ix++;  								blocklistoffset = 0;  							}  							Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  							blocklistoffset += tmp.Length;  						}  						if (blocklistoffset != 0) {  							var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  							// Ensure that the block exists in "blocks"  							if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  								var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  								if (c == 0)  									throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  								else {  									var rc = c6.ExecuteNonQuery (null' c' c);  									if (rc != 2)  										throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  								}  							}  							// Add to table  							c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  							ix++;  						}  					}  				}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c3 = m_connection.CreateCommand (tr))  	using (var c4 = m_connection.CreateCommand (tr))  		using (var c5 = m_connection.CreateCommand (tr))  			using (var c6 = m_connection.CreateCommand (tr)) {  				c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  				c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  				c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  				c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  				foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  					var blocksetid = e.ConvertValueToInt64 (0);  					var ix = 0L;  					c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  					foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  						var tmp = Convert.FromBase64String (h.GetString (0));  						if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  							var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  							// Ensure that the block exists in "blocks"  							if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  								var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  								if (c <= 0)  									throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  								else {  									var rc = c6.ExecuteNonQuery (null' c' c);  									if (rc != 2)  										throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  								}  							}  							// Add to table  							c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  							ix++;  							blocklistoffset = 0;  						}  						Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  						blocklistoffset += tmp.Length;  					}  					if (blocklistoffset != 0) {  						var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  						// Ensure that the block exists in "blocks"  						if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  							var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  							if (c == 0)  								throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  							else {  								var rc = c6.ExecuteNonQuery (null' c' c);  								if (rc != 2)  									throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  							}  						}  						// Add to table  						c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  						ix++;  					}  				}  			}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c3 = m_connection.CreateCommand (tr))  	using (var c4 = m_connection.CreateCommand (tr))  		using (var c5 = m_connection.CreateCommand (tr))  			using (var c6 = m_connection.CreateCommand (tr)) {  				c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  				c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  				c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  				c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  				foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  					var blocksetid = e.ConvertValueToInt64 (0);  					var ix = 0L;  					c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  					foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  						var tmp = Convert.FromBase64String (h.GetString (0));  						if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  							var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  							// Ensure that the block exists in "blocks"  							if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  								var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  								if (c <= 0)  									throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  								else {  									var rc = c6.ExecuteNonQuery (null' c' c);  									if (rc != 2)  										throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  								}  							}  							// Add to table  							c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  							ix++;  							blocklistoffset = 0;  						}  						Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  						blocklistoffset += tmp.Length;  					}  					if (blocklistoffset != 0) {  						var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  						// Ensure that the block exists in "blocks"  						if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  							var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  							if (c == 0)  								throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  							else {  								var rc = c6.ExecuteNonQuery (null' c' c);  								if (rc != 2)  									throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  							}  						}  						// Add to table  						c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  						ix++;  					}  				}  			}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c4 = m_connection.CreateCommand (tr))  	using (var c5 = m_connection.CreateCommand (tr))  		using (var c6 = m_connection.CreateCommand (tr)) {  			c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  			c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  			c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  			c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  			foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  				var blocksetid = e.ConvertValueToInt64 (0);  				var ix = 0L;  				c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  				foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  					var tmp = Convert.FromBase64String (h.GetString (0));  					if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  						var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  						// Ensure that the block exists in "blocks"  						if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  							var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  							if (c <= 0)  								throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  							else {  								var rc = c6.ExecuteNonQuery (null' c' c);  								if (rc != 2)  									throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  							}  						}  						// Add to table  						c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  						ix++;  						blocklistoffset = 0;  					}  					Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  					blocklistoffset += tmp.Length;  				}  				if (blocklistoffset != 0) {  					var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  					// Ensure that the block exists in "blocks"  					if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  						var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  						if (c == 0)  							throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  						else {  							var rc = c6.ExecuteNonQuery (null' c' c);  							if (rc != 2)  								throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  						}  					}  					// Add to table  					c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  					ix++;  				}  			}  		}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c4 = m_connection.CreateCommand (tr))  	using (var c5 = m_connection.CreateCommand (tr))  		using (var c6 = m_connection.CreateCommand (tr)) {  			c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  			c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  			c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  			c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  			foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  				var blocksetid = e.ConvertValueToInt64 (0);  				var ix = 0L;  				c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  				foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  					var tmp = Convert.FromBase64String (h.GetString (0));  					if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  						var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  						// Ensure that the block exists in "blocks"  						if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  							var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  							if (c <= 0)  								throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  							else {  								var rc = c6.ExecuteNonQuery (null' c' c);  								if (rc != 2)  									throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  							}  						}  						// Add to table  						c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  						ix++;  						blocklistoffset = 0;  					}  					Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  					blocklistoffset += tmp.Length;  				}  				if (blocklistoffset != 0) {  					var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  					// Ensure that the block exists in "blocks"  					if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  						var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  						if (c == 0)  							throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  						else {  							var rc = c6.ExecuteNonQuery (null' c' c);  							if (rc != 2)  								throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  						}  					}  					// Add to table  					c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  					ix++;  				}  			}  		}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c5 = m_connection.CreateCommand (tr))  	using (var c6 = m_connection.CreateCommand (tr)) {  		c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  		c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  		c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  		c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  		foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  			var blocksetid = e.ConvertValueToInt64 (0);  			var ix = 0L;  			c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  			foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  				var tmp = Convert.FromBase64String (h.GetString (0));  				if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  					var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  					// Ensure that the block exists in "blocks"  					if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  						var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  						if (c <= 0)  							throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  						else {  							var rc = c6.ExecuteNonQuery (null' c' c);  							if (rc != 2)  								throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  						}  					}  					// Add to table  					c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  					ix++;  					blocklistoffset = 0;  				}  				Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  				blocklistoffset += tmp.Length;  			}  			if (blocklistoffset != 0) {  				var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  				// Ensure that the block exists in "blocks"  				if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  					var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  					if (c == 0)  						throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  					else {  						var rc = c6.ExecuteNonQuery (null' c' c);  						if (rc != 2)  							throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  					}  				}  				// Add to table  				c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  				ix++;  			}  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c5 = m_connection.CreateCommand (tr))  	using (var c6 = m_connection.CreateCommand (tr)) {  		c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  		c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  		c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  		c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  		foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  			var blocksetid = e.ConvertValueToInt64 (0);  			var ix = 0L;  			c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  			foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  				var tmp = Convert.FromBase64String (h.GetString (0));  				if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  					var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  					// Ensure that the block exists in "blocks"  					if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  						var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  						if (c <= 0)  							throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  						else {  							var rc = c6.ExecuteNonQuery (null' c' c);  							if (rc != 2)  								throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  						}  					}  					// Add to table  					c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  					ix++;  					blocklistoffset = 0;  				}  				Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  				blocklistoffset += tmp.Length;  			}  			if (blocklistoffset != 0) {  				var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  				// Ensure that the block exists in "blocks"  				if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  					var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  					if (c == 0)  						throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  					else {  						var rc = c6.ExecuteNonQuery (null' c' c);  						if (rc != 2)  							throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  					}  				}  				// Add to table  				c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  				ix++;  			}  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c6 = m_connection.CreateCommand (tr)) {  	c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  	c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  	c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  	c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  	foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  		var blocksetid = e.ConvertValueToInt64 (0);  		var ix = 0L;  		c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  		foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  			var tmp = Convert.FromBase64String (h.GetString (0));  			if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  				var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  				// Ensure that the block exists in "blocks"  				if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  					var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  					if (c <= 0)  						throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  					else {  						var rc = c6.ExecuteNonQuery (null' c' c);  						if (rc != 2)  							throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  					}  				}  				// Add to table  				c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  				ix++;  				blocklistoffset = 0;  			}  			Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  			blocklistoffset += tmp.Length;  		}  		if (blocklistoffset != 0) {  			var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  			// Ensure that the block exists in "blocks"  			if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  				var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  				if (c == 0)  					throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  				else {  					var rc = c6.ExecuteNonQuery (null' c' c);  					if (rc != 2)  						throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  				}  			}  			// Add to table  			c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  			ix++;  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: using (var c6 = m_connection.CreateCommand (tr)) {  	c3.CommandText = @"INSERT INTO ""BlocklistHash"" (""BlocksetID""' ""Index""' ""Hash"") VALUES (?' ?' ?) ";  	c4.CommandText = @"SELECT COUNT(*) FROM ""Block"" WHERE ""Hash"" = ? AND ""Size"" = ?";  	c5.CommandText = @"SELECT ""ID"" FROM ""DeletedBlock"" WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" IN (SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND (""State"" = ? OR ""State"" = ?))";  	c6.CommandText = @"INSERT INTO ""Block"" (""Hash""' ""Size""' ""VolumeID"") SELECT ""Hash""' ""Size""' ""VolumeID"" FROM ""DeletedBlock"" WHERE ""ID"" = ? LIMIT 1; DELETE FROM ""DeletedBlock"" WHERE ""ID"" = ?;";  	foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  		var blocksetid = e.ConvertValueToInt64 (0);  		var ix = 0L;  		c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  		foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  			var tmp = Convert.FromBase64String (h.GetString (0));  			if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  				var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  				// Ensure that the block exists in "blocks"  				if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  					var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  					if (c <= 0)  						throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  					else {  						var rc = c6.ExecuteNonQuery (null' c' c);  						if (rc != 2)  							throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  					}  				}  				// Add to table  				c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  				ix++;  				blocklistoffset = 0;  			}  			Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  			blocklistoffset += tmp.Length;  		}  		if (blocklistoffset != 0) {  			var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  			// Ensure that the block exists in "blocks"  			if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  				var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  				if (c == 0)  					throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  				else {  					var rc = c6.ExecuteNonQuery (null' c' c);  					if (rc != 2)  						throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  				}  			}  			// Add to table  			c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  			ix++;  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  	var blocksetid = e.ConvertValueToInt64 (0);  	var ix = 0L;  	c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  	foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  		var tmp = Convert.FromBase64String (h.GetString (0));  		if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  			var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  			// Ensure that the block exists in "blocks"  			if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  				var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  				if (c <= 0)  					throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  				else {  					var rc = c6.ExecuteNonQuery (null' c' c);  					if (rc != 2)  						throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  				}  			}  			// Add to table  			c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  			ix++;  			blocklistoffset = 0;  		}  		Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  		blocklistoffset += tmp.Length;  	}  	if (blocklistoffset != 0) {  		var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  		// Ensure that the block exists in "blocks"  		if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  			var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  			if (c == 0)  				throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  			else {  				var rc = c6.ExecuteNonQuery (null' c' c);  				if (rc != 2)  					throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  			}  		}  		// Add to table  		c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  		ix++;  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: foreach (var e in cmd.ExecuteReaderEnumerable (sql)) {  	var blocksetid = e.ConvertValueToInt64 (0);  	var ix = 0L;  	c2.ExecuteNonQuery (@"DELETE FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ?"' blocksetid);  	foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  		var tmp = Convert.FromBase64String (h.GetString (0));  		if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  			var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  			// Ensure that the block exists in "blocks"  			if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  				var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  				if (c <= 0)  					throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  				else {  					var rc = c6.ExecuteNonQuery (null' c' c);  					if (rc != 2)  						throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  				}  			}  			// Add to table  			c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  			ix++;  			blocklistoffset = 0;  		}  		Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  		blocklistoffset += tmp.Length;  	}  	if (blocklistoffset != 0) {  		var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  		// Ensure that the block exists in "blocks"  		if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  			var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  			if (c == 0)  				throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  			else {  				var rc = c6.ExecuteNonQuery (null' c' c);  				if (rc != 2)  					throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  			}  		}  		// Add to table  		c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  		ix++;  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: foreach (var h in c2.ExecuteReaderEnumerable (@"SELECT ""A"".""Hash"" FROM ""Block"" ""A""' ""BlocksetEntry"" ""B"" WHERE ""A"".""ID"" = ""B"".""BlockID"" AND ""B"".""BlocksetID"" = ? ORDER BY ""B"".""Index"""' blocksetid)) {  	var tmp = Convert.FromBase64String (h.GetString (0));  	if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  		var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  		// Ensure that the block exists in "blocks"  		if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  			var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  			if (c <= 0)  				throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  			else {  				var rc = c6.ExecuteNonQuery (null' c' c);  				if (rc != 2)  					throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  			}  		}  		// Add to table  		c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  		ix++;  		blocklistoffset = 0;  	}  	Array.Copy (tmp' 0' blocklistbuffer' blocklistoffset' tmp.Length);  	blocklistoffset += tmp.Length;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (blocklistbuffer.Length - blocklistoffset < tmp.Length) {  	var blkey = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  	// Ensure that the block exists in "blocks"  	if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  		var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  		if (c <= 0)  			throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  		else {  			var rc = c6.ExecuteNonQuery (null' c' c);  			if (rc != 2)  				throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  		}  	}  	// Add to table  	c3.ExecuteNonQuery (null' blocksetid' ix' blkey);  	ix++;  	blocklistoffset = 0;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (c4.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset) != 1) {  	var c = c5.ExecuteScalarInt64 (null' -1' blkey' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (c <= 0)  		throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  	else {  		var rc = c6.ExecuteNonQuery (null' c' c);  		if (rc != 2)  			throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (c <= 0)  	throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkey));  else {  	var rc = c6.ExecuteNonQuery (null' c' c);  	if (rc != 2)  		throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (rc != 2)  	throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (blocklistoffset != 0) {  	var blkeyfinal = Convert.ToBase64String (blockhasher.ComputeHash (blocklistbuffer' 0' blocklistoffset));  	// Ensure that the block exists in "blocks"  	if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  		var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  		if (c == 0)  			throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  		else {  			var rc = c6.ExecuteNonQuery (null' c' c);  			if (rc != 2)  				throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  		}  	}  	// Add to table  	c3.ExecuteNonQuery (null' blocksetid' ix' blkeyfinal);  	ix++;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (c4.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset) != 1) {  	var c = c5.ExecuteScalarInt64 (null' -1' blkeyfinal' blocklistoffset' RemoteVolumeType.Blocks.ToString ()' RemoteVolumeState.Uploaded.ToString ()' RemoteVolumeState.Verified.ToString ());  	if (c == 0)  		throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  	else {  		var rc = c6.ExecuteNonQuery (null' c' c);  		if (rc != 2)  			throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (c == 0)  	throw new Exception (string.Format ("Missing block for blocklisthash: {0}"' blkeyfinal));  else {  	var rc = c6.ExecuteNonQuery (null' c' c);  	if (rc != 2)  		throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixMissingBlocklistHashes,The following statement contains a magic number: if (rc != 2)  	throw new Exception (string.Format ("Unexpected update count: {0}"' rc));  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var dup_sql = @"SELECT * FROM (SELECT ""BlocksetID""' ""Index""' COUNT(*) AS ""EC"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID""' ""Index"") WHERE ""EC"" > 1";  		var sql_count = @"SELECT COUNT(*) FROM (" + dup_sql + ")";  		var x = cmd.ExecuteScalarInt64 (sql_count' 0);  		if (x > 0) {  			m_result.AddMessage ("Found duplicate blocklisthash entries' repairing");  			var unique_count = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);  			using (var c2 = m_connection.CreateCommand (tr)) {  				c2.CommandText = @"DELETE FROM ""BlocklistHash"" WHERE rowid IN (SELECT rowid FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ? AND ""Index"" = ? LIMIT ?)";  				foreach (var rd in cmd.ExecuteReaderEnumerable (dup_sql)) {  					var expected = rd.GetInt32 (2) - 1;  					var actual = c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' expected);  					if (actual != expected)  						throw new Exception (string.Format ("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected));  				}  			}  			cmd.CommandText = sql_count;  			x = cmd.ExecuteScalarInt64 ();  			if (x > 1)  				throw new Exception ("Repair failed' there are still duplicate file entries!");  			var real_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM ""BlocklistHash"""' 0);  			if (real_count != unique_count)  				throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' result should have been {0} blocklist hashes' but result was {1} blocklist hashes"' unique_count' real_count));  			try {  				VerifyConsistency (tr' blocksize' hashsize' true);  			} catch (Exception ex) {  				throw new Duplicati.Library.Interface.UserInformationException ("Repaired blocklisthashes' but the database was broken afterwards' rolled back changes"' ex);  			}  			m_result.AddMessage ("Duplicate blocklisthashes repaired succesfully");  			tr.Commit ();  		}  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var dup_sql = @"SELECT * FROM (SELECT ""BlocksetID""' ""Index""' COUNT(*) AS ""EC"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID""' ""Index"") WHERE ""EC"" > 1";  	var sql_count = @"SELECT COUNT(*) FROM (" + dup_sql + ")";  	var x = cmd.ExecuteScalarInt64 (sql_count' 0);  	if (x > 0) {  		m_result.AddMessage ("Found duplicate blocklisthash entries' repairing");  		var unique_count = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);  		using (var c2 = m_connection.CreateCommand (tr)) {  			c2.CommandText = @"DELETE FROM ""BlocklistHash"" WHERE rowid IN (SELECT rowid FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ? AND ""Index"" = ? LIMIT ?)";  			foreach (var rd in cmd.ExecuteReaderEnumerable (dup_sql)) {  				var expected = rd.GetInt32 (2) - 1;  				var actual = c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' expected);  				if (actual != expected)  					throw new Exception (string.Format ("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected));  			}  		}  		cmd.CommandText = sql_count;  		x = cmd.ExecuteScalarInt64 ();  		if (x > 1)  			throw new Exception ("Repair failed' there are still duplicate file entries!");  		var real_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM ""BlocklistHash"""' 0);  		if (real_count != unique_count)  			throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' result should have been {0} blocklist hashes' but result was {1} blocklist hashes"' unique_count' real_count));  		try {  			VerifyConsistency (tr' blocksize' hashsize' true);  		} catch (Exception ex) {  			throw new Duplicati.Library.Interface.UserInformationException ("Repaired blocklisthashes' but the database was broken afterwards' rolled back changes"' ex);  		}  		m_result.AddMessage ("Duplicate blocklisthashes repaired succesfully");  		tr.Commit ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The following statement contains a magic number: if (x > 0) {  	m_result.AddMessage ("Found duplicate blocklisthash entries' repairing");  	var unique_count = cmd.ExecuteScalarInt64 (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""BlocksetID""' ""Index"" FROM ""BlocklistHash"")"' 0);  	using (var c2 = m_connection.CreateCommand (tr)) {  		c2.CommandText = @"DELETE FROM ""BlocklistHash"" WHERE rowid IN (SELECT rowid FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ? AND ""Index"" = ? LIMIT ?)";  		foreach (var rd in cmd.ExecuteReaderEnumerable (dup_sql)) {  			var expected = rd.GetInt32 (2) - 1;  			var actual = c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' expected);  			if (actual != expected)  				throw new Exception (string.Format ("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected));  		}  	}  	cmd.CommandText = sql_count;  	x = cmd.ExecuteScalarInt64 ();  	if (x > 1)  		throw new Exception ("Repair failed' there are still duplicate file entries!");  	var real_count = cmd.ExecuteScalarInt64 (@"SELECT Count(*) FROM ""BlocklistHash"""' 0);  	if (real_count != unique_count)  		throw new Duplicati.Library.Interface.UserInformationException (string.Format ("Failed to repair' result should have been {0} blocklist hashes' but result was {1} blocklist hashes"' unique_count' real_count));  	try {  		VerifyConsistency (tr' blocksize' hashsize' true);  	} catch (Exception ex) {  		throw new Duplicati.Library.Interface.UserInformationException ("Repaired blocklisthashes' but the database was broken afterwards' rolled back changes"' ex);  	}  	m_result.AddMessage ("Duplicate blocklisthashes repaired succesfully");  	tr.Commit ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The following statement contains a magic number: using (var c2 = m_connection.CreateCommand (tr)) {  	c2.CommandText = @"DELETE FROM ""BlocklistHash"" WHERE rowid IN (SELECT rowid FROM ""BlocklistHash"" WHERE ""BlocksetID"" = ? AND ""Index"" = ? LIMIT ?)";  	foreach (var rd in cmd.ExecuteReaderEnumerable (dup_sql)) {  		var expected = rd.GetInt32 (2) - 1;  		var actual = c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' expected);  		if (actual != expected)  			throw new Exception (string.Format ("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,FixDuplicateBlocklistHashes,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (dup_sql)) {  	var expected = rd.GetInt32 (2) - 1;  	var actual = c2.ExecuteNonQuery (null' rd.GetValue (0)' rd.GetValue (1)' expected);  	if (actual != expected)  		throw new Exception (string.Format ("Unexpected number of results after fix' got: {0}' expected: {1}"' actual' expected));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The following statement contains a magic number: using (var tr = m_connection.BeginTransaction ())  	using (var cmd = m_connection.CreateCommand (tr)) {  		var tablename = "ProbeBlocks-" + Library.Utility.Utility.ByteArrayAsHexString (Guid.NewGuid ().ToByteArray ());  		cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL)"' tablename));  		cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Hash""' ""Size"") VALUES (?' ?)"' tablename);  		cmd.AddParameters (2);  		foreach (var kp in blocks) {  			cmd.SetParameterValue (0' kp.Key);  			cmd.SetParameterValue (1' kp.Value);  			cmd.ExecuteNonQuery ();  		}  		var id = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' -1' filename);  		var aliens = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT ""A"".""VolumeID"" FROM ""{0}"" B LEFT OUTER JOIN ""Block"" A ON ""A"".""Hash"" = ""B"".""Hash"" AND ""A"".""Size"" = ""B"".""Size"") WHERE ""VolumeID"" != ? "' tablename)' 0' id);  		cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tablename));  		if (aliens != 0)  			throw new Exception (string.Format ("Not all blocks were found in {0}"' filename));  	}  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand (tr)) {  	var tablename = "ProbeBlocks-" + Library.Utility.Utility.ByteArrayAsHexString (Guid.NewGuid ().ToByteArray ());  	cmd.ExecuteNonQuery (string.Format (@"CREATE TEMPORARY TABLE ""{0}"" (""Hash"" TEXT NOT NULL' ""Size"" INTEGER NOT NULL)"' tablename));  	cmd.CommandText = string.Format (@"INSERT INTO ""{0}"" (""Hash""' ""Size"") VALUES (?' ?)"' tablename);  	cmd.AddParameters (2);  	foreach (var kp in blocks) {  		cmd.SetParameterValue (0' kp.Key);  		cmd.SetParameterValue (1' kp.Value);  		cmd.ExecuteNonQuery ();  	}  	var id = cmd.ExecuteScalarInt64 (@"SELECT ""ID"" FROM ""RemoteVolume"" WHERE ""Name"" = ?"' -1' filename);  	var aliens = cmd.ExecuteScalarInt64 (string.Format (@"SELECT COUNT(*) FROM (SELECT ""A"".""VolumeID"" FROM ""{0}"" B LEFT OUTER JOIN ""Block"" A ON ""A"".""Hash"" = ""B"".""Hash"" AND ""A"".""Size"" = ""B"".""Size"") WHERE ""VolumeID"" != ? "' tablename)' 0' id);  	cmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' tablename));  	if (aliens != 0)  		throw new Exception (string.Format ("Not all blocks were found in {0}"' filename));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRepairDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRepairDatabase.cs,CheckAllBlocksAreInVolume,The following statement contains a magic number: cmd.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertFileCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertFilesetEntryCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlocksetCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlocklistHashCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_updateBlockVolumeCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlockset.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertSmallBlockset.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findBlocksetCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findMetadatasetCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findFilesetCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_findHashBlockCommand.AddParameters (2);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertBlockCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,LocalRecreateDatabase,The following statement contains a magic number: m_insertDuplicateBlockCommand.AddParameters (3);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: if (m_filesetLookup != null) {  	PathEntryKeeper e;  	if (m_filesetLookup.TryFind (path' out e))  		fileid = e.GetFilesetID (blocksetid' metadataid);  } else {  	m_findFilesetCommand.Transaction = transaction;  	m_findFilesetCommand.SetParameterValue (0' path);  	m_findFilesetCommand.SetParameterValue (1' blocksetid);  	m_findFilesetCommand.SetParameterValue (2' metadataid);  	fileid = m_findFilesetCommand.ExecuteScalarInt64 (-1);  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: m_findFilesetCommand.SetParameterValue (2' metadataid);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: if (fileid < 0) {  	m_insertFileCommand.Transaction = transaction;  	m_insertFileCommand.SetParameterValue (0' path);  	m_insertFileCommand.SetParameterValue (1' blocksetid);  	m_insertFileCommand.SetParameterValue (2' metadataid);  	fileid = m_insertFileCommand.ExecuteScalarInt64 (-1);  	if (m_filesetLookup != null) {  		PathEntryKeeper e;  		if (m_filesetLookup.TryFind (path' out e))  			e.AddFilesetID (blocksetid' metadataid' fileid);  		else {  			e = new PathEntryKeeper ();  			e.AddFilesetID (blocksetid' metadataid' fileid);  			m_filesetLookup.Insert (path' e);  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: m_insertFileCommand.SetParameterValue (2' metadataid);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddEntry,The following statement contains a magic number: m_insertFilesetEntryCommand.SetParameterValue (2' time.ToUniversalTime ().Ticks);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The following statement contains a magic number: if (blocklisthashes != null) {  	var index = 0L;  	m_insertBlocklistHashCommand.Transaction = transaction;  	m_insertBlocklistHashCommand.SetParameterValue (0' blocksetid);  	foreach (var hash in blocklisthashes) {  		if (!string.IsNullOrEmpty (hash)) {  			c++;  			if (c <= expectedblocklisthashes) {  				m_insertBlocklistHashCommand.SetParameterValue (1' index++);  				m_insertBlocklistHashCommand.SetParameterValue (2' hash);  				m_insertBlocklistHashCommand.ExecuteNonQuery ();  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The following statement contains a magic number: foreach (var hash in blocklisthashes) {  	if (!string.IsNullOrEmpty (hash)) {  		c++;  		if (c <= expectedblocklisthashes) {  			m_insertBlocklistHashCommand.SetParameterValue (1' index++);  			m_insertBlocklistHashCommand.SetParameterValue (2' hash);  			m_insertBlocklistHashCommand.ExecuteNonQuery ();  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The following statement contains a magic number: if (!string.IsNullOrEmpty (hash)) {  	c++;  	if (c <= expectedblocklisthashes) {  		m_insertBlocklistHashCommand.SetParameterValue (1' index++);  		m_insertBlocklistHashCommand.SetParameterValue (2' hash);  		m_insertBlocklistHashCommand.ExecuteNonQuery ();  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The following statement contains a magic number: if (c <= expectedblocklisthashes) {  	m_insertBlocklistHashCommand.SetParameterValue (1' index++);  	m_insertBlocklistHashCommand.SetParameterValue (2' hash);  	m_insertBlocklistHashCommand.ExecuteNonQuery ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddBlockset,The following statement contains a magic number: m_insertBlocklistHashCommand.SetParameterValue (2' hash);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2) {  	//Insert  	m_insertBlockCommand.Transaction = transaction;  	m_insertBlockCommand.SetParameterValue (0' hash);  	m_insertBlockCommand.SetParameterValue (1' size);  	m_insertBlockCommand.SetParameterValue (2' volumeID);  	m_insertBlockCommand.ExecuteNonQuery ();  	return true;  } else if (currentVolumeId == -1) {  	//Update  	m_updateBlockVolumeCommand.Transaction = transaction;  	m_updateBlockVolumeCommand.SetParameterValue (0' volumeID);  	m_updateBlockVolumeCommand.SetParameterValue (1' hash);  	m_updateBlockVolumeCommand.SetParameterValue (2' size);  	var c = m_updateBlockVolumeCommand.ExecuteNonQuery ();  	if (c != 1)  		throw new Exception (string.Format ("Failed to update table' found {0} entries for key {1} with size {2}"' c' hash' size));  	return true;  } else {  	m_insertDuplicateBlockCommand.Transaction = transaction;  	m_insertDuplicateBlockCommand.SetParameterValue (0' hash);  	m_insertDuplicateBlockCommand.SetParameterValue (1' size);  	m_insertDuplicateBlockCommand.SetParameterValue (2' volumeID);  	m_insertDuplicateBlockCommand.ExecuteNonQuery ();  	return false;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2) {  	//Insert  	m_insertBlockCommand.Transaction = transaction;  	m_insertBlockCommand.SetParameterValue (0' hash);  	m_insertBlockCommand.SetParameterValue (1' size);  	m_insertBlockCommand.SetParameterValue (2' volumeID);  	m_insertBlockCommand.ExecuteNonQuery ();  	return true;  } else if (currentVolumeId == -1) {  	//Update  	m_updateBlockVolumeCommand.Transaction = transaction;  	m_updateBlockVolumeCommand.SetParameterValue (0' volumeID);  	m_updateBlockVolumeCommand.SetParameterValue (1' hash);  	m_updateBlockVolumeCommand.SetParameterValue (2' size);  	var c = m_updateBlockVolumeCommand.ExecuteNonQuery ();  	if (c != 1)  		throw new Exception (string.Format ("Failed to update table' found {0} entries for key {1} with size {2}"' c' hash' size));  	return true;  } else {  	m_insertDuplicateBlockCommand.Transaction = transaction;  	m_insertDuplicateBlockCommand.SetParameterValue (0' hash);  	m_insertDuplicateBlockCommand.SetParameterValue (1' size);  	m_insertDuplicateBlockCommand.SetParameterValue (2' volumeID);  	m_insertDuplicateBlockCommand.ExecuteNonQuery ();  	return false;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2) {  	//Insert  	m_insertBlockCommand.Transaction = transaction;  	m_insertBlockCommand.SetParameterValue (0' hash);  	m_insertBlockCommand.SetParameterValue (1' size);  	m_insertBlockCommand.SetParameterValue (2' volumeID);  	m_insertBlockCommand.ExecuteNonQuery ();  	return true;  } else if (currentVolumeId == -1) {  	//Update  	m_updateBlockVolumeCommand.Transaction = transaction;  	m_updateBlockVolumeCommand.SetParameterValue (0' volumeID);  	m_updateBlockVolumeCommand.SetParameterValue (1' hash);  	m_updateBlockVolumeCommand.SetParameterValue (2' size);  	var c = m_updateBlockVolumeCommand.ExecuteNonQuery ();  	if (c != 1)  		throw new Exception (string.Format ("Failed to update table' found {0} entries for key {1} with size {2}"' c' hash' size));  	return true;  } else {  	m_insertDuplicateBlockCommand.Transaction = transaction;  	m_insertDuplicateBlockCommand.SetParameterValue (0' hash);  	m_insertDuplicateBlockCommand.SetParameterValue (1' size);  	m_insertDuplicateBlockCommand.SetParameterValue (2' volumeID);  	m_insertDuplicateBlockCommand.ExecuteNonQuery ();  	return false;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -2) {  	//Insert  	m_insertBlockCommand.Transaction = transaction;  	m_insertBlockCommand.SetParameterValue (0' hash);  	m_insertBlockCommand.SetParameterValue (1' size);  	m_insertBlockCommand.SetParameterValue (2' volumeID);  	m_insertBlockCommand.ExecuteNonQuery ();  	return true;  } else if (currentVolumeId == -1) {  	//Update  	m_updateBlockVolumeCommand.Transaction = transaction;  	m_updateBlockVolumeCommand.SetParameterValue (0' volumeID);  	m_updateBlockVolumeCommand.SetParameterValue (1' hash);  	m_updateBlockVolumeCommand.SetParameterValue (2' size);  	var c = m_updateBlockVolumeCommand.ExecuteNonQuery ();  	if (c != 1)  		throw new Exception (string.Format ("Failed to update table' found {0} entries for key {1} with size {2}"' c' hash' size));  	return true;  } else {  	m_insertDuplicateBlockCommand.Transaction = transaction;  	m_insertDuplicateBlockCommand.SetParameterValue (0' hash);  	m_insertDuplicateBlockCommand.SetParameterValue (1' size);  	m_insertDuplicateBlockCommand.SetParameterValue (2' volumeID);  	m_insertDuplicateBlockCommand.ExecuteNonQuery ();  	return false;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: m_insertBlockCommand.SetParameterValue (2' volumeID);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -1) {  	//Update  	m_updateBlockVolumeCommand.Transaction = transaction;  	m_updateBlockVolumeCommand.SetParameterValue (0' volumeID);  	m_updateBlockVolumeCommand.SetParameterValue (1' hash);  	m_updateBlockVolumeCommand.SetParameterValue (2' size);  	var c = m_updateBlockVolumeCommand.ExecuteNonQuery ();  	if (c != 1)  		throw new Exception (string.Format ("Failed to update table' found {0} entries for key {1} with size {2}"' c' hash' size));  	return true;  } else {  	m_insertDuplicateBlockCommand.Transaction = transaction;  	m_insertDuplicateBlockCommand.SetParameterValue (0' hash);  	m_insertDuplicateBlockCommand.SetParameterValue (1' size);  	m_insertDuplicateBlockCommand.SetParameterValue (2' volumeID);  	m_insertDuplicateBlockCommand.ExecuteNonQuery ();  	return false;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: if (currentVolumeId == -1) {  	//Update  	m_updateBlockVolumeCommand.Transaction = transaction;  	m_updateBlockVolumeCommand.SetParameterValue (0' volumeID);  	m_updateBlockVolumeCommand.SetParameterValue (1' hash);  	m_updateBlockVolumeCommand.SetParameterValue (2' size);  	var c = m_updateBlockVolumeCommand.ExecuteNonQuery ();  	if (c != 1)  		throw new Exception (string.Format ("Failed to update table' found {0} entries for key {1} with size {2}"' c' hash' size));  	return true;  } else {  	m_insertDuplicateBlockCommand.Transaction = transaction;  	m_insertDuplicateBlockCommand.SetParameterValue (0' hash);  	m_insertDuplicateBlockCommand.SetParameterValue (1' size);  	m_insertDuplicateBlockCommand.SetParameterValue (2' volumeID);  	m_insertDuplicateBlockCommand.ExecuteNonQuery ();  	return false;  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: m_updateBlockVolumeCommand.SetParameterValue (2' size);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlock,The following statement contains a magic number: m_insertDuplicateBlockCommand.SetParameterValue (2' volumeID);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,AddSmallBlocksetLink,The following statement contains a magic number: m_insertSmallBlockset.SetParameterValue (2' blocksize);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlockset,The following statement contains a magic number: foreach (var s in blocklisthashes) {  	m_insertBlockset.SetParameterValue (1' s);  	m_insertBlockset.SetParameterValue (2' index++);  	m_insertBlockset.ExecuteNonQuery ();  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,UpdateBlockset,The following statement contains a magic number: m_insertBlockset.SetParameterValue (2' index++);  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	var selectCommand = @"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size""' ""RemoteVolume"".""ID"" FROM ""RemoteVolume""";  	var missingBlocklistEntries = string.Format (@"SELECT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash"" LEFT OUTER JOIN ""BlocksetEntry"" ON ""BlocksetEntry"".""Index"" = (""BlocklistHash"".""Index"" * {0}) AND ""BlocksetEntry"".""BlocksetID"" = ""BlocklistHash"".""BlocksetID"" WHERE ""BlocksetEntry"".""BlocksetID"" IS NULL"' blocksize / hashsize);  	var missingBlockInfo = @"SELECT ""VolumeID"" FROM ""Block"" WHERE ""VolumeID"" < 0 ";  	var missingBlocklistVolumes = string.Format (@"SELECT ""VolumeID"" FROM ""Block""' (" + missingBlocklistEntries + @") A WHERE ""A"".""Hash"" = ""Block"".""Hash"" ");  	var countMissingInformation = string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""VolumeID"" FROM ({0} UNION {1}))"' missingBlockInfo' missingBlocklistEntries);  	if (passNo == 0) {  		// On the first pass' we select all the volumes we know we need'  		// which may be an empty list  		cmd.CommandText = string.Format (selectCommand + @" WHERE ""ID"" IN ({0})"' missingBlocklistVolumes);  		// Reset the list  		m_proccessedVolumes = new Dictionary<long' long> ();  	} else {  		//On anything but the first pass' we check if we are done  		var r = cmd.ExecuteScalarInt64 (countMissingInformation' 0);  		if (r == 0)  			yield break;  		if (passNo == 1) {  			// On the second pass' we select all volumes that are not mentioned in the db  			var mentionedVolumes = @"SELECT DISTINCT ""VolumeID"" FROM ""Block"" ";  			cmd.CommandText = string.Format (selectCommand + @" WHERE ""ID"" NOT IN ({0}) AND ""Type"" = ? "' mentionedVolumes);  			cmd.AddParameter (RemoteVolumeType.Blocks.ToString ());  		} else {  			// On the final pass' we select all volumes  			// the filter will ensure that we do not download anything twice  			cmd.CommandText = selectCommand + @" WHERE ""Type"" = ?";  			cmd.AddParameter (RemoteVolumeType.Blocks.ToString ());  		}  	}  	using (var rd = cmd.ExecuteReader ()) {  		while (rd.Read ()) {  			var volumeID = rd.GetInt64 (3);  			// Guard against multiple downloads of the same file  			if (!m_proccessedVolumes.ContainsKey (volumeID)) {  				m_proccessedVolumes.Add (volumeID' volumeID);  				yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: using (var cmd = m_connection.CreateCommand ()) {  	var selectCommand = @"SELECT DISTINCT ""RemoteVolume"".""Name""' ""RemoteVolume"".""Hash""' ""RemoteVolume"".""Size""' ""RemoteVolume"".""ID"" FROM ""RemoteVolume""";  	var missingBlocklistEntries = string.Format (@"SELECT ""BlocklistHash"".""Hash"" FROM ""BlocklistHash"" LEFT OUTER JOIN ""BlocksetEntry"" ON ""BlocksetEntry"".""Index"" = (""BlocklistHash"".""Index"" * {0}) AND ""BlocksetEntry"".""BlocksetID"" = ""BlocklistHash"".""BlocksetID"" WHERE ""BlocksetEntry"".""BlocksetID"" IS NULL"' blocksize / hashsize);  	var missingBlockInfo = @"SELECT ""VolumeID"" FROM ""Block"" WHERE ""VolumeID"" < 0 ";  	var missingBlocklistVolumes = string.Format (@"SELECT ""VolumeID"" FROM ""Block""' (" + missingBlocklistEntries + @") A WHERE ""A"".""Hash"" = ""Block"".""Hash"" ");  	var countMissingInformation = string.Format (@"SELECT COUNT(*) FROM (SELECT DISTINCT ""VolumeID"" FROM ({0} UNION {1}))"' missingBlockInfo' missingBlocklistEntries);  	if (passNo == 0) {  		// On the first pass' we select all the volumes we know we need'  		// which may be an empty list  		cmd.CommandText = string.Format (selectCommand + @" WHERE ""ID"" IN ({0})"' missingBlocklistVolumes);  		// Reset the list  		m_proccessedVolumes = new Dictionary<long' long> ();  	} else {  		//On anything but the first pass' we check if we are done  		var r = cmd.ExecuteScalarInt64 (countMissingInformation' 0);  		if (r == 0)  			yield break;  		if (passNo == 1) {  			// On the second pass' we select all volumes that are not mentioned in the db  			var mentionedVolumes = @"SELECT DISTINCT ""VolumeID"" FROM ""Block"" ";  			cmd.CommandText = string.Format (selectCommand + @" WHERE ""ID"" NOT IN ({0}) AND ""Type"" = ? "' mentionedVolumes);  			cmd.AddParameter (RemoteVolumeType.Blocks.ToString ());  		} else {  			// On the final pass' we select all volumes  			// the filter will ensure that we do not download anything twice  			cmd.CommandText = selectCommand + @" WHERE ""Type"" = ?";  			cmd.AddParameter (RemoteVolumeType.Blocks.ToString ());  		}  	}  	using (var rd = cmd.ExecuteReader ()) {  		while (rd.Read ()) {  			var volumeID = rd.GetInt64 (3);  			// Guard against multiple downloads of the same file  			if (!m_proccessedVolumes.ContainsKey (volumeID)) {  				m_proccessedVolumes.Add (volumeID' volumeID);  				yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ()) {  	while (rd.Read ()) {  		var volumeID = rd.GetInt64 (3);  		// Guard against multiple downloads of the same file  		if (!m_proccessedVolumes.ContainsKey (volumeID)) {  			m_proccessedVolumes.Add (volumeID' volumeID);  			yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: using (var rd = cmd.ExecuteReader ()) {  	while (rd.Read ()) {  		var volumeID = rd.GetInt64 (3);  		// Guard against multiple downloads of the same file  		if (!m_proccessedVolumes.ContainsKey (volumeID)) {  			m_proccessedVolumes.Add (volumeID' volumeID);  			yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  		}  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: while (rd.Read ()) {  	var volumeID = rd.GetInt64 (3);  	// Guard against multiple downloads of the same file  	if (!m_proccessedVolumes.ContainsKey (volumeID)) {  		m_proccessedVolumes.Add (volumeID' volumeID);  		yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: while (rd.Read ()) {  	var volumeID = rd.GetInt64 (3);  	// Guard against multiple downloads of the same file  	if (!m_proccessedVolumes.ContainsKey (volumeID)) {  		m_proccessedVolumes.Add (volumeID' volumeID);  		yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  	}  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: if (!m_proccessedVolumes.ContainsKey (volumeID)) {  	m_proccessedVolumes.Add (volumeID' volumeID);  	yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  }  
Magic Number,Duplicati.Library.Main.Database,LocalRecreateDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalRecreateDatabase.cs,GetMissingBlockListVolumes,The following statement contains a magic number: yield return new RemoteVolume (rd.GetString (0)' rd.ConvertValueToString (1)' rd.ConvertValueToInt64 (2' -1));  
Magic Number,Duplicati.Library.Main.Database,PathLookupHelper,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\PathLookupHelper.cs,PathLookupHelper,The following statement contains a magic number: m_lookup = useHotPath ? new List<KeyValuePair<string' FolderEntry>> (128) : null;  
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilesets,The following statement contains a magic number: using (var cmd = Connection.CreateCommand (transaction))  	foreach (var rd in cmd.ExecuteReaderEnumerable (query' clause.Item2))  		if (!rd.IsDBNull (0))  			yield return new Tuple<DateTime' long' long> (ParseFromEpochSeconds (rd.ConvertValueToInt64 (0' 0))' rd.ConvertValueToInt64 (1' -1)' rd.ConvertValueToInt64 (2' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilesets,The following statement contains a magic number: foreach (var rd in cmd.ExecuteReaderEnumerable (query' clause.Item2))  	if (!rd.IsDBNull (0))  		yield return new Tuple<DateTime' long' long> (ParseFromEpochSeconds (rd.ConvertValueToInt64 (0' 0))' rd.ConvertValueToInt64 (1' -1)' rd.ConvertValueToInt64 (2' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilesets,The following statement contains a magic number: if (!rd.IsDBNull (0))  	yield return new Tuple<DateTime' long' long> (ParseFromEpochSeconds (rd.ConvertValueToInt64 (0' 0))' rd.ConvertValueToInt64 (1' -1)' rd.ConvertValueToInt64 (2' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,GetBrokenFilesets,The following statement contains a magic number: yield return new Tuple<DateTime' long' long> (ParseFromEpochSeconds (rd.ConvertValueToInt64 (0' 0))' rd.ConvertValueToInt64 (1' -1)' rd.ConvertValueToInt64 (2' 0));  
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The following statement contains a magic number: using (var deletecmd = m_connection.CreateCommand (transaction)) {  	string temptransguid = Library.Utility.Utility.ByteArrayAsHexString (Guid.NewGuid ().ToByteArray ());  	var volidstable = "DelVolSetIds-" + temptransguid;  	// Create and fill a temp table with the volids to delete. We avoid using too many parameters that way.  	deletecmd.ExecuteNonQuery (string.Format (@"CREATE TEMP TABLE ""{0}"" (""ID"" INTEGER PRIMARY KEY)"' volidstable));  	deletecmd.CommandText = string.Format (@"INSERT OR IGNORE INTO ""{0}"" (""ID"") VALUES (?)"' volidstable);  	deletecmd.Parameters.Clear ();  	deletecmd.AddParameters (1);  	foreach (var name in names) {  		var volumeid = GetRemoteVolumeID (name' transaction);  		deletecmd.SetParameterValue (0' volumeid);  		deletecmd.ExecuteNonQuery ();  	}  	var volIdsSubQuery = string.Format (@"SELECT ""ID"" FROM ""{0}"" "' volidstable);  	deletecmd.Parameters.Clear ();  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""IndexBlockLink"" WHERE ""BlockVolumeID"" IN ({0}) OR ""IndexVolumeID"" IN ({0})"' volIdsSubQuery));  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""Block"" WHERE ""VolumeID"" IN ({0})"' volIdsSubQuery));  	// Clean up temp tables for subqueries. We truncate content and then try to delete.  	// Drop in try-block' as it fails in nested transactions (SQLite problem)  	// System.Data.SQLite.SQLiteException (0x80004005): database table is locked  	deletecmd.ExecuteNonQuery (string.Format (@"DELETE FROM ""{0}"" "' volidstable));  	try {  		deletecmd.CommandTimeout = 2;  		deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));  	} catch {  		/* Ignore' will be deleted on close anyway. */}  }  
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The following statement contains a magic number: try {  	deletecmd.CommandTimeout = 2;  	deletecmd.ExecuteNonQuery (string.Format (@"DROP TABLE IF EXISTS ""{0}"" "' volidstable));  } catch {  	/* Ignore' will be deleted on close anyway. */}  
Magic Number,Duplicati.Library.Main.Database,LocalListBrokenFilesDatabase,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Database\LocalListBrokenFilesDatabase.cs,RemoveMissingBlocks,The following statement contains a magic number: deletecmd.CommandTimeout = 2;  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The following statement contains a magic number: using (var trn = m_database.BeginTransaction ()) {  	var incompleteSet = incompleteFilesets.Last ();  	var badIds = from n in incompleteFilesets  	select n.Key;  	var prevs = (from n in m_database.FilesetTimes  	where n.Key < incompleteSet.Key && !badIds.Contains (n.Key)  	orderby n.Key  	select n.Key).ToArray ();  	var prevId = prevs.Length == 0 ? -1 : prevs.Last ();  	FilesetVolumeWriter fsw = null;  	try {  		var s = 1;  		var fileTime = incompleteSet.Value + TimeSpan.FromSeconds (s);  		var oldFilesetID = incompleteSet.Key;  		// Probe for an unused filename  		while (s < 60) {  			var id = m_database.GetRemoteVolumeID (VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' fileTime));  			if (id < 0)  				break;  			fileTime = incompleteSet.Value + TimeSpan.FromSeconds (++s);  		}  		fsw = new FilesetVolumeWriter (m_options' fileTime);  		fsw.VolumeID = m_database.RegisterRemoteVolume (fsw.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  		if (!string.IsNullOrEmpty (m_options.ControlFiles))  			foreach (var p in m_options.ControlFiles.Split (new char[] {  				System.IO.Path.PathSeparator  			}' StringSplitOptions.RemoveEmptyEntries))  				fsw.AddControlFile (p' m_options.GetCompressionHintFromFilename (p));  		var newFilesetID = m_database.CreateFileset (fsw.VolumeID' fileTime' trn);  		m_database.LinkFilesetToVolume (newFilesetID' fsw.VolumeID' trn);  		m_database.AppendFilesFromPreviousSet (trn' null' newFilesetID' prevId' fileTime);  		m_database.WriteFileset (fsw' trn' newFilesetID);  		if (m_options.Dryrun) {  			m_result.AddDryrunMessage (string.Format ("Would upload fileset: {0}' size: {1}"' fsw.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (fsw.LocalFilename).Length)));  		} else {  			m_database.UpdateRemoteVolume (fsw.RemoteFilename' RemoteVolumeState.Uploading' -1' null' trn);  			using (new Logging.Timer ("CommitUpdateFilelistVolume"))  				trn.Commit ();  			backend.Put (fsw);  			fsw = null;  		}  	} finally {  		if (fsw != null)  			try {  				fsw.Dispose ();  			} catch {  				fsw = null;  			}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The following statement contains a magic number: try {  	var s = 1;  	var fileTime = incompleteSet.Value + TimeSpan.FromSeconds (s);  	var oldFilesetID = incompleteSet.Key;  	// Probe for an unused filename  	while (s < 60) {  		var id = m_database.GetRemoteVolumeID (VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' fileTime));  		if (id < 0)  			break;  		fileTime = incompleteSet.Value + TimeSpan.FromSeconds (++s);  	}  	fsw = new FilesetVolumeWriter (m_options' fileTime);  	fsw.VolumeID = m_database.RegisterRemoteVolume (fsw.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  	if (!string.IsNullOrEmpty (m_options.ControlFiles))  		foreach (var p in m_options.ControlFiles.Split (new char[] {  			System.IO.Path.PathSeparator  		}' StringSplitOptions.RemoveEmptyEntries))  			fsw.AddControlFile (p' m_options.GetCompressionHintFromFilename (p));  	var newFilesetID = m_database.CreateFileset (fsw.VolumeID' fileTime' trn);  	m_database.LinkFilesetToVolume (newFilesetID' fsw.VolumeID' trn);  	m_database.AppendFilesFromPreviousSet (trn' null' newFilesetID' prevId' fileTime);  	m_database.WriteFileset (fsw' trn' newFilesetID);  	if (m_options.Dryrun) {  		m_result.AddDryrunMessage (string.Format ("Would upload fileset: {0}' size: {1}"' fsw.RemoteFilename' Library.Utility.Utility.FormatSizeString (new FileInfo (fsw.LocalFilename).Length)));  	} else {  		m_database.UpdateRemoteVolume (fsw.RemoteFilename' RemoteVolumeState.Uploading' -1' null' trn);  		using (new Logging.Timer ("CommitUpdateFilelistVolume"))  			trn.Commit ();  		backend.Put (fsw);  		fsw = null;  	}  } finally {  	if (fsw != null)  		try {  			fsw.Dispose ();  		} catch {  			fsw = null;  		}  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,UploadSyntheticFilelist,The following statement contains a magic number: while (s < 60) {  	var id = m_database.GetRemoteVolumeID (VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' fileTime));  	if (id < 0)  		break;  	fileTime = incompleteSet.Value + TimeSpan.FromSeconds (++s);  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,RecreateMissingIndexFiles,The following statement contains a magic number: if (m_options.IndexfilePolicy != Options.IndexFileStrategy.None) {  	var blockhasher = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  	var hashsize = blockhasher.HashSize / 8;  	foreach (var blockfile in m_database.GetMissingIndexFiles ()) {  		m_result.AddMessage (string.Format ("Re-creating missing index file for {0}"' blockfile));  		var w = new IndexVolumeWriter (m_options);  		w.VolumeID = m_database.RegisterRemoteVolume (w.RemoteFilename' RemoteVolumeType.Index' RemoteVolumeState.Temporary' null);  		var blockvolume = m_database.GetRemoteVolumeFromName (blockfile);  		w.StartVolume (blockvolume.Name);  		var volumeid = m_database.GetRemoteVolumeID (blockvolume.Name);  		foreach (var b in m_database.GetBlocks (volumeid))  			w.AddBlock (b.Hash' b.Size);  		w.FinishVolume (blockvolume.Hash' blockvolume.Size);  		if (m_options.IndexfilePolicy == Options.IndexFileStrategy.Full)  			foreach (var b in m_database.GetBlocklists (volumeid' m_options.Blocksize' hashsize))  				w.WriteBlocklist (b.Item1' b.Item2' 0' b.Item3);  		w.Close ();  		m_database.AddIndexBlockLink (w.VolumeID' volumeid' null);  		if (m_options.Dryrun)  			m_result.AddDryrunMessage (string.Format ("would upload new index file {0}' with size {1}' previous size {2}"' w.RemoteFilename' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (w.Filesize)));  		else {  			m_database.UpdateRemoteVolume (w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);  			backend.Put (w);  		}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: using (m_database = new LocalBackupDatabase (m_options.Dbpath' m_options)) {  	m_result.SetDatabase (m_database);  	m_result.Dryrun = m_options.Dryrun;  	Utility.UpdateOptionsFromDb (m_database' m_options);  	Utility.VerifyParameters (m_database' m_options);  	var probe_path = m_database.GetFirstPath ();  	if (probe_path != null && Duplicati.Library.Utility.Utility.GuessDirSeparator (probe_path) != System.IO.Path.DirectorySeparatorChar.ToString ())  		throw new UserInformationException (string.Format ("The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems' which is not supported. To proceed without losing remote data' delete all filesets and make sure the --{0} option is set' then run the backup again to re-use the existing data on the remote store."' "no-auto-compact"));  	if (m_database.PartiallyRecreated)  		throw new UserInformationException ("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");  	if (m_database.RepairInProgress)  		throw new UserInformationException ("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the backup process cannot continue. You may delete the local database and attempt to repair it again.");  	m_blocksize = m_options.Blocksize;  	m_maxmetadatasize = (m_blocksize / (long)m_options.BlockhashSize) * m_blocksize;  	m_blockbuffer = new byte[m_options.Blocksize * Math.Max (1' m_options.FileReadBufferSize / m_options.Blocksize)];  	m_blocklistbuffer = new byte[m_options.Blocksize];  	m_blockhasher = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  	m_filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_options.FileHashAlgorithm);  	if (m_blockhasher == null)  		throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  	if (m_filehasher == null)  		throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.FileHashAlgorithm));  	if (!m_blockhasher.CanReuseTransform)  		throw new UserInformationException (Strings.Common.InvalidCryptoSystem (m_options.BlockHashAlgorithm));  	if (!m_filehasher.CanReuseTransform)  		throw new UserInformationException (Strings.Common.InvalidCryptoSystem (m_options.FileHashAlgorithm));  	m_database.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' false);  	// If there is no filter' we set an empty filter to simplify the code  	// If there is a filter' we make sure that the sources are included  	m_filter = filter ?? new Library.Utility.FilterExpression ();  	m_sourceFilter = new Library.Utility.FilterExpression (sources' true);  	m_backendLogFlushTimer = DateTime.Now.Add (FLUSH_TIMESPAN);  	System.Threading.Thread parallelScanner = null;  	try {  		using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' m_database))  			using (var filesetvolume = new FilesetVolumeWriter (m_options' m_database.OperationTimestamp)) {  				using (var snapshot = GetSnapshot (sources' m_options' m_result)) {  					// Start parallel scan  					if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1) {  						parallelScanner = new System.Threading.Thread (CountFilesThread) {  							Name = "Read ahead file counter"'  							IsBackground = true  						};  						parallelScanner.Start (snapshot);  					}  					string lasttempfilelist = null;  					long lasttempfileid = -1;  					if (!m_options.DisableSyntheticFilelist) {  						var candidates = m_database.GetIncompleteFilesets (null).OrderBy (x => x.Value).ToArray ();  						if (candidates.Length > 0) {  							lasttempfileid = candidates.Last ().Key;  							lasttempfilelist = m_database.GetRemoteVolumeFromID (lasttempfileid).Name;  						}  					}  					// Verify before uploading a synthetic list  					PreBackupVerify (backend' lasttempfilelist);  					// If we have an incomplete entry' upload it now  					if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace (lasttempfilelist) && lasttempfileid >= 0) {  						// Check that we still need to process this after the cleanup has performed its duties  						var syntbase = m_database.GetRemoteVolumeFromID (lasttempfileid);  						if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) {  							UploadSyntheticFilelist (backend);  							// Remove the protected file  							if (syntbase.State == RemoteVolumeState.Uploading) {  								m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));  								backend.Delete (syntbase.Name' syntbase.Size);  							} else if (syntbase.State == RemoteVolumeState.Temporary) {  								m_result.AddMessage (string.Format ("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));  								m_database.RemoveRemoteVolume (syntbase.Name);  							}  						} else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)  							m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);  					}  					var prevfileset = m_database.FilesetTimes.FirstOrDefault ();  					if (prevfileset.Value.ToUniversalTime () > m_database.OperationTimestamp.ToUniversalTime ())  						throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ()));  					m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;  					// Rebuild any index files that are missing  					RecreateMissingIndexFiles (backend);  					m_database.BuildLookupTable (m_options);  					m_transaction = m_database.BeginTransaction ();  					var repcnt = 0;  					while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  						filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  					if (m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  						throw new Exception ("Unable to generate a unique fileset name");  					m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_ProcessingFiles);  					var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  					m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction);  					RunMainOperation (snapshot' backend);  					//If the scanner is still running for some reason' make sure we kill it now   					if (parallelScanner != null && parallelScanner.IsAlive)  						parallelScanner.Abort ();  				}  				var lastVolumeSize = FinalizeRemoteVolumes (backend);  				using (new Logging.Timer ("UpdateChangeStatistics"))  					m_database.UpdateChangeStatistics (m_result);  				using (new Logging.Timer ("VerifyConsistency"))  					m_database.VerifyConsistency (m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);  				UploadRealFileList (backend' filesetvolume);  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_WaitForUpload);  				using (new Logging.Timer ("Async backend wait"))  					backend.WaitForComplete (m_database' m_transaction);  				if (m_result.TaskControlRendevouz () != TaskControlState.Stop)  					CompactIfRequired (backend' lastVolumeSize);  				if (m_options.UploadVerificationFile) {  					m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_VerificationUpload);  					FilelistProcessor.UploadVerificationFile (backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);  				}  				if (m_options.Dryrun) {  					m_transaction.Rollback ();  					m_transaction = null;  				} else {  					using (new Logging.Timer ("CommitFinalizingBackup"))  						m_transaction.Commit ();  					m_transaction = null;  					if (m_result.TaskControlRendevouz () != TaskControlState.Stop) {  						if (m_options.NoBackendverification)  							UpdateStorageStatsFromDatabase ();  						else  							PostBackupVerification ();  					}  				}  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_Complete);  				m_database.WriteResults ();  				m_database.PurgeLogData (m_options.LogRetention);  				return;  			}  	} catch (Exception ex) {  		m_result.AddError ("Fatal error"' ex);  		throw;  	} finally {  		if (parallelScanner != null && parallelScanner.IsAlive) {  			parallelScanner.Abort ();  			parallelScanner.Join (500);  			if (parallelScanner.IsAlive)  				m_result.AddWarning ("Failed to terminate filecounter thread"' null);  		}  		if (m_transaction != null)  			try {  				m_transaction.Rollback ();  			} catch (Exception ex) {  				m_result.AddError (string.Format ("Rollback error: {0}"' ex.Message)' ex);  			}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: using (m_database = new LocalBackupDatabase (m_options.Dbpath' m_options)) {  	m_result.SetDatabase (m_database);  	m_result.Dryrun = m_options.Dryrun;  	Utility.UpdateOptionsFromDb (m_database' m_options);  	Utility.VerifyParameters (m_database' m_options);  	var probe_path = m_database.GetFirstPath ();  	if (probe_path != null && Duplicati.Library.Utility.Utility.GuessDirSeparator (probe_path) != System.IO.Path.DirectorySeparatorChar.ToString ())  		throw new UserInformationException (string.Format ("The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems' which is not supported. To proceed without losing remote data' delete all filesets and make sure the --{0} option is set' then run the backup again to re-use the existing data on the remote store."' "no-auto-compact"));  	if (m_database.PartiallyRecreated)  		throw new UserInformationException ("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");  	if (m_database.RepairInProgress)  		throw new UserInformationException ("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the backup process cannot continue. You may delete the local database and attempt to repair it again.");  	m_blocksize = m_options.Blocksize;  	m_maxmetadatasize = (m_blocksize / (long)m_options.BlockhashSize) * m_blocksize;  	m_blockbuffer = new byte[m_options.Blocksize * Math.Max (1' m_options.FileReadBufferSize / m_options.Blocksize)];  	m_blocklistbuffer = new byte[m_options.Blocksize];  	m_blockhasher = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  	m_filehasher = System.Security.Cryptography.HashAlgorithm.Create (m_options.FileHashAlgorithm);  	if (m_blockhasher == null)  		throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  	if (m_filehasher == null)  		throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.FileHashAlgorithm));  	if (!m_blockhasher.CanReuseTransform)  		throw new UserInformationException (Strings.Common.InvalidCryptoSystem (m_options.BlockHashAlgorithm));  	if (!m_filehasher.CanReuseTransform)  		throw new UserInformationException (Strings.Common.InvalidCryptoSystem (m_options.FileHashAlgorithm));  	m_database.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' false);  	// If there is no filter' we set an empty filter to simplify the code  	// If there is a filter' we make sure that the sources are included  	m_filter = filter ?? new Library.Utility.FilterExpression ();  	m_sourceFilter = new Library.Utility.FilterExpression (sources' true);  	m_backendLogFlushTimer = DateTime.Now.Add (FLUSH_TIMESPAN);  	System.Threading.Thread parallelScanner = null;  	try {  		using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' m_database))  			using (var filesetvolume = new FilesetVolumeWriter (m_options' m_database.OperationTimestamp)) {  				using (var snapshot = GetSnapshot (sources' m_options' m_result)) {  					// Start parallel scan  					if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1) {  						parallelScanner = new System.Threading.Thread (CountFilesThread) {  							Name = "Read ahead file counter"'  							IsBackground = true  						};  						parallelScanner.Start (snapshot);  					}  					string lasttempfilelist = null;  					long lasttempfileid = -1;  					if (!m_options.DisableSyntheticFilelist) {  						var candidates = m_database.GetIncompleteFilesets (null).OrderBy (x => x.Value).ToArray ();  						if (candidates.Length > 0) {  							lasttempfileid = candidates.Last ().Key;  							lasttempfilelist = m_database.GetRemoteVolumeFromID (lasttempfileid).Name;  						}  					}  					// Verify before uploading a synthetic list  					PreBackupVerify (backend' lasttempfilelist);  					// If we have an incomplete entry' upload it now  					if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace (lasttempfilelist) && lasttempfileid >= 0) {  						// Check that we still need to process this after the cleanup has performed its duties  						var syntbase = m_database.GetRemoteVolumeFromID (lasttempfileid);  						if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) {  							UploadSyntheticFilelist (backend);  							// Remove the protected file  							if (syntbase.State == RemoteVolumeState.Uploading) {  								m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));  								backend.Delete (syntbase.Name' syntbase.Size);  							} else if (syntbase.State == RemoteVolumeState.Temporary) {  								m_result.AddMessage (string.Format ("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));  								m_database.RemoveRemoteVolume (syntbase.Name);  							}  						} else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)  							m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);  					}  					var prevfileset = m_database.FilesetTimes.FirstOrDefault ();  					if (prevfileset.Value.ToUniversalTime () > m_database.OperationTimestamp.ToUniversalTime ())  						throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ()));  					m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;  					// Rebuild any index files that are missing  					RecreateMissingIndexFiles (backend);  					m_database.BuildLookupTable (m_options);  					m_transaction = m_database.BeginTransaction ();  					var repcnt = 0;  					while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  						filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  					if (m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  						throw new Exception ("Unable to generate a unique fileset name");  					m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_ProcessingFiles);  					var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  					m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction);  					RunMainOperation (snapshot' backend);  					//If the scanner is still running for some reason' make sure we kill it now   					if (parallelScanner != null && parallelScanner.IsAlive)  						parallelScanner.Abort ();  				}  				var lastVolumeSize = FinalizeRemoteVolumes (backend);  				using (new Logging.Timer ("UpdateChangeStatistics"))  					m_database.UpdateChangeStatistics (m_result);  				using (new Logging.Timer ("VerifyConsistency"))  					m_database.VerifyConsistency (m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);  				UploadRealFileList (backend' filesetvolume);  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_WaitForUpload);  				using (new Logging.Timer ("Async backend wait"))  					backend.WaitForComplete (m_database' m_transaction);  				if (m_result.TaskControlRendevouz () != TaskControlState.Stop)  					CompactIfRequired (backend' lastVolumeSize);  				if (m_options.UploadVerificationFile) {  					m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_VerificationUpload);  					FilelistProcessor.UploadVerificationFile (backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);  				}  				if (m_options.Dryrun) {  					m_transaction.Rollback ();  					m_transaction = null;  				} else {  					using (new Logging.Timer ("CommitFinalizingBackup"))  						m_transaction.Commit ();  					m_transaction = null;  					if (m_result.TaskControlRendevouz () != TaskControlState.Stop) {  						if (m_options.NoBackendverification)  							UpdateStorageStatsFromDatabase ();  						else  							PostBackupVerification ();  					}  				}  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_Complete);  				m_database.WriteResults ();  				m_database.PurgeLogData (m_options.LogRetention);  				return;  			}  	} catch (Exception ex) {  		m_result.AddError ("Fatal error"' ex);  		throw;  	} finally {  		if (parallelScanner != null && parallelScanner.IsAlive) {  			parallelScanner.Abort ();  			parallelScanner.Join (500);  			if (parallelScanner.IsAlive)  				m_result.AddWarning ("Failed to terminate filecounter thread"' null);  		}  		if (m_transaction != null)  			try {  				m_transaction.Rollback ();  			} catch (Exception ex) {  				m_result.AddError (string.Format ("Rollback error: {0}"' ex.Message)' ex);  			}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: try {  	using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' m_database))  		using (var filesetvolume = new FilesetVolumeWriter (m_options' m_database.OperationTimestamp)) {  			using (var snapshot = GetSnapshot (sources' m_options' m_result)) {  				// Start parallel scan  				if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1) {  					parallelScanner = new System.Threading.Thread (CountFilesThread) {  						Name = "Read ahead file counter"'  						IsBackground = true  					};  					parallelScanner.Start (snapshot);  				}  				string lasttempfilelist = null;  				long lasttempfileid = -1;  				if (!m_options.DisableSyntheticFilelist) {  					var candidates = m_database.GetIncompleteFilesets (null).OrderBy (x => x.Value).ToArray ();  					if (candidates.Length > 0) {  						lasttempfileid = candidates.Last ().Key;  						lasttempfilelist = m_database.GetRemoteVolumeFromID (lasttempfileid).Name;  					}  				}  				// Verify before uploading a synthetic list  				PreBackupVerify (backend' lasttempfilelist);  				// If we have an incomplete entry' upload it now  				if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace (lasttempfilelist) && lasttempfileid >= 0) {  					// Check that we still need to process this after the cleanup has performed its duties  					var syntbase = m_database.GetRemoteVolumeFromID (lasttempfileid);  					if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) {  						UploadSyntheticFilelist (backend);  						// Remove the protected file  						if (syntbase.State == RemoteVolumeState.Uploading) {  							m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));  							backend.Delete (syntbase.Name' syntbase.Size);  						} else if (syntbase.State == RemoteVolumeState.Temporary) {  							m_result.AddMessage (string.Format ("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));  							m_database.RemoveRemoteVolume (syntbase.Name);  						}  					} else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)  						m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);  				}  				var prevfileset = m_database.FilesetTimes.FirstOrDefault ();  				if (prevfileset.Value.ToUniversalTime () > m_database.OperationTimestamp.ToUniversalTime ())  					throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ()));  				m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;  				// Rebuild any index files that are missing  				RecreateMissingIndexFiles (backend);  				m_database.BuildLookupTable (m_options);  				m_transaction = m_database.BeginTransaction ();  				var repcnt = 0;  				while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  					filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  				if (m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  					throw new Exception ("Unable to generate a unique fileset name");  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_ProcessingFiles);  				var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  				m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction);  				RunMainOperation (snapshot' backend);  				//If the scanner is still running for some reason' make sure we kill it now   				if (parallelScanner != null && parallelScanner.IsAlive)  					parallelScanner.Abort ();  			}  			var lastVolumeSize = FinalizeRemoteVolumes (backend);  			using (new Logging.Timer ("UpdateChangeStatistics"))  				m_database.UpdateChangeStatistics (m_result);  			using (new Logging.Timer ("VerifyConsistency"))  				m_database.VerifyConsistency (m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);  			UploadRealFileList (backend' filesetvolume);  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_WaitForUpload);  			using (new Logging.Timer ("Async backend wait"))  				backend.WaitForComplete (m_database' m_transaction);  			if (m_result.TaskControlRendevouz () != TaskControlState.Stop)  				CompactIfRequired (backend' lastVolumeSize);  			if (m_options.UploadVerificationFile) {  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_VerificationUpload);  				FilelistProcessor.UploadVerificationFile (backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);  			}  			if (m_options.Dryrun) {  				m_transaction.Rollback ();  				m_transaction = null;  			} else {  				using (new Logging.Timer ("CommitFinalizingBackup"))  					m_transaction.Commit ();  				m_transaction = null;  				if (m_result.TaskControlRendevouz () != TaskControlState.Stop) {  					if (m_options.NoBackendverification)  						UpdateStorageStatsFromDatabase ();  					else  						PostBackupVerification ();  				}  			}  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_Complete);  			m_database.WriteResults ();  			m_database.PurgeLogData (m_options.LogRetention);  			return;  		}  } catch (Exception ex) {  	m_result.AddError ("Fatal error"' ex);  	throw;  } finally {  	if (parallelScanner != null && parallelScanner.IsAlive) {  		parallelScanner.Abort ();  		parallelScanner.Join (500);  		if (parallelScanner.IsAlive)  			m_result.AddWarning ("Failed to terminate filecounter thread"' null);  	}  	if (m_transaction != null)  		try {  			m_transaction.Rollback ();  		} catch (Exception ex) {  			m_result.AddError (string.Format ("Rollback error: {0}"' ex.Message)' ex);  		}  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: try {  	using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' m_database))  		using (var filesetvolume = new FilesetVolumeWriter (m_options' m_database.OperationTimestamp)) {  			using (var snapshot = GetSnapshot (sources' m_options' m_result)) {  				// Start parallel scan  				if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1) {  					parallelScanner = new System.Threading.Thread (CountFilesThread) {  						Name = "Read ahead file counter"'  						IsBackground = true  					};  					parallelScanner.Start (snapshot);  				}  				string lasttempfilelist = null;  				long lasttempfileid = -1;  				if (!m_options.DisableSyntheticFilelist) {  					var candidates = m_database.GetIncompleteFilesets (null).OrderBy (x => x.Value).ToArray ();  					if (candidates.Length > 0) {  						lasttempfileid = candidates.Last ().Key;  						lasttempfilelist = m_database.GetRemoteVolumeFromID (lasttempfileid).Name;  					}  				}  				// Verify before uploading a synthetic list  				PreBackupVerify (backend' lasttempfilelist);  				// If we have an incomplete entry' upload it now  				if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace (lasttempfilelist) && lasttempfileid >= 0) {  					// Check that we still need to process this after the cleanup has performed its duties  					var syntbase = m_database.GetRemoteVolumeFromID (lasttempfileid);  					if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) {  						UploadSyntheticFilelist (backend);  						// Remove the protected file  						if (syntbase.State == RemoteVolumeState.Uploading) {  							m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));  							backend.Delete (syntbase.Name' syntbase.Size);  						} else if (syntbase.State == RemoteVolumeState.Temporary) {  							m_result.AddMessage (string.Format ("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));  							m_database.RemoveRemoteVolume (syntbase.Name);  						}  					} else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)  						m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);  				}  				var prevfileset = m_database.FilesetTimes.FirstOrDefault ();  				if (prevfileset.Value.ToUniversalTime () > m_database.OperationTimestamp.ToUniversalTime ())  					throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ()));  				m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;  				// Rebuild any index files that are missing  				RecreateMissingIndexFiles (backend);  				m_database.BuildLookupTable (m_options);  				m_transaction = m_database.BeginTransaction ();  				var repcnt = 0;  				while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  					filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  				if (m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  					throw new Exception ("Unable to generate a unique fileset name");  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_ProcessingFiles);  				var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  				m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction);  				RunMainOperation (snapshot' backend);  				//If the scanner is still running for some reason' make sure we kill it now   				if (parallelScanner != null && parallelScanner.IsAlive)  					parallelScanner.Abort ();  			}  			var lastVolumeSize = FinalizeRemoteVolumes (backend);  			using (new Logging.Timer ("UpdateChangeStatistics"))  				m_database.UpdateChangeStatistics (m_result);  			using (new Logging.Timer ("VerifyConsistency"))  				m_database.VerifyConsistency (m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);  			UploadRealFileList (backend' filesetvolume);  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_WaitForUpload);  			using (new Logging.Timer ("Async backend wait"))  				backend.WaitForComplete (m_database' m_transaction);  			if (m_result.TaskControlRendevouz () != TaskControlState.Stop)  				CompactIfRequired (backend' lastVolumeSize);  			if (m_options.UploadVerificationFile) {  				m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_VerificationUpload);  				FilelistProcessor.UploadVerificationFile (backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);  			}  			if (m_options.Dryrun) {  				m_transaction.Rollback ();  				m_transaction = null;  			} else {  				using (new Logging.Timer ("CommitFinalizingBackup"))  					m_transaction.Commit ();  				m_transaction = null;  				if (m_result.TaskControlRendevouz () != TaskControlState.Stop) {  					if (m_options.NoBackendverification)  						UpdateStorageStatsFromDatabase ();  					else  						PostBackupVerification ();  				}  			}  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_Complete);  			m_database.WriteResults ();  			m_database.PurgeLogData (m_options.LogRetention);  			return;  		}  } catch (Exception ex) {  	m_result.AddError ("Fatal error"' ex);  	throw;  } finally {  	if (parallelScanner != null && parallelScanner.IsAlive) {  		parallelScanner.Abort ();  		parallelScanner.Join (500);  		if (parallelScanner.IsAlive)  			m_result.AddWarning ("Failed to terminate filecounter thread"' null);  	}  	if (m_transaction != null)  		try {  			m_transaction.Rollback ();  		} catch (Exception ex) {  			m_result.AddError (string.Format ("Rollback error: {0}"' ex.Message)' ex);  		}  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' m_database))  	using (var filesetvolume = new FilesetVolumeWriter (m_options' m_database.OperationTimestamp)) {  		using (var snapshot = GetSnapshot (sources' m_options' m_result)) {  			// Start parallel scan  			if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1) {  				parallelScanner = new System.Threading.Thread (CountFilesThread) {  					Name = "Read ahead file counter"'  					IsBackground = true  				};  				parallelScanner.Start (snapshot);  			}  			string lasttempfilelist = null;  			long lasttempfileid = -1;  			if (!m_options.DisableSyntheticFilelist) {  				var candidates = m_database.GetIncompleteFilesets (null).OrderBy (x => x.Value).ToArray ();  				if (candidates.Length > 0) {  					lasttempfileid = candidates.Last ().Key;  					lasttempfilelist = m_database.GetRemoteVolumeFromID (lasttempfileid).Name;  				}  			}  			// Verify before uploading a synthetic list  			PreBackupVerify (backend' lasttempfilelist);  			// If we have an incomplete entry' upload it now  			if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace (lasttempfilelist) && lasttempfileid >= 0) {  				// Check that we still need to process this after the cleanup has performed its duties  				var syntbase = m_database.GetRemoteVolumeFromID (lasttempfileid);  				if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) {  					UploadSyntheticFilelist (backend);  					// Remove the protected file  					if (syntbase.State == RemoteVolumeState.Uploading) {  						m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));  						backend.Delete (syntbase.Name' syntbase.Size);  					} else if (syntbase.State == RemoteVolumeState.Temporary) {  						m_result.AddMessage (string.Format ("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));  						m_database.RemoveRemoteVolume (syntbase.Name);  					}  				} else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)  					m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);  			}  			var prevfileset = m_database.FilesetTimes.FirstOrDefault ();  			if (prevfileset.Value.ToUniversalTime () > m_database.OperationTimestamp.ToUniversalTime ())  				throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ()));  			m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;  			// Rebuild any index files that are missing  			RecreateMissingIndexFiles (backend);  			m_database.BuildLookupTable (m_options);  			m_transaction = m_database.BeginTransaction ();  			var repcnt = 0;  			while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  				filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  			if (m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  				throw new Exception ("Unable to generate a unique fileset name");  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_ProcessingFiles);  			var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  			m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction);  			RunMainOperation (snapshot' backend);  			//If the scanner is still running for some reason' make sure we kill it now   			if (parallelScanner != null && parallelScanner.IsAlive)  				parallelScanner.Abort ();  		}  		var lastVolumeSize = FinalizeRemoteVolumes (backend);  		using (new Logging.Timer ("UpdateChangeStatistics"))  			m_database.UpdateChangeStatistics (m_result);  		using (new Logging.Timer ("VerifyConsistency"))  			m_database.VerifyConsistency (m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);  		UploadRealFileList (backend' filesetvolume);  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_WaitForUpload);  		using (new Logging.Timer ("Async backend wait"))  			backend.WaitForComplete (m_database' m_transaction);  		if (m_result.TaskControlRendevouz () != TaskControlState.Stop)  			CompactIfRequired (backend' lastVolumeSize);  		if (m_options.UploadVerificationFile) {  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_VerificationUpload);  			FilelistProcessor.UploadVerificationFile (backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);  		}  		if (m_options.Dryrun) {  			m_transaction.Rollback ();  			m_transaction = null;  		} else {  			using (new Logging.Timer ("CommitFinalizingBackup"))  				m_transaction.Commit ();  			m_transaction = null;  			if (m_result.TaskControlRendevouz () != TaskControlState.Stop) {  				if (m_options.NoBackendverification)  					UpdateStorageStatsFromDatabase ();  				else  					PostBackupVerification ();  			}  		}  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_Complete);  		m_database.WriteResults ();  		m_database.PurgeLogData (m_options.LogRetention);  		return;  	}  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: using (var filesetvolume = new FilesetVolumeWriter (m_options' m_database.OperationTimestamp)) {  	using (var snapshot = GetSnapshot (sources' m_options' m_result)) {  		// Start parallel scan  		if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1) {  			parallelScanner = new System.Threading.Thread (CountFilesThread) {  				Name = "Read ahead file counter"'  				IsBackground = true  			};  			parallelScanner.Start (snapshot);  		}  		string lasttempfilelist = null;  		long lasttempfileid = -1;  		if (!m_options.DisableSyntheticFilelist) {  			var candidates = m_database.GetIncompleteFilesets (null).OrderBy (x => x.Value).ToArray ();  			if (candidates.Length > 0) {  				lasttempfileid = candidates.Last ().Key;  				lasttempfilelist = m_database.GetRemoteVolumeFromID (lasttempfileid).Name;  			}  		}  		// Verify before uploading a synthetic list  		PreBackupVerify (backend' lasttempfilelist);  		// If we have an incomplete entry' upload it now  		if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace (lasttempfilelist) && lasttempfileid >= 0) {  			// Check that we still need to process this after the cleanup has performed its duties  			var syntbase = m_database.GetRemoteVolumeFromID (lasttempfileid);  			if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) {  				UploadSyntheticFilelist (backend);  				// Remove the protected file  				if (syntbase.State == RemoteVolumeState.Uploading) {  					m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));  					backend.Delete (syntbase.Name' syntbase.Size);  				} else if (syntbase.State == RemoteVolumeState.Temporary) {  					m_result.AddMessage (string.Format ("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));  					m_database.RemoveRemoteVolume (syntbase.Name);  				}  			} else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)  				m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);  		}  		var prevfileset = m_database.FilesetTimes.FirstOrDefault ();  		if (prevfileset.Value.ToUniversalTime () > m_database.OperationTimestamp.ToUniversalTime ())  			throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ()));  		m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;  		// Rebuild any index files that are missing  		RecreateMissingIndexFiles (backend);  		m_database.BuildLookupTable (m_options);  		m_transaction = m_database.BeginTransaction ();  		var repcnt = 0;  		while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  			filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  		if (m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  			throw new Exception ("Unable to generate a unique fileset name");  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_ProcessingFiles);  		var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  		m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction);  		RunMainOperation (snapshot' backend);  		//If the scanner is still running for some reason' make sure we kill it now   		if (parallelScanner != null && parallelScanner.IsAlive)  			parallelScanner.Abort ();  	}  	var lastVolumeSize = FinalizeRemoteVolumes (backend);  	using (new Logging.Timer ("UpdateChangeStatistics"))  		m_database.UpdateChangeStatistics (m_result);  	using (new Logging.Timer ("VerifyConsistency"))  		m_database.VerifyConsistency (m_transaction' m_options.Blocksize' m_options.BlockhashSize' false);  	UploadRealFileList (backend' filesetvolume);  	m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_WaitForUpload);  	using (new Logging.Timer ("Async backend wait"))  		backend.WaitForComplete (m_database' m_transaction);  	if (m_result.TaskControlRendevouz () != TaskControlState.Stop)  		CompactIfRequired (backend' lastVolumeSize);  	if (m_options.UploadVerificationFile) {  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_VerificationUpload);  		FilelistProcessor.UploadVerificationFile (backend.BackendUrl' m_options' m_result.BackendWriter' m_database' m_transaction);  	}  	if (m_options.Dryrun) {  		m_transaction.Rollback ();  		m_transaction = null;  	} else {  		using (new Logging.Timer ("CommitFinalizingBackup"))  			m_transaction.Commit ();  		m_transaction = null;  		if (m_result.TaskControlRendevouz () != TaskControlState.Stop) {  			if (m_options.NoBackendverification)  				UpdateStorageStatsFromDatabase ();  			else  				PostBackupVerification ();  		}  	}  	m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_Complete);  	m_database.WriteResults ();  	m_database.PurgeLogData (m_options.LogRetention);  	return;  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: using (var snapshot = GetSnapshot (sources' m_options' m_result)) {  	// Start parallel scan  	if (m_options.ChangedFilelist == null || m_options.ChangedFilelist.Length < 1) {  		parallelScanner = new System.Threading.Thread (CountFilesThread) {  			Name = "Read ahead file counter"'  			IsBackground = true  		};  		parallelScanner.Start (snapshot);  	}  	string lasttempfilelist = null;  	long lasttempfileid = -1;  	if (!m_options.DisableSyntheticFilelist) {  		var candidates = m_database.GetIncompleteFilesets (null).OrderBy (x => x.Value).ToArray ();  		if (candidates.Length > 0) {  			lasttempfileid = candidates.Last ().Key;  			lasttempfilelist = m_database.GetRemoteVolumeFromID (lasttempfileid).Name;  		}  	}  	// Verify before uploading a synthetic list  	PreBackupVerify (backend' lasttempfilelist);  	// If we have an incomplete entry' upload it now  	if (!m_options.DisableSyntheticFilelist && !string.IsNullOrWhiteSpace (lasttempfilelist) && lasttempfileid >= 0) {  		// Check that we still need to process this after the cleanup has performed its duties  		var syntbase = m_database.GetRemoteVolumeFromID (lasttempfileid);  		if (syntbase.Name != null && (syntbase.State == RemoteVolumeState.Uploading || syntbase.State == RemoteVolumeState.Temporary)) {  			UploadSyntheticFilelist (backend);  			// Remove the protected file  			if (syntbase.State == RemoteVolumeState.Uploading) {  				m_result.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' syntbase.State' syntbase.Name));  				backend.Delete (syntbase.Name' syntbase.Size);  			} else if (syntbase.State == RemoteVolumeState.Temporary) {  				m_result.AddMessage (string.Format ("removing file listed as {0}: {1}"' syntbase.State' syntbase.Name));  				m_database.RemoveRemoteVolume (syntbase.Name);  			}  		} else if (syntbase.Name == null || syntbase.State != RemoteVolumeState.Uploaded)  			m_result.AddWarning (string.Format ("Expected there to be a temporary fileset for synthetic filelist ({0}' {1})' but none was found?"' lasttempfileid' lasttempfilelist)' null);  	}  	var prevfileset = m_database.FilesetTimes.FirstOrDefault ();  	if (prevfileset.Value.ToUniversalTime () > m_database.OperationTimestamp.ToUniversalTime ())  		throw new UserInformationException (string.Format ("The previous backup has time {0}' but this backup has time {1}. Something is wrong with the clock."' prevfileset.Value.ToLocalTime ()' m_database.OperationTimestamp.ToLocalTime ()));  	m_lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;  	// Rebuild any index files that are missing  	RecreateMissingIndexFiles (backend);  	m_database.BuildLookupTable (m_options);  	m_transaction = m_database.BeginTransaction ();  	var repcnt = 0;  	while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  		filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  	if (m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  		throw new Exception ("Unable to generate a unique fileset name");  	m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.Backup_ProcessingFiles);  	var filesetvolumeid = m_database.RegisterRemoteVolume (filesetvolume.RemoteFilename' RemoteVolumeType.Files' RemoteVolumeState.Temporary' m_transaction);  	m_database.CreateFileset (filesetvolumeid' VolumeBase.ParseFilename (filesetvolume.RemoteFilename).Time' m_transaction);  	RunMainOperation (snapshot' backend);  	//If the scanner is still running for some reason' make sure we kill it now   	if (parallelScanner != null && parallelScanner.IsAlive)  		parallelScanner.Abort ();  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: while (repcnt < 100 && m_database.GetRemoteVolumeID (filesetvolume.RemoteFilename) >= 0)  	filesetvolume.ResetRemoteFilename (m_options' m_database.OperationTimestamp.AddSeconds (repcnt++));  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: if (parallelScanner != null && parallelScanner.IsAlive) {  	parallelScanner.Abort ();  	parallelScanner.Join (500);  	if (parallelScanner.IsAlive)  		m_result.AddWarning ("Failed to terminate filecounter thread"' null);  }  
Magic Number,Duplicati.Library.Main.Operation,BackupHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\BackupHandler.cs,Run,The following statement contains a magic number: parallelScanner.Join (500);  
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: using (var restoredb = new LocalRecreateDatabase (dbparent' m_options))  	using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' restoredb)) {  		restoredb.RepairInProgress = true;  		var volumeIds = new Dictionary<string' long> ();  		var rawlist = backend.List ();  		//First step is to examine the remote storage to see what  		// kind of data we can find  		var remotefiles = (from x in rawlist  		let n = VolumeBase.ParseFilename (x)  		where n != null && n.Prefix == m_options.Prefix  		select n).ToArray ();  		//ToArray() ensures that we do not remote-request it multiple times  		if (remotefiles.Length == 0) {  			if (rawlist.Count == 0)  				throw new UserInformationException ("No files were found at the remote location' perhaps the target url is incorrect?");  			else {  				var tmp = (from x in rawlist  				let n = VolumeBase.ParseFilename (x)  				where n != null  				select n.Prefix).ToArray ();  				var types = tmp.Distinct ().ToArray ();  				if (tmp.Length == 0)  					throw new UserInformationException (string.Format ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count));  				else if (types.Length == 1)  					throw new UserInformationException (string.Format ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]));  				else  					throw new UserInformationException (string.Format ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types)));  			}  		}  		//Then we select the filelist we should work with'  		// and create the filelist table to fit  		IEnumerable<IParsedVolume> filelists = from n in remotefiles  		where n.FileType == RemoteVolumeType.Files  		orderby n.Time descending  		select n;  		if (filelists.Count () <= 0)  			throw new UserInformationException (string.Format ("No filelists found on the remote destination"));  		if (filelistfilter != null)  			filelists = filelistfilter (filelists).Select (x => x.Value).ToArray ();  		if (filelists.Count () <= 0)  			throw new UserInformationException (string.Format ("No filelists"));  		// If we are updating' all files should be accounted for  		foreach (var fl in remotefiles)  			volumeIds [fl.File.Name] = updating ? restoredb.GetRemoteVolumeID (fl.File.Name) : restoredb.RegisterRemoteVolume (fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded);  		var hasUpdatedOptions = false;  		if (updating) {  			Utility.UpdateOptionsFromDb (restoredb' m_options);  			Utility.VerifyParameters (restoredb' m_options);  		}  		//Record all blocksets and files needed  		using (var tr = restoredb.BeginTransaction ()) {  			var filelistWork = (from n in filelists  			orderby n.Time  			select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  			m_result.AddMessage (string.Format ("Rebuild database started' downloading {0} filelists"' filelistWork.Count));  			var progress = 0;  			// Register the files we are working with' if not already updated  			if (updating) {  				foreach (var n in filelists)  					if (volumeIds [n.File.Name] == -1)  						volumeIds [n.File.Name] = restoredb.RegisterRemoteVolume (n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan (0)' tr);  			}  			var isFirstFilelist = true;  			var blocksize = m_options.Blocksize;  			var hashes_pr_block = blocksize / m_options.BlockhashSize;  			foreach (var entry in new AsyncDownloader (filelistWork' backend))  				try {  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  						backend.WaitForComplete (restoredb' null);  						m_result.EndTime = DateTime.UtcNow;  						return;  					}  					progress++;  					if (filelistWork.Count == 1 && m_options.RepairOnlyPaths)  						m_result.OperationProgressUpdater.UpdateProgress (0.5f);  					else  						m_result.OperationProgressUpdater.UpdateProgress (((float)progress / filelistWork.Count ()) * (m_options.RepairOnlyPaths ? 1f : 0.2f));  					using (var tmpfile = entry.TempFile) {  						isFirstFilelist = false;  						if (entry.Hash != null && entry.Size > 0)  							restoredb.UpdateRemoteVolume (entry.Name' RemoteVolumeState.Verified' entry.Size' entry.Hash' tr);  						var parsed = VolumeBase.ParseFilename (entry.Name);  						if (!hasUpdatedOptions && !updating) {  							VolumeReaderBase.UpdateOptionsFromManifest (parsed.CompressionModule' tmpfile' m_options);  							hasUpdatedOptions = true;  							// Recompute the cached sizes  							blocksize = m_options.Blocksize;  							hashes_pr_block = blocksize / m_options.BlockhashSize;  						}  						// Create timestamped operations based on the file timestamp  						var filesetid = restoredb.CreateFileset (volumeIds [entry.Name]' parsed.Time' tr);  						using (var filelistreader = new FilesetVolumeReader (parsed.CompressionModule' tmpfile' m_options))  							foreach (var fe in filelistreader.Files.Where (x => Library.Utility.FilterExpression.Matches (filter' x.Path))) {  								try {  									var expectedmetablocks = (fe.Metasize + blocksize - 1) / blocksize;  									var expectedmetablocklisthashes = (expectedmetablocks + hashes_pr_block - 1) / hashes_pr_block;  									if (expectedmetablocks <= 1)  										expectedmetablocklisthashes = 0;  									if (fe.Type == FilelistEntryType.Folder) {  										var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  										restoredb.AddDirectoryEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  									} else if (fe.Type == FilelistEntryType.File) {  										var expectedblocks = (fe.Size + blocksize - 1) / blocksize;  										var expectedblocklisthashes = (expectedblocks + hashes_pr_block - 1) / hashes_pr_block;  										if (expectedblocks <= 1)  											expectedblocklisthashes = 0;  										var blocksetid = restoredb.AddBlockset (fe.Hash' fe.Size' fe.BlocklistHashes' expectedblocklisthashes' tr);  										var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  										restoredb.AddFileEntry (filesetid' fe.Path' fe.Time' blocksetid' metadataid' tr);  										if (fe.Size <= blocksize) {  											if (!string.IsNullOrWhiteSpace (fe.Blockhash))  												restoredb.AddSmallBlocksetLink (fe.Hash' fe.Blockhash' fe.Blocksize' tr);  											else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  												restoredb.AddSmallBlocksetLink (fe.Hash' fe.Hash' fe.Size' tr);  											else  												m_result.AddWarning (string.Format ("No block hash found for file: {0}"' fe.Path)' null);  										}  									} else if (fe.Type == FilelistEntryType.Symlink) {  										var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  										restoredb.AddSymlinkEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  									} else {  										m_result.AddWarning (string.Format ("Skipping file-entry with unknown type {0}: {1} "' fe.Type' fe.Path)' null);  									}  									if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)) {  										if (!string.IsNullOrWhiteSpace (fe.Metablockhash))  											restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metablockhash' fe.Metasize' tr);  										else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  											restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metahash' fe.Metasize' tr);  										else  											m_result.AddWarning (string.Format ("No block hash found for file metadata: {0}"' fe.Path)' null);  									}  								} catch (Exception ex) {  									m_result.AddWarning (string.Format ("Failed to process file-entry: {0}"' fe.Path)' ex);  								}  							}  					}  				} catch (Exception ex) {  					m_result.AddWarning (string.Format ("Failed to process file: {0}"' entry.Name)' ex);  					if (ex is System.Threading.ThreadAbortException) {  						m_result.EndTime = DateTime.UtcNow;  						throw;  					}  					if (isFirstFilelist && ex is System.Security.Cryptography.CryptographicException) {  						m_result.EndTime = DateTime.UtcNow;  						throw;  					}  				}  			//Make sure we write the config  			if (!updating)  				Utility.VerifyParameters (restoredb' m_options' tr);  			using (new Logging.Timer ("CommitUpdateFilesetFromRemote"))  				tr.Commit ();  		}  		if (!m_options.RepairOnlyPaths) {  			var hashalg = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  			if (hashalg == null)  				throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  			var hashsize = hashalg.HashSize / 8;  			//Grab all index files' and update the block table  			using (var tr = restoredb.BeginTransaction ()) {  				var indexfiles = (from n in remotefiles  				where n.FileType == RemoteVolumeType.Index  				select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  				m_result.AddMessage (string.Format ("Filelists restored' downloading {0} index files"' indexfiles.Count));  				var progress = 0;  				foreach (var sf in new AsyncDownloader (indexfiles' backend))  					try {  						if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  							backend.WaitForComplete (restoredb' null);  							m_result.EndTime = DateTime.UtcNow;  							return;  						}  						progress++;  						m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);  						using (var tmpfile = sf.TempFile) {  							if (sf.Hash != null && sf.Size > 0)  								restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);  							using (var svr = new IndexVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options' hashsize)) {  								foreach (var a in svr.Volumes) {  									var filename = a.Filename;  									var volumeID = restoredb.GetRemoteVolumeID (filename);  									// No such file  									if (volumeID < 0)  										volumeID = ProbeForMatchingFilename (ref filename' restoredb);  									// Still broken' register a missing item  									if (volumeID < 0) {  										var p = VolumeBase.ParseFilename (filename);  										if (p == null)  											throw new Exception (string.Format ("Unable to parse filename: {0}"' filename));  										m_result.AddError (string.Format ("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);  										volumeID = restoredb.RegisterRemoteVolume (filename' p.FileType' RemoteVolumeState.Verified' tr);  									}  									//Add all block/volume mappings  									foreach (var b in a.Blocks)  										restoredb.UpdateBlock (b.Key' b.Value' volumeID' tr);  									restoredb.UpdateRemoteVolume (filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);  									restoredb.AddIndexBlockLink (restoredb.GetRemoteVolumeID (sf.Name)' volumeID' tr);  								}  								//If there are blocklists in the index file' update the blocklists  								foreach (var b in svr.BlockLists)  									restoredb.UpdateBlockset (b.Hash' b.Blocklist' tr);  							}  						}  					} catch (Exception ex) {  						//Not fatal  						m_result.AddWarning (string.Format ("Failed to process index file: {0}"' sf.Name)' ex);  						if (ex is System.Threading.ThreadAbortException) {  							m_result.EndTime = DateTime.UtcNow;  							throw;  						}  					}  				using (new Logging.Timer ("CommitRecreatedDb"))  					tr.Commit ();  				// TODO: In some cases' we can avoid downloading all index files'   				// if we are lucky and pick the right ones  			}  			// We have now grabbed as much information as possible'  			// if we are still missing data' we must now fetch block files  			restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' null);  			//We do this in three passes  			for (var i = 0; i < 3; i++) {  				// Grab the list matching the pass type  				var lst = restoredb.GetMissingBlockListVolumes (i' m_options.Blocksize' hashsize).ToList ();  				if (lst.Count > 0) {  					switch (i) {  					case 0:  						if (m_options.Verbose)  							m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  						else  							m_result.AddMessage (string.Format ("Processing required {0} blocklist volumes"' lst.Count));  						break;  					case 1:  						if (m_options.Verbose)  							m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  						else  							m_result.AddMessage (string.Format ("Probing {0} candidate blocklist volumes"' lst.Count));  						break;  					default:  						if (m_options.Verbose)  							m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  						else  							m_result.AddMessage (string.Format ("Processing all of the {0} volumes for blocklists"' lst.Count));  						break;  					}  				}  				var progress = 0;  				foreach (var sf in new AsyncDownloader (lst' backend))  					using (var tmpfile = sf.TempFile)  						using (var rd = new BlockVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options))  							using (var tr = restoredb.BeginTransaction ()) {  								if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  									backend.WaitForComplete (restoredb' null);  									m_result.EndTime = DateTime.UtcNow;  									return;  								}  								progress++;  								m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));  								var volumeid = restoredb.GetRemoteVolumeID (sf.Name);  								restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);  								// Update the block table so we know about the block/volume map  								foreach (var h in rd.Blocks)  									restoredb.UpdateBlock (h.Key' h.Value' volumeid' tr);  								// Grab all known blocklists from the volume  								foreach (var blocklisthash in restoredb.GetBlockLists (volumeid))  									restoredb.UpdateBlockset (blocklisthash' rd.ReadBlocklist (blocklisthash' hashsize)' tr);  								// Update tables so we know if we are done  								restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' tr);  								using (new Logging.Timer ("CommitRestoredBlocklist"))  									tr.Commit ();  								//At this point we can patch files with data from the block volume  								if (blockprocessor != null)  									blockprocessor (sf.Name' rd);  							}  			}  		}  		backend.WaitForComplete (restoredb' null);  		if (m_options.RepairOnlyPaths) {  			m_result.AddMessage ("Recreate/path-update completed' not running consistency checks");  		} else {  			m_result.AddMessage ("Recreate completed' verifying the database consistency");  			//All done' we must verify that we have all blocklist fully intact  			// if this fails' the db will not be deleted' so it can be used'  			// except to continue a backup  			m_result.EndTime = DateTime.UtcNow;  			using (var lbfdb = new LocalListBrokenFilesDatabase (restoredb)) {  				var broken = lbfdb.GetBrokenFilesets (new DateTime (0)' null' null).Count ();  				if (broken != 0)  					throw new UserInformationException (string.Format ("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files"));  			}  			restoredb.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' true);  			m_result.AddMessage ("Recreate completed' and consistency checks completed' marking database as complete");  			restoredb.RepairInProgress = false;  		}  		m_result.EndTime = DateTime.UtcNow;  	}  
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: using (var restoredb = new LocalRecreateDatabase (dbparent' m_options))  	using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' restoredb)) {  		restoredb.RepairInProgress = true;  		var volumeIds = new Dictionary<string' long> ();  		var rawlist = backend.List ();  		//First step is to examine the remote storage to see what  		// kind of data we can find  		var remotefiles = (from x in rawlist  		let n = VolumeBase.ParseFilename (x)  		where n != null && n.Prefix == m_options.Prefix  		select n).ToArray ();  		//ToArray() ensures that we do not remote-request it multiple times  		if (remotefiles.Length == 0) {  			if (rawlist.Count == 0)  				throw new UserInformationException ("No files were found at the remote location' perhaps the target url is incorrect?");  			else {  				var tmp = (from x in rawlist  				let n = VolumeBase.ParseFilename (x)  				where n != null  				select n.Prefix).ToArray ();  				var types = tmp.Distinct ().ToArray ();  				if (tmp.Length == 0)  					throw new UserInformationException (string.Format ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count));  				else if (types.Length == 1)  					throw new UserInformationException (string.Format ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]));  				else  					throw new UserInformationException (string.Format ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types)));  			}  		}  		//Then we select the filelist we should work with'  		// and create the filelist table to fit  		IEnumerable<IParsedVolume> filelists = from n in remotefiles  		where n.FileType == RemoteVolumeType.Files  		orderby n.Time descending  		select n;  		if (filelists.Count () <= 0)  			throw new UserInformationException (string.Format ("No filelists found on the remote destination"));  		if (filelistfilter != null)  			filelists = filelistfilter (filelists).Select (x => x.Value).ToArray ();  		if (filelists.Count () <= 0)  			throw new UserInformationException (string.Format ("No filelists"));  		// If we are updating' all files should be accounted for  		foreach (var fl in remotefiles)  			volumeIds [fl.File.Name] = updating ? restoredb.GetRemoteVolumeID (fl.File.Name) : restoredb.RegisterRemoteVolume (fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded);  		var hasUpdatedOptions = false;  		if (updating) {  			Utility.UpdateOptionsFromDb (restoredb' m_options);  			Utility.VerifyParameters (restoredb' m_options);  		}  		//Record all blocksets and files needed  		using (var tr = restoredb.BeginTransaction ()) {  			var filelistWork = (from n in filelists  			orderby n.Time  			select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  			m_result.AddMessage (string.Format ("Rebuild database started' downloading {0} filelists"' filelistWork.Count));  			var progress = 0;  			// Register the files we are working with' if not already updated  			if (updating) {  				foreach (var n in filelists)  					if (volumeIds [n.File.Name] == -1)  						volumeIds [n.File.Name] = restoredb.RegisterRemoteVolume (n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan (0)' tr);  			}  			var isFirstFilelist = true;  			var blocksize = m_options.Blocksize;  			var hashes_pr_block = blocksize / m_options.BlockhashSize;  			foreach (var entry in new AsyncDownloader (filelistWork' backend))  				try {  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  						backend.WaitForComplete (restoredb' null);  						m_result.EndTime = DateTime.UtcNow;  						return;  					}  					progress++;  					if (filelistWork.Count == 1 && m_options.RepairOnlyPaths)  						m_result.OperationProgressUpdater.UpdateProgress (0.5f);  					else  						m_result.OperationProgressUpdater.UpdateProgress (((float)progress / filelistWork.Count ()) * (m_options.RepairOnlyPaths ? 1f : 0.2f));  					using (var tmpfile = entry.TempFile) {  						isFirstFilelist = false;  						if (entry.Hash != null && entry.Size > 0)  							restoredb.UpdateRemoteVolume (entry.Name' RemoteVolumeState.Verified' entry.Size' entry.Hash' tr);  						var parsed = VolumeBase.ParseFilename (entry.Name);  						if (!hasUpdatedOptions && !updating) {  							VolumeReaderBase.UpdateOptionsFromManifest (parsed.CompressionModule' tmpfile' m_options);  							hasUpdatedOptions = true;  							// Recompute the cached sizes  							blocksize = m_options.Blocksize;  							hashes_pr_block = blocksize / m_options.BlockhashSize;  						}  						// Create timestamped operations based on the file timestamp  						var filesetid = restoredb.CreateFileset (volumeIds [entry.Name]' parsed.Time' tr);  						using (var filelistreader = new FilesetVolumeReader (parsed.CompressionModule' tmpfile' m_options))  							foreach (var fe in filelistreader.Files.Where (x => Library.Utility.FilterExpression.Matches (filter' x.Path))) {  								try {  									var expectedmetablocks = (fe.Metasize + blocksize - 1) / blocksize;  									var expectedmetablocklisthashes = (expectedmetablocks + hashes_pr_block - 1) / hashes_pr_block;  									if (expectedmetablocks <= 1)  										expectedmetablocklisthashes = 0;  									if (fe.Type == FilelistEntryType.Folder) {  										var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  										restoredb.AddDirectoryEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  									} else if (fe.Type == FilelistEntryType.File) {  										var expectedblocks = (fe.Size + blocksize - 1) / blocksize;  										var expectedblocklisthashes = (expectedblocks + hashes_pr_block - 1) / hashes_pr_block;  										if (expectedblocks <= 1)  											expectedblocklisthashes = 0;  										var blocksetid = restoredb.AddBlockset (fe.Hash' fe.Size' fe.BlocklistHashes' expectedblocklisthashes' tr);  										var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  										restoredb.AddFileEntry (filesetid' fe.Path' fe.Time' blocksetid' metadataid' tr);  										if (fe.Size <= blocksize) {  											if (!string.IsNullOrWhiteSpace (fe.Blockhash))  												restoredb.AddSmallBlocksetLink (fe.Hash' fe.Blockhash' fe.Blocksize' tr);  											else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  												restoredb.AddSmallBlocksetLink (fe.Hash' fe.Hash' fe.Size' tr);  											else  												m_result.AddWarning (string.Format ("No block hash found for file: {0}"' fe.Path)' null);  										}  									} else if (fe.Type == FilelistEntryType.Symlink) {  										var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  										restoredb.AddSymlinkEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  									} else {  										m_result.AddWarning (string.Format ("Skipping file-entry with unknown type {0}: {1} "' fe.Type' fe.Path)' null);  									}  									if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)) {  										if (!string.IsNullOrWhiteSpace (fe.Metablockhash))  											restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metablockhash' fe.Metasize' tr);  										else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  											restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metahash' fe.Metasize' tr);  										else  											m_result.AddWarning (string.Format ("No block hash found for file metadata: {0}"' fe.Path)' null);  									}  								} catch (Exception ex) {  									m_result.AddWarning (string.Format ("Failed to process file-entry: {0}"' fe.Path)' ex);  								}  							}  					}  				} catch (Exception ex) {  					m_result.AddWarning (string.Format ("Failed to process file: {0}"' entry.Name)' ex);  					if (ex is System.Threading.ThreadAbortException) {  						m_result.EndTime = DateTime.UtcNow;  						throw;  					}  					if (isFirstFilelist && ex is System.Security.Cryptography.CryptographicException) {  						m_result.EndTime = DateTime.UtcNow;  						throw;  					}  				}  			//Make sure we write the config  			if (!updating)  				Utility.VerifyParameters (restoredb' m_options' tr);  			using (new Logging.Timer ("CommitUpdateFilesetFromRemote"))  				tr.Commit ();  		}  		if (!m_options.RepairOnlyPaths) {  			var hashalg = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  			if (hashalg == null)  				throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  			var hashsize = hashalg.HashSize / 8;  			//Grab all index files' and update the block table  			using (var tr = restoredb.BeginTransaction ()) {  				var indexfiles = (from n in remotefiles  				where n.FileType == RemoteVolumeType.Index  				select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  				m_result.AddMessage (string.Format ("Filelists restored' downloading {0} index files"' indexfiles.Count));  				var progress = 0;  				foreach (var sf in new AsyncDownloader (indexfiles' backend))  					try {  						if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  							backend.WaitForComplete (restoredb' null);  							m_result.EndTime = DateTime.UtcNow;  							return;  						}  						progress++;  						m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);  						using (var tmpfile = sf.TempFile) {  							if (sf.Hash != null && sf.Size > 0)  								restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);  							using (var svr = new IndexVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options' hashsize)) {  								foreach (var a in svr.Volumes) {  									var filename = a.Filename;  									var volumeID = restoredb.GetRemoteVolumeID (filename);  									// No such file  									if (volumeID < 0)  										volumeID = ProbeForMatchingFilename (ref filename' restoredb);  									// Still broken' register a missing item  									if (volumeID < 0) {  										var p = VolumeBase.ParseFilename (filename);  										if (p == null)  											throw new Exception (string.Format ("Unable to parse filename: {0}"' filename));  										m_result.AddError (string.Format ("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);  										volumeID = restoredb.RegisterRemoteVolume (filename' p.FileType' RemoteVolumeState.Verified' tr);  									}  									//Add all block/volume mappings  									foreach (var b in a.Blocks)  										restoredb.UpdateBlock (b.Key' b.Value' volumeID' tr);  									restoredb.UpdateRemoteVolume (filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);  									restoredb.AddIndexBlockLink (restoredb.GetRemoteVolumeID (sf.Name)' volumeID' tr);  								}  								//If there are blocklists in the index file' update the blocklists  								foreach (var b in svr.BlockLists)  									restoredb.UpdateBlockset (b.Hash' b.Blocklist' tr);  							}  						}  					} catch (Exception ex) {  						//Not fatal  						m_result.AddWarning (string.Format ("Failed to process index file: {0}"' sf.Name)' ex);  						if (ex is System.Threading.ThreadAbortException) {  							m_result.EndTime = DateTime.UtcNow;  							throw;  						}  					}  				using (new Logging.Timer ("CommitRecreatedDb"))  					tr.Commit ();  				// TODO: In some cases' we can avoid downloading all index files'   				// if we are lucky and pick the right ones  			}  			// We have now grabbed as much information as possible'  			// if we are still missing data' we must now fetch block files  			restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' null);  			//We do this in three passes  			for (var i = 0; i < 3; i++) {  				// Grab the list matching the pass type  				var lst = restoredb.GetMissingBlockListVolumes (i' m_options.Blocksize' hashsize).ToList ();  				if (lst.Count > 0) {  					switch (i) {  					case 0:  						if (m_options.Verbose)  							m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  						else  							m_result.AddMessage (string.Format ("Processing required {0} blocklist volumes"' lst.Count));  						break;  					case 1:  						if (m_options.Verbose)  							m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  						else  							m_result.AddMessage (string.Format ("Probing {0} candidate blocklist volumes"' lst.Count));  						break;  					default:  						if (m_options.Verbose)  							m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  						else  							m_result.AddMessage (string.Format ("Processing all of the {0} volumes for blocklists"' lst.Count));  						break;  					}  				}  				var progress = 0;  				foreach (var sf in new AsyncDownloader (lst' backend))  					using (var tmpfile = sf.TempFile)  						using (var rd = new BlockVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options))  							using (var tr = restoredb.BeginTransaction ()) {  								if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  									backend.WaitForComplete (restoredb' null);  									m_result.EndTime = DateTime.UtcNow;  									return;  								}  								progress++;  								m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));  								var volumeid = restoredb.GetRemoteVolumeID (sf.Name);  								restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);  								// Update the block table so we know about the block/volume map  								foreach (var h in rd.Blocks)  									restoredb.UpdateBlock (h.Key' h.Value' volumeid' tr);  								// Grab all known blocklists from the volume  								foreach (var blocklisthash in restoredb.GetBlockLists (volumeid))  									restoredb.UpdateBlockset (blocklisthash' rd.ReadBlocklist (blocklisthash' hashsize)' tr);  								// Update tables so we know if we are done  								restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' tr);  								using (new Logging.Timer ("CommitRestoredBlocklist"))  									tr.Commit ();  								//At this point we can patch files with data from the block volume  								if (blockprocessor != null)  									blockprocessor (sf.Name' rd);  							}  			}  		}  		backend.WaitForComplete (restoredb' null);  		if (m_options.RepairOnlyPaths) {  			m_result.AddMessage ("Recreate/path-update completed' not running consistency checks");  		} else {  			m_result.AddMessage ("Recreate completed' verifying the database consistency");  			//All done' we must verify that we have all blocklist fully intact  			// if this fails' the db will not be deleted' so it can be used'  			// except to continue a backup  			m_result.EndTime = DateTime.UtcNow;  			using (var lbfdb = new LocalListBrokenFilesDatabase (restoredb)) {  				var broken = lbfdb.GetBrokenFilesets (new DateTime (0)' null' null).Count ();  				if (broken != 0)  					throw new UserInformationException (string.Format ("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files"));  			}  			restoredb.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' true);  			m_result.AddMessage ("Recreate completed' and consistency checks completed' marking database as complete");  			restoredb.RepairInProgress = false;  		}  		m_result.EndTime = DateTime.UtcNow;  	}  
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' restoredb)) {  	restoredb.RepairInProgress = true;  	var volumeIds = new Dictionary<string' long> ();  	var rawlist = backend.List ();  	//First step is to examine the remote storage to see what  	// kind of data we can find  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			throw new UserInformationException ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				throw new UserInformationException (string.Format ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count));  			else if (types.Length == 1)  				throw new UserInformationException (string.Format ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]));  			else  				throw new UserInformationException (string.Format ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types)));  		}  	}  	//Then we select the filelist we should work with'  	// and create the filelist table to fit  	IEnumerable<IParsedVolume> filelists = from n in remotefiles  	where n.FileType == RemoteVolumeType.Files  	orderby n.Time descending  	select n;  	if (filelists.Count () <= 0)  		throw new UserInformationException (string.Format ("No filelists found on the remote destination"));  	if (filelistfilter != null)  		filelists = filelistfilter (filelists).Select (x => x.Value).ToArray ();  	if (filelists.Count () <= 0)  		throw new UserInformationException (string.Format ("No filelists"));  	// If we are updating' all files should be accounted for  	foreach (var fl in remotefiles)  		volumeIds [fl.File.Name] = updating ? restoredb.GetRemoteVolumeID (fl.File.Name) : restoredb.RegisterRemoteVolume (fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded);  	var hasUpdatedOptions = false;  	if (updating) {  		Utility.UpdateOptionsFromDb (restoredb' m_options);  		Utility.VerifyParameters (restoredb' m_options);  	}  	//Record all blocksets and files needed  	using (var tr = restoredb.BeginTransaction ()) {  		var filelistWork = (from n in filelists  		orderby n.Time  		select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  		m_result.AddMessage (string.Format ("Rebuild database started' downloading {0} filelists"' filelistWork.Count));  		var progress = 0;  		// Register the files we are working with' if not already updated  		if (updating) {  			foreach (var n in filelists)  				if (volumeIds [n.File.Name] == -1)  					volumeIds [n.File.Name] = restoredb.RegisterRemoteVolume (n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan (0)' tr);  		}  		var isFirstFilelist = true;  		var blocksize = m_options.Blocksize;  		var hashes_pr_block = blocksize / m_options.BlockhashSize;  		foreach (var entry in new AsyncDownloader (filelistWork' backend))  			try {  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  					backend.WaitForComplete (restoredb' null);  					m_result.EndTime = DateTime.UtcNow;  					return;  				}  				progress++;  				if (filelistWork.Count == 1 && m_options.RepairOnlyPaths)  					m_result.OperationProgressUpdater.UpdateProgress (0.5f);  				else  					m_result.OperationProgressUpdater.UpdateProgress (((float)progress / filelistWork.Count ()) * (m_options.RepairOnlyPaths ? 1f : 0.2f));  				using (var tmpfile = entry.TempFile) {  					isFirstFilelist = false;  					if (entry.Hash != null && entry.Size > 0)  						restoredb.UpdateRemoteVolume (entry.Name' RemoteVolumeState.Verified' entry.Size' entry.Hash' tr);  					var parsed = VolumeBase.ParseFilename (entry.Name);  					if (!hasUpdatedOptions && !updating) {  						VolumeReaderBase.UpdateOptionsFromManifest (parsed.CompressionModule' tmpfile' m_options);  						hasUpdatedOptions = true;  						// Recompute the cached sizes  						blocksize = m_options.Blocksize;  						hashes_pr_block = blocksize / m_options.BlockhashSize;  					}  					// Create timestamped operations based on the file timestamp  					var filesetid = restoredb.CreateFileset (volumeIds [entry.Name]' parsed.Time' tr);  					using (var filelistreader = new FilesetVolumeReader (parsed.CompressionModule' tmpfile' m_options))  						foreach (var fe in filelistreader.Files.Where (x => Library.Utility.FilterExpression.Matches (filter' x.Path))) {  							try {  								var expectedmetablocks = (fe.Metasize + blocksize - 1) / blocksize;  								var expectedmetablocklisthashes = (expectedmetablocks + hashes_pr_block - 1) / hashes_pr_block;  								if (expectedmetablocks <= 1)  									expectedmetablocklisthashes = 0;  								if (fe.Type == FilelistEntryType.Folder) {  									var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  									restoredb.AddDirectoryEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  								} else if (fe.Type == FilelistEntryType.File) {  									var expectedblocks = (fe.Size + blocksize - 1) / blocksize;  									var expectedblocklisthashes = (expectedblocks + hashes_pr_block - 1) / hashes_pr_block;  									if (expectedblocks <= 1)  										expectedblocklisthashes = 0;  									var blocksetid = restoredb.AddBlockset (fe.Hash' fe.Size' fe.BlocklistHashes' expectedblocklisthashes' tr);  									var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  									restoredb.AddFileEntry (filesetid' fe.Path' fe.Time' blocksetid' metadataid' tr);  									if (fe.Size <= blocksize) {  										if (!string.IsNullOrWhiteSpace (fe.Blockhash))  											restoredb.AddSmallBlocksetLink (fe.Hash' fe.Blockhash' fe.Blocksize' tr);  										else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  											restoredb.AddSmallBlocksetLink (fe.Hash' fe.Hash' fe.Size' tr);  										else  											m_result.AddWarning (string.Format ("No block hash found for file: {0}"' fe.Path)' null);  									}  								} else if (fe.Type == FilelistEntryType.Symlink) {  									var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  									restoredb.AddSymlinkEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  								} else {  									m_result.AddWarning (string.Format ("Skipping file-entry with unknown type {0}: {1} "' fe.Type' fe.Path)' null);  								}  								if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)) {  									if (!string.IsNullOrWhiteSpace (fe.Metablockhash))  										restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metablockhash' fe.Metasize' tr);  									else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  										restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metahash' fe.Metasize' tr);  									else  										m_result.AddWarning (string.Format ("No block hash found for file metadata: {0}"' fe.Path)' null);  								}  							} catch (Exception ex) {  								m_result.AddWarning (string.Format ("Failed to process file-entry: {0}"' fe.Path)' ex);  							}  						}  				}  			} catch (Exception ex) {  				m_result.AddWarning (string.Format ("Failed to process file: {0}"' entry.Name)' ex);  				if (ex is System.Threading.ThreadAbortException) {  					m_result.EndTime = DateTime.UtcNow;  					throw;  				}  				if (isFirstFilelist && ex is System.Security.Cryptography.CryptographicException) {  					m_result.EndTime = DateTime.UtcNow;  					throw;  				}  			}  		//Make sure we write the config  		if (!updating)  			Utility.VerifyParameters (restoredb' m_options' tr);  		using (new Logging.Timer ("CommitUpdateFilesetFromRemote"))  			tr.Commit ();  	}  	if (!m_options.RepairOnlyPaths) {  		var hashalg = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  		if (hashalg == null)  			throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  		var hashsize = hashalg.HashSize / 8;  		//Grab all index files' and update the block table  		using (var tr = restoredb.BeginTransaction ()) {  			var indexfiles = (from n in remotefiles  			where n.FileType == RemoteVolumeType.Index  			select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  			m_result.AddMessage (string.Format ("Filelists restored' downloading {0} index files"' indexfiles.Count));  			var progress = 0;  			foreach (var sf in new AsyncDownloader (indexfiles' backend))  				try {  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  						backend.WaitForComplete (restoredb' null);  						m_result.EndTime = DateTime.UtcNow;  						return;  					}  					progress++;  					m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);  					using (var tmpfile = sf.TempFile) {  						if (sf.Hash != null && sf.Size > 0)  							restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);  						using (var svr = new IndexVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options' hashsize)) {  							foreach (var a in svr.Volumes) {  								var filename = a.Filename;  								var volumeID = restoredb.GetRemoteVolumeID (filename);  								// No such file  								if (volumeID < 0)  									volumeID = ProbeForMatchingFilename (ref filename' restoredb);  								// Still broken' register a missing item  								if (volumeID < 0) {  									var p = VolumeBase.ParseFilename (filename);  									if (p == null)  										throw new Exception (string.Format ("Unable to parse filename: {0}"' filename));  									m_result.AddError (string.Format ("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);  									volumeID = restoredb.RegisterRemoteVolume (filename' p.FileType' RemoteVolumeState.Verified' tr);  								}  								//Add all block/volume mappings  								foreach (var b in a.Blocks)  									restoredb.UpdateBlock (b.Key' b.Value' volumeID' tr);  								restoredb.UpdateRemoteVolume (filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);  								restoredb.AddIndexBlockLink (restoredb.GetRemoteVolumeID (sf.Name)' volumeID' tr);  							}  							//If there are blocklists in the index file' update the blocklists  							foreach (var b in svr.BlockLists)  								restoredb.UpdateBlockset (b.Hash' b.Blocklist' tr);  						}  					}  				} catch (Exception ex) {  					//Not fatal  					m_result.AddWarning (string.Format ("Failed to process index file: {0}"' sf.Name)' ex);  					if (ex is System.Threading.ThreadAbortException) {  						m_result.EndTime = DateTime.UtcNow;  						throw;  					}  				}  			using (new Logging.Timer ("CommitRecreatedDb"))  				tr.Commit ();  			// TODO: In some cases' we can avoid downloading all index files'   			// if we are lucky and pick the right ones  		}  		// We have now grabbed as much information as possible'  		// if we are still missing data' we must now fetch block files  		restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' null);  		//We do this in three passes  		for (var i = 0; i < 3; i++) {  			// Grab the list matching the pass type  			var lst = restoredb.GetMissingBlockListVolumes (i' m_options.Blocksize' hashsize).ToList ();  			if (lst.Count > 0) {  				switch (i) {  				case 0:  					if (m_options.Verbose)  						m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  					else  						m_result.AddMessage (string.Format ("Processing required {0} blocklist volumes"' lst.Count));  					break;  				case 1:  					if (m_options.Verbose)  						m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  					else  						m_result.AddMessage (string.Format ("Probing {0} candidate blocklist volumes"' lst.Count));  					break;  				default:  					if (m_options.Verbose)  						m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  					else  						m_result.AddMessage (string.Format ("Processing all of the {0} volumes for blocklists"' lst.Count));  					break;  				}  			}  			var progress = 0;  			foreach (var sf in new AsyncDownloader (lst' backend))  				using (var tmpfile = sf.TempFile)  					using (var rd = new BlockVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options))  						using (var tr = restoredb.BeginTransaction ()) {  							if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  								backend.WaitForComplete (restoredb' null);  								m_result.EndTime = DateTime.UtcNow;  								return;  							}  							progress++;  							m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));  							var volumeid = restoredb.GetRemoteVolumeID (sf.Name);  							restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);  							// Update the block table so we know about the block/volume map  							foreach (var h in rd.Blocks)  								restoredb.UpdateBlock (h.Key' h.Value' volumeid' tr);  							// Grab all known blocklists from the volume  							foreach (var blocklisthash in restoredb.GetBlockLists (volumeid))  								restoredb.UpdateBlockset (blocklisthash' rd.ReadBlocklist (blocklisthash' hashsize)' tr);  							// Update tables so we know if we are done  							restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' tr);  							using (new Logging.Timer ("CommitRestoredBlocklist"))  								tr.Commit ();  							//At this point we can patch files with data from the block volume  							if (blockprocessor != null)  								blockprocessor (sf.Name' rd);  						}  		}  	}  	backend.WaitForComplete (restoredb' null);  	if (m_options.RepairOnlyPaths) {  		m_result.AddMessage ("Recreate/path-update completed' not running consistency checks");  	} else {  		m_result.AddMessage ("Recreate completed' verifying the database consistency");  		//All done' we must verify that we have all blocklist fully intact  		// if this fails' the db will not be deleted' so it can be used'  		// except to continue a backup  		m_result.EndTime = DateTime.UtcNow;  		using (var lbfdb = new LocalListBrokenFilesDatabase (restoredb)) {  			var broken = lbfdb.GetBrokenFilesets (new DateTime (0)' null' null).Count ();  			if (broken != 0)  				throw new UserInformationException (string.Format ("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files"));  		}  		restoredb.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' true);  		m_result.AddMessage ("Recreate completed' and consistency checks completed' marking database as complete");  		restoredb.RepairInProgress = false;  	}  	m_result.EndTime = DateTime.UtcNow;  }  
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' restoredb)) {  	restoredb.RepairInProgress = true;  	var volumeIds = new Dictionary<string' long> ();  	var rawlist = backend.List ();  	//First step is to examine the remote storage to see what  	// kind of data we can find  	var remotefiles = (from x in rawlist  	let n = VolumeBase.ParseFilename (x)  	where n != null && n.Prefix == m_options.Prefix  	select n).ToArray ();  	//ToArray() ensures that we do not remote-request it multiple times  	if (remotefiles.Length == 0) {  		if (rawlist.Count == 0)  			throw new UserInformationException ("No files were found at the remote location' perhaps the target url is incorrect?");  		else {  			var tmp = (from x in rawlist  			let n = VolumeBase.ParseFilename (x)  			where n != null  			select n.Prefix).ToArray ();  			var types = tmp.Distinct ().ToArray ();  			if (tmp.Length == 0)  				throw new UserInformationException (string.Format ("Found {0} files at the remote storage' but none that could be parsed"' rawlist.Count));  			else if (types.Length == 1)  				throw new UserInformationException (string.Format ("Found {0} parse-able files with the prefix {1}' did you forget to set the backup-prefix?"' tmp.Length' types [0]));  			else  				throw new UserInformationException (string.Format ("Found {0} parse-able files (of {1} files) with different prefixes: {2}' did you forget to set the backup-prefix?"' tmp.Length' rawlist.Count' string.Join ("' "' types)));  		}  	}  	//Then we select the filelist we should work with'  	// and create the filelist table to fit  	IEnumerable<IParsedVolume> filelists = from n in remotefiles  	where n.FileType == RemoteVolumeType.Files  	orderby n.Time descending  	select n;  	if (filelists.Count () <= 0)  		throw new UserInformationException (string.Format ("No filelists found on the remote destination"));  	if (filelistfilter != null)  		filelists = filelistfilter (filelists).Select (x => x.Value).ToArray ();  	if (filelists.Count () <= 0)  		throw new UserInformationException (string.Format ("No filelists"));  	// If we are updating' all files should be accounted for  	foreach (var fl in remotefiles)  		volumeIds [fl.File.Name] = updating ? restoredb.GetRemoteVolumeID (fl.File.Name) : restoredb.RegisterRemoteVolume (fl.File.Name' fl.FileType' fl.File.Size' RemoteVolumeState.Uploaded);  	var hasUpdatedOptions = false;  	if (updating) {  		Utility.UpdateOptionsFromDb (restoredb' m_options);  		Utility.VerifyParameters (restoredb' m_options);  	}  	//Record all blocksets and files needed  	using (var tr = restoredb.BeginTransaction ()) {  		var filelistWork = (from n in filelists  		orderby n.Time  		select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  		m_result.AddMessage (string.Format ("Rebuild database started' downloading {0} filelists"' filelistWork.Count));  		var progress = 0;  		// Register the files we are working with' if not already updated  		if (updating) {  			foreach (var n in filelists)  				if (volumeIds [n.File.Name] == -1)  					volumeIds [n.File.Name] = restoredb.RegisterRemoteVolume (n.File.Name' n.FileType' RemoteVolumeState.Uploaded' n.File.Size' new TimeSpan (0)' tr);  		}  		var isFirstFilelist = true;  		var blocksize = m_options.Blocksize;  		var hashes_pr_block = blocksize / m_options.BlockhashSize;  		foreach (var entry in new AsyncDownloader (filelistWork' backend))  			try {  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  					backend.WaitForComplete (restoredb' null);  					m_result.EndTime = DateTime.UtcNow;  					return;  				}  				progress++;  				if (filelistWork.Count == 1 && m_options.RepairOnlyPaths)  					m_result.OperationProgressUpdater.UpdateProgress (0.5f);  				else  					m_result.OperationProgressUpdater.UpdateProgress (((float)progress / filelistWork.Count ()) * (m_options.RepairOnlyPaths ? 1f : 0.2f));  				using (var tmpfile = entry.TempFile) {  					isFirstFilelist = false;  					if (entry.Hash != null && entry.Size > 0)  						restoredb.UpdateRemoteVolume (entry.Name' RemoteVolumeState.Verified' entry.Size' entry.Hash' tr);  					var parsed = VolumeBase.ParseFilename (entry.Name);  					if (!hasUpdatedOptions && !updating) {  						VolumeReaderBase.UpdateOptionsFromManifest (parsed.CompressionModule' tmpfile' m_options);  						hasUpdatedOptions = true;  						// Recompute the cached sizes  						blocksize = m_options.Blocksize;  						hashes_pr_block = blocksize / m_options.BlockhashSize;  					}  					// Create timestamped operations based on the file timestamp  					var filesetid = restoredb.CreateFileset (volumeIds [entry.Name]' parsed.Time' tr);  					using (var filelistreader = new FilesetVolumeReader (parsed.CompressionModule' tmpfile' m_options))  						foreach (var fe in filelistreader.Files.Where (x => Library.Utility.FilterExpression.Matches (filter' x.Path))) {  							try {  								var expectedmetablocks = (fe.Metasize + blocksize - 1) / blocksize;  								var expectedmetablocklisthashes = (expectedmetablocks + hashes_pr_block - 1) / hashes_pr_block;  								if (expectedmetablocks <= 1)  									expectedmetablocklisthashes = 0;  								if (fe.Type == FilelistEntryType.Folder) {  									var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  									restoredb.AddDirectoryEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  								} else if (fe.Type == FilelistEntryType.File) {  									var expectedblocks = (fe.Size + blocksize - 1) / blocksize;  									var expectedblocklisthashes = (expectedblocks + hashes_pr_block - 1) / hashes_pr_block;  									if (expectedblocks <= 1)  										expectedblocklisthashes = 0;  									var blocksetid = restoredb.AddBlockset (fe.Hash' fe.Size' fe.BlocklistHashes' expectedblocklisthashes' tr);  									var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  									restoredb.AddFileEntry (filesetid' fe.Path' fe.Time' blocksetid' metadataid' tr);  									if (fe.Size <= blocksize) {  										if (!string.IsNullOrWhiteSpace (fe.Blockhash))  											restoredb.AddSmallBlocksetLink (fe.Hash' fe.Blockhash' fe.Blocksize' tr);  										else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  											restoredb.AddSmallBlocksetLink (fe.Hash' fe.Hash' fe.Size' tr);  										else  											m_result.AddWarning (string.Format ("No block hash found for file: {0}"' fe.Path)' null);  									}  								} else if (fe.Type == FilelistEntryType.Symlink) {  									var metadataid = restoredb.AddMetadataset (fe.Metahash' fe.Metasize' fe.MetaBlocklistHashes' expectedmetablocklisthashes' tr);  									restoredb.AddSymlinkEntry (filesetid' fe.Path' fe.Time' metadataid' tr);  								} else {  									m_result.AddWarning (string.Format ("Skipping file-entry with unknown type {0}: {1} "' fe.Type' fe.Path)' null);  								}  								if (fe.Metasize <= blocksize && (fe.Type == FilelistEntryType.Folder || fe.Type == FilelistEntryType.File || fe.Type == FilelistEntryType.Symlink)) {  									if (!string.IsNullOrWhiteSpace (fe.Metablockhash))  										restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metablockhash' fe.Metasize' tr);  									else if (m_options.BlockHashAlgorithm == m_options.FileHashAlgorithm)  										restoredb.AddSmallBlocksetLink (fe.Metahash' fe.Metahash' fe.Metasize' tr);  									else  										m_result.AddWarning (string.Format ("No block hash found for file metadata: {0}"' fe.Path)' null);  								}  							} catch (Exception ex) {  								m_result.AddWarning (string.Format ("Failed to process file-entry: {0}"' fe.Path)' ex);  							}  						}  				}  			} catch (Exception ex) {  				m_result.AddWarning (string.Format ("Failed to process file: {0}"' entry.Name)' ex);  				if (ex is System.Threading.ThreadAbortException) {  					m_result.EndTime = DateTime.UtcNow;  					throw;  				}  				if (isFirstFilelist && ex is System.Security.Cryptography.CryptographicException) {  					m_result.EndTime = DateTime.UtcNow;  					throw;  				}  			}  		//Make sure we write the config  		if (!updating)  			Utility.VerifyParameters (restoredb' m_options' tr);  		using (new Logging.Timer ("CommitUpdateFilesetFromRemote"))  			tr.Commit ();  	}  	if (!m_options.RepairOnlyPaths) {  		var hashalg = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  		if (hashalg == null)  			throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  		var hashsize = hashalg.HashSize / 8;  		//Grab all index files' and update the block table  		using (var tr = restoredb.BeginTransaction ()) {  			var indexfiles = (from n in remotefiles  			where n.FileType == RemoteVolumeType.Index  			select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  			m_result.AddMessage (string.Format ("Filelists restored' downloading {0} index files"' indexfiles.Count));  			var progress = 0;  			foreach (var sf in new AsyncDownloader (indexfiles' backend))  				try {  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  						backend.WaitForComplete (restoredb' null);  						m_result.EndTime = DateTime.UtcNow;  						return;  					}  					progress++;  					m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);  					using (var tmpfile = sf.TempFile) {  						if (sf.Hash != null && sf.Size > 0)  							restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);  						using (var svr = new IndexVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options' hashsize)) {  							foreach (var a in svr.Volumes) {  								var filename = a.Filename;  								var volumeID = restoredb.GetRemoteVolumeID (filename);  								// No such file  								if (volumeID < 0)  									volumeID = ProbeForMatchingFilename (ref filename' restoredb);  								// Still broken' register a missing item  								if (volumeID < 0) {  									var p = VolumeBase.ParseFilename (filename);  									if (p == null)  										throw new Exception (string.Format ("Unable to parse filename: {0}"' filename));  									m_result.AddError (string.Format ("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);  									volumeID = restoredb.RegisterRemoteVolume (filename' p.FileType' RemoteVolumeState.Verified' tr);  								}  								//Add all block/volume mappings  								foreach (var b in a.Blocks)  									restoredb.UpdateBlock (b.Key' b.Value' volumeID' tr);  								restoredb.UpdateRemoteVolume (filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);  								restoredb.AddIndexBlockLink (restoredb.GetRemoteVolumeID (sf.Name)' volumeID' tr);  							}  							//If there are blocklists in the index file' update the blocklists  							foreach (var b in svr.BlockLists)  								restoredb.UpdateBlockset (b.Hash' b.Blocklist' tr);  						}  					}  				} catch (Exception ex) {  					//Not fatal  					m_result.AddWarning (string.Format ("Failed to process index file: {0}"' sf.Name)' ex);  					if (ex is System.Threading.ThreadAbortException) {  						m_result.EndTime = DateTime.UtcNow;  						throw;  					}  				}  			using (new Logging.Timer ("CommitRecreatedDb"))  				tr.Commit ();  			// TODO: In some cases' we can avoid downloading all index files'   			// if we are lucky and pick the right ones  		}  		// We have now grabbed as much information as possible'  		// if we are still missing data' we must now fetch block files  		restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' null);  		//We do this in three passes  		for (var i = 0; i < 3; i++) {  			// Grab the list matching the pass type  			var lst = restoredb.GetMissingBlockListVolumes (i' m_options.Blocksize' hashsize).ToList ();  			if (lst.Count > 0) {  				switch (i) {  				case 0:  					if (m_options.Verbose)  						m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  					else  						m_result.AddMessage (string.Format ("Processing required {0} blocklist volumes"' lst.Count));  					break;  				case 1:  					if (m_options.Verbose)  						m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  					else  						m_result.AddMessage (string.Format ("Probing {0} candidate blocklist volumes"' lst.Count));  					break;  				default:  					if (m_options.Verbose)  						m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  					else  						m_result.AddMessage (string.Format ("Processing all of the {0} volumes for blocklists"' lst.Count));  					break;  				}  			}  			var progress = 0;  			foreach (var sf in new AsyncDownloader (lst' backend))  				using (var tmpfile = sf.TempFile)  					using (var rd = new BlockVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options))  						using (var tr = restoredb.BeginTransaction ()) {  							if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  								backend.WaitForComplete (restoredb' null);  								m_result.EndTime = DateTime.UtcNow;  								return;  							}  							progress++;  							m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));  							var volumeid = restoredb.GetRemoteVolumeID (sf.Name);  							restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);  							// Update the block table so we know about the block/volume map  							foreach (var h in rd.Blocks)  								restoredb.UpdateBlock (h.Key' h.Value' volumeid' tr);  							// Grab all known blocklists from the volume  							foreach (var blocklisthash in restoredb.GetBlockLists (volumeid))  								restoredb.UpdateBlockset (blocklisthash' rd.ReadBlocklist (blocklisthash' hashsize)' tr);  							// Update tables so we know if we are done  							restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' tr);  							using (new Logging.Timer ("CommitRestoredBlocklist"))  								tr.Commit ();  							//At this point we can patch files with data from the block volume  							if (blockprocessor != null)  								blockprocessor (sf.Name' rd);  						}  		}  	}  	backend.WaitForComplete (restoredb' null);  	if (m_options.RepairOnlyPaths) {  		m_result.AddMessage ("Recreate/path-update completed' not running consistency checks");  	} else {  		m_result.AddMessage ("Recreate completed' verifying the database consistency");  		//All done' we must verify that we have all blocklist fully intact  		// if this fails' the db will not be deleted' so it can be used'  		// except to continue a backup  		m_result.EndTime = DateTime.UtcNow;  		using (var lbfdb = new LocalListBrokenFilesDatabase (restoredb)) {  			var broken = lbfdb.GetBrokenFilesets (new DateTime (0)' null' null).Count ();  			if (broken != 0)  				throw new UserInformationException (string.Format ("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database."' broken' "list-broken-files"' "purge-broken-files"));  		}  		restoredb.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' true);  		m_result.AddMessage ("Recreate completed' and consistency checks completed' marking database as complete");  		restoredb.RepairInProgress = false;  	}  	m_result.EndTime = DateTime.UtcNow;  }  
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: if (!m_options.RepairOnlyPaths) {  	var hashalg = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  	if (hashalg == null)  		throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  	var hashsize = hashalg.HashSize / 8;  	//Grab all index files' and update the block table  	using (var tr = restoredb.BeginTransaction ()) {  		var indexfiles = (from n in remotefiles  		where n.FileType == RemoteVolumeType.Index  		select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  		m_result.AddMessage (string.Format ("Filelists restored' downloading {0} index files"' indexfiles.Count));  		var progress = 0;  		foreach (var sf in new AsyncDownloader (indexfiles' backend))  			try {  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  					backend.WaitForComplete (restoredb' null);  					m_result.EndTime = DateTime.UtcNow;  					return;  				}  				progress++;  				m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);  				using (var tmpfile = sf.TempFile) {  					if (sf.Hash != null && sf.Size > 0)  						restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);  					using (var svr = new IndexVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options' hashsize)) {  						foreach (var a in svr.Volumes) {  							var filename = a.Filename;  							var volumeID = restoredb.GetRemoteVolumeID (filename);  							// No such file  							if (volumeID < 0)  								volumeID = ProbeForMatchingFilename (ref filename' restoredb);  							// Still broken' register a missing item  							if (volumeID < 0) {  								var p = VolumeBase.ParseFilename (filename);  								if (p == null)  									throw new Exception (string.Format ("Unable to parse filename: {0}"' filename));  								m_result.AddError (string.Format ("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);  								volumeID = restoredb.RegisterRemoteVolume (filename' p.FileType' RemoteVolumeState.Verified' tr);  							}  							//Add all block/volume mappings  							foreach (var b in a.Blocks)  								restoredb.UpdateBlock (b.Key' b.Value' volumeID' tr);  							restoredb.UpdateRemoteVolume (filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);  							restoredb.AddIndexBlockLink (restoredb.GetRemoteVolumeID (sf.Name)' volumeID' tr);  						}  						//If there are blocklists in the index file' update the blocklists  						foreach (var b in svr.BlockLists)  							restoredb.UpdateBlockset (b.Hash' b.Blocklist' tr);  					}  				}  			} catch (Exception ex) {  				//Not fatal  				m_result.AddWarning (string.Format ("Failed to process index file: {0}"' sf.Name)' ex);  				if (ex is System.Threading.ThreadAbortException) {  					m_result.EndTime = DateTime.UtcNow;  					throw;  				}  			}  		using (new Logging.Timer ("CommitRecreatedDb"))  			tr.Commit ();  		// TODO: In some cases' we can avoid downloading all index files'   		// if we are lucky and pick the right ones  	}  	// We have now grabbed as much information as possible'  	// if we are still missing data' we must now fetch block files  	restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' null);  	//We do this in three passes  	for (var i = 0; i < 3; i++) {  		// Grab the list matching the pass type  		var lst = restoredb.GetMissingBlockListVolumes (i' m_options.Blocksize' hashsize).ToList ();  		if (lst.Count > 0) {  			switch (i) {  			case 0:  				if (m_options.Verbose)  					m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  				else  					m_result.AddMessage (string.Format ("Processing required {0} blocklist volumes"' lst.Count));  				break;  			case 1:  				if (m_options.Verbose)  					m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  				else  					m_result.AddMessage (string.Format ("Probing {0} candidate blocklist volumes"' lst.Count));  				break;  			default:  				if (m_options.Verbose)  					m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  				else  					m_result.AddMessage (string.Format ("Processing all of the {0} volumes for blocklists"' lst.Count));  				break;  			}  		}  		var progress = 0;  		foreach (var sf in new AsyncDownloader (lst' backend))  			using (var tmpfile = sf.TempFile)  				using (var rd = new BlockVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options))  					using (var tr = restoredb.BeginTransaction ()) {  						if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  							backend.WaitForComplete (restoredb' null);  							m_result.EndTime = DateTime.UtcNow;  							return;  						}  						progress++;  						m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));  						var volumeid = restoredb.GetRemoteVolumeID (sf.Name);  						restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);  						// Update the block table so we know about the block/volume map  						foreach (var h in rd.Blocks)  							restoredb.UpdateBlock (h.Key' h.Value' volumeid' tr);  						// Grab all known blocklists from the volume  						foreach (var blocklisthash in restoredb.GetBlockLists (volumeid))  							restoredb.UpdateBlockset (blocklisthash' rd.ReadBlocklist (blocklisthash' hashsize)' tr);  						// Update tables so we know if we are done  						restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' tr);  						using (new Logging.Timer ("CommitRestoredBlocklist"))  							tr.Commit ();  						//At this point we can patch files with data from the block volume  						if (blockprocessor != null)  							blockprocessor (sf.Name' rd);  					}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: if (!m_options.RepairOnlyPaths) {  	var hashalg = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  	if (hashalg == null)  		throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  	var hashsize = hashalg.HashSize / 8;  	//Grab all index files' and update the block table  	using (var tr = restoredb.BeginTransaction ()) {  		var indexfiles = (from n in remotefiles  		where n.FileType == RemoteVolumeType.Index  		select new RemoteVolume (n.File) as IRemoteVolume).ToList ();  		m_result.AddMessage (string.Format ("Filelists restored' downloading {0} index files"' indexfiles.Count));  		var progress = 0;  		foreach (var sf in new AsyncDownloader (indexfiles' backend))  			try {  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  					backend.WaitForComplete (restoredb' null);  					m_result.EndTime = DateTime.UtcNow;  					return;  				}  				progress++;  				m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / indexfiles.Count) * 0.5f) + 0.2f);  				using (var tmpfile = sf.TempFile) {  					if (sf.Hash != null && sf.Size > 0)  						restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Verified' sf.Size' sf.Hash' tr);  					using (var svr = new IndexVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options' hashsize)) {  						foreach (var a in svr.Volumes) {  							var filename = a.Filename;  							var volumeID = restoredb.GetRemoteVolumeID (filename);  							// No such file  							if (volumeID < 0)  								volumeID = ProbeForMatchingFilename (ref filename' restoredb);  							// Still broken' register a missing item  							if (volumeID < 0) {  								var p = VolumeBase.ParseFilename (filename);  								if (p == null)  									throw new Exception (string.Format ("Unable to parse filename: {0}"' filename));  								m_result.AddError (string.Format ("Remote file referenced as {0}' but not found in list' registering a missing remote file"' filename)' null);  								volumeID = restoredb.RegisterRemoteVolume (filename' p.FileType' RemoteVolumeState.Verified' tr);  							}  							//Add all block/volume mappings  							foreach (var b in a.Blocks)  								restoredb.UpdateBlock (b.Key' b.Value' volumeID' tr);  							restoredb.UpdateRemoteVolume (filename' RemoteVolumeState.Verified' a.Length' a.Hash' tr);  							restoredb.AddIndexBlockLink (restoredb.GetRemoteVolumeID (sf.Name)' volumeID' tr);  						}  						//If there are blocklists in the index file' update the blocklists  						foreach (var b in svr.BlockLists)  							restoredb.UpdateBlockset (b.Hash' b.Blocklist' tr);  					}  				}  			} catch (Exception ex) {  				//Not fatal  				m_result.AddWarning (string.Format ("Failed to process index file: {0}"' sf.Name)' ex);  				if (ex is System.Threading.ThreadAbortException) {  					m_result.EndTime = DateTime.UtcNow;  					throw;  				}  			}  		using (new Logging.Timer ("CommitRecreatedDb"))  			tr.Commit ();  		// TODO: In some cases' we can avoid downloading all index files'   		// if we are lucky and pick the right ones  	}  	// We have now grabbed as much information as possible'  	// if we are still missing data' we must now fetch block files  	restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' null);  	//We do this in three passes  	for (var i = 0; i < 3; i++) {  		// Grab the list matching the pass type  		var lst = restoredb.GetMissingBlockListVolumes (i' m_options.Blocksize' hashsize).ToList ();  		if (lst.Count > 0) {  			switch (i) {  			case 0:  				if (m_options.Verbose)  					m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  				else  					m_result.AddMessage (string.Format ("Processing required {0} blocklist volumes"' lst.Count));  				break;  			case 1:  				if (m_options.Verbose)  					m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  				else  					m_result.AddMessage (string.Format ("Probing {0} candidate blocklist volumes"' lst.Count));  				break;  			default:  				if (m_options.Verbose)  					m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  				else  					m_result.AddMessage (string.Format ("Processing all of the {0} volumes for blocklists"' lst.Count));  				break;  			}  		}  		var progress = 0;  		foreach (var sf in new AsyncDownloader (lst' backend))  			using (var tmpfile = sf.TempFile)  				using (var rd = new BlockVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options))  					using (var tr = restoredb.BeginTransaction ()) {  						if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  							backend.WaitForComplete (restoredb' null);  							m_result.EndTime = DateTime.UtcNow;  							return;  						}  						progress++;  						m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));  						var volumeid = restoredb.GetRemoteVolumeID (sf.Name);  						restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);  						// Update the block table so we know about the block/volume map  						foreach (var h in rd.Blocks)  							restoredb.UpdateBlock (h.Key' h.Value' volumeid' tr);  						// Grab all known blocklists from the volume  						foreach (var blocklisthash in restoredb.GetBlockLists (volumeid))  							restoredb.UpdateBlockset (blocklisthash' rd.ReadBlocklist (blocklisthash' hashsize)' tr);  						// Update tables so we know if we are done  						restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' tr);  						using (new Logging.Timer ("CommitRestoredBlocklist"))  							tr.Commit ();  						//At this point we can patch files with data from the block volume  						if (blockprocessor != null)  							blockprocessor (sf.Name' rd);  					}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,RecreateDatabaseHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RecreateDatabaseHandler.cs,DoRun,The following statement contains a magic number: for (var i = 0; i < 3; i++) {  	// Grab the list matching the pass type  	var lst = restoredb.GetMissingBlockListVolumes (i' m_options.Blocksize' hashsize).ToList ();  	if (lst.Count > 0) {  		switch (i) {  		case 0:  			if (m_options.Verbose)  				m_result.AddVerboseMessage ("Processing required {0} blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  			else  				m_result.AddMessage (string.Format ("Processing required {0} blocklist volumes"' lst.Count));  			break;  		case 1:  			if (m_options.Verbose)  				m_result.AddVerboseMessage ("Probing {0} candidate blocklist volumes: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  			else  				m_result.AddMessage (string.Format ("Probing {0} candidate blocklist volumes"' lst.Count));  			break;  		default:  			if (m_options.Verbose)  				m_result.AddVerboseMessage ("Processing all of the {0} volumes for blocklists: {1}"' lst.Count' string.Join ("' "' lst.Select (x => x.Name)));  			else  				m_result.AddMessage (string.Format ("Processing all of the {0} volumes for blocklists"' lst.Count));  			break;  		}  	}  	var progress = 0;  	foreach (var sf in new AsyncDownloader (lst' backend))  		using (var tmpfile = sf.TempFile)  			using (var rd = new BlockVolumeReader (RestoreHandler.GetCompressionModule (sf.Name)' tmpfile' m_options))  				using (var tr = restoredb.BeginTransaction ()) {  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  						backend.WaitForComplete (restoredb' null);  						m_result.EndTime = DateTime.UtcNow;  						return;  					}  					progress++;  					m_result.OperationProgressUpdater.UpdateProgress ((((float)progress / lst.Count) * 0.1f) + 0.7f + (i * 0.1f));  					var volumeid = restoredb.GetRemoteVolumeID (sf.Name);  					restoredb.UpdateRemoteVolume (sf.Name' RemoteVolumeState.Uploaded' sf.Size' sf.Hash' tr);  					// Update the block table so we know about the block/volume map  					foreach (var h in rd.Blocks)  						restoredb.UpdateBlock (h.Key' h.Value' volumeid' tr);  					// Grab all known blocklists from the volume  					foreach (var blocklisthash in restoredb.GetBlockLists (volumeid))  						restoredb.UpdateBlockset (blocklisthash' rd.ReadBlocklist (blocklisthash' hashsize)' tr);  					// Update tables so we know if we are done  					restoredb.FindMissingBlocklistHashes (hashsize' m_options.Blocksize' tr);  					using (new Logging.Timer ("CommitRestoredBlocklist"))  						tr.Commit ();  					//At this point we can patch files with data from the block volume  					if (blockprocessor != null)  						blockprocessor (sf.Name' rd);  				}  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker ())  	using (var volumekeeper = database.GetMissingBlockData (blocks' options.Blocksize)) {  		foreach (var restorelist in volumekeeper.FilesWithMissingBlocks) {  			var targetpath = restorelist.Path;  			result.AddVerboseMessage ("Patching file with remote data: {0}"' targetpath);  			if (options.Dryrun) {  				result.AddDryrunMessage (string.Format ("Would patch file with remote data: {0}"' targetpath));  			} else {  				try {  					var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  					if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  						result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  						m_systemIO.DirectoryCreate (folderpath);  					}  					// TODO: Much faster if we iterate the volume and checks what blocks are used'  					// because the compressors usually like sequential reading  					using (var file = m_systemIO.FileOpenWrite (targetpath))  						foreach (var targetblock in restorelist.Blocks) {  							file.Position = targetblock.Offset;  							var size = blocks.ReadBlock (targetblock.Key' blockbuffer);  							if (targetblock.Size == size) {  								var valid = !fullblockverification;  								if (!valid) {  									blockhasher.Initialize ();  									var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  									if (targetblock.Key == key)  										valid = true;  									else  										result.AddWarning (string.Format ("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null);  								}  								if (valid) {  									file.Write (blockbuffer' 0' size);  									blockmarker.SetBlockRestored (restorelist.FileID' targetblock.Offset / blocksize' targetblock.Key' size' false);  								}  							} else {  								result.AddWarning (string.Format ("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null);  							}  						}  					if ((++updateCounter) % 20 == 0)  						blockmarker.UpdateProcessed (result.OperationProgressUpdater);  				} catch (Exception ex) {  					result.AddWarning (string.Format ("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex);  				}  			}  		}  		if (!options.SkipMetadata) {  			foreach (var restoremetadata in volumekeeper.MetadataWithMissingBlocks) {  				var targetpath = restoremetadata.Path;  				result.AddVerboseMessage ("Recording metadata from remote data: {0}"' targetpath);  				try {  					// TODO: When we support multi-block metadata this needs to deal with it  					using (var ms = new System.IO.MemoryStream ()) {  						foreach (var targetblock in restoremetadata.Blocks) {  							ms.Position = targetblock.Offset;  							var size = blocks.ReadBlock (targetblock.Key' blockbuffer);  							if (targetblock.Size == size) {  								ms.Write (blockbuffer' 0' size);  								blockmarker.SetBlockRestored (restoremetadata.FileID' targetblock.Offset / blocksize' targetblock.Key' size' true);  							}  						}  						ms.Position = 0;  						metadatastorage.Add (targetpath' ms);  						//blockmarker.RecordMetadata(restoremetadata.FileID' ms);  					}  				} catch (Exception ex) {  					result.AddWarning (string.Format ("Failed to record metadata for file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  				}  			}  		}  		blockmarker.UpdateProcessed (result.OperationProgressUpdater);  		blockmarker.Commit (result);  	}  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The following statement contains a magic number: using (var volumekeeper = database.GetMissingBlockData (blocks' options.Blocksize)) {  	foreach (var restorelist in volumekeeper.FilesWithMissingBlocks) {  		var targetpath = restorelist.Path;  		result.AddVerboseMessage ("Patching file with remote data: {0}"' targetpath);  		if (options.Dryrun) {  			result.AddDryrunMessage (string.Format ("Would patch file with remote data: {0}"' targetpath));  		} else {  			try {  				var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  				if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  					result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  					m_systemIO.DirectoryCreate (folderpath);  				}  				// TODO: Much faster if we iterate the volume and checks what blocks are used'  				// because the compressors usually like sequential reading  				using (var file = m_systemIO.FileOpenWrite (targetpath))  					foreach (var targetblock in restorelist.Blocks) {  						file.Position = targetblock.Offset;  						var size = blocks.ReadBlock (targetblock.Key' blockbuffer);  						if (targetblock.Size == size) {  							var valid = !fullblockverification;  							if (!valid) {  								blockhasher.Initialize ();  								var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  								if (targetblock.Key == key)  									valid = true;  								else  									result.AddWarning (string.Format ("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null);  							}  							if (valid) {  								file.Write (blockbuffer' 0' size);  								blockmarker.SetBlockRestored (restorelist.FileID' targetblock.Offset / blocksize' targetblock.Key' size' false);  							}  						} else {  							result.AddWarning (string.Format ("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null);  						}  					}  				if ((++updateCounter) % 20 == 0)  					blockmarker.UpdateProcessed (result.OperationProgressUpdater);  			} catch (Exception ex) {  				result.AddWarning (string.Format ("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex);  			}  		}  	}  	if (!options.SkipMetadata) {  		foreach (var restoremetadata in volumekeeper.MetadataWithMissingBlocks) {  			var targetpath = restoremetadata.Path;  			result.AddVerboseMessage ("Recording metadata from remote data: {0}"' targetpath);  			try {  				// TODO: When we support multi-block metadata this needs to deal with it  				using (var ms = new System.IO.MemoryStream ()) {  					foreach (var targetblock in restoremetadata.Blocks) {  						ms.Position = targetblock.Offset;  						var size = blocks.ReadBlock (targetblock.Key' blockbuffer);  						if (targetblock.Size == size) {  							ms.Write (blockbuffer' 0' size);  							blockmarker.SetBlockRestored (restoremetadata.FileID' targetblock.Offset / blocksize' targetblock.Key' size' true);  						}  					}  					ms.Position = 0;  					metadatastorage.Add (targetpath' ms);  					//blockmarker.RecordMetadata(restoremetadata.FileID' ms);  				}  			} catch (Exception ex) {  				result.AddWarning (string.Format ("Failed to record metadata for file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  			}  		}  	}  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	blockmarker.Commit (result);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The following statement contains a magic number: foreach (var restorelist in volumekeeper.FilesWithMissingBlocks) {  	var targetpath = restorelist.Path;  	result.AddVerboseMessage ("Patching file with remote data: {0}"' targetpath);  	if (options.Dryrun) {  		result.AddDryrunMessage (string.Format ("Would patch file with remote data: {0}"' targetpath));  	} else {  		try {  			var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  			if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  				result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  				m_systemIO.DirectoryCreate (folderpath);  			}  			// TODO: Much faster if we iterate the volume and checks what blocks are used'  			// because the compressors usually like sequential reading  			using (var file = m_systemIO.FileOpenWrite (targetpath))  				foreach (var targetblock in restorelist.Blocks) {  					file.Position = targetblock.Offset;  					var size = blocks.ReadBlock (targetblock.Key' blockbuffer);  					if (targetblock.Size == size) {  						var valid = !fullblockverification;  						if (!valid) {  							blockhasher.Initialize ();  							var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  							if (targetblock.Key == key)  								valid = true;  							else  								result.AddWarning (string.Format ("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null);  						}  						if (valid) {  							file.Write (blockbuffer' 0' size);  							blockmarker.SetBlockRestored (restorelist.FileID' targetblock.Offset / blocksize' targetblock.Key' size' false);  						}  					} else {  						result.AddWarning (string.Format ("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null);  					}  				}  			if ((++updateCounter) % 20 == 0)  				blockmarker.UpdateProcessed (result.OperationProgressUpdater);  		} catch (Exception ex) {  			result.AddWarning (string.Format ("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex);  		}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The following statement contains a magic number: if (options.Dryrun) {  	result.AddDryrunMessage (string.Format ("Would patch file with remote data: {0}"' targetpath));  } else {  	try {  		var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  		if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  			result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  			m_systemIO.DirectoryCreate (folderpath);  		}  		// TODO: Much faster if we iterate the volume and checks what blocks are used'  		// because the compressors usually like sequential reading  		using (var file = m_systemIO.FileOpenWrite (targetpath))  			foreach (var targetblock in restorelist.Blocks) {  				file.Position = targetblock.Offset;  				var size = blocks.ReadBlock (targetblock.Key' blockbuffer);  				if (targetblock.Size == size) {  					var valid = !fullblockverification;  					if (!valid) {  						blockhasher.Initialize ();  						var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  						if (targetblock.Key == key)  							valid = true;  						else  							result.AddWarning (string.Format ("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null);  					}  					if (valid) {  						file.Write (blockbuffer' 0' size);  						blockmarker.SetBlockRestored (restorelist.FileID' targetblock.Offset / blocksize' targetblock.Key' size' false);  					}  				} else {  					result.AddWarning (string.Format ("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null);  				}  			}  		if ((++updateCounter) % 20 == 0)  			blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	} catch (Exception ex) {  		result.AddWarning (string.Format ("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex);  	}  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The following statement contains a magic number: try {  	var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  	if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  		result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  		m_systemIO.DirectoryCreate (folderpath);  	}  	// TODO: Much faster if we iterate the volume and checks what blocks are used'  	// because the compressors usually like sequential reading  	using (var file = m_systemIO.FileOpenWrite (targetpath))  		foreach (var targetblock in restorelist.Blocks) {  			file.Position = targetblock.Offset;  			var size = blocks.ReadBlock (targetblock.Key' blockbuffer);  			if (targetblock.Size == size) {  				var valid = !fullblockverification;  				if (!valid) {  					blockhasher.Initialize ();  					var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  					if (targetblock.Key == key)  						valid = true;  					else  						result.AddWarning (string.Format ("Invalid block detected for {0}' expected hash: {1}' actual hash: {2}"' targetpath' targetblock.Key' key)' null);  				}  				if (valid) {  					file.Write (blockbuffer' 0' size);  					blockmarker.SetBlockRestored (restorelist.FileID' targetblock.Offset / blocksize' targetblock.Key' size' false);  				}  			} else {  				result.AddWarning (string.Format ("Block with hash {0} should have size {1} but has size {2}"' targetblock.Key' targetblock.Size' size)' null);  			}  		}  	if ((++updateCounter) % 20 == 0)  		blockmarker.UpdateProcessed (result.OperationProgressUpdater);  } catch (Exception ex) {  	result.AddWarning (string.Format ("Failed to patch file: \"{0}\"' message: {1}' message: {1}"' targetpath' ex.Message)' ex);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,PatchWithBlocklist,The following statement contains a magic number: if ((++updateCounter) % 20 == 0)  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker ()) {  	var updateCount = 0L;  	foreach (var entry in database.GetFilesAndSourceBlocksFast (options.Blocksize)) {  		var targetpath = entry.TargetPath;  		var targetfileid = entry.TargetFileID;  		var sourcepath = entry.SourcePath;  		var patched = false;  		try {  			if (m_systemIO.FileExists (sourcepath)) {  				var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  				if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  					result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  					m_systemIO.DirectoryCreate (folderpath);  				}  				using (var targetstream = options.Dryrun ? null : m_systemIO.FileOpenWrite (targetpath)) {  					try {  						using (var sourcestream = m_systemIO.FileOpenRead (sourcepath)) {  							foreach (var block in entry.Blocks) {  								if (result.TaskControlRendevouz () == TaskControlState.Stop)  									return;  								//TODO: Handle metadata  								if (sourcestream.Length > block.Offset) {  									sourcestream.Position = block.Offset;  									var size = sourcestream.Read (blockbuffer' 0' blockbuffer.Length);  									if (size == block.Size) {  										var key = Convert.ToBase64String (hasher.ComputeHash (blockbuffer' 0' size));  										if (key == block.Hash) {  											patched = true;  											if (!options.Dryrun) {  												targetstream.Position = block.Offset;  												targetstream.Write (blockbuffer' 0' size);  											}  											blockmarker.SetBlockRestored (targetfileid' block.Index' key' block.Size' false);  										}  									}  								}  							}  						}  					} catch (Exception ex) {  						result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' sourcepath' ex.Message)' ex);  						if (ex is System.Threading.ThreadAbortException)  							throw;  					}  				}  				if ((++updateCount) % 20 == 0) {  					blockmarker.UpdateProcessed (result.OperationProgressUpdater);  					if (result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  				}  			} else {  				result.AddVerboseMessage ("Local source file not found: {0}"' sourcepath);  			}  		} catch (Exception ex) {  			result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);  			if (ex is System.Threading.ThreadAbortException)  				throw;  		}  		if (patched)  			result.AddVerboseMessage ("Target file is patched with some local data: {0}"' targetpath);  		else  			result.AddVerboseMessage ("Target file is not patched any local data: {0}"' targetpath);  		if (patched && options.Dryrun)  			result.AddDryrunMessage (string.Format ("Would patch file with local data: {0}"' targetpath));  	}  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	blockmarker.Commit (result);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The following statement contains a magic number: foreach (var entry in database.GetFilesAndSourceBlocksFast (options.Blocksize)) {  	var targetpath = entry.TargetPath;  	var targetfileid = entry.TargetFileID;  	var sourcepath = entry.SourcePath;  	var patched = false;  	try {  		if (m_systemIO.FileExists (sourcepath)) {  			var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  			if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  				result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  				m_systemIO.DirectoryCreate (folderpath);  			}  			using (var targetstream = options.Dryrun ? null : m_systemIO.FileOpenWrite (targetpath)) {  				try {  					using (var sourcestream = m_systemIO.FileOpenRead (sourcepath)) {  						foreach (var block in entry.Blocks) {  							if (result.TaskControlRendevouz () == TaskControlState.Stop)  								return;  							//TODO: Handle metadata  							if (sourcestream.Length > block.Offset) {  								sourcestream.Position = block.Offset;  								var size = sourcestream.Read (blockbuffer' 0' blockbuffer.Length);  								if (size == block.Size) {  									var key = Convert.ToBase64String (hasher.ComputeHash (blockbuffer' 0' size));  									if (key == block.Hash) {  										patched = true;  										if (!options.Dryrun) {  											targetstream.Position = block.Offset;  											targetstream.Write (blockbuffer' 0' size);  										}  										blockmarker.SetBlockRestored (targetfileid' block.Index' key' block.Size' false);  									}  								}  							}  						}  					}  				} catch (Exception ex) {  					result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' sourcepath' ex.Message)' ex);  					if (ex is System.Threading.ThreadAbortException)  						throw;  				}  			}  			if ((++updateCount) % 20 == 0) {  				blockmarker.UpdateProcessed (result.OperationProgressUpdater);  				if (result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  			}  		} else {  			result.AddVerboseMessage ("Local source file not found: {0}"' sourcepath);  		}  	} catch (Exception ex) {  		result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);  		if (ex is System.Threading.ThreadAbortException)  			throw;  	}  	if (patched)  		result.AddVerboseMessage ("Target file is patched with some local data: {0}"' targetpath);  	else  		result.AddVerboseMessage ("Target file is not patched any local data: {0}"' targetpath);  	if (patched && options.Dryrun)  		result.AddDryrunMessage (string.Format ("Would patch file with local data: {0}"' targetpath));  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The following statement contains a magic number: try {  	if (m_systemIO.FileExists (sourcepath)) {  		var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  		if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  			result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  			m_systemIO.DirectoryCreate (folderpath);  		}  		using (var targetstream = options.Dryrun ? null : m_systemIO.FileOpenWrite (targetpath)) {  			try {  				using (var sourcestream = m_systemIO.FileOpenRead (sourcepath)) {  					foreach (var block in entry.Blocks) {  						if (result.TaskControlRendevouz () == TaskControlState.Stop)  							return;  						//TODO: Handle metadata  						if (sourcestream.Length > block.Offset) {  							sourcestream.Position = block.Offset;  							var size = sourcestream.Read (blockbuffer' 0' blockbuffer.Length);  							if (size == block.Size) {  								var key = Convert.ToBase64String (hasher.ComputeHash (blockbuffer' 0' size));  								if (key == block.Hash) {  									patched = true;  									if (!options.Dryrun) {  										targetstream.Position = block.Offset;  										targetstream.Write (blockbuffer' 0' size);  									}  									blockmarker.SetBlockRestored (targetfileid' block.Index' key' block.Size' false);  								}  							}  						}  					}  				}  			} catch (Exception ex) {  				result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' sourcepath' ex.Message)' ex);  				if (ex is System.Threading.ThreadAbortException)  					throw;  			}  		}  		if ((++updateCount) % 20 == 0) {  			blockmarker.UpdateProcessed (result.OperationProgressUpdater);  			if (result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  		}  	} else {  		result.AddVerboseMessage ("Local source file not found: {0}"' sourcepath);  	}  } catch (Exception ex) {  	result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);  	if (ex is System.Threading.ThreadAbortException)  		throw;  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The following statement contains a magic number: if (m_systemIO.FileExists (sourcepath)) {  	var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  	if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  		result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  		m_systemIO.DirectoryCreate (folderpath);  	}  	using (var targetstream = options.Dryrun ? null : m_systemIO.FileOpenWrite (targetpath)) {  		try {  			using (var sourcestream = m_systemIO.FileOpenRead (sourcepath)) {  				foreach (var block in entry.Blocks) {  					if (result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  					//TODO: Handle metadata  					if (sourcestream.Length > block.Offset) {  						sourcestream.Position = block.Offset;  						var size = sourcestream.Read (blockbuffer' 0' blockbuffer.Length);  						if (size == block.Size) {  							var key = Convert.ToBase64String (hasher.ComputeHash (blockbuffer' 0' size));  							if (key == block.Hash) {  								patched = true;  								if (!options.Dryrun) {  									targetstream.Position = block.Offset;  									targetstream.Write (blockbuffer' 0' size);  								}  								blockmarker.SetBlockRestored (targetfileid' block.Index' key' block.Size' false);  							}  						}  					}  				}  			}  		} catch (Exception ex) {  			result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' sourcepath' ex.Message)' ex);  			if (ex is System.Threading.ThreadAbortException)  				throw;  		}  	}  	if ((++updateCount) % 20 == 0) {  		blockmarker.UpdateProcessed (result.OperationProgressUpdater);  		if (result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  	}  } else {  	result.AddVerboseMessage ("Local source file not found: {0}"' sourcepath);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocksFast,The following statement contains a magic number: if ((++updateCount) % 20 == 0) {  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	if (result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker ()) {  	var updateCount = 0L;  	foreach (var restorelist in database.GetFilesAndSourceBlocks (options.SkipMetadata' options.Blocksize)) {  		var targetpath = restorelist.TargetPath;  		var targetfileid = restorelist.TargetFileID;  		var patched = false;  		try {  			if (result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  			var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  			if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  				result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  				m_systemIO.DirectoryCreate (folderpath);  			}  			using (var file = options.Dryrun ? null : m_systemIO.FileOpenWrite (targetpath))  				foreach (var targetblock in restorelist.Blocks) {  					foreach (var source in targetblock.Blocksources) {  						try {  							if (result.TaskControlRendevouz () == TaskControlState.Stop)  								return;  							if (m_systemIO.FileExists (source.Path)) {  								if (source.IsMetadata) {  									// TODO: Handle this by reconstructing   									// metadata from file and checking the hash  									continue;  								} else {  									using (var sourcefile = m_systemIO.FileOpenRead (source.Path)) {  										sourcefile.Position = source.Offset;  										var size = sourcefile.Read (blockbuffer' 0' blockbuffer.Length);  										if (size == targetblock.Size) {  											var key = Convert.ToBase64String (hasher.ComputeHash (blockbuffer' 0' size));  											if (key == targetblock.Hash) {  												if (!options.Dryrun) {  													if (targetblock.IsMetadata)  														metadatastorage.Add (targetpath' new System.IO.MemoryStream (blockbuffer' 0' size));  													else {  														file.Position = targetblock.Offset;  														file.Write (blockbuffer' 0' size);  													}  												}  												blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' targetblock.Size' false);  												patched = true;  												break;  											}  										}  									}  								}  							}  						} catch (Exception ex) {  							result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' source.Path' ex.Message)' ex);  							if (ex is System.Threading.ThreadAbortException)  								throw;  						}  					}  				}  			if ((++updateCount) % 20 == 0)  				blockmarker.UpdateProcessed (result.OperationProgressUpdater);  		} catch (Exception ex) {  			result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);  		}  		if (patched)  			result.AddVerboseMessage ("Target file is patched with some local data: {0}"' targetpath);  		else  			result.AddVerboseMessage ("Target file is not patched any local data: {0}"' targetpath);  		if (patched && options.Dryrun)  			result.AddDryrunMessage (string.Format ("Would patch file with local data: {0}"' targetpath));  	}  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	blockmarker.Commit (result);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The following statement contains a magic number: foreach (var restorelist in database.GetFilesAndSourceBlocks (options.SkipMetadata' options.Blocksize)) {  	var targetpath = restorelist.TargetPath;  	var targetfileid = restorelist.TargetFileID;  	var patched = false;  	try {  		if (result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  		var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  		if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  			result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  			m_systemIO.DirectoryCreate (folderpath);  		}  		using (var file = options.Dryrun ? null : m_systemIO.FileOpenWrite (targetpath))  			foreach (var targetblock in restorelist.Blocks) {  				foreach (var source in targetblock.Blocksources) {  					try {  						if (result.TaskControlRendevouz () == TaskControlState.Stop)  							return;  						if (m_systemIO.FileExists (source.Path)) {  							if (source.IsMetadata) {  								// TODO: Handle this by reconstructing   								// metadata from file and checking the hash  								continue;  							} else {  								using (var sourcefile = m_systemIO.FileOpenRead (source.Path)) {  									sourcefile.Position = source.Offset;  									var size = sourcefile.Read (blockbuffer' 0' blockbuffer.Length);  									if (size == targetblock.Size) {  										var key = Convert.ToBase64String (hasher.ComputeHash (blockbuffer' 0' size));  										if (key == targetblock.Hash) {  											if (!options.Dryrun) {  												if (targetblock.IsMetadata)  													metadatastorage.Add (targetpath' new System.IO.MemoryStream (blockbuffer' 0' size));  												else {  													file.Position = targetblock.Offset;  													file.Write (blockbuffer' 0' size);  												}  											}  											blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' targetblock.Size' false);  											patched = true;  											break;  										}  									}  								}  							}  						}  					} catch (Exception ex) {  						result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' source.Path' ex.Message)' ex);  						if (ex is System.Threading.ThreadAbortException)  							throw;  					}  				}  			}  		if ((++updateCount) % 20 == 0)  			blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	} catch (Exception ex) {  		result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);  	}  	if (patched)  		result.AddVerboseMessage ("Target file is patched with some local data: {0}"' targetpath);  	else  		result.AddVerboseMessage ("Target file is not patched any local data: {0}"' targetpath);  	if (patched && options.Dryrun)  		result.AddDryrunMessage (string.Format ("Would patch file with local data: {0}"' targetpath));  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The following statement contains a magic number: try {  	if (result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  	var folderpath = m_systemIO.PathGetDirectoryName (targetpath);  	if (!options.Dryrun && !m_systemIO.DirectoryExists (folderpath)) {  		result.AddWarning (string.Format ("Creating missing folder {0} for  file {1}"' folderpath' targetpath)' null);  		m_systemIO.DirectoryCreate (folderpath);  	}  	using (var file = options.Dryrun ? null : m_systemIO.FileOpenWrite (targetpath))  		foreach (var targetblock in restorelist.Blocks) {  			foreach (var source in targetblock.Blocksources) {  				try {  					if (result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  					if (m_systemIO.FileExists (source.Path)) {  						if (source.IsMetadata) {  							// TODO: Handle this by reconstructing   							// metadata from file and checking the hash  							continue;  						} else {  							using (var sourcefile = m_systemIO.FileOpenRead (source.Path)) {  								sourcefile.Position = source.Offset;  								var size = sourcefile.Read (blockbuffer' 0' blockbuffer.Length);  								if (size == targetblock.Size) {  									var key = Convert.ToBase64String (hasher.ComputeHash (blockbuffer' 0' size));  									if (key == targetblock.Hash) {  										if (!options.Dryrun) {  											if (targetblock.IsMetadata)  												metadatastorage.Add (targetpath' new System.IO.MemoryStream (blockbuffer' 0' size));  											else {  												file.Position = targetblock.Offset;  												file.Write (blockbuffer' 0' size);  											}  										}  										blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' targetblock.Size' false);  										patched = true;  										break;  									}  								}  							}  						}  					}  				} catch (Exception ex) {  					result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with data from local file \"{1}\"' message: {2}"' targetpath' source.Path' ex.Message)' ex);  					if (ex is System.Threading.ThreadAbortException)  						throw;  				}  			}  		}  	if ((++updateCount) % 20 == 0)  		blockmarker.UpdateProcessed (result.OperationProgressUpdater);  } catch (Exception ex) {  	result.AddWarning (string.Format ("Failed to patch file: \"{0}\" with local data' message: {1}"' targetpath' ex.Message)' ex);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingSourceBlocks,The following statement contains a magic number: if ((++updateCount) % 20 == 0)  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker ()) {  	var updateCount = 0L;  	foreach (var restorelist in database.GetExistingFilesWithBlocks ()) {  		var rename = !options.Overwrite;  		var targetpath = restorelist.TargetPath;  		var targetfileid = restorelist.TargetFileID;  		var targetfilehash = restorelist.TargetHash;  		var targetfilelength = restorelist.Length;  		if (m_systemIO.FileExists (targetpath)) {  			try {  				if (result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  				var currentfilelength = m_systemIO.FileLength (targetpath);  				var wasTruncated = false;  				// Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)  				// We do it before scanning for blocks. This allows full verification on files that only needs to   				// be truncated (i.e. forthwritten log files).  				if (!rename && currentfilelength > targetfilelength) {  					var currentAttr = m_systemIO.GetFileAttributes (targetpath);  					if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)// clear readonly attribute  					 {  						if (options.Dryrun)  							result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  						else  							m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  					}  					if (options.Dryrun)  						result.AddDryrunMessage (string.Format ("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));  					else {  						using (var file = m_systemIO.FileOpenWrite (targetpath))  							file.SetLength (targetfilelength);  						currentfilelength = targetfilelength;  					}  					wasTruncated = true;  				}  				// If file size does not match and we have to rename on conflict'   				// the whole scan can be skipped here because all blocks have to be restored anyway.  				// For the other cases' we will check block and and file hashes and look for blocks  				// to be restored and files that can already be verified.  				if (!rename || currentfilelength == targetfilelength) {  					// a file hash for verification will only be necessary if the file has exactly  					// the wanted size so we have a chance to already mark the file as data-verified.  					bool calcFileHash = (currentfilelength == targetfilelength);  					if (calcFileHash)  						filehasher.Initialize ();  					using (var file = m_systemIO.FileOpenRead (targetpath))  						using (var block = new Blockprocessor (file' blockbuffer))  							foreach (var targetblock in restorelist.Blocks) {  								var size = block.Readblock ();  								if (size <= 0)  									break;  								//TODO: Handle Metadata  								bool blockhashmatch = false;  								if (size == targetblock.Size) {  									// Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.  									// Actually' in future always calculate the file hash and mark the file data as already verified.  									System.Threading.Tasks.Task calcFileHashTask = null;  									if (calcFileHash)  										calcFileHashTask = System.Threading.Tasks.Task.Run (() => filehasher.TransformBlock (blockbuffer' 0' size' blockbuffer' 0));  									var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  									if (calcFileHashTask != null)  										calcFileHashTask.Wait ();  									// wait because blockbuffer will be overwritten.  									if (key == targetblock.Hash) {  										blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' size' false);  										blockhashmatch = true;  									}  								}  								if (calcFileHash && !blockhashmatch)// will not be necessary anymore  								 {  									filehasher.TransformFinalBlock (blockbuffer' 0' 0);  									// So a new initialize will not throw  									calcFileHash = false;  									if (rename)  										// file does not match. So break.  										break;  								}  							}  					bool fullfilehashmatch = false;  					if (calcFileHash)// now check if files are identical  					 {  						filehasher.TransformFinalBlock (blockbuffer' 0' 0);  						var filekey = Convert.ToBase64String (filehasher.Hash);  						fullfilehashmatch = (filekey == targetfilehash);  					}  					if (!rename && !fullfilehashmatch && !wasTruncated)// Reset read-only attribute (if set) to overwrite  					 {  						var currentAttr = m_systemIO.GetFileAttributes (targetpath);  						if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) {  							if (options.Dryrun)  								result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  							else  								m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  						}  					}  					if (fullfilehashmatch) {  						//TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.  						blockmarker.SetFileDataVerified (targetfileid);  						result.AddVerboseMessage ("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");  						rename = false;  					} else if (rename) {  						// The new file will have none of the correct blocks'  						// even if the scanned file had some  						blockmarker.SetAllBlocksMissing (targetfileid);  					}  				}  				if ((++updateCount) % 20 == 0) {  					blockmarker.UpdateProcessed (result.OperationProgressUpdater);  					if (result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  				}  			} catch (Exception ex) {  				result.AddWarning (string.Format ("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  				if (ex is System.Threading.ThreadAbortException)  					throw;  			}  		} else {  			result.AddVerboseMessage ("Target file does not exist: {0}"' targetpath);  			rename = false;  		}  		if (rename) {  			//Select a new filename  			var ext = m_systemIO.PathGetExtension (targetpath) ?? "";  			if (!string.IsNullOrEmpty (ext) && !ext.StartsWith ("."))  				ext = "." + ext;  			// First we try with a simple date append' assuming that there are not many conflicts there  			var newname = m_systemIO.PathChangeExtension (targetpath' null) + "." + database.RestoreTime.ToLocalTime ().ToString ("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture);  			var tr = newname + ext;  			var c = 0;  			while (m_systemIO.FileExists (tr) && c < 1000) {  				try {  					// If we have a file with the correct name'   					// it is most likely the file we want  					filehasher.Initialize ();  					string key;  					using (var file = m_systemIO.FileOpenRead (tr))  						key = Convert.ToBase64String (filehasher.ComputeHash (file));  					if (key == targetfilehash) {  						//TODO: Also needs metadata check to make correct decision.  						//      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.  						blockmarker.SetAllBlocksRestored (targetfileid' false);  						blockmarker.SetFileDataVerified (targetfileid);  						break;  					}  				} catch (Exception ex) {  					result.AddWarning (string.Format ("Failed to read candidate restore target {0}"' tr)' ex);  				}  				tr = newname + " (" + (c++).ToString () + ")" + ext;  			}  			newname = tr;  			result.AddVerboseMessage ("Target file exists and will be restored to: {0}"' newname);  			database.UpdateTargetPath (targetfileid' newname);  		}  	}  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	blockmarker.Commit (result);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: using (var blockmarker = database.CreateBlockMarker ()) {  	var updateCount = 0L;  	foreach (var restorelist in database.GetExistingFilesWithBlocks ()) {  		var rename = !options.Overwrite;  		var targetpath = restorelist.TargetPath;  		var targetfileid = restorelist.TargetFileID;  		var targetfilehash = restorelist.TargetHash;  		var targetfilelength = restorelist.Length;  		if (m_systemIO.FileExists (targetpath)) {  			try {  				if (result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  				var currentfilelength = m_systemIO.FileLength (targetpath);  				var wasTruncated = false;  				// Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)  				// We do it before scanning for blocks. This allows full verification on files that only needs to   				// be truncated (i.e. forthwritten log files).  				if (!rename && currentfilelength > targetfilelength) {  					var currentAttr = m_systemIO.GetFileAttributes (targetpath);  					if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)// clear readonly attribute  					 {  						if (options.Dryrun)  							result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  						else  							m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  					}  					if (options.Dryrun)  						result.AddDryrunMessage (string.Format ("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));  					else {  						using (var file = m_systemIO.FileOpenWrite (targetpath))  							file.SetLength (targetfilelength);  						currentfilelength = targetfilelength;  					}  					wasTruncated = true;  				}  				// If file size does not match and we have to rename on conflict'   				// the whole scan can be skipped here because all blocks have to be restored anyway.  				// For the other cases' we will check block and and file hashes and look for blocks  				// to be restored and files that can already be verified.  				if (!rename || currentfilelength == targetfilelength) {  					// a file hash for verification will only be necessary if the file has exactly  					// the wanted size so we have a chance to already mark the file as data-verified.  					bool calcFileHash = (currentfilelength == targetfilelength);  					if (calcFileHash)  						filehasher.Initialize ();  					using (var file = m_systemIO.FileOpenRead (targetpath))  						using (var block = new Blockprocessor (file' blockbuffer))  							foreach (var targetblock in restorelist.Blocks) {  								var size = block.Readblock ();  								if (size <= 0)  									break;  								//TODO: Handle Metadata  								bool blockhashmatch = false;  								if (size == targetblock.Size) {  									// Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.  									// Actually' in future always calculate the file hash and mark the file data as already verified.  									System.Threading.Tasks.Task calcFileHashTask = null;  									if (calcFileHash)  										calcFileHashTask = System.Threading.Tasks.Task.Run (() => filehasher.TransformBlock (blockbuffer' 0' size' blockbuffer' 0));  									var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  									if (calcFileHashTask != null)  										calcFileHashTask.Wait ();  									// wait because blockbuffer will be overwritten.  									if (key == targetblock.Hash) {  										blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' size' false);  										blockhashmatch = true;  									}  								}  								if (calcFileHash && !blockhashmatch)// will not be necessary anymore  								 {  									filehasher.TransformFinalBlock (blockbuffer' 0' 0);  									// So a new initialize will not throw  									calcFileHash = false;  									if (rename)  										// file does not match. So break.  										break;  								}  							}  					bool fullfilehashmatch = false;  					if (calcFileHash)// now check if files are identical  					 {  						filehasher.TransformFinalBlock (blockbuffer' 0' 0);  						var filekey = Convert.ToBase64String (filehasher.Hash);  						fullfilehashmatch = (filekey == targetfilehash);  					}  					if (!rename && !fullfilehashmatch && !wasTruncated)// Reset read-only attribute (if set) to overwrite  					 {  						var currentAttr = m_systemIO.GetFileAttributes (targetpath);  						if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) {  							if (options.Dryrun)  								result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  							else  								m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  						}  					}  					if (fullfilehashmatch) {  						//TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.  						blockmarker.SetFileDataVerified (targetfileid);  						result.AddVerboseMessage ("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");  						rename = false;  					} else if (rename) {  						// The new file will have none of the correct blocks'  						// even if the scanned file had some  						blockmarker.SetAllBlocksMissing (targetfileid);  					}  				}  				if ((++updateCount) % 20 == 0) {  					blockmarker.UpdateProcessed (result.OperationProgressUpdater);  					if (result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  				}  			} catch (Exception ex) {  				result.AddWarning (string.Format ("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  				if (ex is System.Threading.ThreadAbortException)  					throw;  			}  		} else {  			result.AddVerboseMessage ("Target file does not exist: {0}"' targetpath);  			rename = false;  		}  		if (rename) {  			//Select a new filename  			var ext = m_systemIO.PathGetExtension (targetpath) ?? "";  			if (!string.IsNullOrEmpty (ext) && !ext.StartsWith ("."))  				ext = "." + ext;  			// First we try with a simple date append' assuming that there are not many conflicts there  			var newname = m_systemIO.PathChangeExtension (targetpath' null) + "." + database.RestoreTime.ToLocalTime ().ToString ("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture);  			var tr = newname + ext;  			var c = 0;  			while (m_systemIO.FileExists (tr) && c < 1000) {  				try {  					// If we have a file with the correct name'   					// it is most likely the file we want  					filehasher.Initialize ();  					string key;  					using (var file = m_systemIO.FileOpenRead (tr))  						key = Convert.ToBase64String (filehasher.ComputeHash (file));  					if (key == targetfilehash) {  						//TODO: Also needs metadata check to make correct decision.  						//      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.  						blockmarker.SetAllBlocksRestored (targetfileid' false);  						blockmarker.SetFileDataVerified (targetfileid);  						break;  					}  				} catch (Exception ex) {  					result.AddWarning (string.Format ("Failed to read candidate restore target {0}"' tr)' ex);  				}  				tr = newname + " (" + (c++).ToString () + ")" + ext;  			}  			newname = tr;  			result.AddVerboseMessage ("Target file exists and will be restored to: {0}"' newname);  			database.UpdateTargetPath (targetfileid' newname);  		}  	}  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	blockmarker.Commit (result);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: foreach (var restorelist in database.GetExistingFilesWithBlocks ()) {  	var rename = !options.Overwrite;  	var targetpath = restorelist.TargetPath;  	var targetfileid = restorelist.TargetFileID;  	var targetfilehash = restorelist.TargetHash;  	var targetfilelength = restorelist.Length;  	if (m_systemIO.FileExists (targetpath)) {  		try {  			if (result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  			var currentfilelength = m_systemIO.FileLength (targetpath);  			var wasTruncated = false;  			// Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)  			// We do it before scanning for blocks. This allows full verification on files that only needs to   			// be truncated (i.e. forthwritten log files).  			if (!rename && currentfilelength > targetfilelength) {  				var currentAttr = m_systemIO.GetFileAttributes (targetpath);  				if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)// clear readonly attribute  				 {  					if (options.Dryrun)  						result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  					else  						m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  				}  				if (options.Dryrun)  					result.AddDryrunMessage (string.Format ("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));  				else {  					using (var file = m_systemIO.FileOpenWrite (targetpath))  						file.SetLength (targetfilelength);  					currentfilelength = targetfilelength;  				}  				wasTruncated = true;  			}  			// If file size does not match and we have to rename on conflict'   			// the whole scan can be skipped here because all blocks have to be restored anyway.  			// For the other cases' we will check block and and file hashes and look for blocks  			// to be restored and files that can already be verified.  			if (!rename || currentfilelength == targetfilelength) {  				// a file hash for verification will only be necessary if the file has exactly  				// the wanted size so we have a chance to already mark the file as data-verified.  				bool calcFileHash = (currentfilelength == targetfilelength);  				if (calcFileHash)  					filehasher.Initialize ();  				using (var file = m_systemIO.FileOpenRead (targetpath))  					using (var block = new Blockprocessor (file' blockbuffer))  						foreach (var targetblock in restorelist.Blocks) {  							var size = block.Readblock ();  							if (size <= 0)  								break;  							//TODO: Handle Metadata  							bool blockhashmatch = false;  							if (size == targetblock.Size) {  								// Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.  								// Actually' in future always calculate the file hash and mark the file data as already verified.  								System.Threading.Tasks.Task calcFileHashTask = null;  								if (calcFileHash)  									calcFileHashTask = System.Threading.Tasks.Task.Run (() => filehasher.TransformBlock (blockbuffer' 0' size' blockbuffer' 0));  								var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  								if (calcFileHashTask != null)  									calcFileHashTask.Wait ();  								// wait because blockbuffer will be overwritten.  								if (key == targetblock.Hash) {  									blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' size' false);  									blockhashmatch = true;  								}  							}  							if (calcFileHash && !blockhashmatch)// will not be necessary anymore  							 {  								filehasher.TransformFinalBlock (blockbuffer' 0' 0);  								// So a new initialize will not throw  								calcFileHash = false;  								if (rename)  									// file does not match. So break.  									break;  							}  						}  				bool fullfilehashmatch = false;  				if (calcFileHash)// now check if files are identical  				 {  					filehasher.TransformFinalBlock (blockbuffer' 0' 0);  					var filekey = Convert.ToBase64String (filehasher.Hash);  					fullfilehashmatch = (filekey == targetfilehash);  				}  				if (!rename && !fullfilehashmatch && !wasTruncated)// Reset read-only attribute (if set) to overwrite  				 {  					var currentAttr = m_systemIO.GetFileAttributes (targetpath);  					if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) {  						if (options.Dryrun)  							result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  						else  							m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  					}  				}  				if (fullfilehashmatch) {  					//TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.  					blockmarker.SetFileDataVerified (targetfileid);  					result.AddVerboseMessage ("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");  					rename = false;  				} else if (rename) {  					// The new file will have none of the correct blocks'  					// even if the scanned file had some  					blockmarker.SetAllBlocksMissing (targetfileid);  				}  			}  			if ((++updateCount) % 20 == 0) {  				blockmarker.UpdateProcessed (result.OperationProgressUpdater);  				if (result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  			}  		} catch (Exception ex) {  			result.AddWarning (string.Format ("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  			if (ex is System.Threading.ThreadAbortException)  				throw;  		}  	} else {  		result.AddVerboseMessage ("Target file does not exist: {0}"' targetpath);  		rename = false;  	}  	if (rename) {  		//Select a new filename  		var ext = m_systemIO.PathGetExtension (targetpath) ?? "";  		if (!string.IsNullOrEmpty (ext) && !ext.StartsWith ("."))  			ext = "." + ext;  		// First we try with a simple date append' assuming that there are not many conflicts there  		var newname = m_systemIO.PathChangeExtension (targetpath' null) + "." + database.RestoreTime.ToLocalTime ().ToString ("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture);  		var tr = newname + ext;  		var c = 0;  		while (m_systemIO.FileExists (tr) && c < 1000) {  			try {  				// If we have a file with the correct name'   				// it is most likely the file we want  				filehasher.Initialize ();  				string key;  				using (var file = m_systemIO.FileOpenRead (tr))  					key = Convert.ToBase64String (filehasher.ComputeHash (file));  				if (key == targetfilehash) {  					//TODO: Also needs metadata check to make correct decision.  					//      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.  					blockmarker.SetAllBlocksRestored (targetfileid' false);  					blockmarker.SetFileDataVerified (targetfileid);  					break;  				}  			} catch (Exception ex) {  				result.AddWarning (string.Format ("Failed to read candidate restore target {0}"' tr)' ex);  			}  			tr = newname + " (" + (c++).ToString () + ")" + ext;  		}  		newname = tr;  		result.AddVerboseMessage ("Target file exists and will be restored to: {0}"' newname);  		database.UpdateTargetPath (targetfileid' newname);  	}  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: foreach (var restorelist in database.GetExistingFilesWithBlocks ()) {  	var rename = !options.Overwrite;  	var targetpath = restorelist.TargetPath;  	var targetfileid = restorelist.TargetFileID;  	var targetfilehash = restorelist.TargetHash;  	var targetfilelength = restorelist.Length;  	if (m_systemIO.FileExists (targetpath)) {  		try {  			if (result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  			var currentfilelength = m_systemIO.FileLength (targetpath);  			var wasTruncated = false;  			// Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)  			// We do it before scanning for blocks. This allows full verification on files that only needs to   			// be truncated (i.e. forthwritten log files).  			if (!rename && currentfilelength > targetfilelength) {  				var currentAttr = m_systemIO.GetFileAttributes (targetpath);  				if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)// clear readonly attribute  				 {  					if (options.Dryrun)  						result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  					else  						m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  				}  				if (options.Dryrun)  					result.AddDryrunMessage (string.Format ("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));  				else {  					using (var file = m_systemIO.FileOpenWrite (targetpath))  						file.SetLength (targetfilelength);  					currentfilelength = targetfilelength;  				}  				wasTruncated = true;  			}  			// If file size does not match and we have to rename on conflict'   			// the whole scan can be skipped here because all blocks have to be restored anyway.  			// For the other cases' we will check block and and file hashes and look for blocks  			// to be restored and files that can already be verified.  			if (!rename || currentfilelength == targetfilelength) {  				// a file hash for verification will only be necessary if the file has exactly  				// the wanted size so we have a chance to already mark the file as data-verified.  				bool calcFileHash = (currentfilelength == targetfilelength);  				if (calcFileHash)  					filehasher.Initialize ();  				using (var file = m_systemIO.FileOpenRead (targetpath))  					using (var block = new Blockprocessor (file' blockbuffer))  						foreach (var targetblock in restorelist.Blocks) {  							var size = block.Readblock ();  							if (size <= 0)  								break;  							//TODO: Handle Metadata  							bool blockhashmatch = false;  							if (size == targetblock.Size) {  								// Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.  								// Actually' in future always calculate the file hash and mark the file data as already verified.  								System.Threading.Tasks.Task calcFileHashTask = null;  								if (calcFileHash)  									calcFileHashTask = System.Threading.Tasks.Task.Run (() => filehasher.TransformBlock (blockbuffer' 0' size' blockbuffer' 0));  								var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  								if (calcFileHashTask != null)  									calcFileHashTask.Wait ();  								// wait because blockbuffer will be overwritten.  								if (key == targetblock.Hash) {  									blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' size' false);  									blockhashmatch = true;  								}  							}  							if (calcFileHash && !blockhashmatch)// will not be necessary anymore  							 {  								filehasher.TransformFinalBlock (blockbuffer' 0' 0);  								// So a new initialize will not throw  								calcFileHash = false;  								if (rename)  									// file does not match. So break.  									break;  							}  						}  				bool fullfilehashmatch = false;  				if (calcFileHash)// now check if files are identical  				 {  					filehasher.TransformFinalBlock (blockbuffer' 0' 0);  					var filekey = Convert.ToBase64String (filehasher.Hash);  					fullfilehashmatch = (filekey == targetfilehash);  				}  				if (!rename && !fullfilehashmatch && !wasTruncated)// Reset read-only attribute (if set) to overwrite  				 {  					var currentAttr = m_systemIO.GetFileAttributes (targetpath);  					if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) {  						if (options.Dryrun)  							result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  						else  							m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  					}  				}  				if (fullfilehashmatch) {  					//TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.  					blockmarker.SetFileDataVerified (targetfileid);  					result.AddVerboseMessage ("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");  					rename = false;  				} else if (rename) {  					// The new file will have none of the correct blocks'  					// even if the scanned file had some  					blockmarker.SetAllBlocksMissing (targetfileid);  				}  			}  			if ((++updateCount) % 20 == 0) {  				blockmarker.UpdateProcessed (result.OperationProgressUpdater);  				if (result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  			}  		} catch (Exception ex) {  			result.AddWarning (string.Format ("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  			if (ex is System.Threading.ThreadAbortException)  				throw;  		}  	} else {  		result.AddVerboseMessage ("Target file does not exist: {0}"' targetpath);  		rename = false;  	}  	if (rename) {  		//Select a new filename  		var ext = m_systemIO.PathGetExtension (targetpath) ?? "";  		if (!string.IsNullOrEmpty (ext) && !ext.StartsWith ("."))  			ext = "." + ext;  		// First we try with a simple date append' assuming that there are not many conflicts there  		var newname = m_systemIO.PathChangeExtension (targetpath' null) + "." + database.RestoreTime.ToLocalTime ().ToString ("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture);  		var tr = newname + ext;  		var c = 0;  		while (m_systemIO.FileExists (tr) && c < 1000) {  			try {  				// If we have a file with the correct name'   				// it is most likely the file we want  				filehasher.Initialize ();  				string key;  				using (var file = m_systemIO.FileOpenRead (tr))  					key = Convert.ToBase64String (filehasher.ComputeHash (file));  				if (key == targetfilehash) {  					//TODO: Also needs metadata check to make correct decision.  					//      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.  					blockmarker.SetAllBlocksRestored (targetfileid' false);  					blockmarker.SetFileDataVerified (targetfileid);  					break;  				}  			} catch (Exception ex) {  				result.AddWarning (string.Format ("Failed to read candidate restore target {0}"' tr)' ex);  			}  			tr = newname + " (" + (c++).ToString () + ")" + ext;  		}  		newname = tr;  		result.AddVerboseMessage ("Target file exists and will be restored to: {0}"' newname);  		database.UpdateTargetPath (targetfileid' newname);  	}  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: if (m_systemIO.FileExists (targetpath)) {  	try {  		if (result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  		var currentfilelength = m_systemIO.FileLength (targetpath);  		var wasTruncated = false;  		// Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)  		// We do it before scanning for blocks. This allows full verification on files that only needs to   		// be truncated (i.e. forthwritten log files).  		if (!rename && currentfilelength > targetfilelength) {  			var currentAttr = m_systemIO.GetFileAttributes (targetpath);  			if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)// clear readonly attribute  			 {  				if (options.Dryrun)  					result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  				else  					m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  			}  			if (options.Dryrun)  				result.AddDryrunMessage (string.Format ("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));  			else {  				using (var file = m_systemIO.FileOpenWrite (targetpath))  					file.SetLength (targetfilelength);  				currentfilelength = targetfilelength;  			}  			wasTruncated = true;  		}  		// If file size does not match and we have to rename on conflict'   		// the whole scan can be skipped here because all blocks have to be restored anyway.  		// For the other cases' we will check block and and file hashes and look for blocks  		// to be restored and files that can already be verified.  		if (!rename || currentfilelength == targetfilelength) {  			// a file hash for verification will only be necessary if the file has exactly  			// the wanted size so we have a chance to already mark the file as data-verified.  			bool calcFileHash = (currentfilelength == targetfilelength);  			if (calcFileHash)  				filehasher.Initialize ();  			using (var file = m_systemIO.FileOpenRead (targetpath))  				using (var block = new Blockprocessor (file' blockbuffer))  					foreach (var targetblock in restorelist.Blocks) {  						var size = block.Readblock ();  						if (size <= 0)  							break;  						//TODO: Handle Metadata  						bool blockhashmatch = false;  						if (size == targetblock.Size) {  							// Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.  							// Actually' in future always calculate the file hash and mark the file data as already verified.  							System.Threading.Tasks.Task calcFileHashTask = null;  							if (calcFileHash)  								calcFileHashTask = System.Threading.Tasks.Task.Run (() => filehasher.TransformBlock (blockbuffer' 0' size' blockbuffer' 0));  							var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  							if (calcFileHashTask != null)  								calcFileHashTask.Wait ();  							// wait because blockbuffer will be overwritten.  							if (key == targetblock.Hash) {  								blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' size' false);  								blockhashmatch = true;  							}  						}  						if (calcFileHash && !blockhashmatch)// will not be necessary anymore  						 {  							filehasher.TransformFinalBlock (blockbuffer' 0' 0);  							// So a new initialize will not throw  							calcFileHash = false;  							if (rename)  								// file does not match. So break.  								break;  						}  					}  			bool fullfilehashmatch = false;  			if (calcFileHash)// now check if files are identical  			 {  				filehasher.TransformFinalBlock (blockbuffer' 0' 0);  				var filekey = Convert.ToBase64String (filehasher.Hash);  				fullfilehashmatch = (filekey == targetfilehash);  			}  			if (!rename && !fullfilehashmatch && !wasTruncated)// Reset read-only attribute (if set) to overwrite  			 {  				var currentAttr = m_systemIO.GetFileAttributes (targetpath);  				if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) {  					if (options.Dryrun)  						result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  					else  						m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  				}  			}  			if (fullfilehashmatch) {  				//TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.  				blockmarker.SetFileDataVerified (targetfileid);  				result.AddVerboseMessage ("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");  				rename = false;  			} else if (rename) {  				// The new file will have none of the correct blocks'  				// even if the scanned file had some  				blockmarker.SetAllBlocksMissing (targetfileid);  			}  		}  		if ((++updateCount) % 20 == 0) {  			blockmarker.UpdateProcessed (result.OperationProgressUpdater);  			if (result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  		}  	} catch (Exception ex) {  		result.AddWarning (string.Format ("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  		if (ex is System.Threading.ThreadAbortException)  			throw;  	}  } else {  	result.AddVerboseMessage ("Target file does not exist: {0}"' targetpath);  	rename = false;  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: try {  	if (result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  	var currentfilelength = m_systemIO.FileLength (targetpath);  	var wasTruncated = false;  	// Adjust file length in overwrite mode if necessary (smaller is ok' will be extended during restore)  	// We do it before scanning for blocks. This allows full verification on files that only needs to   	// be truncated (i.e. forthwritten log files).  	if (!rename && currentfilelength > targetfilelength) {  		var currentAttr = m_systemIO.GetFileAttributes (targetpath);  		if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0)// clear readonly attribute  		 {  			if (options.Dryrun)  				result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  			else  				m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  		}  		if (options.Dryrun)  			result.AddDryrunMessage (string.Format ("Would truncate file '{0}' to length of {1:N0} bytes"' targetpath' targetfilelength));  		else {  			using (var file = m_systemIO.FileOpenWrite (targetpath))  				file.SetLength (targetfilelength);  			currentfilelength = targetfilelength;  		}  		wasTruncated = true;  	}  	// If file size does not match and we have to rename on conflict'   	// the whole scan can be skipped here because all blocks have to be restored anyway.  	// For the other cases' we will check block and and file hashes and look for blocks  	// to be restored and files that can already be verified.  	if (!rename || currentfilelength == targetfilelength) {  		// a file hash for verification will only be necessary if the file has exactly  		// the wanted size so we have a chance to already mark the file as data-verified.  		bool calcFileHash = (currentfilelength == targetfilelength);  		if (calcFileHash)  			filehasher.Initialize ();  		using (var file = m_systemIO.FileOpenRead (targetpath))  			using (var block = new Blockprocessor (file' blockbuffer))  				foreach (var targetblock in restorelist.Blocks) {  					var size = block.Readblock ();  					if (size <= 0)  						break;  					//TODO: Handle Metadata  					bool blockhashmatch = false;  					if (size == targetblock.Size) {  						// Parallelize file hash calculation on rename. Running read-only on same array should not cause conflicts or races.  						// Actually' in future always calculate the file hash and mark the file data as already verified.  						System.Threading.Tasks.Task calcFileHashTask = null;  						if (calcFileHash)  							calcFileHashTask = System.Threading.Tasks.Task.Run (() => filehasher.TransformBlock (blockbuffer' 0' size' blockbuffer' 0));  						var key = Convert.ToBase64String (blockhasher.ComputeHash (blockbuffer' 0' size));  						if (calcFileHashTask != null)  							calcFileHashTask.Wait ();  						// wait because blockbuffer will be overwritten.  						if (key == targetblock.Hash) {  							blockmarker.SetBlockRestored (targetfileid' targetblock.Index' key' size' false);  							blockhashmatch = true;  						}  					}  					if (calcFileHash && !blockhashmatch)// will not be necessary anymore  					 {  						filehasher.TransformFinalBlock (blockbuffer' 0' 0);  						// So a new initialize will not throw  						calcFileHash = false;  						if (rename)  							// file does not match. So break.  							break;  					}  				}  		bool fullfilehashmatch = false;  		if (calcFileHash)// now check if files are identical  		 {  			filehasher.TransformFinalBlock (blockbuffer' 0' 0);  			var filekey = Convert.ToBase64String (filehasher.Hash);  			fullfilehashmatch = (filekey == targetfilehash);  		}  		if (!rename && !fullfilehashmatch && !wasTruncated)// Reset read-only attribute (if set) to overwrite  		 {  			var currentAttr = m_systemIO.GetFileAttributes (targetpath);  			if ((currentAttr & System.IO.FileAttributes.ReadOnly) != 0) {  				if (options.Dryrun)  					result.AddDryrunMessage (string.Format ("Would reset read-only attribute on file: {0}"' targetpath));  				else  					m_systemIO.SetFileAttributes (targetpath' currentAttr & ~System.IO.FileAttributes.ReadOnly);  			}  		}  		if (fullfilehashmatch) {  			//TODO: Check metadata to trigger rename? If metadata changed' it will still be restored for the file in-place.  			blockmarker.SetFileDataVerified (targetfileid);  			result.AddVerboseMessage ("Target file exists{1} and is correct version: {0}"' targetpath' wasTruncated ? " (but was truncated)" : "");  			rename = false;  		} else if (rename) {  			// The new file will have none of the correct blocks'  			// even if the scanned file had some  			blockmarker.SetAllBlocksMissing (targetfileid);  		}  	}  	if ((++updateCount) % 20 == 0) {  		blockmarker.UpdateProcessed (result.OperationProgressUpdater);  		if (result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  	}  } catch (Exception ex) {  	result.AddWarning (string.Format ("Failed to read target file: \"{0}\"' message: {1}"' targetpath' ex.Message)' ex);  	if (ex is System.Threading.ThreadAbortException)  		throw;  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: if ((++updateCount) % 20 == 0) {  	blockmarker.UpdateProcessed (result.OperationProgressUpdater);  	if (result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: if (rename) {  	//Select a new filename  	var ext = m_systemIO.PathGetExtension (targetpath) ?? "";  	if (!string.IsNullOrEmpty (ext) && !ext.StartsWith ("."))  		ext = "." + ext;  	// First we try with a simple date append' assuming that there are not many conflicts there  	var newname = m_systemIO.PathChangeExtension (targetpath' null) + "." + database.RestoreTime.ToLocalTime ().ToString ("yyyy-MM-dd"' System.Globalization.CultureInfo.InvariantCulture);  	var tr = newname + ext;  	var c = 0;  	while (m_systemIO.FileExists (tr) && c < 1000) {  		try {  			// If we have a file with the correct name'   			// it is most likely the file we want  			filehasher.Initialize ();  			string key;  			using (var file = m_systemIO.FileOpenRead (tr))  				key = Convert.ToBase64String (filehasher.ComputeHash (file));  			if (key == targetfilehash) {  				//TODO: Also needs metadata check to make correct decision.  				//      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.  				blockmarker.SetAllBlocksRestored (targetfileid' false);  				blockmarker.SetFileDataVerified (targetfileid);  				break;  			}  		} catch (Exception ex) {  			result.AddWarning (string.Format ("Failed to read candidate restore target {0}"' tr)' ex);  		}  		tr = newname + " (" + (c++).ToString () + ")" + ext;  	}  	newname = tr;  	result.AddVerboseMessage ("Target file exists and will be restored to: {0}"' newname);  	database.UpdateTargetPath (targetfileid' newname);  }  
Magic Number,Duplicati.Library.Main.Operation,RestoreHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RestoreHandler.cs,ScanForExistingTargetBlocks,The following statement contains a magic number: while (m_systemIO.FileExists (tr) && c < 1000) {  	try {  		// If we have a file with the correct name'   		// it is most likely the file we want  		filehasher.Initialize ();  		string key;  		using (var file = m_systemIO.FileOpenRead (tr))  			key = Convert.ToBase64String (filehasher.ComputeHash (file));  		if (key == targetfilehash) {  			//TODO: Also needs metadata check to make correct decision.  			//      We stick to the policy to restore metadata in place' if data ok. So' metadata block may be restored.  			blockmarker.SetAllBlocksRestored (targetfileid' false);  			blockmarker.SetFileDataVerified (targetfileid);  			break;  		}  	} catch (Exception ex) {  		result.AddWarning (string.Format ("Failed to read candidate restore target {0}"' tr)' ex);  	}  	tr = newname + " (" + (c++).ToString () + ")" + ext;  }  
Magic Number,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,Run,The following statement contains a magic number: if (knownRemotes <= 0) {  	if (m_options.Dryrun) {  		m_result.AddDryrunMessage ("Performing dryrun recreate");  	} else {  		var baseName = System.IO.Path.ChangeExtension (m_options.Dbpath' "backup");  		var i = 0;  		while (System.IO.File.Exists (baseName) && i++ < 1000)  			baseName = System.IO.Path.ChangeExtension (m_options.Dbpath' "backup-" + i.ToString ());  		m_result.AddMessage (string.Format ("Renaming existing db from {0} to {1}"' m_options.Dbpath' baseName));  		System.IO.File.Move (m_options.Dbpath' baseName);  	}  	RunRepairLocal (filter);  	RunRepairCommon ();  } else {  	RunRepairCommon ();  	RunRepairRemote ();  }  
Magic Number,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,Run,The following statement contains a magic number: if (m_options.Dryrun) {  	m_result.AddDryrunMessage ("Performing dryrun recreate");  } else {  	var baseName = System.IO.Path.ChangeExtension (m_options.Dbpath' "backup");  	var i = 0;  	while (System.IO.File.Exists (baseName) && i++ < 1000)  		baseName = System.IO.Path.ChangeExtension (m_options.Dbpath' "backup-" + i.ToString ());  	m_result.AddMessage (string.Format ("Renaming existing db from {0} to {1}"' m_options.Dbpath' baseName));  	System.IO.File.Move (m_options.Dbpath' baseName);  }  
Magic Number,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,Run,The following statement contains a magic number: while (System.IO.File.Exists (baseName) && i++ < 1000)  	baseName = System.IO.Path.ChangeExtension (m_options.Dbpath' "backup-" + i.ToString ());  
Magic Number,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The following statement contains a magic number: using (var db = new LocalRepairDatabase (m_options.Dbpath))  	using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db)) {  		m_result.SetDatabase (db);  		Utility.UpdateOptionsFromDb (db' m_options);  		Utility.VerifyParameters (db' m_options);  		if (db.PartiallyRecreated)  			throw new UserInformationException ("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");  		if (db.RepairInProgress)  			throw new UserInformationException ("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");  		var tp = FilelistProcessor.RemoteListAnalysis (backend' m_options' db' m_result.BackendWriter' null);  		var buffer = new byte[m_options.Blocksize];  		var blockhasher = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  		var hashsize = blockhasher.HashSize / 8;  		if (blockhasher == null)  			throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  		if (!blockhasher.CanReuseTransform)  			throw new UserInformationException (Strings.Common.InvalidCryptoSystem (m_options.BlockHashAlgorithm));  		var progress = 0;  		var targetProgess = tp.ExtraVolumes.Count () + tp.MissingVolumes.Count () + tp.VerificationRequiredVolumes.Count ();  		if (m_options.Dryrun) {  			if (tp.ParsedVolumes.Count () == 0 && tp.OtherVolumes.Count () > 0) {  				if (tp.BackupPrefixes.Length == 1)  					throw new UserInformationException (string.Format ("Found no backup files with prefix {0}' but files with prefix {1}' did you forget to set the backup-prefix?"' m_options.Prefix' tp.BackupPrefixes [0]));  				else  					throw new UserInformationException (string.Format ("Found no backup files with prefix {0}' but files with prefixes {1}' did you forget to set the backup-prefix?"' m_options.Prefix' string.Join ("' "' tp.BackupPrefixes)));  			} else if (tp.ParsedVolumes.Count () == 0 && tp.ExtraVolumes.Count () > 0) {  				throw new UserInformationException (string.Format ("No files were missing' but {0} remote files were' found' did you mean to run recreate-database?"' tp.ExtraVolumes.Count ()));  			}  		}  		if (tp.ExtraVolumes.Count () > 0 || tp.MissingVolumes.Count () > 0 || tp.VerificationRequiredVolumes.Count () > 0) {  			if (tp.VerificationRequiredVolumes.Any ()) {  				using (var testdb = new LocalTestDatabase (db)) {  					foreach (var n in tp.VerificationRequiredVolumes)  						try {  							if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  								backend.WaitForComplete (db' null);  								return;  							}  							progress++;  							m_result.OperationProgressUpdater.UpdateProgress ((float)progress / targetProgess);  							long size;  							string hash;  							KeyValuePair<string' IEnumerable<KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>>> res;  							using (var tf = backend.GetWithInfo (n.Name' out size' out hash))  								res = TestHandler.TestVolumeInternals (testdb' n' tf' m_options' m_result' 1);  							if (res.Value.Any ())  								throw new Exception (string.Format ("Remote verification failure: {0}"' res.Value.First ()));  							if (!m_options.Dryrun) {  								m_result.AddMessage (string.Format ("Sucessfully captured hash for {0}' updating database"' n.Name));  								db.UpdateRemoteVolume (n.Name' RemoteVolumeState.Verified' size' hash);  							}  						} catch (Exception ex) {  							m_result.AddError (string.Format ("Failed to perform verification for file: {0}' please run verify; message: {1}"' n.Name' ex.Message)' ex);  							if (ex is System.Threading.ThreadAbortException)  								throw;  						}  				}  			}  			// TODO: It is actually possible to use the extra files if we parse them  			foreach (var n in tp.ExtraVolumes)  				try {  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  						backend.WaitForComplete (db' null);  						return;  					}  					progress++;  					m_result.OperationProgressUpdater.UpdateProgress ((float)progress / targetProgess);  					// If this is a new index file' we can accept it if it matches our local data  					// This makes it possible to augment the remote store with new index data  					if (n.FileType == RemoteVolumeType.Index && m_options.IndexfilePolicy != Options.IndexFileStrategy.None) {  						try {  							string hash;  							long size;  							using (var tf = backend.GetWithInfo (n.File.Name' out size' out hash))  								using (var ifr = new IndexVolumeReader (n.CompressionModule' tf' m_options' m_options.BlockhashSize)) {  									foreach (var rv in ifr.Volumes) {  										string cmphash;  										long cmpsize;  										RemoteVolumeType cmptype;  										RemoteVolumeState cmpstate;  										if (!db.GetRemoteVolume (rv.Filename' out cmphash' out cmpsize' out cmptype' out cmpstate))  											throw new Exception (string.Format ("Unknown remote file {0} detected"' rv.Filename));  										if (!new[] {  											RemoteVolumeState.Uploading'  											RemoteVolumeState.Uploaded'  											RemoteVolumeState.Verified  										}.Contains (cmpstate))  											throw new Exception (string.Format ("Volume {0} has local state {1}"' rv.Filename' cmpstate));  										if (cmphash != rv.Hash || cmpsize != rv.Length || !new[] {  											RemoteVolumeState.Uploading'  											RemoteVolumeState.Uploaded'  											RemoteVolumeState.Verified  										}.Contains (cmpstate))  											throw new Exception (string.Format ("Volume {0} hash/size mismatch ({1} - {2}) vs ({3} - {4})"' rv.Filename' cmphash' cmpsize' rv.Hash' rv.Length));  										db.CheckAllBlocksAreInVolume (rv.Filename' rv.Blocks);  									}  									var blocksize = m_options.Blocksize;  									foreach (var ixb in ifr.BlockLists)  										db.CheckBlocklistCorrect (ixb.Hash' ixb.Length' ixb.Blocklist' blocksize' hashsize);  									var selfid = db.GetRemoteVolumeID (n.File.Name);  									foreach (var rv in ifr.Volumes)  										db.AddIndexBlockLink (selfid' db.GetRemoteVolumeID (rv.Filename)' null);  								}  							// All checks fine' we accept the new index file  							m_result.AddMessage (string.Format ("Accepting new index file {0}"' n.File.Name));  							db.RegisterRemoteVolume (n.File.Name' RemoteVolumeType.Index' size' RemoteVolumeState.Uploading);  							db.UpdateRemoteVolume (n.File.Name' RemoteVolumeState.Verified' size' hash);  							continue;  						} catch (Exception rex) {  							m_result.AddError (string.Format ("Failed to accept new index file: {0}' message: {1}"' n.File.Name' rex.Message)' rex);  						}  					}  					if (!m_options.Dryrun) {  						db.RegisterRemoteVolume (n.File.Name' n.FileType' n.File.Size' RemoteVolumeState.Deleting);  						backend.Delete (n.File.Name' n.File.Size);  					} else  						m_result.AddDryrunMessage (string.Format ("would delete file {0}"' n.File.Name));  				} catch (Exception ex) {  					m_result.AddError (string.Format ("Failed to perform cleanup for extra file: {0}' message: {1}"' n.File.Name' ex.Message)' ex);  					if (ex is System.Threading.ThreadAbortException)  						throw;  				}  			foreach (var n in tp.MissingVolumes) {  				IDisposable newEntry = null;  				try {  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  						backend.WaitForComplete (db' null);  						return;  					}  					progress++;  					m_result.OperationProgressUpdater.UpdateProgress ((float)progress / targetProgess);  					if (n.Type == RemoteVolumeType.Files) {  						var filesetId = db.GetFilesetIdFromRemotename (n.Name);  						var w = new FilesetVolumeWriter (m_options' DateTime.UtcNow);  						newEntry = w;  						w.SetRemoteFilename (n.Name);  						db.WriteFileset (w' null' filesetId);  						w.Close ();  						if (m_options.Dryrun)  							m_result.AddDryrunMessage (string.Format ("would re-upload fileset {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size)));  						else {  							db.UpdateRemoteVolume (w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);  							backend.Put (w);  						}  					} else if (n.Type == RemoteVolumeType.Index) {  						var w = new IndexVolumeWriter (m_options);  						newEntry = w;  						w.SetRemoteFilename (n.Name);  						var h = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  						foreach (var blockvolume in db.GetBlockVolumesFromIndexName (n.Name)) {  							w.StartVolume (blockvolume.Name);  							var volumeid = db.GetRemoteVolumeID (blockvolume.Name);  							foreach (var b in db.GetBlocks (volumeid))  								w.AddBlock (b.Hash' b.Size);  							w.FinishVolume (blockvolume.Hash' blockvolume.Size);  							if (m_options.IndexfilePolicy == Options.IndexFileStrategy.Full)  								foreach (var b in db.GetBlocklists (volumeid' m_options.Blocksize' hashsize)) {  									var bh = Convert.ToBase64String (h.ComputeHash (b.Item2' 0' b.Item3));  									if (bh != b.Item1)  										throw new Exception (string.Format ("Internal consistency check failed' generated index block has wrong hash' {0} vs {1}"' bh' b.Item1));  									w.WriteBlocklist (b.Item1' b.Item2' 0' b.Item3);  								}  						}  						w.Close ();  						if (m_options.Dryrun)  							m_result.AddDryrunMessage (string.Format ("would re-upload index file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size)));  						else {  							db.UpdateRemoteVolume (w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);  							backend.Put (w);  						}  					} else if (n.Type == RemoteVolumeType.Blocks) {  						var w = new BlockVolumeWriter (m_options);  						newEntry = w;  						w.SetRemoteFilename (n.Name);  						using (var mbl = db.CreateBlockList (n.Name)) {  							//First we grab all known blocks from local files  							foreach (var block in mbl.GetSourceFilesWithBlocks (m_options.Blocksize)) {  								var hash = block.Hash;  								var size = (int)block.Size;  								foreach (var source in block.Sources) {  									var file = source.File;  									var offset = source.Offset;  									try {  										if (System.IO.File.Exists (file))  											using (var f = System.IO.File.OpenRead (file)) {  												f.Position = offset;  												if (size == Library.Utility.Utility.ForceStreamRead (f' buffer' size)) {  													var newhash = Convert.ToBase64String (blockhasher.ComputeHash (buffer' 0' size));  													if (newhash == hash) {  														if (mbl.SetBlockRestored (hash' size))  															w.AddBlock (hash' buffer' 0' size' Duplicati.Library.Interface.CompressionHint.Default);  														break;  													}  												}  											}  									} catch (Exception ex) {  										m_result.AddError (string.Format ("Failed to access file: {0}"' file)' ex);  									}  								}  							}  							//Then we grab all remote volumes that have the missing blocks  							foreach (var vol in new AsyncDownloader (mbl.GetMissingBlockSources ().ToList ()' backend)) {  								try {  									using (var tmpfile = vol.TempFile)  										using (var f = new BlockVolumeReader (RestoreHandler.GetCompressionModule (vol.Name)' tmpfile' m_options))  											foreach (var b in f.Blocks)  												if (mbl.SetBlockRestored (b.Key' b.Value))  													if (f.ReadBlock (b.Key' buffer) == b.Value)  														w.AddBlock (b.Key' buffer' 0' (int)b.Value' Duplicati.Library.Interface.CompressionHint.Default);  								} catch (Exception ex) {  									m_result.AddError (string.Format ("Failed to access remote file: {0}"' vol.Name)' ex);  								}  							}  							// If we managed to recover all blocks' NICE!  							var missingBlocks = mbl.GetMissingBlocks ().Count ();  							if (missingBlocks > 0) {  								m_result.AddMessage (string.Format ("Repair cannot acquire {0} required blocks for volume {1}' which are required by the following filesets: "' missingBlocks' n.Name));  								foreach (var f in mbl.GetFilesetsUsingMissingBlocks ())  									m_result.AddMessage (f.Name);  								var recoverymsg = string.Format ("If you want to continue working with the database' you can use the \"{0}\" and \"{1}\" commands to purge the missing data from the database and the remote storage."' "list-broken-files"' "purge-broken-files");  								if (!m_options.Dryrun) {  									m_result.AddMessage ("This may be fixed by deleting the filesets and running repair again");  									throw new UserInformationException (string.Format ("Repair not possible' missing {0} blocks.\n" + recoverymsg' missingBlocks));  								} else {  									m_result.AddMessage (recoverymsg);  								}  							} else {  								if (m_options.Dryrun)  									m_result.AddDryrunMessage (string.Format ("would re-upload block file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size)));  								else {  									db.UpdateRemoteVolume (w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);  									backend.Put (w);  								}  							}  						}  					}  				} catch (Exception ex) {  					if (newEntry != null)  						try {  							newEntry.Dispose ();  						} catch {  						} finally {  							newEntry = null;  						}  					m_result.AddError (string.Format ("Failed to perform cleanup for missing file: {0}' message: {1}"' n.Name' ex.Message)' ex);  					if (ex is System.Threading.ThreadAbortException)  						throw;  				}  			}  		} else {  			m_result.AddMessage ("Destination and database are synchronized' not making any changes");  		}  		m_result.OperationProgressUpdater.UpdateProgress (1);  		backend.WaitForComplete (db' null);  		db.WriteResults ();  	}  
Magic Number,Duplicati.Library.Main.Operation,RepairHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\RepairHandler.cs,RunRepairRemote,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db)) {  	m_result.SetDatabase (db);  	Utility.UpdateOptionsFromDb (db' m_options);  	Utility.VerifyParameters (db' m_options);  	if (db.PartiallyRecreated)  		throw new UserInformationException ("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");  	if (db.RepairInProgress)  		throw new UserInformationException ("The database was attempted repaired' but the repair did not complete. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.");  	var tp = FilelistProcessor.RemoteListAnalysis (backend' m_options' db' m_result.BackendWriter' null);  	var buffer = new byte[m_options.Blocksize];  	var blockhasher = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  	var hashsize = blockhasher.HashSize / 8;  	if (blockhasher == null)  		throw new UserInformationException (Strings.Common.InvalidHashAlgorithm (m_options.BlockHashAlgorithm));  	if (!blockhasher.CanReuseTransform)  		throw new UserInformationException (Strings.Common.InvalidCryptoSystem (m_options.BlockHashAlgorithm));  	var progress = 0;  	var targetProgess = tp.ExtraVolumes.Count () + tp.MissingVolumes.Count () + tp.VerificationRequiredVolumes.Count ();  	if (m_options.Dryrun) {  		if (tp.ParsedVolumes.Count () == 0 && tp.OtherVolumes.Count () > 0) {  			if (tp.BackupPrefixes.Length == 1)  				throw new UserInformationException (string.Format ("Found no backup files with prefix {0}' but files with prefix {1}' did you forget to set the backup-prefix?"' m_options.Prefix' tp.BackupPrefixes [0]));  			else  				throw new UserInformationException (string.Format ("Found no backup files with prefix {0}' but files with prefixes {1}' did you forget to set the backup-prefix?"' m_options.Prefix' string.Join ("' "' tp.BackupPrefixes)));  		} else if (tp.ParsedVolumes.Count () == 0 && tp.ExtraVolumes.Count () > 0) {  			throw new UserInformationException (string.Format ("No files were missing' but {0} remote files were' found' did you mean to run recreate-database?"' tp.ExtraVolumes.Count ()));  		}  	}  	if (tp.ExtraVolumes.Count () > 0 || tp.MissingVolumes.Count () > 0 || tp.VerificationRequiredVolumes.Count () > 0) {  		if (tp.VerificationRequiredVolumes.Any ()) {  			using (var testdb = new LocalTestDatabase (db)) {  				foreach (var n in tp.VerificationRequiredVolumes)  					try {  						if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  							backend.WaitForComplete (db' null);  							return;  						}  						progress++;  						m_result.OperationProgressUpdater.UpdateProgress ((float)progress / targetProgess);  						long size;  						string hash;  						KeyValuePair<string' IEnumerable<KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>>> res;  						using (var tf = backend.GetWithInfo (n.Name' out size' out hash))  							res = TestHandler.TestVolumeInternals (testdb' n' tf' m_options' m_result' 1);  						if (res.Value.Any ())  							throw new Exception (string.Format ("Remote verification failure: {0}"' res.Value.First ()));  						if (!m_options.Dryrun) {  							m_result.AddMessage (string.Format ("Sucessfully captured hash for {0}' updating database"' n.Name));  							db.UpdateRemoteVolume (n.Name' RemoteVolumeState.Verified' size' hash);  						}  					} catch (Exception ex) {  						m_result.AddError (string.Format ("Failed to perform verification for file: {0}' please run verify; message: {1}"' n.Name' ex.Message)' ex);  						if (ex is System.Threading.ThreadAbortException)  							throw;  					}  			}  		}  		// TODO: It is actually possible to use the extra files if we parse them  		foreach (var n in tp.ExtraVolumes)  			try {  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  					backend.WaitForComplete (db' null);  					return;  				}  				progress++;  				m_result.OperationProgressUpdater.UpdateProgress ((float)progress / targetProgess);  				// If this is a new index file' we can accept it if it matches our local data  				// This makes it possible to augment the remote store with new index data  				if (n.FileType == RemoteVolumeType.Index && m_options.IndexfilePolicy != Options.IndexFileStrategy.None) {  					try {  						string hash;  						long size;  						using (var tf = backend.GetWithInfo (n.File.Name' out size' out hash))  							using (var ifr = new IndexVolumeReader (n.CompressionModule' tf' m_options' m_options.BlockhashSize)) {  								foreach (var rv in ifr.Volumes) {  									string cmphash;  									long cmpsize;  									RemoteVolumeType cmptype;  									RemoteVolumeState cmpstate;  									if (!db.GetRemoteVolume (rv.Filename' out cmphash' out cmpsize' out cmptype' out cmpstate))  										throw new Exception (string.Format ("Unknown remote file {0} detected"' rv.Filename));  									if (!new[] {  										RemoteVolumeState.Uploading'  										RemoteVolumeState.Uploaded'  										RemoteVolumeState.Verified  									}.Contains (cmpstate))  										throw new Exception (string.Format ("Volume {0} has local state {1}"' rv.Filename' cmpstate));  									if (cmphash != rv.Hash || cmpsize != rv.Length || !new[] {  										RemoteVolumeState.Uploading'  										RemoteVolumeState.Uploaded'  										RemoteVolumeState.Verified  									}.Contains (cmpstate))  										throw new Exception (string.Format ("Volume {0} hash/size mismatch ({1} - {2}) vs ({3} - {4})"' rv.Filename' cmphash' cmpsize' rv.Hash' rv.Length));  									db.CheckAllBlocksAreInVolume (rv.Filename' rv.Blocks);  								}  								var blocksize = m_options.Blocksize;  								foreach (var ixb in ifr.BlockLists)  									db.CheckBlocklistCorrect (ixb.Hash' ixb.Length' ixb.Blocklist' blocksize' hashsize);  								var selfid = db.GetRemoteVolumeID (n.File.Name);  								foreach (var rv in ifr.Volumes)  									db.AddIndexBlockLink (selfid' db.GetRemoteVolumeID (rv.Filename)' null);  							}  						// All checks fine' we accept the new index file  						m_result.AddMessage (string.Format ("Accepting new index file {0}"' n.File.Name));  						db.RegisterRemoteVolume (n.File.Name' RemoteVolumeType.Index' size' RemoteVolumeState.Uploading);  						db.UpdateRemoteVolume (n.File.Name' RemoteVolumeState.Verified' size' hash);  						continue;  					} catch (Exception rex) {  						m_result.AddError (string.Format ("Failed to accept new index file: {0}' message: {1}"' n.File.Name' rex.Message)' rex);  					}  				}  				if (!m_options.Dryrun) {  					db.RegisterRemoteVolume (n.File.Name' n.FileType' n.File.Size' RemoteVolumeState.Deleting);  					backend.Delete (n.File.Name' n.File.Size);  				} else  					m_result.AddDryrunMessage (string.Format ("would delete file {0}"' n.File.Name));  			} catch (Exception ex) {  				m_result.AddError (string.Format ("Failed to perform cleanup for extra file: {0}' message: {1}"' n.File.Name' ex.Message)' ex);  				if (ex is System.Threading.ThreadAbortException)  					throw;  			}  		foreach (var n in tp.MissingVolumes) {  			IDisposable newEntry = null;  			try {  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop) {  					backend.WaitForComplete (db' null);  					return;  				}  				progress++;  				m_result.OperationProgressUpdater.UpdateProgress ((float)progress / targetProgess);  				if (n.Type == RemoteVolumeType.Files) {  					var filesetId = db.GetFilesetIdFromRemotename (n.Name);  					var w = new FilesetVolumeWriter (m_options' DateTime.UtcNow);  					newEntry = w;  					w.SetRemoteFilename (n.Name);  					db.WriteFileset (w' null' filesetId);  					w.Close ();  					if (m_options.Dryrun)  						m_result.AddDryrunMessage (string.Format ("would re-upload fileset {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size)));  					else {  						db.UpdateRemoteVolume (w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);  						backend.Put (w);  					}  				} else if (n.Type == RemoteVolumeType.Index) {  					var w = new IndexVolumeWriter (m_options);  					newEntry = w;  					w.SetRemoteFilename (n.Name);  					var h = System.Security.Cryptography.HashAlgorithm.Create (m_options.BlockHashAlgorithm);  					foreach (var blockvolume in db.GetBlockVolumesFromIndexName (n.Name)) {  						w.StartVolume (blockvolume.Name);  						var volumeid = db.GetRemoteVolumeID (blockvolume.Name);  						foreach (var b in db.GetBlocks (volumeid))  							w.AddBlock (b.Hash' b.Size);  						w.FinishVolume (blockvolume.Hash' blockvolume.Size);  						if (m_options.IndexfilePolicy == Options.IndexFileStrategy.Full)  							foreach (var b in db.GetBlocklists (volumeid' m_options.Blocksize' hashsize)) {  								var bh = Convert.ToBase64String (h.ComputeHash (b.Item2' 0' b.Item3));  								if (bh != b.Item1)  									throw new Exception (string.Format ("Internal consistency check failed' generated index block has wrong hash' {0} vs {1}"' bh' b.Item1));  								w.WriteBlocklist (b.Item1' b.Item2' 0' b.Item3);  							}  					}  					w.Close ();  					if (m_options.Dryrun)  						m_result.AddDryrunMessage (string.Format ("would re-upload index file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size)));  					else {  						db.UpdateRemoteVolume (w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);  						backend.Put (w);  					}  				} else if (n.Type == RemoteVolumeType.Blocks) {  					var w = new BlockVolumeWriter (m_options);  					newEntry = w;  					w.SetRemoteFilename (n.Name);  					using (var mbl = db.CreateBlockList (n.Name)) {  						//First we grab all known blocks from local files  						foreach (var block in mbl.GetSourceFilesWithBlocks (m_options.Blocksize)) {  							var hash = block.Hash;  							var size = (int)block.Size;  							foreach (var source in block.Sources) {  								var file = source.File;  								var offset = source.Offset;  								try {  									if (System.IO.File.Exists (file))  										using (var f = System.IO.File.OpenRead (file)) {  											f.Position = offset;  											if (size == Library.Utility.Utility.ForceStreamRead (f' buffer' size)) {  												var newhash = Convert.ToBase64String (blockhasher.ComputeHash (buffer' 0' size));  												if (newhash == hash) {  													if (mbl.SetBlockRestored (hash' size))  														w.AddBlock (hash' buffer' 0' size' Duplicati.Library.Interface.CompressionHint.Default);  													break;  												}  											}  										}  								} catch (Exception ex) {  									m_result.AddError (string.Format ("Failed to access file: {0}"' file)' ex);  								}  							}  						}  						//Then we grab all remote volumes that have the missing blocks  						foreach (var vol in new AsyncDownloader (mbl.GetMissingBlockSources ().ToList ()' backend)) {  							try {  								using (var tmpfile = vol.TempFile)  									using (var f = new BlockVolumeReader (RestoreHandler.GetCompressionModule (vol.Name)' tmpfile' m_options))  										foreach (var b in f.Blocks)  											if (mbl.SetBlockRestored (b.Key' b.Value))  												if (f.ReadBlock (b.Key' buffer) == b.Value)  													w.AddBlock (b.Key' buffer' 0' (int)b.Value' Duplicati.Library.Interface.CompressionHint.Default);  							} catch (Exception ex) {  								m_result.AddError (string.Format ("Failed to access remote file: {0}"' vol.Name)' ex);  							}  						}  						// If we managed to recover all blocks' NICE!  						var missingBlocks = mbl.GetMissingBlocks ().Count ();  						if (missingBlocks > 0) {  							m_result.AddMessage (string.Format ("Repair cannot acquire {0} required blocks for volume {1}' which are required by the following filesets: "' missingBlocks' n.Name));  							foreach (var f in mbl.GetFilesetsUsingMissingBlocks ())  								m_result.AddMessage (f.Name);  							var recoverymsg = string.Format ("If you want to continue working with the database' you can use the \"{0}\" and \"{1}\" commands to purge the missing data from the database and the remote storage."' "list-broken-files"' "purge-broken-files");  							if (!m_options.Dryrun) {  								m_result.AddMessage ("This may be fixed by deleting the filesets and running repair again");  								throw new UserInformationException (string.Format ("Repair not possible' missing {0} blocks.\n" + recoverymsg' missingBlocks));  							} else {  								m_result.AddMessage (recoverymsg);  							}  						} else {  							if (m_options.Dryrun)  								m_result.AddDryrunMessage (string.Format ("would re-upload block file {0}' with size {1}' previous size {2}"' n.Name' Library.Utility.Utility.FormatSizeString (new System.IO.FileInfo (w.LocalFilename).Length)' Library.Utility.Utility.FormatSizeString (n.Size)));  							else {  								db.UpdateRemoteVolume (w.RemoteFilename' RemoteVolumeState.Uploading' -1' null' null);  								backend.Put (w);  							}  						}  					}  				}  			} catch (Exception ex) {  				if (newEntry != null)  					try {  						newEntry.Dispose ();  					} catch {  					} finally {  						newEntry = null;  					}  				m_result.AddError (string.Format ("Failed to perform cleanup for missing file: {0}' message: {1}"' n.Name' ex.Message)' ex);  				if (ex is System.Threading.ThreadAbortException)  					throw;  			}  		}  	} else {  		m_result.AddMessage ("Destination and database are synchronized' not making any changes");  	}  	m_result.OperationProgressUpdater.UpdateProgress (1);  	backend.WaitForComplete (db' null);  	db.WriteResults ();  }  
Magic Number,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The following statement contains a magic number: foreach (var i in locallist) {  	Volumes.IParsedVolume r;  	var remoteFound = lookup.TryGetValue (i.Name' out r);  	var correctSize = remoteFound && i.Size >= 0 && (i.Size == r.File.Size || r.File.Size < 0);  	lookup.Remove (i.Name);  	switch (i.State) {  	case RemoteVolumeState.Deleted:  		if (remoteFound)  			log.AddMessage (string.Format ("ignoring remote file listed as {0}: {1}"' i.State' i.Name));  		break;  	case RemoteVolumeState.Temporary:  	case RemoteVolumeState.Deleting:  		if (remoteFound) {  			log.AddMessage (string.Format ("removing remote file listed as {0}: {1}"' i.State' i.Name));  			backend.Delete (i.Name' i.Size' true);  		} else {  			if (i.deleteGracePeriod > DateTime.UtcNow) {  				log.AddMessage (string.Format ("keeping delete request for {0} until {1}"' i.Name' i.deleteGracePeriod.ToLocalTime ()));  			} else {  				if (string.Equals (i.Name' protectedfile) && i.State == RemoteVolumeState.Temporary) {  					log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  				} else {  					log.AddMessage (string.Format ("removing file listed as {0}: {1}"' i.State' i.Name));  					cleanupRemovedRemoteVolumes.Add (i.Name);  				}  			}  		}  		break;  	case RemoteVolumeState.Uploading:  		if (remoteFound && correctSize && r.File.Size >= 0) {  			log.AddMessage (string.Format ("promoting uploaded complete file from {0} to {2}: {1}"' i.State' i.Name' RemoteVolumeState.Uploaded));  			database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Uploaded' i.Size' i.Hash);  		} else if (!remoteFound) {  			if (string.Equals (i.Name' protectedfile)) {  				log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  				database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Temporary' i.Size' i.Hash' false' new TimeSpan (0)' null);  			} else {  				log.AddMessage (string.Format ("scheduling missing file for deletion' currently listed as {0}: {1}"' i.State' i.Name));  				cleanupRemovedRemoteVolumes.Add (i.Name);  				database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Deleting' i.Size' i.Hash' false' TimeSpan.FromHours (2)' null);  			}  		} else {  			if (string.Equals (i.Name' protectedfile)) {  				log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  			} else {  				log.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' i.State' i.Name));  				backend.Delete (i.Name' i.Size' true);  			}  		}  		break;  	case RemoteVolumeState.Uploaded:  		if (!remoteFound)  			missing.Add (i);  		else if (correctSize)  			database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Verified' i.Size' i.Hash);  		else  			missingHash.Add (new Tuple<long' RemoteVolumeEntry> (r.File.Size' i));  		break;  	case RemoteVolumeState.Verified:  		if (!remoteFound)  			missing.Add (i);  		else if (!correctSize)  			missingHash.Add (new Tuple<long' RemoteVolumeEntry> (r.File.Size' i));  		break;  	default:  		log.AddWarning (string.Format ("unknown state for remote file listed as {0}: {1}"' i.State' i.Name)' null);  		break;  	}  	backend.FlushDbMessages ();  }  
Magic Number,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The following statement contains a magic number: switch (i.State) {  case RemoteVolumeState.Deleted:  	if (remoteFound)  		log.AddMessage (string.Format ("ignoring remote file listed as {0}: {1}"' i.State' i.Name));  	break;  case RemoteVolumeState.Temporary:  case RemoteVolumeState.Deleting:  	if (remoteFound) {  		log.AddMessage (string.Format ("removing remote file listed as {0}: {1}"' i.State' i.Name));  		backend.Delete (i.Name' i.Size' true);  	} else {  		if (i.deleteGracePeriod > DateTime.UtcNow) {  			log.AddMessage (string.Format ("keeping delete request for {0} until {1}"' i.Name' i.deleteGracePeriod.ToLocalTime ()));  		} else {  			if (string.Equals (i.Name' protectedfile) && i.State == RemoteVolumeState.Temporary) {  				log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  			} else {  				log.AddMessage (string.Format ("removing file listed as {0}: {1}"' i.State' i.Name));  				cleanupRemovedRemoteVolumes.Add (i.Name);  			}  		}  	}  	break;  case RemoteVolumeState.Uploading:  	if (remoteFound && correctSize && r.File.Size >= 0) {  		log.AddMessage (string.Format ("promoting uploaded complete file from {0} to {2}: {1}"' i.State' i.Name' RemoteVolumeState.Uploaded));  		database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Uploaded' i.Size' i.Hash);  	} else if (!remoteFound) {  		if (string.Equals (i.Name' protectedfile)) {  			log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  			database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Temporary' i.Size' i.Hash' false' new TimeSpan (0)' null);  		} else {  			log.AddMessage (string.Format ("scheduling missing file for deletion' currently listed as {0}: {1}"' i.State' i.Name));  			cleanupRemovedRemoteVolumes.Add (i.Name);  			database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Deleting' i.Size' i.Hash' false' TimeSpan.FromHours (2)' null);  		}  	} else {  		if (string.Equals (i.Name' protectedfile)) {  			log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  		} else {  			log.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' i.State' i.Name));  			backend.Delete (i.Name' i.Size' true);  		}  	}  	break;  case RemoteVolumeState.Uploaded:  	if (!remoteFound)  		missing.Add (i);  	else if (correctSize)  		database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Verified' i.Size' i.Hash);  	else  		missingHash.Add (new Tuple<long' RemoteVolumeEntry> (r.File.Size' i));  	break;  case RemoteVolumeState.Verified:  	if (!remoteFound)  		missing.Add (i);  	else if (!correctSize)  		missingHash.Add (new Tuple<long' RemoteVolumeEntry> (r.File.Size' i));  	break;  default:  	log.AddWarning (string.Format ("unknown state for remote file listed as {0}: {1}"' i.State' i.Name)' null);  	break;  }  
Magic Number,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The following statement contains a magic number: if (remoteFound && correctSize && r.File.Size >= 0) {  	log.AddMessage (string.Format ("promoting uploaded complete file from {0} to {2}: {1}"' i.State' i.Name' RemoteVolumeState.Uploaded));  	database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Uploaded' i.Size' i.Hash);  } else if (!remoteFound) {  	if (string.Equals (i.Name' protectedfile)) {  		log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  		database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Temporary' i.Size' i.Hash' false' new TimeSpan (0)' null);  	} else {  		log.AddMessage (string.Format ("scheduling missing file for deletion' currently listed as {0}: {1}"' i.State' i.Name));  		cleanupRemovedRemoteVolumes.Add (i.Name);  		database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Deleting' i.Size' i.Hash' false' TimeSpan.FromHours (2)' null);  	}  } else {  	if (string.Equals (i.Name' protectedfile)) {  		log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  	} else {  		log.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' i.State' i.Name));  		backend.Delete (i.Name' i.Size' true);  	}  }  
Magic Number,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The following statement contains a magic number: if (!remoteFound) {  	if (string.Equals (i.Name' protectedfile)) {  		log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  		database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Temporary' i.Size' i.Hash' false' new TimeSpan (0)' null);  	} else {  		log.AddMessage (string.Format ("scheduling missing file for deletion' currently listed as {0}: {1}"' i.State' i.Name));  		cleanupRemovedRemoteVolumes.Add (i.Name);  		database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Deleting' i.Size' i.Hash' false' TimeSpan.FromHours (2)' null);  	}  } else {  	if (string.Equals (i.Name' protectedfile)) {  		log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  	} else {  		log.AddMessage (string.Format ("removing incomplete remote file listed as {0}: {1}"' i.State' i.Name));  		backend.Delete (i.Name' i.Size' true);  	}  }  
Magic Number,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The following statement contains a magic number: if (string.Equals (i.Name' protectedfile)) {  	log.AddMessage (string.Format ("keeping protected incomplete remote file listed as {0}: {1}"' i.State' i.Name));  	database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Temporary' i.Size' i.Hash' false' new TimeSpan (0)' null);  } else {  	log.AddMessage (string.Format ("scheduling missing file for deletion' currently listed as {0}: {1}"' i.State' i.Name));  	cleanupRemovedRemoteVolumes.Add (i.Name);  	database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Deleting' i.Size' i.Hash' false' TimeSpan.FromHours (2)' null);  }  
Magic Number,Duplicati.Library.Main.Operation,FilelistProcessor,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\FilelistProcessor.cs,RemoteListAnalysis,The following statement contains a magic number: database.UpdateRemoteVolume (i.Name' RemoteVolumeState.Deleting' i.Size' i.Hash' false' TimeSpan.FromHours (2)' null);  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var tmpdb = useLocalDb ? null : new Library.Utility.TempFile ())  	using (var db = new Database.LocalListChangesDatabase (useLocalDb ? m_options.Dbpath : (string)tmpdb))  		using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db))  			using (var storageKeeper = db.CreateStorageHelper ()) {  				m_result.SetDatabase (db);  				if (useLocalDb) {  					var dbtimes = db.FilesetTimes.ToList ();  					if (dbtimes.Count < 2)  						throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  					long baseVersionId;  					long compareVersionId;  					var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  					var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  					times.Remove (bt);  					SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  					storageKeeper.AddFromDb (baseVersionId' false' filter);  					storageKeeper.AddFromDb (compareVersionId' true' filter);  				} else {  					m_result.AddMessage ("No local database' accessing remote store");  					var parsedlist = (from n in backend.List ()  					let p = Volumes.VolumeBase.ParseFilename (n)  					where p != null && p.FileType == RemoteVolumeType.Files  					orderby p.Time descending  					select p).ToArray ();  					var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  					if (numberedList.Count < 2)  						throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  					Volumes.IParsedVolume baseFile;  					Volumes.IParsedVolume compareFile;  					var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  					numberedList.Remove (bt);  					SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  					Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  						switch (x) {  						case FilelistEntryType.File:  							return Library.Interface.ListChangesElementType.File;  						case FilelistEntryType.Folder:  							return Library.Interface.ListChangesElementType.Folder;  						case FilelistEntryType.Symlink:  							return Library.Interface.ListChangesElementType.Symlink;  						default:  							return (Library.Interface.ListChangesElementType)(-1);  						}  					};  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  					using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  						using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  							foreach (var f in rd.Files)  								if (Library.Utility.FilterExpression.Matches (filter' f.Path))  									storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  					using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  						using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  							foreach (var f in rd.Files)  								if (Library.Utility.FilterExpression.Matches (filter' f.Path))  									storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  				}  				var changes = storageKeeper.CreateChangeCountReport ();  				var sizes = storageKeeper.CreateChangeSizeReport ();  				var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  				select n) : null;  				m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  				if (callback != null)  					callback (m_result' lst);  				return;  			}  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var tmpdb = useLocalDb ? null : new Library.Utility.TempFile ())  	using (var db = new Database.LocalListChangesDatabase (useLocalDb ? m_options.Dbpath : (string)tmpdb))  		using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db))  			using (var storageKeeper = db.CreateStorageHelper ()) {  				m_result.SetDatabase (db);  				if (useLocalDb) {  					var dbtimes = db.FilesetTimes.ToList ();  					if (dbtimes.Count < 2)  						throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  					long baseVersionId;  					long compareVersionId;  					var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  					var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  					times.Remove (bt);  					SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  					storageKeeper.AddFromDb (baseVersionId' false' filter);  					storageKeeper.AddFromDb (compareVersionId' true' filter);  				} else {  					m_result.AddMessage ("No local database' accessing remote store");  					var parsedlist = (from n in backend.List ()  					let p = Volumes.VolumeBase.ParseFilename (n)  					where p != null && p.FileType == RemoteVolumeType.Files  					orderby p.Time descending  					select p).ToArray ();  					var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  					if (numberedList.Count < 2)  						throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  					Volumes.IParsedVolume baseFile;  					Volumes.IParsedVolume compareFile;  					var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  					numberedList.Remove (bt);  					SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  					Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  						switch (x) {  						case FilelistEntryType.File:  							return Library.Interface.ListChangesElementType.File;  						case FilelistEntryType.Folder:  							return Library.Interface.ListChangesElementType.Folder;  						case FilelistEntryType.Symlink:  							return Library.Interface.ListChangesElementType.Symlink;  						default:  							return (Library.Interface.ListChangesElementType)(-1);  						}  					};  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  					using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  						using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  							foreach (var f in rd.Files)  								if (Library.Utility.FilterExpression.Matches (filter' f.Path))  									storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  					if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  						return;  					using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  						using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  							foreach (var f in rd.Files)  								if (Library.Utility.FilterExpression.Matches (filter' f.Path))  									storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  				}  				var changes = storageKeeper.CreateChangeCountReport ();  				var sizes = storageKeeper.CreateChangeSizeReport ();  				var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  				select n) : null;  				m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  				if (callback != null)  					callback (m_result' lst);  				return;  			}  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var db = new Database.LocalListChangesDatabase (useLocalDb ? m_options.Dbpath : (string)tmpdb))  	using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db))  		using (var storageKeeper = db.CreateStorageHelper ()) {  			m_result.SetDatabase (db);  			if (useLocalDb) {  				var dbtimes = db.FilesetTimes.ToList ();  				if (dbtimes.Count < 2)  					throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  				long baseVersionId;  				long compareVersionId;  				var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  				var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  				times.Remove (bt);  				SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  				storageKeeper.AddFromDb (baseVersionId' false' filter);  				storageKeeper.AddFromDb (compareVersionId' true' filter);  			} else {  				m_result.AddMessage ("No local database' accessing remote store");  				var parsedlist = (from n in backend.List ()  				let p = Volumes.VolumeBase.ParseFilename (n)  				where p != null && p.FileType == RemoteVolumeType.Files  				orderby p.Time descending  				select p).ToArray ();  				var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  				if (numberedList.Count < 2)  					throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  				Volumes.IParsedVolume baseFile;  				Volumes.IParsedVolume compareFile;  				var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  				numberedList.Remove (bt);  				SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  				Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  					switch (x) {  					case FilelistEntryType.File:  						return Library.Interface.ListChangesElementType.File;  					case FilelistEntryType.Folder:  						return Library.Interface.ListChangesElementType.Folder;  					case FilelistEntryType.Symlink:  						return Library.Interface.ListChangesElementType.Symlink;  					default:  						return (Library.Interface.ListChangesElementType)(-1);  					}  				};  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  				using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  					using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  						foreach (var f in rd.Files)  							if (Library.Utility.FilterExpression.Matches (filter' f.Path))  								storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  				using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  					using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  						foreach (var f in rd.Files)  							if (Library.Utility.FilterExpression.Matches (filter' f.Path))  								storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  			}  			var changes = storageKeeper.CreateChangeCountReport ();  			var sizes = storageKeeper.CreateChangeSizeReport ();  			var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  			select n) : null;  			m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  			if (callback != null)  				callback (m_result' lst);  			return;  		}  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var db = new Database.LocalListChangesDatabase (useLocalDb ? m_options.Dbpath : (string)tmpdb))  	using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db))  		using (var storageKeeper = db.CreateStorageHelper ()) {  			m_result.SetDatabase (db);  			if (useLocalDb) {  				var dbtimes = db.FilesetTimes.ToList ();  				if (dbtimes.Count < 2)  					throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  				long baseVersionId;  				long compareVersionId;  				var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  				var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  				times.Remove (bt);  				SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  				storageKeeper.AddFromDb (baseVersionId' false' filter);  				storageKeeper.AddFromDb (compareVersionId' true' filter);  			} else {  				m_result.AddMessage ("No local database' accessing remote store");  				var parsedlist = (from n in backend.List ()  				let p = Volumes.VolumeBase.ParseFilename (n)  				where p != null && p.FileType == RemoteVolumeType.Files  				orderby p.Time descending  				select p).ToArray ();  				var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  				if (numberedList.Count < 2)  					throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  				Volumes.IParsedVolume baseFile;  				Volumes.IParsedVolume compareFile;  				var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  				numberedList.Remove (bt);  				SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  				Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  					switch (x) {  					case FilelistEntryType.File:  						return Library.Interface.ListChangesElementType.File;  					case FilelistEntryType.Folder:  						return Library.Interface.ListChangesElementType.Folder;  					case FilelistEntryType.Symlink:  						return Library.Interface.ListChangesElementType.Symlink;  					default:  						return (Library.Interface.ListChangesElementType)(-1);  					}  				};  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  				using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  					using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  						foreach (var f in rd.Files)  							if (Library.Utility.FilterExpression.Matches (filter' f.Path))  								storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  				if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  					return;  				using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  					using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  						foreach (var f in rd.Files)  							if (Library.Utility.FilterExpression.Matches (filter' f.Path))  								storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  			}  			var changes = storageKeeper.CreateChangeCountReport ();  			var sizes = storageKeeper.CreateChangeSizeReport ();  			var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  			select n) : null;  			m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  			if (callback != null)  				callback (m_result' lst);  			return;  		}  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db))  	using (var storageKeeper = db.CreateStorageHelper ()) {  		m_result.SetDatabase (db);  		if (useLocalDb) {  			var dbtimes = db.FilesetTimes.ToList ();  			if (dbtimes.Count < 2)  				throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  			long baseVersionId;  			long compareVersionId;  			var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  			var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  			times.Remove (bt);  			SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  			storageKeeper.AddFromDb (baseVersionId' false' filter);  			storageKeeper.AddFromDb (compareVersionId' true' filter);  		} else {  			m_result.AddMessage ("No local database' accessing remote store");  			var parsedlist = (from n in backend.List ()  			let p = Volumes.VolumeBase.ParseFilename (n)  			where p != null && p.FileType == RemoteVolumeType.Files  			orderby p.Time descending  			select p).ToArray ();  			var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  			if (numberedList.Count < 2)  				throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  			Volumes.IParsedVolume baseFile;  			Volumes.IParsedVolume compareFile;  			var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  			numberedList.Remove (bt);  			SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  			Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  				switch (x) {  				case FilelistEntryType.File:  					return Library.Interface.ListChangesElementType.File;  				case FilelistEntryType.Folder:  					return Library.Interface.ListChangesElementType.Folder;  				case FilelistEntryType.Symlink:  					return Library.Interface.ListChangesElementType.Symlink;  				default:  					return (Library.Interface.ListChangesElementType)(-1);  				}  			};  			if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  			using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  				using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  					foreach (var f in rd.Files)  						if (Library.Utility.FilterExpression.Matches (filter' f.Path))  							storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  			if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  			using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  				using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  					foreach (var f in rd.Files)  						if (Library.Utility.FilterExpression.Matches (filter' f.Path))  							storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  		}  		var changes = storageKeeper.CreateChangeCountReport ();  		var sizes = storageKeeper.CreateChangeSizeReport ();  		var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  		select n) : null;  		m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  		if (callback != null)  			callback (m_result' lst);  		return;  	}  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db))  	using (var storageKeeper = db.CreateStorageHelper ()) {  		m_result.SetDatabase (db);  		if (useLocalDb) {  			var dbtimes = db.FilesetTimes.ToList ();  			if (dbtimes.Count < 2)  				throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  			long baseVersionId;  			long compareVersionId;  			var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  			var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  			times.Remove (bt);  			SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  			storageKeeper.AddFromDb (baseVersionId' false' filter);  			storageKeeper.AddFromDb (compareVersionId' true' filter);  		} else {  			m_result.AddMessage ("No local database' accessing remote store");  			var parsedlist = (from n in backend.List ()  			let p = Volumes.VolumeBase.ParseFilename (n)  			where p != null && p.FileType == RemoteVolumeType.Files  			orderby p.Time descending  			select p).ToArray ();  			var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  			if (numberedList.Count < 2)  				throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  			Volumes.IParsedVolume baseFile;  			Volumes.IParsedVolume compareFile;  			var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  			numberedList.Remove (bt);  			SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  			Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  				switch (x) {  				case FilelistEntryType.File:  					return Library.Interface.ListChangesElementType.File;  				case FilelistEntryType.Folder:  					return Library.Interface.ListChangesElementType.Folder;  				case FilelistEntryType.Symlink:  					return Library.Interface.ListChangesElementType.Symlink;  				default:  					return (Library.Interface.ListChangesElementType)(-1);  				}  			};  			if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  			using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  				using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  					foreach (var f in rd.Files)  						if (Library.Utility.FilterExpression.Matches (filter' f.Path))  							storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  			if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  				return;  			using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  				using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  					foreach (var f in rd.Files)  						if (Library.Utility.FilterExpression.Matches (filter' f.Path))  							storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  		}  		var changes = storageKeeper.CreateChangeCountReport ();  		var sizes = storageKeeper.CreateChangeSizeReport ();  		var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  		select n) : null;  		m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  		if (callback != null)  			callback (m_result' lst);  		return;  	}  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var storageKeeper = db.CreateStorageHelper ()) {  	m_result.SetDatabase (db);  	if (useLocalDb) {  		var dbtimes = db.FilesetTimes.ToList ();  		if (dbtimes.Count < 2)  			throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  		long baseVersionId;  		long compareVersionId;  		var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  		var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  		times.Remove (bt);  		SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  		storageKeeper.AddFromDb (baseVersionId' false' filter);  		storageKeeper.AddFromDb (compareVersionId' true' filter);  	} else {  		m_result.AddMessage ("No local database' accessing remote store");  		var parsedlist = (from n in backend.List ()  		let p = Volumes.VolumeBase.ParseFilename (n)  		where p != null && p.FileType == RemoteVolumeType.Files  		orderby p.Time descending  		select p).ToArray ();  		var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  		if (numberedList.Count < 2)  			throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  		Volumes.IParsedVolume baseFile;  		Volumes.IParsedVolume compareFile;  		var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  		numberedList.Remove (bt);  		SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  		Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  			switch (x) {  			case FilelistEntryType.File:  				return Library.Interface.ListChangesElementType.File;  			case FilelistEntryType.Folder:  				return Library.Interface.ListChangesElementType.Folder;  			case FilelistEntryType.Symlink:  				return Library.Interface.ListChangesElementType.Symlink;  			default:  				return (Library.Interface.ListChangesElementType)(-1);  			}  		};  		if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  		using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  			using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  				foreach (var f in rd.Files)  					if (Library.Utility.FilterExpression.Matches (filter' f.Path))  						storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  		if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  		using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  			using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  				foreach (var f in rd.Files)  					if (Library.Utility.FilterExpression.Matches (filter' f.Path))  						storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  	}  	var changes = storageKeeper.CreateChangeCountReport ();  	var sizes = storageKeeper.CreateChangeSizeReport ();  	var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  	select n) : null;  	m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  	if (callback != null)  		callback (m_result' lst);  	return;  }  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: using (var storageKeeper = db.CreateStorageHelper ()) {  	m_result.SetDatabase (db);  	if (useLocalDb) {  		var dbtimes = db.FilesetTimes.ToList ();  		if (dbtimes.Count < 2)  			throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  		long baseVersionId;  		long compareVersionId;  		var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  		var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  		times.Remove (bt);  		SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  		storageKeeper.AddFromDb (baseVersionId' false' filter);  		storageKeeper.AddFromDb (compareVersionId' true' filter);  	} else {  		m_result.AddMessage ("No local database' accessing remote store");  		var parsedlist = (from n in backend.List ()  		let p = Volumes.VolumeBase.ParseFilename (n)  		where p != null && p.FileType == RemoteVolumeType.Files  		orderby p.Time descending  		select p).ToArray ();  		var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  		if (numberedList.Count < 2)  			throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  		Volumes.IParsedVolume baseFile;  		Volumes.IParsedVolume compareFile;  		var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  		numberedList.Remove (bt);  		SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  		Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  			switch (x) {  			case FilelistEntryType.File:  				return Library.Interface.ListChangesElementType.File;  			case FilelistEntryType.Folder:  				return Library.Interface.ListChangesElementType.Folder;  			case FilelistEntryType.Symlink:  				return Library.Interface.ListChangesElementType.Symlink;  			default:  				return (Library.Interface.ListChangesElementType)(-1);  			}  		};  		if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  		using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  			using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  				foreach (var f in rd.Files)  					if (Library.Utility.FilterExpression.Matches (filter' f.Path))  						storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  		if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  			return;  		using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  			using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  				foreach (var f in rd.Files)  					if (Library.Utility.FilterExpression.Matches (filter' f.Path))  						storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  	}  	var changes = storageKeeper.CreateChangeCountReport ();  	var sizes = storageKeeper.CreateChangeSizeReport ();  	var lst = (m_options.Verbose || m_options.FullResult || callback != null) ? (from n in storageKeeper.CreateChangedFileReport ()  	select n) : null;  	m_result.SetResult (baseVersionTime' baseVersionIndex' compareVersionTime' compareVersionIndex' changes.AddedFolders' changes.AddedSymlinks' changes.AddedFiles' changes.DeletedFolders' changes.DeletedSymlinks' changes.DeletedFiles' changes.ModifiedFolders' changes.ModifiedSymlinks' changes.ModifiedFiles' sizes.AddedSize' sizes.DeletedSize' sizes.PreviousSize' sizes.CurrentSize' (lst == null || callback != null) ? null : lst.ToArray ());  	if (callback != null)  		callback (m_result' lst);  	return;  }  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: if (useLocalDb) {  	var dbtimes = db.FilesetTimes.ToList ();  	if (dbtimes.Count < 2)  		throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  	long baseVersionId;  	long compareVersionId;  	var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  	var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  	times.Remove (bt);  	SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  	storageKeeper.AddFromDb (baseVersionId' false' filter);  	storageKeeper.AddFromDb (compareVersionId' true' filter);  } else {  	m_result.AddMessage ("No local database' accessing remote store");  	var parsedlist = (from n in backend.List ()  	let p = Volumes.VolumeBase.ParseFilename (n)  	where p != null && p.FileType == RemoteVolumeType.Files  	orderby p.Time descending  	select p).ToArray ();  	var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  	if (numberedList.Count < 2)  		throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  	Volumes.IParsedVolume baseFile;  	Volumes.IParsedVolume compareFile;  	var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  	numberedList.Remove (bt);  	SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  	Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  		switch (x) {  		case FilelistEntryType.File:  			return Library.Interface.ListChangesElementType.File;  		case FilelistEntryType.Folder:  			return Library.Interface.ListChangesElementType.Folder;  		case FilelistEntryType.Symlink:  			return Library.Interface.ListChangesElementType.Symlink;  		default:  			return (Library.Interface.ListChangesElementType)(-1);  		}  	};  	if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  	using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  		using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  			foreach (var f in rd.Files)  				if (Library.Utility.FilterExpression.Matches (filter' f.Path))  					storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  	if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  	using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  		using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  			foreach (var f in rd.Files)  				if (Library.Utility.FilterExpression.Matches (filter' f.Path))  					storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  }  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: if (useLocalDb) {  	var dbtimes = db.FilesetTimes.ToList ();  	if (dbtimes.Count < 2)  		throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  	long baseVersionId;  	long compareVersionId;  	var times = dbtimes.Zip (Enumerable.Range (0' dbtimes.Count)' (a' b) => new Tuple<long' DateTime' long> (b' a.Value' a.Key)).ToList ();  	var bt = SelectTime (baseVersion' times' out baseVersionIndex' out baseVersionTime' out baseVersionId);  	times.Remove (bt);  	SelectTime (compareVersion' times' out compareVersionIndex' out compareVersionTime' out compareVersionId);  	storageKeeper.AddFromDb (baseVersionId' false' filter);  	storageKeeper.AddFromDb (compareVersionId' true' filter);  } else {  	m_result.AddMessage ("No local database' accessing remote store");  	var parsedlist = (from n in backend.List ()  	let p = Volumes.VolumeBase.ParseFilename (n)  	where p != null && p.FileType == RemoteVolumeType.Files  	orderby p.Time descending  	select p).ToArray ();  	var numberedList = parsedlist.Zip (Enumerable.Range (0' parsedlist.Length)' (a' b) => new Tuple<long' DateTime' Volumes.IParsedVolume> (b' a.Time' a)).ToList ();  	if (numberedList.Count < 2)  		throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  	Volumes.IParsedVolume baseFile;  	Volumes.IParsedVolume compareFile;  	var bt = SelectTime (baseVersion' numberedList' out baseVersionIndex' out baseVersionTime' out baseFile);  	numberedList.Remove (bt);  	SelectTime (compareVersion' numberedList' out compareVersionIndex' out compareVersionTime' out compareFile);  	Func<FilelistEntryType' Library.Interface.ListChangesElementType> conv = x => {  		switch (x) {  		case FilelistEntryType.File:  			return Library.Interface.ListChangesElementType.File;  		case FilelistEntryType.Folder:  			return Library.Interface.ListChangesElementType.Folder;  		case FilelistEntryType.Symlink:  			return Library.Interface.ListChangesElementType.Symlink;  		default:  			return (Library.Interface.ListChangesElementType)(-1);  		}  	};  	if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  	using (var tmpfile = backend.Get (baseFile.File.Name' baseFile.File.Size' null))  		using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (baseFile.File.Name)' tmpfile' m_options))  			foreach (var f in rd.Files)  				if (Library.Utility.FilterExpression.Matches (filter' f.Path))  					storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' false);  	if (m_result.TaskControlRendevouz () == TaskControlState.Stop)  		return;  	using (var tmpfile = backend.Get (compareFile.File.Name' compareFile.File.Size' null))  		using (var rd = new Volumes.FilesetVolumeReader (RestoreHandler.GetCompressionModule (compareFile.File.Name)' tmpfile' m_options))  			foreach (var f in rd.Files)  				if (Library.Utility.FilterExpression.Matches (filter' f.Path))  					storageKeeper.AddElement (f.Path' f.Hash' f.Metahash' f.Size' conv (f.Type)' true);  }  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: if (dbtimes.Count < 2)  	throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' dbtimes.Count));  
Magic Number,Duplicati.Library.Main.Operation,ListChangesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\ListChangesHandler.cs,Run,The following statement contains a magic number: if (numberedList.Count < 2)  	throw new UserInformationException (string.Format ("Need at least two backups to show differences' database contains {0} backups"' numberedList.Count));  
Magic Number,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The following statement contains a magic number: if (m_options.FullRemoteVerification) {  	foreach (var vol in new AsyncDownloader (files' backend)) {  		try {  			if (m_results.TaskControlRendevouz () == TaskControlState.Stop) {  				backend.WaitForComplete (db' null);  				m_results.EndTime = DateTime.UtcNow;  				return;  			}  			progress++;  			m_results.OperationProgressUpdater.UpdateProgress ((float)progress / files.Count);  			KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> res;  			using (var tf = vol.TempFile)  				res = TestVolumeInternals (db' vol' tf' m_options' m_results' m_options.FullBlockVerification ? 1.0 : 0.2);  			m_results.AddResult (res.Key' res.Value);  			if (!string.IsNullOrWhiteSpace (vol.Hash) && vol.Size > 0) {  				if (res.Value == null || !res.Value.Any ()) {  					string dbhash;  					long dbsize;  					RemoteVolumeType dbtype;  					RemoteVolumeState dbstate;  					if (db.GetRemoteVolume (vol.Name' out dbhash' out dbsize' out dbtype' out dbstate)) {  						if (string.IsNullOrWhiteSpace (dbhash) || dbsize <= 0) {  							if (m_options.Dryrun) {  								m_results.AddDryrunMessage (string.Format ("Sucessfully captured hash and size for {0}' would update database"' vol.Name));  							} else {  								m_results.AddMessage (string.Format ("Sucessfully captured hash and size for {0}' updating database"' vol.Name));  								db.UpdateRemoteVolume (vol.Name' RemoteVolumeState.Verified' vol.Size' vol.Hash);  							}  						}  					}  				}  			}  			db.UpdateVerificationCount (vol.Name);  		} catch (Exception ex) {  			m_results.AddResult (vol.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] {  				new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string> (Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message)  			});  			m_results.AddError (string.Format ("Failed to process file {0}"' vol.Name)' ex);  			if (ex is System.Threading.ThreadAbortException) {  				m_results.EndTime = DateTime.UtcNow;  				throw;  			}  		}  	}  } else {  	foreach (var f in files) {  		try {  			if (m_results.TaskControlRendevouz () == TaskControlState.Stop) {  				m_results.EndTime = DateTime.UtcNow;  				return;  			}  			progress++;  			m_results.OperationProgressUpdater.UpdateProgress ((float)progress / files.Count);  			if (f.Size <= 0 || string.IsNullOrWhiteSpace (f.Hash)) {  				m_results.AddMessage (string.Format ("No hash or size recorded for {0}' performing full verification"' f.Name));  				KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> res;  				string hash;  				long size;  				using (var tf = backend.GetWithInfo (f.Name' out size' out hash))  					res = TestVolumeInternals (db' f' tf' m_options' m_results' 1);  				m_results.AddResult (res.Key' res.Value);  				if (!string.IsNullOrWhiteSpace (hash) && size > 0) {  					if (res.Value == null || !res.Value.Any ()) {  						if (m_options.Dryrun) {  							m_results.AddDryrunMessage (string.Format ("Sucessfully captured hash and size for {0}' would update database"' f.Name));  						} else {  							m_results.AddMessage (string.Format ("Sucessfully captured hash and size for {0}' updating database"' f.Name));  							db.UpdateRemoteVolume (f.Name' RemoteVolumeState.Verified' size' hash);  						}  					}  				}  			} else  				backend.GetForTesting (f.Name' f.Size' f.Hash);  			db.UpdateVerificationCount (f.Name);  			m_results.AddResult (f.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[0]);  		} catch (Exception ex) {  			m_results.AddResult (f.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] {  				new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string> (Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message)  			});  			m_results.AddError (string.Format ("Failed to process file {0}"' f.Name)' ex);  			if (ex is System.Threading.ThreadAbortException) {  				m_results.EndTime = DateTime.UtcNow;  				throw;  			}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The following statement contains a magic number: foreach (var vol in new AsyncDownloader (files' backend)) {  	try {  		if (m_results.TaskControlRendevouz () == TaskControlState.Stop) {  			backend.WaitForComplete (db' null);  			m_results.EndTime = DateTime.UtcNow;  			return;  		}  		progress++;  		m_results.OperationProgressUpdater.UpdateProgress ((float)progress / files.Count);  		KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> res;  		using (var tf = vol.TempFile)  			res = TestVolumeInternals (db' vol' tf' m_options' m_results' m_options.FullBlockVerification ? 1.0 : 0.2);  		m_results.AddResult (res.Key' res.Value);  		if (!string.IsNullOrWhiteSpace (vol.Hash) && vol.Size > 0) {  			if (res.Value == null || !res.Value.Any ()) {  				string dbhash;  				long dbsize;  				RemoteVolumeType dbtype;  				RemoteVolumeState dbstate;  				if (db.GetRemoteVolume (vol.Name' out dbhash' out dbsize' out dbtype' out dbstate)) {  					if (string.IsNullOrWhiteSpace (dbhash) || dbsize <= 0) {  						if (m_options.Dryrun) {  							m_results.AddDryrunMessage (string.Format ("Sucessfully captured hash and size for {0}' would update database"' vol.Name));  						} else {  							m_results.AddMessage (string.Format ("Sucessfully captured hash and size for {0}' updating database"' vol.Name));  							db.UpdateRemoteVolume (vol.Name' RemoteVolumeState.Verified' vol.Size' vol.Hash);  						}  					}  				}  			}  		}  		db.UpdateVerificationCount (vol.Name);  	} catch (Exception ex) {  		m_results.AddResult (vol.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] {  			new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string> (Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message)  		});  		m_results.AddError (string.Format ("Failed to process file {0}"' vol.Name)' ex);  		if (ex is System.Threading.ThreadAbortException) {  			m_results.EndTime = DateTime.UtcNow;  			throw;  		}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The following statement contains a magic number: try {  	if (m_results.TaskControlRendevouz () == TaskControlState.Stop) {  		backend.WaitForComplete (db' null);  		m_results.EndTime = DateTime.UtcNow;  		return;  	}  	progress++;  	m_results.OperationProgressUpdater.UpdateProgress ((float)progress / files.Count);  	KeyValuePair<string' IEnumerable<KeyValuePair<TestEntryStatus' string>>> res;  	using (var tf = vol.TempFile)  		res = TestVolumeInternals (db' vol' tf' m_options' m_results' m_options.FullBlockVerification ? 1.0 : 0.2);  	m_results.AddResult (res.Key' res.Value);  	if (!string.IsNullOrWhiteSpace (vol.Hash) && vol.Size > 0) {  		if (res.Value == null || !res.Value.Any ()) {  			string dbhash;  			long dbsize;  			RemoteVolumeType dbtype;  			RemoteVolumeState dbstate;  			if (db.GetRemoteVolume (vol.Name' out dbhash' out dbsize' out dbtype' out dbstate)) {  				if (string.IsNullOrWhiteSpace (dbhash) || dbsize <= 0) {  					if (m_options.Dryrun) {  						m_results.AddDryrunMessage (string.Format ("Sucessfully captured hash and size for {0}' would update database"' vol.Name));  					} else {  						m_results.AddMessage (string.Format ("Sucessfully captured hash and size for {0}' updating database"' vol.Name));  						db.UpdateRemoteVolume (vol.Name' RemoteVolumeState.Verified' vol.Size' vol.Hash);  					}  				}  			}  		}  	}  	db.UpdateVerificationCount (vol.Name);  } catch (Exception ex) {  	m_results.AddResult (vol.Name' new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string>[] {  		new KeyValuePair<Duplicati.Library.Interface.TestEntryStatus' string> (Duplicati.Library.Interface.TestEntryStatus.Error' ex.Message)  	});  	m_results.AddError (string.Format ("Failed to process file {0}"' vol.Name)' ex);  	if (ex is System.Threading.ThreadAbortException) {  		m_results.EndTime = DateTime.UtcNow;  		throw;  	}  }  
Magic Number,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The following statement contains a magic number: using (var tf = vol.TempFile)  	res = TestVolumeInternals (db' vol' tf' m_options' m_results' m_options.FullBlockVerification ? 1.0 : 0.2);  
Magic Number,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,DoRun,The following statement contains a magic number: res = TestVolumeInternals (db' vol' tf' m_options' m_results' m_options.FullBlockVerification ? 1.0 : 0.2);  
Magic Number,Duplicati.Library.Main.Operation,TestHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\TestHandler.cs,TestVolumeInternals,The following statement contains a magic number: sample_percent = Math.Min (1' Math.Max (sample_percent' 0.01));  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db)) {  	if (db.PartiallyRecreated)  		throw new UserInformationException ("The purge command does not work on partially recreated databases");  	if (db.RepairInProgress && filtercommand == null)  		throw new UserInformationException (string.Format ("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));  	var versions = db.GetFilesetIDs (m_options.Time' m_options.Version).ToArray ();  	if (versions.Length <= 0)  		throw new UserInformationException ("No filesets matched the supplied time or versions");  	var orphans = db.CountOrphanFiles (null);  	if (orphans != 0)  		throw new UserInformationException (string.Format ("Unable to start the purge process as there are {0} orphan file(s)"' orphans));  	Utility.UpdateOptionsFromDb (db' m_options);  	Utility.VerifyParameters (db' m_options);  	if (filtercommand == null) {  		db.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' false);  		if (m_options.NoBackendverification)  			FilelistProcessor.VerifyLocalList (backend' m_options' db' m_result.BackendWriter);  		else  			FilelistProcessor.VerifyRemoteList (backend' m_options' db' m_result.BackendWriter' null);  	}  	var filesets = db.FilesetTimes.ToArray ();  	var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;  	var currentprogress = pgoffset;  	m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Process);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	// Reverse makes sure we re-write the old versions first  	foreach (var versionid in versions.Reverse ()) {  		using (var tr = db.BeginTransaction ()) {  			var ix = -1;  			for (var i = 0; i < filesets.Length; i++)  				if (filesets [i].Key == versionid) {  					ix = i;  					break;  				}  			if (ix < 0)  				throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  			var secs = 0;  			while (secs < 60) {  				secs++;  				var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  				if (db.GetRemoteVolumeID (tfn' tr) < 0)  					break;  			}  			var ts = filesets [ix].Value.AddSeconds (secs);  			var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  			if (secs >= 60)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  			if (ix != 0 && filesets [ix - 1].Value <= ts)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  			using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  				if (filtercommand == null)  					tempset.ApplyFilter (filter);  				else  					tempset.ApplyFilter (filtercommand);  				if (tempset.RemovedFileCount == 0) {  					m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  					currentprogress += versionprogress;  					tr.Rollback ();  					continue;  				} else {  					using (var tf = new Library.Utility.TempFile ())  						using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  							var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  							vol.VolumeID = newids.Item1;  							m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  							db.WriteFileset (vol' tr' newids.Item2);  							m_result.RemovedFileSize += tempset.RemovedFileSize;  							m_result.RemovedFileCount += tempset.RemovedFileCount;  							m_result.RewrittenFileLists++;  							currentprogress += (versionprogress / 2);  							m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  							if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  								foreach (var fe in tempset.ListAllDeletedFiles ()) {  									var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  									if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  										Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  									if (m_options.Dryrun)  										m_result.AddDryrunMessage (msg);  									else if (m_options.Verbose)  										m_result.AddVerboseMessage (msg);  								}  								if (m_options.Dryrun)  									m_result.AddDryrunMessage ("Writing files to remote storage");  								else if (m_options.Verbose)  									m_result.AddVerboseMessage ("Writing files to remote storage");  							}  							if (m_options.Dryrun) {  								m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  								tr.Rollback ();  							} else {  								var lst = db.DropFilesetsFromTable (new[] {  									filesets [ix].Value  								}' tr).ToArray ();  								foreach (var f in lst)  									db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  								tr.Commit ();  								backend.Put (vol' synchronous: true);  								backend.Delete (prevfilename' -1' true);  								backend.FlushDbMessages ();  							}  						}  				}  			}  		}  		currentprogress += (versionprogress / 2);  		m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	}  	if (doCompactStep) {  		if (m_result.RewrittenFileLists == 0) {  			m_result.AddMessage ("Skipping compacting as no new volumes were written");  		} else {  			m_result.OperationProgressUpdater.UpdateProgress (pgoffset + (0.75f * pgspan));  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Compact);  			m_result.CompactResults = new CompactResults (m_result);  			using (var cdb = new Database.LocalDeleteDatabase (db)) {  				var tr = cdb.BeginTransaction ();  				try {  					new CompactHandler (backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact (cdb' true' ref tr);  				} catch {  					try {  						tr.Rollback ();  					} catch {  					}  				} finally {  					try {  						tr.Commit ();  					} catch {  					}  				}  			}  		}  		m_result.OperationProgressUpdater.UpdateProgress (pgoffset + pgspan);  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Complete);  	}  	backend.WaitForComplete (db' null);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db)) {  	if (db.PartiallyRecreated)  		throw new UserInformationException ("The purge command does not work on partially recreated databases");  	if (db.RepairInProgress && filtercommand == null)  		throw new UserInformationException (string.Format ("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));  	var versions = db.GetFilesetIDs (m_options.Time' m_options.Version).ToArray ();  	if (versions.Length <= 0)  		throw new UserInformationException ("No filesets matched the supplied time or versions");  	var orphans = db.CountOrphanFiles (null);  	if (orphans != 0)  		throw new UserInformationException (string.Format ("Unable to start the purge process as there are {0} orphan file(s)"' orphans));  	Utility.UpdateOptionsFromDb (db' m_options);  	Utility.VerifyParameters (db' m_options);  	if (filtercommand == null) {  		db.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' false);  		if (m_options.NoBackendverification)  			FilelistProcessor.VerifyLocalList (backend' m_options' db' m_result.BackendWriter);  		else  			FilelistProcessor.VerifyRemoteList (backend' m_options' db' m_result.BackendWriter' null);  	}  	var filesets = db.FilesetTimes.ToArray ();  	var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;  	var currentprogress = pgoffset;  	m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Process);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	// Reverse makes sure we re-write the old versions first  	foreach (var versionid in versions.Reverse ()) {  		using (var tr = db.BeginTransaction ()) {  			var ix = -1;  			for (var i = 0; i < filesets.Length; i++)  				if (filesets [i].Key == versionid) {  					ix = i;  					break;  				}  			if (ix < 0)  				throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  			var secs = 0;  			while (secs < 60) {  				secs++;  				var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  				if (db.GetRemoteVolumeID (tfn' tr) < 0)  					break;  			}  			var ts = filesets [ix].Value.AddSeconds (secs);  			var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  			if (secs >= 60)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  			if (ix != 0 && filesets [ix - 1].Value <= ts)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  			using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  				if (filtercommand == null)  					tempset.ApplyFilter (filter);  				else  					tempset.ApplyFilter (filtercommand);  				if (tempset.RemovedFileCount == 0) {  					m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  					currentprogress += versionprogress;  					tr.Rollback ();  					continue;  				} else {  					using (var tf = new Library.Utility.TempFile ())  						using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  							var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  							vol.VolumeID = newids.Item1;  							m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  							db.WriteFileset (vol' tr' newids.Item2);  							m_result.RemovedFileSize += tempset.RemovedFileSize;  							m_result.RemovedFileCount += tempset.RemovedFileCount;  							m_result.RewrittenFileLists++;  							currentprogress += (versionprogress / 2);  							m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  							if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  								foreach (var fe in tempset.ListAllDeletedFiles ()) {  									var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  									if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  										Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  									if (m_options.Dryrun)  										m_result.AddDryrunMessage (msg);  									else if (m_options.Verbose)  										m_result.AddVerboseMessage (msg);  								}  								if (m_options.Dryrun)  									m_result.AddDryrunMessage ("Writing files to remote storage");  								else if (m_options.Verbose)  									m_result.AddVerboseMessage ("Writing files to remote storage");  							}  							if (m_options.Dryrun) {  								m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  								tr.Rollback ();  							} else {  								var lst = db.DropFilesetsFromTable (new[] {  									filesets [ix].Value  								}' tr).ToArray ();  								foreach (var f in lst)  									db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  								tr.Commit ();  								backend.Put (vol' synchronous: true);  								backend.Delete (prevfilename' -1' true);  								backend.FlushDbMessages ();  							}  						}  				}  			}  		}  		currentprogress += (versionprogress / 2);  		m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	}  	if (doCompactStep) {  		if (m_result.RewrittenFileLists == 0) {  			m_result.AddMessage ("Skipping compacting as no new volumes were written");  		} else {  			m_result.OperationProgressUpdater.UpdateProgress (pgoffset + (0.75f * pgspan));  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Compact);  			m_result.CompactResults = new CompactResults (m_result);  			using (var cdb = new Database.LocalDeleteDatabase (db)) {  				var tr = cdb.BeginTransaction ();  				try {  					new CompactHandler (backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact (cdb' true' ref tr);  				} catch {  					try {  						tr.Rollback ();  					} catch {  					}  				} finally {  					try {  						tr.Commit ();  					} catch {  					}  				}  			}  		}  		m_result.OperationProgressUpdater.UpdateProgress (pgoffset + pgspan);  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Complete);  	}  	backend.WaitForComplete (db' null);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db)) {  	if (db.PartiallyRecreated)  		throw new UserInformationException ("The purge command does not work on partially recreated databases");  	if (db.RepairInProgress && filtercommand == null)  		throw new UserInformationException (string.Format ("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));  	var versions = db.GetFilesetIDs (m_options.Time' m_options.Version).ToArray ();  	if (versions.Length <= 0)  		throw new UserInformationException ("No filesets matched the supplied time or versions");  	var orphans = db.CountOrphanFiles (null);  	if (orphans != 0)  		throw new UserInformationException (string.Format ("Unable to start the purge process as there are {0} orphan file(s)"' orphans));  	Utility.UpdateOptionsFromDb (db' m_options);  	Utility.VerifyParameters (db' m_options);  	if (filtercommand == null) {  		db.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' false);  		if (m_options.NoBackendverification)  			FilelistProcessor.VerifyLocalList (backend' m_options' db' m_result.BackendWriter);  		else  			FilelistProcessor.VerifyRemoteList (backend' m_options' db' m_result.BackendWriter' null);  	}  	var filesets = db.FilesetTimes.ToArray ();  	var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;  	var currentprogress = pgoffset;  	m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Process);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	// Reverse makes sure we re-write the old versions first  	foreach (var versionid in versions.Reverse ()) {  		using (var tr = db.BeginTransaction ()) {  			var ix = -1;  			for (var i = 0; i < filesets.Length; i++)  				if (filesets [i].Key == versionid) {  					ix = i;  					break;  				}  			if (ix < 0)  				throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  			var secs = 0;  			while (secs < 60) {  				secs++;  				var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  				if (db.GetRemoteVolumeID (tfn' tr) < 0)  					break;  			}  			var ts = filesets [ix].Value.AddSeconds (secs);  			var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  			if (secs >= 60)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  			if (ix != 0 && filesets [ix - 1].Value <= ts)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  			using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  				if (filtercommand == null)  					tempset.ApplyFilter (filter);  				else  					tempset.ApplyFilter (filtercommand);  				if (tempset.RemovedFileCount == 0) {  					m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  					currentprogress += versionprogress;  					tr.Rollback ();  					continue;  				} else {  					using (var tf = new Library.Utility.TempFile ())  						using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  							var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  							vol.VolumeID = newids.Item1;  							m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  							db.WriteFileset (vol' tr' newids.Item2);  							m_result.RemovedFileSize += tempset.RemovedFileSize;  							m_result.RemovedFileCount += tempset.RemovedFileCount;  							m_result.RewrittenFileLists++;  							currentprogress += (versionprogress / 2);  							m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  							if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  								foreach (var fe in tempset.ListAllDeletedFiles ()) {  									var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  									if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  										Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  									if (m_options.Dryrun)  										m_result.AddDryrunMessage (msg);  									else if (m_options.Verbose)  										m_result.AddVerboseMessage (msg);  								}  								if (m_options.Dryrun)  									m_result.AddDryrunMessage ("Writing files to remote storage");  								else if (m_options.Verbose)  									m_result.AddVerboseMessage ("Writing files to remote storage");  							}  							if (m_options.Dryrun) {  								m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  								tr.Rollback ();  							} else {  								var lst = db.DropFilesetsFromTable (new[] {  									filesets [ix].Value  								}' tr).ToArray ();  								foreach (var f in lst)  									db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  								tr.Commit ();  								backend.Put (vol' synchronous: true);  								backend.Delete (prevfilename' -1' true);  								backend.FlushDbMessages ();  							}  						}  				}  			}  		}  		currentprogress += (versionprogress / 2);  		m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	}  	if (doCompactStep) {  		if (m_result.RewrittenFileLists == 0) {  			m_result.AddMessage ("Skipping compacting as no new volumes were written");  		} else {  			m_result.OperationProgressUpdater.UpdateProgress (pgoffset + (0.75f * pgspan));  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Compact);  			m_result.CompactResults = new CompactResults (m_result);  			using (var cdb = new Database.LocalDeleteDatabase (db)) {  				var tr = cdb.BeginTransaction ();  				try {  					new CompactHandler (backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact (cdb' true' ref tr);  				} catch {  					try {  						tr.Rollback ();  					} catch {  					}  				} finally {  					try {  						tr.Commit ();  					} catch {  					}  				}  			}  		}  		m_result.OperationProgressUpdater.UpdateProgress (pgoffset + pgspan);  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Complete);  	}  	backend.WaitForComplete (db' null);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var backend = new BackendManager (m_backendurl' m_options' m_result.BackendWriter' db)) {  	if (db.PartiallyRecreated)  		throw new UserInformationException ("The purge command does not work on partially recreated databases");  	if (db.RepairInProgress && filtercommand == null)  		throw new UserInformationException (string.Format ("The purge command does not work on an incomplete database' try the {0} operation."' "purge-broken-files"));  	var versions = db.GetFilesetIDs (m_options.Time' m_options.Version).ToArray ();  	if (versions.Length <= 0)  		throw new UserInformationException ("No filesets matched the supplied time or versions");  	var orphans = db.CountOrphanFiles (null);  	if (orphans != 0)  		throw new UserInformationException (string.Format ("Unable to start the purge process as there are {0} orphan file(s)"' orphans));  	Utility.UpdateOptionsFromDb (db' m_options);  	Utility.VerifyParameters (db' m_options);  	if (filtercommand == null) {  		db.VerifyConsistency (null' m_options.Blocksize' m_options.BlockhashSize' false);  		if (m_options.NoBackendverification)  			FilelistProcessor.VerifyLocalList (backend' m_options' db' m_result.BackendWriter);  		else  			FilelistProcessor.VerifyRemoteList (backend' m_options' db' m_result.BackendWriter' null);  	}  	var filesets = db.FilesetTimes.ToArray ();  	var versionprogress = ((doCompactStep ? 0.75f : 1.0f) / versions.Length) * pgspan;  	var currentprogress = pgoffset;  	m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Process);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	// Reverse makes sure we re-write the old versions first  	foreach (var versionid in versions.Reverse ()) {  		using (var tr = db.BeginTransaction ()) {  			var ix = -1;  			for (var i = 0; i < filesets.Length; i++)  				if (filesets [i].Key == versionid) {  					ix = i;  					break;  				}  			if (ix < 0)  				throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  			var secs = 0;  			while (secs < 60) {  				secs++;  				var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  				if (db.GetRemoteVolumeID (tfn' tr) < 0)  					break;  			}  			var ts = filesets [ix].Value.AddSeconds (secs);  			var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  			if (secs >= 60)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  			if (ix != 0 && filesets [ix - 1].Value <= ts)  				throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  			using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  				if (filtercommand == null)  					tempset.ApplyFilter (filter);  				else  					tempset.ApplyFilter (filtercommand);  				if (tempset.RemovedFileCount == 0) {  					m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  					currentprogress += versionprogress;  					tr.Rollback ();  					continue;  				} else {  					using (var tf = new Library.Utility.TempFile ())  						using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  							var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  							vol.VolumeID = newids.Item1;  							m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  							db.WriteFileset (vol' tr' newids.Item2);  							m_result.RemovedFileSize += tempset.RemovedFileSize;  							m_result.RemovedFileCount += tempset.RemovedFileCount;  							m_result.RewrittenFileLists++;  							currentprogress += (versionprogress / 2);  							m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  							if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  								foreach (var fe in tempset.ListAllDeletedFiles ()) {  									var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  									if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  										Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  									if (m_options.Dryrun)  										m_result.AddDryrunMessage (msg);  									else if (m_options.Verbose)  										m_result.AddVerboseMessage (msg);  								}  								if (m_options.Dryrun)  									m_result.AddDryrunMessage ("Writing files to remote storage");  								else if (m_options.Verbose)  									m_result.AddVerboseMessage ("Writing files to remote storage");  							}  							if (m_options.Dryrun) {  								m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  								tr.Rollback ();  							} else {  								var lst = db.DropFilesetsFromTable (new[] {  									filesets [ix].Value  								}' tr).ToArray ();  								foreach (var f in lst)  									db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  								tr.Commit ();  								backend.Put (vol' synchronous: true);  								backend.Delete (prevfilename' -1' true);  								backend.FlushDbMessages ();  							}  						}  				}  			}  		}  		currentprogress += (versionprogress / 2);  		m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	}  	if (doCompactStep) {  		if (m_result.RewrittenFileLists == 0) {  			m_result.AddMessage ("Skipping compacting as no new volumes were written");  		} else {  			m_result.OperationProgressUpdater.UpdateProgress (pgoffset + (0.75f * pgspan));  			m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Compact);  			m_result.CompactResults = new CompactResults (m_result);  			using (var cdb = new Database.LocalDeleteDatabase (db)) {  				var tr = cdb.BeginTransaction ();  				try {  					new CompactHandler (backend.BackendUrl' m_options' (CompactResults)m_result.CompactResults).DoCompact (cdb' true' ref tr);  				} catch {  					try {  						tr.Rollback ();  					} catch {  					}  				} finally {  					try {  						tr.Commit ();  					} catch {  					}  				}  			}  		}  		m_result.OperationProgressUpdater.UpdateProgress (pgoffset + pgspan);  		m_result.OperationProgressUpdater.UpdatePhase (OperationPhase.PurgeFiles_Complete);  	}  	backend.WaitForComplete (db' null);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: foreach (var versionid in versions.Reverse ()) {  	using (var tr = db.BeginTransaction ()) {  		var ix = -1;  		for (var i = 0; i < filesets.Length; i++)  			if (filesets [i].Key == versionid) {  				ix = i;  				break;  			}  		if (ix < 0)  			throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  		var secs = 0;  		while (secs < 60) {  			secs++;  			var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  			if (db.GetRemoteVolumeID (tfn' tr) < 0)  				break;  		}  		var ts = filesets [ix].Value.AddSeconds (secs);  		var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  		if (secs >= 60)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  		if (ix != 0 && filesets [ix - 1].Value <= ts)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  		using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  			if (filtercommand == null)  				tempset.ApplyFilter (filter);  			else  				tempset.ApplyFilter (filtercommand);  			if (tempset.RemovedFileCount == 0) {  				m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  				currentprogress += versionprogress;  				tr.Rollback ();  				continue;  			} else {  				using (var tf = new Library.Utility.TempFile ())  					using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  						var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  						vol.VolumeID = newids.Item1;  						m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  						db.WriteFileset (vol' tr' newids.Item2);  						m_result.RemovedFileSize += tempset.RemovedFileSize;  						m_result.RemovedFileCount += tempset.RemovedFileCount;  						m_result.RewrittenFileLists++;  						currentprogress += (versionprogress / 2);  						m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  						if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  							foreach (var fe in tempset.ListAllDeletedFiles ()) {  								var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  								if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  									Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  								if (m_options.Dryrun)  									m_result.AddDryrunMessage (msg);  								else if (m_options.Verbose)  									m_result.AddVerboseMessage (msg);  							}  							if (m_options.Dryrun)  								m_result.AddDryrunMessage ("Writing files to remote storage");  							else if (m_options.Verbose)  								m_result.AddVerboseMessage ("Writing files to remote storage");  						}  						if (m_options.Dryrun) {  							m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  							tr.Rollback ();  						} else {  							var lst = db.DropFilesetsFromTable (new[] {  								filesets [ix].Value  							}' tr).ToArray ();  							foreach (var f in lst)  								db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  							tr.Commit ();  							backend.Put (vol' synchronous: true);  							backend.Delete (prevfilename' -1' true);  							backend.FlushDbMessages ();  						}  					}  			}  		}  	}  	currentprogress += (versionprogress / 2);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: foreach (var versionid in versions.Reverse ()) {  	using (var tr = db.BeginTransaction ()) {  		var ix = -1;  		for (var i = 0; i < filesets.Length; i++)  			if (filesets [i].Key == versionid) {  				ix = i;  				break;  			}  		if (ix < 0)  			throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  		var secs = 0;  		while (secs < 60) {  			secs++;  			var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  			if (db.GetRemoteVolumeID (tfn' tr) < 0)  				break;  		}  		var ts = filesets [ix].Value.AddSeconds (secs);  		var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  		if (secs >= 60)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  		if (ix != 0 && filesets [ix - 1].Value <= ts)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  		using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  			if (filtercommand == null)  				tempset.ApplyFilter (filter);  			else  				tempset.ApplyFilter (filtercommand);  			if (tempset.RemovedFileCount == 0) {  				m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  				currentprogress += versionprogress;  				tr.Rollback ();  				continue;  			} else {  				using (var tf = new Library.Utility.TempFile ())  					using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  						var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  						vol.VolumeID = newids.Item1;  						m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  						db.WriteFileset (vol' tr' newids.Item2);  						m_result.RemovedFileSize += tempset.RemovedFileSize;  						m_result.RemovedFileCount += tempset.RemovedFileCount;  						m_result.RewrittenFileLists++;  						currentprogress += (versionprogress / 2);  						m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  						if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  							foreach (var fe in tempset.ListAllDeletedFiles ()) {  								var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  								if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  									Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  								if (m_options.Dryrun)  									m_result.AddDryrunMessage (msg);  								else if (m_options.Verbose)  									m_result.AddVerboseMessage (msg);  							}  							if (m_options.Dryrun)  								m_result.AddDryrunMessage ("Writing files to remote storage");  							else if (m_options.Verbose)  								m_result.AddVerboseMessage ("Writing files to remote storage");  						}  						if (m_options.Dryrun) {  							m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  							tr.Rollback ();  						} else {  							var lst = db.DropFilesetsFromTable (new[] {  								filesets [ix].Value  							}' tr).ToArray ();  							foreach (var f in lst)  								db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  							tr.Commit ();  							backend.Put (vol' synchronous: true);  							backend.Delete (prevfilename' -1' true);  							backend.FlushDbMessages ();  						}  					}  			}  		}  	}  	currentprogress += (versionprogress / 2);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: foreach (var versionid in versions.Reverse ()) {  	using (var tr = db.BeginTransaction ()) {  		var ix = -1;  		for (var i = 0; i < filesets.Length; i++)  			if (filesets [i].Key == versionid) {  				ix = i;  				break;  			}  		if (ix < 0)  			throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  		var secs = 0;  		while (secs < 60) {  			secs++;  			var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  			if (db.GetRemoteVolumeID (tfn' tr) < 0)  				break;  		}  		var ts = filesets [ix].Value.AddSeconds (secs);  		var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  		if (secs >= 60)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  		if (ix != 0 && filesets [ix - 1].Value <= ts)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  		using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  			if (filtercommand == null)  				tempset.ApplyFilter (filter);  			else  				tempset.ApplyFilter (filtercommand);  			if (tempset.RemovedFileCount == 0) {  				m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  				currentprogress += versionprogress;  				tr.Rollback ();  				continue;  			} else {  				using (var tf = new Library.Utility.TempFile ())  					using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  						var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  						vol.VolumeID = newids.Item1;  						m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  						db.WriteFileset (vol' tr' newids.Item2);  						m_result.RemovedFileSize += tempset.RemovedFileSize;  						m_result.RemovedFileCount += tempset.RemovedFileCount;  						m_result.RewrittenFileLists++;  						currentprogress += (versionprogress / 2);  						m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  						if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  							foreach (var fe in tempset.ListAllDeletedFiles ()) {  								var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  								if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  									Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  								if (m_options.Dryrun)  									m_result.AddDryrunMessage (msg);  								else if (m_options.Verbose)  									m_result.AddVerboseMessage (msg);  							}  							if (m_options.Dryrun)  								m_result.AddDryrunMessage ("Writing files to remote storage");  							else if (m_options.Verbose)  								m_result.AddVerboseMessage ("Writing files to remote storage");  						}  						if (m_options.Dryrun) {  							m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  							tr.Rollback ();  						} else {  							var lst = db.DropFilesetsFromTable (new[] {  								filesets [ix].Value  							}' tr).ToArray ();  							foreach (var f in lst)  								db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  							tr.Commit ();  							backend.Put (vol' synchronous: true);  							backend.Delete (prevfilename' -1' true);  							backend.FlushDbMessages ();  						}  					}  			}  		}  	}  	currentprogress += (versionprogress / 2);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: foreach (var versionid in versions.Reverse ()) {  	using (var tr = db.BeginTransaction ()) {  		var ix = -1;  		for (var i = 0; i < filesets.Length; i++)  			if (filesets [i].Key == versionid) {  				ix = i;  				break;  			}  		if (ix < 0)  			throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  		var secs = 0;  		while (secs < 60) {  			secs++;  			var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  			if (db.GetRemoteVolumeID (tfn' tr) < 0)  				break;  		}  		var ts = filesets [ix].Value.AddSeconds (secs);  		var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  		if (secs >= 60)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  		if (ix != 0 && filesets [ix - 1].Value <= ts)  			throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  		using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  			if (filtercommand == null)  				tempset.ApplyFilter (filter);  			else  				tempset.ApplyFilter (filtercommand);  			if (tempset.RemovedFileCount == 0) {  				m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  				currentprogress += versionprogress;  				tr.Rollback ();  				continue;  			} else {  				using (var tf = new Library.Utility.TempFile ())  					using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  						var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  						vol.VolumeID = newids.Item1;  						m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  						db.WriteFileset (vol' tr' newids.Item2);  						m_result.RemovedFileSize += tempset.RemovedFileSize;  						m_result.RemovedFileCount += tempset.RemovedFileCount;  						m_result.RewrittenFileLists++;  						currentprogress += (versionprogress / 2);  						m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  						if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  							foreach (var fe in tempset.ListAllDeletedFiles ()) {  								var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  								if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  									Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  								if (m_options.Dryrun)  									m_result.AddDryrunMessage (msg);  								else if (m_options.Verbose)  									m_result.AddVerboseMessage (msg);  							}  							if (m_options.Dryrun)  								m_result.AddDryrunMessage ("Writing files to remote storage");  							else if (m_options.Verbose)  								m_result.AddVerboseMessage ("Writing files to remote storage");  						}  						if (m_options.Dryrun) {  							m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  							tr.Rollback ();  						} else {  							var lst = db.DropFilesetsFromTable (new[] {  								filesets [ix].Value  							}' tr).ToArray ();  							foreach (var f in lst)  								db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  							tr.Commit ();  							backend.Put (vol' synchronous: true);  							backend.Delete (prevfilename' -1' true);  							backend.FlushDbMessages ();  						}  					}  			}  		}  	}  	currentprogress += (versionprogress / 2);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var tr = db.BeginTransaction ()) {  	var ix = -1;  	for (var i = 0; i < filesets.Length; i++)  		if (filesets [i].Key == versionid) {  			ix = i;  			break;  		}  	if (ix < 0)  		throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  	var secs = 0;  	while (secs < 60) {  		secs++;  		var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  		if (db.GetRemoteVolumeID (tfn' tr) < 0)  			break;  	}  	var ts = filesets [ix].Value.AddSeconds (secs);  	var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  	if (secs >= 60)  		throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  	if (ix != 0 && filesets [ix - 1].Value <= ts)  		throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  	using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  		if (filtercommand == null)  			tempset.ApplyFilter (filter);  		else  			tempset.ApplyFilter (filtercommand);  		if (tempset.RemovedFileCount == 0) {  			m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  			currentprogress += versionprogress;  			tr.Rollback ();  			continue;  		} else {  			using (var tf = new Library.Utility.TempFile ())  				using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  					var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  					vol.VolumeID = newids.Item1;  					m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  					db.WriteFileset (vol' tr' newids.Item2);  					m_result.RemovedFileSize += tempset.RemovedFileSize;  					m_result.RemovedFileCount += tempset.RemovedFileCount;  					m_result.RewrittenFileLists++;  					currentprogress += (versionprogress / 2);  					m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  					if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  						foreach (var fe in tempset.ListAllDeletedFiles ()) {  							var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  							if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  								Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  							if (m_options.Dryrun)  								m_result.AddDryrunMessage (msg);  							else if (m_options.Verbose)  								m_result.AddVerboseMessage (msg);  						}  						if (m_options.Dryrun)  							m_result.AddDryrunMessage ("Writing files to remote storage");  						else if (m_options.Verbose)  							m_result.AddVerboseMessage ("Writing files to remote storage");  					}  					if (m_options.Dryrun) {  						m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  						tr.Rollback ();  					} else {  						var lst = db.DropFilesetsFromTable (new[] {  							filesets [ix].Value  						}' tr).ToArray ();  						foreach (var f in lst)  							db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  						tr.Commit ();  						backend.Put (vol' synchronous: true);  						backend.Delete (prevfilename' -1' true);  						backend.FlushDbMessages ();  					}  				}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var tr = db.BeginTransaction ()) {  	var ix = -1;  	for (var i = 0; i < filesets.Length; i++)  		if (filesets [i].Key == versionid) {  			ix = i;  			break;  		}  	if (ix < 0)  		throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  	var secs = 0;  	while (secs < 60) {  		secs++;  		var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  		if (db.GetRemoteVolumeID (tfn' tr) < 0)  			break;  	}  	var ts = filesets [ix].Value.AddSeconds (secs);  	var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  	if (secs >= 60)  		throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  	if (ix != 0 && filesets [ix - 1].Value <= ts)  		throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  	using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  		if (filtercommand == null)  			tempset.ApplyFilter (filter);  		else  			tempset.ApplyFilter (filtercommand);  		if (tempset.RemovedFileCount == 0) {  			m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  			currentprogress += versionprogress;  			tr.Rollback ();  			continue;  		} else {  			using (var tf = new Library.Utility.TempFile ())  				using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  					var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  					vol.VolumeID = newids.Item1;  					m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  					db.WriteFileset (vol' tr' newids.Item2);  					m_result.RemovedFileSize += tempset.RemovedFileSize;  					m_result.RemovedFileCount += tempset.RemovedFileCount;  					m_result.RewrittenFileLists++;  					currentprogress += (versionprogress / 2);  					m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  					if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  						foreach (var fe in tempset.ListAllDeletedFiles ()) {  							var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  							if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  								Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  							if (m_options.Dryrun)  								m_result.AddDryrunMessage (msg);  							else if (m_options.Verbose)  								m_result.AddVerboseMessage (msg);  						}  						if (m_options.Dryrun)  							m_result.AddDryrunMessage ("Writing files to remote storage");  						else if (m_options.Verbose)  							m_result.AddVerboseMessage ("Writing files to remote storage");  					}  					if (m_options.Dryrun) {  						m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  						tr.Rollback ();  					} else {  						var lst = db.DropFilesetsFromTable (new[] {  							filesets [ix].Value  						}' tr).ToArray ();  						foreach (var f in lst)  							db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  						tr.Commit ();  						backend.Put (vol' synchronous: true);  						backend.Delete (prevfilename' -1' true);  						backend.FlushDbMessages ();  					}  				}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var tr = db.BeginTransaction ()) {  	var ix = -1;  	for (var i = 0; i < filesets.Length; i++)  		if (filesets [i].Key == versionid) {  			ix = i;  			break;  		}  	if (ix < 0)  		throw new InvalidProgramException (string.Format ("Fileset was reported with id {0}' but could not be found?"' versionid));  	var secs = 0;  	while (secs < 60) {  		secs++;  		var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  		if (db.GetRemoteVolumeID (tfn' tr) < 0)  			break;  	}  	var ts = filesets [ix].Value.AddSeconds (secs);  	var prevfilename = db.GetRemoteVolumeNameForFileset (filesets [ix].Key' tr);  	if (secs >= 60)  		throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  	if (ix != 0 && filesets [ix - 1].Value <= ts)  		throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}"' prevfilename' ts' filesets [ix - 1].Value));  	using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  		if (filtercommand == null)  			tempset.ApplyFilter (filter);  		else  			tempset.ApplyFilter (filtercommand);  		if (tempset.RemovedFileCount == 0) {  			m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  			currentprogress += versionprogress;  			tr.Rollback ();  			continue;  		} else {  			using (var tf = new Library.Utility.TempFile ())  				using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  					var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  					vol.VolumeID = newids.Item1;  					m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  					db.WriteFileset (vol' tr' newids.Item2);  					m_result.RemovedFileSize += tempset.RemovedFileSize;  					m_result.RemovedFileCount += tempset.RemovedFileCount;  					m_result.RewrittenFileLists++;  					currentprogress += (versionprogress / 2);  					m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  					if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  						foreach (var fe in tempset.ListAllDeletedFiles ()) {  							var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  							if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  								Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  							if (m_options.Dryrun)  								m_result.AddDryrunMessage (msg);  							else if (m_options.Verbose)  								m_result.AddVerboseMessage (msg);  						}  						if (m_options.Dryrun)  							m_result.AddDryrunMessage ("Writing files to remote storage");  						else if (m_options.Verbose)  							m_result.AddVerboseMessage ("Writing files to remote storage");  					}  					if (m_options.Dryrun) {  						m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  						tr.Rollback ();  					} else {  						var lst = db.DropFilesetsFromTable (new[] {  							filesets [ix].Value  						}' tr).ToArray ();  						foreach (var f in lst)  							db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  						tr.Commit ();  						backend.Put (vol' synchronous: true);  						backend.Delete (prevfilename' -1' true);  						backend.FlushDbMessages ();  					}  				}  		}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: while (secs < 60) {  	secs++;  	var tfn = Volumes.VolumeBase.GenerateFilename (RemoteVolumeType.Files' m_options' null' filesets [ix].Value.AddSeconds (secs));  	if (db.GetRemoteVolumeID (tfn' tr) < 0)  		break;  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: if (secs >= 60)  	throw new Exception (string.Format ("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away"' prevfilename' ts));  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var tempset = db.CreateTemporaryFileset (versionid' tr)) {  	if (filtercommand == null)  		tempset.ApplyFilter (filter);  	else  		tempset.ApplyFilter (filtercommand);  	if (tempset.RemovedFileCount == 0) {  		m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  		currentprogress += versionprogress;  		tr.Rollback ();  		continue;  	} else {  		using (var tf = new Library.Utility.TempFile ())  			using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  				var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  				vol.VolumeID = newids.Item1;  				m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  				db.WriteFileset (vol' tr' newids.Item2);  				m_result.RemovedFileSize += tempset.RemovedFileSize;  				m_result.RemovedFileCount += tempset.RemovedFileCount;  				m_result.RewrittenFileLists++;  				currentprogress += (versionprogress / 2);  				m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  				if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  					foreach (var fe in tempset.ListAllDeletedFiles ()) {  						var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  						if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  							Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  						if (m_options.Dryrun)  							m_result.AddDryrunMessage (msg);  						else if (m_options.Verbose)  							m_result.AddVerboseMessage (msg);  					}  					if (m_options.Dryrun)  						m_result.AddDryrunMessage ("Writing files to remote storage");  					else if (m_options.Verbose)  						m_result.AddVerboseMessage ("Writing files to remote storage");  				}  				if (m_options.Dryrun) {  					m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  					tr.Rollback ();  				} else {  					var lst = db.DropFilesetsFromTable (new[] {  						filesets [ix].Value  					}' tr).ToArray ();  					foreach (var f in lst)  						db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  					tr.Commit ();  					backend.Put (vol' synchronous: true);  					backend.Delete (prevfilename' -1' true);  					backend.FlushDbMessages ();  				}  			}  	}  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: if (tempset.RemovedFileCount == 0) {  	m_result.AddMessage (string.Format ("Not writing a new fileset for {0} as it was not changed"' prevfilename));  	currentprogress += versionprogress;  	tr.Rollback ();  	continue;  } else {  	using (var tf = new Library.Utility.TempFile ())  		using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  			var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  			vol.VolumeID = newids.Item1;  			m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  			db.WriteFileset (vol' tr' newids.Item2);  			m_result.RemovedFileSize += tempset.RemovedFileSize;  			m_result.RemovedFileCount += tempset.RemovedFileCount;  			m_result.RewrittenFileLists++;  			currentprogress += (versionprogress / 2);  			m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  			if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  				foreach (var fe in tempset.ListAllDeletedFiles ()) {  					var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  					if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  						Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  					if (m_options.Dryrun)  						m_result.AddDryrunMessage (msg);  					else if (m_options.Verbose)  						m_result.AddVerboseMessage (msg);  				}  				if (m_options.Dryrun)  					m_result.AddDryrunMessage ("Writing files to remote storage");  				else if (m_options.Verbose)  					m_result.AddVerboseMessage ("Writing files to remote storage");  			}  			if (m_options.Dryrun) {  				m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  				tr.Rollback ();  			} else {  				var lst = db.DropFilesetsFromTable (new[] {  					filesets [ix].Value  				}' tr).ToArray ();  				foreach (var f in lst)  					db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  				tr.Commit ();  				backend.Put (vol' synchronous: true);  				backend.Delete (prevfilename' -1' true);  				backend.FlushDbMessages ();  			}  		}  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var tf = new Library.Utility.TempFile ())  	using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  		var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  		vol.VolumeID = newids.Item1;  		m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  		db.WriteFileset (vol' tr' newids.Item2);  		m_result.RemovedFileSize += tempset.RemovedFileSize;  		m_result.RemovedFileCount += tempset.RemovedFileCount;  		m_result.RewrittenFileLists++;  		currentprogress += (versionprogress / 2);  		m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  		if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  			foreach (var fe in tempset.ListAllDeletedFiles ()) {  				var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  				if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  					Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  				if (m_options.Dryrun)  					m_result.AddDryrunMessage (msg);  				else if (m_options.Verbose)  					m_result.AddVerboseMessage (msg);  			}  			if (m_options.Dryrun)  				m_result.AddDryrunMessage ("Writing files to remote storage");  			else if (m_options.Verbose)  				m_result.AddVerboseMessage ("Writing files to remote storage");  		}  		if (m_options.Dryrun) {  			m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  			tr.Rollback ();  		} else {  			var lst = db.DropFilesetsFromTable (new[] {  				filesets [ix].Value  			}' tr).ToArray ();  			foreach (var f in lst)  				db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  			tr.Commit ();  			backend.Put (vol' synchronous: true);  			backend.Delete (prevfilename' -1' true);  			backend.FlushDbMessages ();  		}  	}  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: using (var vol = new Volumes.FilesetVolumeWriter (m_options' ts)) {  	var newids = tempset.ConvertToPermanentFileset (vol.RemoteFilename' ts);  	vol.VolumeID = newids.Item1;  	m_result.AddMessage (string.Format ("Replacing fileset {0} with {1} which has with {2} fewer file(s) ({3} reduction)"' prevfilename' vol.RemoteFilename' tempset.RemovedFileCount' Library.Utility.Utility.FormatSizeString (tempset.RemovedFileSize)));  	db.WriteFileset (vol' tr' newids.Item2);  	m_result.RemovedFileSize += tempset.RemovedFileSize;  	m_result.RemovedFileCount += tempset.RemovedFileCount;  	m_result.RewrittenFileLists++;  	currentprogress += (versionprogress / 2);  	m_result.OperationProgressUpdater.UpdateProgress (currentprogress);  	if (m_options.Dryrun || m_options.Verbose || Logging.Log.LogLevel == Logging.LogMessageType.Profiling) {  		foreach (var fe in tempset.ListAllDeletedFiles ()) {  			var msg = string.Format ("  Purging file {0} ({1})"' fe.Key' Library.Utility.Utility.FormatSizeString (fe.Value));  			if (Logging.Log.LogLevel == Logging.LogMessageType.Profiling)  				Logging.Log.WriteMessage (msg' Logging.LogMessageType.Profiling);  			if (m_options.Dryrun)  				m_result.AddDryrunMessage (msg);  			else if (m_options.Verbose)  				m_result.AddVerboseMessage (msg);  		}  		if (m_options.Dryrun)  			m_result.AddDryrunMessage ("Writing files to remote storage");  		else if (m_options.Verbose)  			m_result.AddVerboseMessage ("Writing files to remote storage");  	}  	if (m_options.Dryrun) {  		m_result.AddDryrunMessage (string.Format ("Would upload file {0} ({1}) and delete file {2}' removing {3} files"' vol.RemoteFilename' Library.Utility.Utility.FormatSizeString (vol.Filesize)' prevfilename' tempset.RemovedFileCount));  		tr.Rollback ();  	} else {  		var lst = db.DropFilesetsFromTable (new[] {  			filesets [ix].Value  		}' tr).ToArray ();  		foreach (var f in lst)  			db.UpdateRemoteVolume (f.Key' RemoteVolumeState.Deleting' f.Value' null' tr);  		tr.Commit ();  		backend.Put (vol' synchronous: true);  		backend.Delete (prevfilename' -1' true);  		backend.FlushDbMessages ();  	}  }  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: currentprogress += (versionprogress / 2);  
Magic Number,Duplicati.Library.Main.Operation,PurgeFilesHandler,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\Operation\PurgeFilesHandler.cs,DoRun,The following statement contains a magic number: currentprogress += (versionprogress / 2);  
Missing Default,Duplicati.Library.Main,BackendManager,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\BackendManager.cs,ThreadRun,The following switch statement is missing a default case: switch (item.Operation) {  case OperationType.Put:  	DoPut (item);  	// We do not auto create folders'  	// because we know the folder exists  	uploadSuccess = true;  	break;  case OperationType.Get:  	DoGet (item);  	break;  case OperationType.List:  	DoList (item);  	break;  case OperationType.Delete:  	DoDelete (item);  	break;  case OperationType.CreateFolder:  	DoCreateFolder (item);  	break;  case OperationType.Terminate:  	m_queue.SetCompleted ();  	break;  case OperationType.Nothing:  	item.SignalComplete ();  	break;  }  
Missing Default,Duplicati.Library.Main,BackendWriter,F:\newReposMay17\duplicati_duplicati\Duplicati\Library\Main\ResultClasses.cs,SendEvent,The following switch statement is missing a default case: switch (action) {  case BackendActionType.CreateFolder:  	System.Threading.Interlocked.Increment (ref m_foldersCreated);  	break;  case BackendActionType.List:  	break;  case BackendActionType.Delete:  	System.Threading.Interlocked.Increment (ref m_filesDeleted);  	break;  case BackendActionType.Get:  	System.Threading.Interlocked.Increment (ref m_filesDownloaded);  	System.Threading.Interlocked.Add (ref m_bytesDownloaded' size);  	break;  case BackendActionType.Put:  	System.Threading.Interlocked.Increment (ref m_filesUploaded);  	System.Threading.Interlocked.Add (ref m_bytesUploaded' size);  	break;  }  
