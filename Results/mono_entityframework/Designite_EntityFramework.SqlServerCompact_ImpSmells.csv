Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,GetEdmType,The method has 112 lines of code.
Long Method,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,GetStoreType,The method has 127 lines of code.
Long Method,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,Visit,The method has 119 lines of code.
Long Method,System.Data.Entity.SqlServerCompact.SqlGen,SqlSelectStatement,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlSelectStatement.cs,WriteSql,The method has 121 lines of code.
Complex Method,System.Data.Entity.SqlServerCompact,SqlCeProviderServices,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderServices.cs,CreateSqlCeParameter,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Entity.SqlServerCompact.SqlGen,SqlSelectStatement,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlSelectStatement.cs,WriteSql,Cyclomatic complexity of the method is 17
Long Parameter List,System.Data.Entity.SqlServerCompact,SqlCeProviderServices,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderServices.cs,CreateSqlCeParameter,The method has 5 parameters. Parameters: name' type' value' ignoreMaxLengthFacet' isLocalProvider
Long Parameter List,System.Data.Entity.SqlServerCompact.SqlGen,DmlSqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\DmlSqlGenerator.cs,HandleIdentity,The method has 5 parameters. Parameters: commandText' translator' member' flag' target
Long Parameter List,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,AddColumns,The method has 5 parameters. Parameters: selectStatement' symbol' columnList' columnDictionary' separator
Long Parameter List,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,AddColumn,The method has 6 parameters. Parameters: selectStatement' symbol' columnList' columnDictionary' separator' columnName
Long Parameter List,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,CreateNewSelectStatement,The method has 5 parameters. Parameters: oldStatement' inputVarName' inputVarType' finalizeOldStatement' fromSymbol
Long Identifier,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,,The length of the parameter storeSchemaDescriptionFileForRDP is 32.
Long Identifier,System.Data.Entity.SqlServerCompact.SqlGen,DmlSqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\DmlSqlGenerator.cs,,The length of the parameter s_commandTextBuilderInitialCapacity is 35.
Long Identifier,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,InitializeFunctionNameToOperatorDictionary,The length of the parameter functionNameToOperatorDictionary is 32.
Long Identifier,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,,The length of the parameter _functionNameToOperatorDictionary is 33.
Long Identifier,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,,The length of the parameter _functionRequiresReturnTypeCast is 31.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter ADP_CanNotRetrieveServerGeneratedKey is 36.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter Mapping_Provider_WrongConnectionType is 36.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter Update_SqlEntitySetWithoutDmlFunctions is 38.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter Mapping_Provider_WrongManifestType is 34.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter ProviderReturnedNullForGetDbInformation is 39.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter InvalidDatePartArgumentExpression is 33.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter NiladicFunctionsCannotHaveParameters is 36.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter UserDefinedFunctionsNotSupported is 32.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter DistinctAggregatesNotSupported is 30.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter UpdateStatementCannotBeGeneratedForAcquiringLock is 48.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter Update_NotSupportedServerGenKey is 31.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter Update_NotSupportedIdentityType is 31.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter ADP_NotSupportedEnumerationValue is 32.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter ADP_InvalidConnectionOptionValue is 32.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter InvalidConnectionTypeException is 30.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter ServerGeneratedGuidKeyNotSupported is 34.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter DeleteDatabaseNotAllowedWithinTransaction is 41.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter CreateDatabaseNotAllowedWithinTransaction is 41.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter DeleteDatabaseWithOpenConnection is 32.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter ColumnGreaterThanMaxLengthNotSupported is 38.
Long Identifier,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,,The length of the parameter SqlServerMigrationSqlGenerator_UnknownOperation is 47.
Long Statement,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteReader,The length of the statement  "                // index == 1' means there are multiple commands in this SqlCeMultiCommand. Which indicates Server generated keys scenario. " is 123.
Long Statement,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteResultSet,The length of the statement  "                // index == 1' means there are multiple commands in this SqlCeMultiCommand. Which indicates Server generated keys scenario. " is 123.
Long Statement,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteNonQuery,The length of the statement  "                // index == 1' means there are multiple commands in this SqlCeMultiCommand. Which indicates Server generated keys scenario. " is 123.
Long Statement,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteScalar,The length of the statement  "                // index == 1' means there are multiple commands in this SqlCeMultiCommand. Which indicates Server generated keys scenario. " is 123.
Long Statement,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,GetDbInformation,The length of the statement  "            throw ADP1.ProviderIncompatible(EntityRes.GetString(EntityRes.ProviderReturnedNullForGetDbInformation' informationType)); " is 121.
Long Statement,System.Data.Entity.SqlServerCompact,SqlDdlBuilder,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlDdlBuilder.cs,AppendType,The length of the statement  "                        //throw EntityUtil.NotSupported(Strings.SqlProvider_DdlGeneration_StoreGeneratedPatternNotSupported(Enum.GetName(typeof(StoreGeneratedPattern)' storeGenPattern))); " is 163.
Long Statement,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "                    return VisitBinaryExpression(" <> "' DbExpressionKind.NotEquals' comparisonExpression.Left' comparisonExpression.Right); " is 120.
Long Statement,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,HandleSpecialFunctionToOperator,The length of the statement  "            Debug.Assert(_functionNameToOperatorDictionary.ContainsKey(e.Function.Name)' "The function can not be mapped to an operator"); " is 126.
Long Statement,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,TransformIntersectOrExcept,The length of the statement  "            var newRightSelectStatement = CreateNewSelectStatement(inputRightStatement' "b"' rightCollectionType.TypeUsage' out rightSymbol); " is 129.
Long Statement,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,TransformIntersectOrExcept,The length of the statement  "            var newSelectStatement = CreateNewSelectStatement(inputLeftStatement' "a"' leftCollectionType.TypeUsage' out leftSymbol); " is 121.
Complex Conditional,System.Data.Entity.SqlServerCompact,SqlDdlBuilder,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlDdlBuilder.cs,AppendType,The conditional expression  "type.EdmType.Name == "binary"                  &&                  8 == (int)type.Facets["MaxLength"].Value                  &&                  column.TypeUsage.Facets.TryGetValue("StoreGeneratedPattern"' false' out storeGenFacet)                  &&                  storeGenFacet.Value != null                  &&                  StoreGeneratedPattern.Computed == (StoreGeneratedPattern)storeGenFacet.Value"  is complex.
Complex Conditional,System.Data.Entity.SqlServerCompact.SqlGen,SqlSelectStatement,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlSelectStatement.cs,WriteSql,The conditional expression  "(null != orderBy)                  && !OrderBy.IsEmpty                  && (IsTopMost || Top != null || Skip != null)"  is complex.
Complex Conditional,System.Data.Entity.Migrations.Sql,SqlCeMigrationSqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMigrationSqlGenerator.cs,Generate,The conditional expression  "(column.IsNullable != null)                      && !column.IsNullable.Value                      && (column.DefaultValue == null)                      && (string.IsNullOrWhiteSpace(column.DefaultValueSql))                      && !column.IsIdentity                      && !column.IsTimestamp                      && !column.StoreType.EqualsIgnoreCase("rowversion")                      && !column.StoreType.EqualsIgnoreCase("timestamp")"  is complex.
Empty Catch Block,System.Data.Entity.SqlServerCompact,RemoteProviderHelper,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\RemoteProviderHelper.cs,GetRemoteProviderType,The method has an empty catch block.
Empty Catch Block,System.Data.Entity.SqlServerCompact,RemoteProviderHelper,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\RemoteProviderHelper.cs,GetRemoteProviderType,The method has an empty catch block.
Empty Catch Block,System.Data.Entity.SqlServerCompact,RemoteProviderHelper,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\RemoteProviderHelper.cs,GetRemoteProviderType,The method has an empty catch block.
Magic Number,System.Data.Entity.SqlServerCompact.Utilities,DatabaseName,C:\repos\mono_entityframework\src\Common\DatabaseName.cs,Parse,The following statement contains a magic number: if (parts.Length > 2)              {                  throw Error.InvalidDatabaseName(name);              }
Magic Number,System.Data.Entity.SqlServerCompact.Utilities,DatabaseName,C:\repos\mono_entityframework\src\Common\DatabaseName.cs,Parse,The following statement contains a magic number: if (parts.Length == 2)              {                  schema = parts[0];                    if (string.IsNullOrWhiteSpace(schema))                  {                      throw Error.InvalidDatabaseName(name);                  }                    objectName = parts[1];              }              else              {                  objectName = parts[0];              }
Magic Number,System.Data.Entity.SqlServerCompact.Utilities,DatabaseName,C:\repos\mono_entityframework\src\Common\DatabaseName.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (_name.GetHashCode() * 397) ^ (_schema != null ? _schema.GetHashCode() : 0);              }
Magic Number,System.Data.Entity.SqlServerCompact.Utilities,StringExtensions,C:\repos\mono_entityframework\src\Common\StringExtensions.cs,MigrationName,The following statement contains a magic number: return migrationId.Substring(16);
Magic Number,System.Data.Entity.SqlServerCompact.Utilities,StringExtensions,C:\repos\mono_entityframework\src\Common\StringExtensions.cs,ToAutomaticMigrationId,The following statement contains a magic number: var timeStampInt = Convert.ToInt64(migrationId.Substring(0' 15)' CultureInfo.InvariantCulture) - 1;
Magic Number,System.Data.Entity.SqlServerCompact.Utilities,StringExtensions,C:\repos\mono_entityframework\src\Common\StringExtensions.cs,ToAutomaticMigrationId,The following statement contains a magic number: return timeStampInt + migrationId.Substring(15) + "_" + Strings.AutomaticMigration;
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteReader,The following statement contains a magic number: Debug.Assert(CommandTexts.Length == 1 || CommandTexts.Length == 2);
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteResultSet,The following statement contains a magic number: Debug.Assert(CommandTexts.Length == 1 || CommandTexts.Length == 2);
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteNonQuery,The following statement contains a magic number: Debug.Assert(CommandTexts.Length == 1 || CommandTexts.Length == 2);
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeMultiCommand,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMultiCommand.cs,ExecuteScalar,The following statement contains a magic number: Debug.Assert(CommandTexts.Length == 1 || CommandTexts.Length == 2);
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,GetEdmType,The following statement contains a magic number: switch (storeTypeName)              {                      // for some types we just go with simple type usage with no facets                  case "tinyint":                  case "smallint":                  case "bigint":                  case "bit":                  case "uniqueidentifier":                  case "int":                      return TypeUsage.CreateDefaultTypeUsage(edmPrimitiveType);                    case "nvarchar":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isUnicode = true;                      isFixedLen = false;                      break;                    case "nchar":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isUnicode = true;                      isFixedLen = true;                      break;                    case "ntext":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = true;                      isUnicode = true;                      isFixedLen = false;                      break;                    case "binary":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isFixedLen = true;                      break;                    case "varbinary":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isFixedLen = false;                      break;                    case "image":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = true;                      isFixedLen = false;                      break;                    case "timestamp":                  case "rowversion":                      return TypeUsage.CreateBinaryTypeUsage(edmPrimitiveType' true' 8);                    case "float":                  case "real":                      return TypeUsage.CreateDefaultTypeUsage(edmPrimitiveType);                    case "decimal":                  case "numeric":                      {                          byte precision;                          byte scale;                          if (TypeHelpers.TryGetPrecision(storeType' out precision)                              && TypeHelpers.TryGetScale(storeType' out scale))                          {                              return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType' precision' scale);                          }                          else                          {                              return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType);                          }                      }                    case "money":                      return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType' 19' 4);                    case "datetime":                      return TypeUsage.CreateDateTimeTypeUsage(edmPrimitiveType' null);                    default:                      throw ADP1.NotSupported(EntityRes.GetString(EntityRes.ProviderDoesNotSupportType' storeTypeName));              }
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,GetEdmType,The following statement contains a magic number: switch (storeTypeName)              {                      // for some types we just go with simple type usage with no facets                  case "tinyint":                  case "smallint":                  case "bigint":                  case "bit":                  case "uniqueidentifier":                  case "int":                      return TypeUsage.CreateDefaultTypeUsage(edmPrimitiveType);                    case "nvarchar":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isUnicode = true;                      isFixedLen = false;                      break;                    case "nchar":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isUnicode = true;                      isFixedLen = true;                      break;                    case "ntext":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = true;                      isUnicode = true;                      isFixedLen = false;                      break;                    case "binary":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isFixedLen = true;                      break;                    case "varbinary":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isFixedLen = false;                      break;                    case "image":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = true;                      isFixedLen = false;                      break;                    case "timestamp":                  case "rowversion":                      return TypeUsage.CreateBinaryTypeUsage(edmPrimitiveType' true' 8);                    case "float":                  case "real":                      return TypeUsage.CreateDefaultTypeUsage(edmPrimitiveType);                    case "decimal":                  case "numeric":                      {                          byte precision;                          byte scale;                          if (TypeHelpers.TryGetPrecision(storeType' out precision)                              && TypeHelpers.TryGetScale(storeType' out scale))                          {                              return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType' precision' scale);                          }                          else                          {                              return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType);                          }                      }                    case "money":                      return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType' 19' 4);                    case "datetime":                      return TypeUsage.CreateDateTimeTypeUsage(edmPrimitiveType' null);                    default:                      throw ADP1.NotSupported(EntityRes.GetString(EntityRes.ProviderDoesNotSupportType' storeTypeName));              }
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,GetEdmType,The following statement contains a magic number: switch (storeTypeName)              {                      // for some types we just go with simple type usage with no facets                  case "tinyint":                  case "smallint":                  case "bigint":                  case "bit":                  case "uniqueidentifier":                  case "int":                      return TypeUsage.CreateDefaultTypeUsage(edmPrimitiveType);                    case "nvarchar":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isUnicode = true;                      isFixedLen = false;                      break;                    case "nchar":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isUnicode = true;                      isFixedLen = true;                      break;                    case "ntext":                      newPrimitiveTypeKind = PrimitiveTypeKind.String;                      isUnbounded = true;                      isUnicode = true;                      isFixedLen = false;                      break;                    case "binary":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isFixedLen = true;                      break;                    case "varbinary":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = !TypeHelpers.TryGetMaxLength(storeType' out maxLength);                      isFixedLen = false;                      break;                    case "image":                      newPrimitiveTypeKind = PrimitiveTypeKind.Binary;                      isUnbounded = true;                      isFixedLen = false;                      break;                    case "timestamp":                  case "rowversion":                      return TypeUsage.CreateBinaryTypeUsage(edmPrimitiveType' true' 8);                    case "float":                  case "real":                      return TypeUsage.CreateDefaultTypeUsage(edmPrimitiveType);                    case "decimal":                  case "numeric":                      {                          byte precision;                          byte scale;                          if (TypeHelpers.TryGetPrecision(storeType' out precision)                              && TypeHelpers.TryGetScale(storeType' out scale))                          {                              return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType' precision' scale);                          }                          else                          {                              return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType);                          }                      }                    case "money":                      return TypeUsage.CreateDecimalTypeUsage(edmPrimitiveType' 19' 4);                    case "datetime":                      return TypeUsage.CreateDateTimeTypeUsage(edmPrimitiveType' null);                    default:                      throw ADP1.NotSupported(EntityRes.GetString(EntityRes.ProviderDoesNotSupportType' storeTypeName));              }
Magic Number,System.Data.Entity.SqlServerCompact,SqlCeProviderManifest,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeProviderManifest.cs,GetStoreType,The following statement contains a magic number: switch (primitiveType.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.Boolean:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["bit"]);                    case PrimitiveTypeKind.Byte:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["tinyint"]);                    case PrimitiveTypeKind.Int16:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["smallint"]);                    case PrimitiveTypeKind.Int32:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["int"]);                    case PrimitiveTypeKind.Int64:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["bigint"]);                    case PrimitiveTypeKind.Guid:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["uniqueidentifier"]);                    case PrimitiveTypeKind.Double:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["float"]);                    case PrimitiveTypeKind.Single:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["real"]);                    case PrimitiveTypeKind.Decimal: // decimal' numeric' money                      {                          byte precision;                          if (!TypeHelpers.TryGetPrecision(edmType' out precision))                          {                              precision = 18;                          }                            byte scale;                          if (!TypeHelpers.TryGetScale(edmType' out scale))                          {                              scale = 0;                          }                          var tu = TypeUsage.CreateDecimalTypeUsage(StoreTypeNameToStorePrimitiveType["decimal"]' precision' scale);                          return tu;                      }                    case PrimitiveTypeKind.Binary: // binary' varbinary' image' timestamp' rowversion                      {                          var isFixedLength = null != facets[ProviderManifest.FixedLengthFacetName].Value                                              && (bool)facets[ProviderManifest.FixedLengthFacetName].Value;                          var f = facets[ProviderManifest.MaxLengthFacetName];                          var isMaxLength = Helper.IsUnboundedFacetValue(f) || null == f.Value || (int)f.Value > binaryMaxSize;                          var maxLength = !isMaxLength ? (int)f.Value : Int32.MinValue;                            TypeUsage tu;                          if (isFixedLength)                          {                              tu = TypeUsage.CreateBinaryTypeUsage(                                  StoreTypeNameToStorePrimitiveType["binary"]' true' (isMaxLength ? binaryMaxSize : maxLength));                          }                          else                          {                              if (null == f.Value)                              {                                  tu = TypeUsage.CreateBinaryTypeUsage(StoreTypeNameToStorePrimitiveType["varbinary"]' false' binaryMaxSize);                              }                              else if (Helper.IsUnboundedFacetValue(f)                                       || edmType.EdmType.Name == "image")                              {                                  tu = TypeUsage.CreateBinaryTypeUsage(StoreTypeNameToStorePrimitiveType["image"]' false);                              }                              else if ((int)f.Value > binaryMaxSize)                              {                                  throw ADP1.ColumnGreaterThanMaxLengthNotSupported(edmType.EdmType.Name' binaryMaxSize);                              }                              else                              {                                  tu = TypeUsage.CreateBinaryTypeUsage(StoreTypeNameToStorePrimitiveType["varbinary"]' false' maxLength);                              }                          }                          return tu;                      }                    case PrimitiveTypeKind.String:                      //char' nchar' varchar' nvarchar' ntext' text' xml                      {                          var isUnicode = null == facets[ProviderManifest.UnicodeFacetName].Value                                          || (bool)facets[ProviderManifest.UnicodeFacetName].Value;                          var isFixedLength = null != facets[ProviderManifest.FixedLengthFacetName].Value                                              && (bool)facets[ProviderManifest.FixedLengthFacetName].Value;                          var f = facets[ProviderManifest.MaxLengthFacetName];                          // maxlen is true if facet value is unbounded' the value is bigger than the limited string sizes *or* the facet                          // value is null. this is needed since functions still have maxlength facet value as null                          var isMaxLength = Helper.IsUnboundedFacetValue(f) || null == f.Value || (int)f.Value > (nvarcharMaxSize);                          var maxLength = !isMaxLength ? (int)f.Value : Int32.MinValue;                            TypeUsage tu;                            if (isFixedLength)                          {                              tu = TypeUsage.CreateStringTypeUsage(                                  StoreTypeNameToStorePrimitiveType["nchar"]' true' true' (isMaxLength ? nvarcharMaxSize : maxLength));                          }                          else                          {                              if (null == f.Value)                              {                                  // if it is unknown' fallback to nvarchar[4000] instead of ntext since it has limited store semantics                                  tu = TypeUsage.CreateStringTypeUsage(                                      StoreTypeNameToStorePrimitiveType["nvarchar"]' true' false' nvarcharMaxSize);                              }                              else if (Helper.IsUnboundedFacetValue(f)                                       || edmType.EdmType.Name == "ntext")                              {                                  tu = TypeUsage.CreateStringTypeUsage(StoreTypeNameToStorePrimitiveType["ntext"]' true' false);                              }                              else if ((int)f.Value > nvarcharMaxSize)                              {                                  throw ADP1.ColumnGreaterThanMaxLengthNotSupported(edmType.EdmType.Name' nvarcharMaxSize);                              }                              else                              {                                  tu = TypeUsage.CreateStringTypeUsage(StoreTypeNameToStorePrimitiveType["nvarchar"]' true' false' maxLength);                              }                          }                          return tu;                      }                    case PrimitiveTypeKind.DateTime:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["datetime"]);                    default:                      throw ADP1.NotSupported(                          EntityRes.GetString(                              EntityRes.NoStoreTypeForEdmType' TypeHelpers.GetIdentity(edmType)' primitiveType.PrimitiveTypeKind));              }
Magic Number,System.Data.Entity.SqlServerCompact,SqlDdlBuilder,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlDdlBuilder.cs,AppendType,The following statement contains a magic number: if (type.EdmType.Name == "binary"                  &&                  8 == (int)type.Facets["MaxLength"].Value                  &&                  column.TypeUsage.Facets.TryGetValue("StoreGeneratedPattern"' false' out storeGenFacet)                  &&                  storeGenFacet.Value != null                  &&                  StoreGeneratedPattern.Computed == (StoreGeneratedPattern)storeGenFacet.Value)              {                  isTimestamp = true;                  builder.Append("rowversion");              }              else              {                  var typeName = type.EdmType.Name;                    builder.Append(typeName);                  switch (type.EdmType.Name)                  {                      case "decimal":                      case "numeric":                          AppendSqlInvariantFormat(builder' "({0}' {1})"' type.Facets["Precision"].Value' type.Facets["Scale"].Value);                          break;                      case "binary":                      case "varbinary":                      case "nvarchar":                      case "varchar":                      case "char":                      case "nchar":                          AppendSqlInvariantFormat(builder' "({0})"' type.Facets["MaxLength"].Value);                          break;                      default:                          break;                  }              }
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,InitializeStoreFunctionHandlers,The following statement contains a magic number: var functionHandlers = new Dictionary<string' FunctionHandler>(5' StringComparer.Ordinal);
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,InitializeCanonicalFunctionHandlers,The following statement contains a magic number: var functionHandlers = new Dictionary<string' FunctionHandler>(16' StringComparer.Ordinal);
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,InitializeDatepartKeywords,The following statement contains a magic number: var datepartKeywords = new Dictionary<string' object>(30' StringComparer.OrdinalIgnoreCase);
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,InitializeFunctionNameToOperatorDictionary,The following statement contains a magic number: var functionNameToOperatorDictionary = new Dictionary<string' string>(5' StringComparer.Ordinal);
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,WriteSql,The following statement contains a magic number: var builder = new StringBuilder(1024);
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,VisitConstant,The following statement contains a magic number: if (TypeHelpers.TryGetPrimitiveTypeKind(e.ResultType' out typeKind))              {                  switch (typeKind)                  {                      case PrimitiveTypeKind.Int32:                          // default sql server type for integral values.                          result.Append(e.Value.ToString());                          break;                        case PrimitiveTypeKind.Binary:                          result.Append(" 0x");                          result.Append(ByteArrayToBinaryString((Byte[])e.Value));                          result.Append(" ");                          break;                        case PrimitiveTypeKind.Boolean:                          // Bugs 450277' 430294: Need to preserve the boolean type-ness of                          // this value for round-trippability                          WrapWithCastIfNeeded(!isCastOptional' (bool)e.Value ? "1" : "0"' "bit"' result);                          break;                        case PrimitiveTypeKind.Byte:                          WrapWithCastIfNeeded(!isCastOptional' e.Value.ToString()' "tinyint"' result);                          break;                        case PrimitiveTypeKind.DateTime:                          result.Append("convert(");                          result.Append("datetime");                          result.Append("' ");                          result.Append(                              EscapeSingleQuote(                                  ((DateTime)e.Value).ToString("yyyy-MM-dd HH:mm:ss.fff"' CultureInfo.InvariantCulture)' false /* IsUnicode */));                          result.Append("' 121)");                          break;                        case PrimitiveTypeKind.Decimal:                          var strDecimal = ((Decimal)e.Value).ToString(CultureInfo.InvariantCulture);                          // if the decimal value has no decimal part' cast as decimal to preserve type                          // if the number has precision > int64 max precision' it will be handled as decimal by sql server                          // and does not need cast. if precision is lest then 20' then cast using Max(literal precision' sql default precision)                          var needsCast = -1 == strDecimal.IndexOf('.') && (strDecimal.TrimStart(new[] { '-' }).Length < 20);                            var precision = Math.Max((Byte)strDecimal.Length' defaultDecimalPrecision);                          Debug.Assert(precision > 0' "Precision must be greater than zero");                            var decimalType = "decimal(" + precision.ToString(CultureInfo.InvariantCulture) + ")";                            WrapWithCastIfNeeded(needsCast' strDecimal' decimalType' result);                          break;                        case PrimitiveTypeKind.Double:                          WrapWithCastIfNeeded(true' ((Double)e.Value).ToString("R"' CultureInfo.InvariantCulture)' "float"' result);                          break;    #if REVISIT_SUPPORT_FOR_GUID_CONSTANTS  #else                      case PrimitiveTypeKind.Guid:                          WrapWithCastIfNeeded(true' EscapeSingleQuote(e.Value.ToString()' false /* IsUnicode */)' "uniqueidentifier"' result);                          break;  #endif                        case PrimitiveTypeKind.Int16:                          WrapWithCastIfNeeded(!isCastOptional' e.Value.ToString()' "smallint"' result);                          break;                        case PrimitiveTypeKind.Int64:                          WrapWithCastIfNeeded(!isCastOptional' e.Value.ToString()' "bigint"' result);                          break;                        case PrimitiveTypeKind.Single:                          WrapWithCastIfNeeded(true' ((Single)e.Value).ToString("R"' CultureInfo.InvariantCulture)' "real"' result);                          break;                        case PrimitiveTypeKind.String:                          bool isUnicode;                          if (!TypeHelpers.TryGetIsUnicode(e.ResultType' out isUnicode))                          {                              isUnicode = true;                          }                          result.Append(EscapeSingleQuote(e.Value as string' isUnicode));                          break;                        case PrimitiveTypeKind.Time:                          throw ADP1.NotSupported(EntityRes.GetString(EntityRes.ProviderDoesNotSupportType' "Time"));                        case PrimitiveTypeKind.DateTimeOffset:                          throw ADP1.NotSupported(EntityRes.GetString(EntityRes.ProviderDoesNotSupportType' "DateTimeOffset"));                        default:                          // all known scalar types should been handled already.                          throw ADP1.NotSupported();                  }              }              else              {                  throw ADP1.NotSupported();                  //if/when Enum types are supported' then handle appropriately' for now is not a valid type for constants.                  //result.Append(e.Value.ToString());              }
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,GetTargetTSql,The following statement contains a magic number: if (entitySetBase.MetadataProperties.TryGetValue("DefiningQuery"' false' out definingQuery)                  &&                  null != definingQuery.Value)              {                  targetTSql = "(" + (string)definingQuery.Value + ")";              }              else              {                  // construct escaped T-SQL referencing entity set                  var builder = new StringBuilder(50);                    if (entitySetBase.MetadataProperties.TryGetValue("Table"' false' out table)                      &&                      !string.IsNullOrEmpty((string)table.Value))                  {                      builder.Append(QuoteIdentifier((string)table.Value));                  }                  else                  {                      builder.Append(QuoteIdentifier(entitySetBase.Name));                  }                  targetTSql = builder.ToString();              }
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,Visit,The following statement contains a magic number: var inputs = new List<DbExpressionBinding>(2);
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,HandleSpecialFunctionToOperator,The following statement contains a magic number: Debug.Assert(e.Arguments.Count > 0 && e.Arguments.Count <= 2' "There should be 1 or 2 arguments for operator");
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,ByteArrayToBinaryString,The following statement contains a magic number: var sb = new StringBuilder(binaryArray.Length * 2);
Magic Number,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,ByteArrayToBinaryString,The following statement contains a magic number: for (var i = 0; i < binaryArray.Length; i++)              {                  sb.Append(_hexDigits[(binaryArray[i] & 0xF0) >> 4]).Append(_hexDigits[binaryArray[i] & 0x0F]);              }
Magic Number,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,GetString,The following statement contains a magic number: if (args != null                  && args.Length > 0)              {                  for (var i = 0; i < args.Length; i ++)                  {                      var value = args[i] as String;                      if (value != null                          && value.Length > 1024)                      {                          args[i] = value.Substring(0' 1024 - 3) + "...";                      }                  }                  return String.Format(CultureInfo.CurrentCulture' res' args);              }              else              {                  return res;              }
Magic Number,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,GetString,The following statement contains a magic number: if (args != null                  && args.Length > 0)              {                  for (var i = 0; i < args.Length; i ++)                  {                      var value = args[i] as String;                      if (value != null                          && value.Length > 1024)                      {                          args[i] = value.Substring(0' 1024 - 3) + "...";                      }                  }                  return String.Format(CultureInfo.CurrentCulture' res' args);              }              else              {                  return res;              }
Magic Number,System.Data.Entity.SqlServerCompact.Resources,EntityRes,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\Properties\Resources.SqlServerCompact.cs,GetString,The following statement contains a magic number: if (args != null                  && args.Length > 0)              {                  for (var i = 0; i < args.Length; i ++)                  {                      var value = args[i] as String;                      if (value != null                          && value.Length > 1024)                      {                          args[i] = value.Substring(0' 1024 - 3) + "...";                      }                  }                  return String.Format(CultureInfo.CurrentCulture' res' args);              }              else              {                  return res;              }
Missing Default,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,VisitIsNullExpression,The following switch statement is missing a default case: switch (primitiveTypeKind)                          {                              case PrimitiveTypeKind.String:                                  castAsType = "ntext";                                  break;                              case PrimitiveTypeKind.Binary:                                  castAsType = "image";                                  break;                          }
Missing Default,System.Data.Entity.SqlServerCompact.SqlGen,SqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlGen\SqlGenerator.cs,VisitJoinExpression,The following switch statement is missing a default case: switch (joinKind)              {                  case DbExpressionKind.FullOuterJoin:                  case DbExpressionKind.InnerJoin:                  case DbExpressionKind.LeftOuterJoin:                      result.From.Append(" ON ");                      isParentAJoinStack.Push(false);                      result.From.Append(joinCondition.Accept(this));                      isParentAJoinStack.Pop();                      break;              }
Missing Default,System.Data.Entity.Migrations.Sql,SqlCeMigrationSqlGenerator,C:\repos\mono_entityframework\src\EntityFramework.SqlServerCompact\SqlCeMigrationSqlGenerator.cs,BuildPropertyType,The following switch statement is missing a default case: switch (originalStoreTypeName)              {                  case "decimal":                  case "numeric":                      storeTypeName += "(" + (propertyModel.Precision ?? DefaultNumericPrecision)                                       + "' " + (propertyModel.Scale ?? DefaultScale) + ")";                      break;                  case "datetime2":                  case "datetimeoffset":                  case "time":                      storeTypeName += "(" + (propertyModel.Precision ?? DefaultTimePrecision) + ")";                      break;                  case "binary":                  case "varbinary":                  case "nvarchar":                  case "varchar":                  case "char":                  case "nchar":                      storeTypeName += "(" + (propertyModel.MaxLength ?? DefaultMaxLength) + ")";                      break;              }
