Implementation smell,Namespace,Class,File,Method,Description
Long Method,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The method has 191 lines of code.
Long Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The method has 132 lines of code.
Long Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The method has 370 lines of code.
Complex Method,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetASCIIBytesFromBinaryBuffer,Cyclomatic complexity of the method is 51
Complex Method,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetBinaryBufferFromASCIIBytes,Cyclomatic complexity of the method is 51
Complex Method,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,EightBitToByte,Cyclomatic complexity of the method is 8
Complex Method,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,Cyclomatic complexity of the method is 8
Complex Method,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,Cyclomatic complexity of the method is 8
Complex Method,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,Cyclomatic complexity of the method is 91
Complex Method,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,WriteMultipleRegisters,Cyclomatic complexity of the method is 9
Complex Method,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,Cyclomatic complexity of the method is 8
Complex Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IsAllRegistersPresent,Cyclomatic complexity of the method is 19
Complex Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,Cyclomatic complexity of the method is 12
Complex Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadByte,Cyclomatic complexity of the method is 22
Complex Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,WriteBuffer,Cyclomatic complexity of the method is 13
Complex Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,Cyclomatic complexity of the method is 51
Complex Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,Cyclomatic complexity of the method is 183
Complex Method,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,Cyclomatic complexity of the method is 19
Long Parameter List,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,The method has 5 parameters.
Long Parameter List,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IsAllRegistersPresent,The method has 8 parameters.
Long Parameter List,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The method has 6 parameters.
Long Parameter List,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The method has 27 parameters.
Long Parameter List,Modbus,ModbusSlaveSerial,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ModbusSlaveSerial,The method has 8 parameters.
Long Parameter List,Modbus,ModbusMasterSerial,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ModbusMasterSerial,The method has 7 parameters.
Long Parameter List,Modbus,Datastore,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Datastore,The method has 5 parameters.
Long Statement,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,The length of the statement  "	if ((read_len > MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG) || (values.Length > MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)) { " is 135.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IsAllRegistersPresent,The length of the statement  "			modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (starting_address' quantity_of_registers); " is 120.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IsAllRegistersPresent,The length of the statement  "			modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.ToList ().GetRange (starting_address' quantity_of_registers); " is 120.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IsAllRegistersPresent,The length of the statement  "			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.ToList ().GetRange (starting_address' quantity_of_registers); " is 122.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The length of the statement  "				modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii); " is 124.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The length of the statement  "			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask))); " is 183.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The length of the statement  "		if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) { " is 159.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The length of the statement  "		if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) { " is 167.
Long Statement,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The length of the statement  "				modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii); " is 126.
Complex Conditional,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The conditional expression  "!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))"  is complex.
Complex Conditional,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The conditional expression  "!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))"  is complex.
Complex Conditional,Modbus,Datastore,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Datastore,The conditional expression  "((n_discrete_inputs >= 0) && (n_discrete_inputs <= MAX_ELEMENTS)) && ((n_coils >= 0) && (n_coils <= MAX_ELEMENTS)) && ((n_input_registers >= 0) && (n_input_registers <= MAX_ELEMENTS)) && ((n_holding_registers >= 0) && (n_holding_registers <= MAX_ELEMENTS))"  is complex.
Empty Catch Block,Modbus,ModbusSlaveSerial,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GestRequests,The method has an empty catch block.
Empty Catch Block,Modbus,ModbusSlaveTCP,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,DoAcceptTcpClientCallback,The method has an empty catch block.
Empty Catch Block,Modbus,ModbusSlaveUDP,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,DoAcceptUdpDataCallback,The method has an empty catch block.
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetBytes,The following statement contains a magic number: array [0] = (byte)(value >> 8);  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetASCIIBytesFromBinaryBuffer,The following statement contains a magic number: for (int ii = 0' jj = 0; ii < buffer.Length * 2; ii++) {  	char ch;  	byte val = (byte)((ii % 2) == 0 ? buffer [jj] >> 4 : buffer [jj] & 0x0F);  	switch (val) {  	default:  	case 0x00:  		ch = '0';  		break;  	case 0x01:  		ch = '1';  		break;  	case 0x02:  		ch = '2';  		break;  	case 0x03:  		ch = '3';  		break;  	case 0x04:  		ch = '4';  		break;  	case 0x05:  		ch = '5';  		break;  	case 0x06:  		ch = '6';  		break;  	case 0x07:  		ch = '7';  		break;  	case 0x08:  		ch = '8';  		break;  	case 0x09:  		ch = '9';  		break;  	case 0x0A:  		ch = 'A';  		break;  	case 0x0B:  		ch = 'B';  		break;  	case 0x0C:  		ch = 'C';  		break;  	case 0x0D:  		ch = 'D';  		break;  	case 0x0E:  		ch = 'E';  		break;  	case 0x0F:  		ch = 'F';  		break;  	}  	chars.Add (ch);  	if ((ii % 2) != 0)  		jj++;  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetASCIIBytesFromBinaryBuffer,The following statement contains a magic number: for (int ii = 0' jj = 0; ii < buffer.Length * 2; ii++) {  	char ch;  	byte val = (byte)((ii % 2) == 0 ? buffer [jj] >> 4 : buffer [jj] & 0x0F);  	switch (val) {  	default:  	case 0x00:  		ch = '0';  		break;  	case 0x01:  		ch = '1';  		break;  	case 0x02:  		ch = '2';  		break;  	case 0x03:  		ch = '3';  		break;  	case 0x04:  		ch = '4';  		break;  	case 0x05:  		ch = '5';  		break;  	case 0x06:  		ch = '6';  		break;  	case 0x07:  		ch = '7';  		break;  	case 0x08:  		ch = '8';  		break;  	case 0x09:  		ch = '9';  		break;  	case 0x0A:  		ch = 'A';  		break;  	case 0x0B:  		ch = 'B';  		break;  	case 0x0C:  		ch = 'C';  		break;  	case 0x0D:  		ch = 'D';  		break;  	case 0x0E:  		ch = 'E';  		break;  	case 0x0F:  		ch = 'F';  		break;  	}  	chars.Add (ch);  	if ((ii % 2) != 0)  		jj++;  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetASCIIBytesFromBinaryBuffer,The following statement contains a magic number: for (int ii = 0' jj = 0; ii < buffer.Length * 2; ii++) {  	char ch;  	byte val = (byte)((ii % 2) == 0 ? buffer [jj] >> 4 : buffer [jj] & 0x0F);  	switch (val) {  	default:  	case 0x00:  		ch = '0';  		break;  	case 0x01:  		ch = '1';  		break;  	case 0x02:  		ch = '2';  		break;  	case 0x03:  		ch = '3';  		break;  	case 0x04:  		ch = '4';  		break;  	case 0x05:  		ch = '5';  		break;  	case 0x06:  		ch = '6';  		break;  	case 0x07:  		ch = '7';  		break;  	case 0x08:  		ch = '8';  		break;  	case 0x09:  		ch = '9';  		break;  	case 0x0A:  		ch = 'A';  		break;  	case 0x0B:  		ch = 'B';  		break;  	case 0x0C:  		ch = 'C';  		break;  	case 0x0D:  		ch = 'D';  		break;  	case 0x0E:  		ch = 'E';  		break;  	case 0x0F:  		ch = 'F';  		break;  	}  	chars.Add (ch);  	if ((ii % 2) != 0)  		jj++;  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetASCIIBytesFromBinaryBuffer,The following statement contains a magic number: for (int ii = 0' jj = 0; ii < buffer.Length * 2; ii++) {  	char ch;  	byte val = (byte)((ii % 2) == 0 ? buffer [jj] >> 4 : buffer [jj] & 0x0F);  	switch (val) {  	default:  	case 0x00:  		ch = '0';  		break;  	case 0x01:  		ch = '1';  		break;  	case 0x02:  		ch = '2';  		break;  	case 0x03:  		ch = '3';  		break;  	case 0x04:  		ch = '4';  		break;  	case 0x05:  		ch = '5';  		break;  	case 0x06:  		ch = '6';  		break;  	case 0x07:  		ch = '7';  		break;  	case 0x08:  		ch = '8';  		break;  	case 0x09:  		ch = '9';  		break;  	case 0x0A:  		ch = 'A';  		break;  	case 0x0B:  		ch = 'B';  		break;  	case 0x0C:  		ch = 'C';  		break;  	case 0x0D:  		ch = 'D';  		break;  	case 0x0E:  		ch = 'E';  		break;  	case 0x0F:  		ch = 'F';  		break;  	}  	chars.Add (ch);  	if ((ii % 2) != 0)  		jj++;  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetASCIIBytesFromBinaryBuffer,The following statement contains a magic number: if ((ii % 2) != 0)  	jj++;  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetBinaryBufferFromASCIIBytes,The following statement contains a magic number: for (int ii = 0; ii < buffer.Length; ii++) {  	byte tmp;  	switch (chars [ii]) {  	default:  	case '0':  		tmp = 0x00;  		break;  	case '1':  		tmp = 0x01;  		break;  	case '2':  		tmp = 0x02;  		break;  	case '3':  		tmp = 0x03;  		break;  	case '4':  		tmp = 0x04;  		break;  	case '5':  		tmp = 0x05;  		break;  	case '6':  		tmp = 0x06;  		break;  	case '7':  		tmp = 0x07;  		break;  	case '8':  		tmp = 0x08;  		break;  	case '9':  		tmp = 0x09;  		break;  	case 'A':  		tmp = 0x0A;  		break;  	case 'B':  		tmp = 0x0B;  		break;  	case 'C':  		tmp = 0x0C;  		break;  	case 'D':  		tmp = 0x0D;  		break;  	case 'E':  		tmp = 0x0E;  		break;  	case 'F':  		tmp = 0x0F;  		break;  	}  	if (ii % 2 != 0) {  		bt |= tmp;  		ret.Add (bt);  		bt = 0;  	}  	else  		bt = (byte)(tmp << 4);  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetBinaryBufferFromASCIIBytes,The following statement contains a magic number: for (int ii = 0; ii < buffer.Length; ii++) {  	byte tmp;  	switch (chars [ii]) {  	default:  	case '0':  		tmp = 0x00;  		break;  	case '1':  		tmp = 0x01;  		break;  	case '2':  		tmp = 0x02;  		break;  	case '3':  		tmp = 0x03;  		break;  	case '4':  		tmp = 0x04;  		break;  	case '5':  		tmp = 0x05;  		break;  	case '6':  		tmp = 0x06;  		break;  	case '7':  		tmp = 0x07;  		break;  	case '8':  		tmp = 0x08;  		break;  	case '9':  		tmp = 0x09;  		break;  	case 'A':  		tmp = 0x0A;  		break;  	case 'B':  		tmp = 0x0B;  		break;  	case 'C':  		tmp = 0x0C;  		break;  	case 'D':  		tmp = 0x0D;  		break;  	case 'E':  		tmp = 0x0E;  		break;  	case 'F':  		tmp = 0x0F;  		break;  	}  	if (ii % 2 != 0) {  		bt |= tmp;  		ret.Add (bt);  		bt = 0;  	}  	else  		bt = (byte)(tmp << 4);  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetBinaryBufferFromASCIIBytes,The following statement contains a magic number: if (ii % 2 != 0) {  	bt |= tmp;  	ret.Add (bt);  	bt = 0;  }  else  	bt = (byte)(tmp << 4);  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetBinaryBufferFromASCIIBytes,The following statement contains a magic number: if (ii % 2 != 0) {  	bt |= tmp;  	ret.Add (bt);  	bt = 0;  }  else  	bt = (byte)(tmp << 4);  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetBinaryBufferFromASCIIBytes,The following statement contains a magic number: bt = (byte)(tmp << 4);  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ToUInt16,The following statement contains a magic number: return (ushort)((value [offset] << 8) | (value [offset + 1] & 0x00FF));  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,EightBitToByte,The following statement contains a magic number: if (array.Length < 8)  	throw new Exception (MethodInfo.GetCurrentMethod ().Name + ": The array must be at least 8-bit length!");  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,EightBitToByte,The following statement contains a magic number: for (int ii = 0; ii < 8; ii++) {  	switch (array [offset + ii]) {  	case true:  		ret |= (byte)(1 << ii);  		break;  	case false:  		ret &= (byte)(~(1 << ii));  		break;  	}  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: if (sp.BaudRate > 19200)  	ret_val = 2;  // Fixed value = 1.75ms up rounded  else {  	int nbits = 1 + sp.DataBits;  	nbits += sp.Parity == Parity.None ? 0 : 1;  	switch (sp.StopBits) {  	case StopBits.One:  		nbits += 1;  		break;  	case StopBits.OnePointFive:  	// Ceiling  	case StopBits.Two:  		nbits += 2;  		break;  	}  	ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 3.5d)) / 1000)));  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: if (sp.BaudRate > 19200)  	ret_val = 2;  // Fixed value = 1.75ms up rounded  else {  	int nbits = 1 + sp.DataBits;  	nbits += sp.Parity == Parity.None ? 0 : 1;  	switch (sp.StopBits) {  	case StopBits.One:  		nbits += 1;  		break;  	case StopBits.OnePointFive:  	// Ceiling  	case StopBits.Two:  		nbits += 2;  		break;  	}  	ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 3.5d)) / 1000)));  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: if (sp.BaudRate > 19200)  	ret_val = 2;  // Fixed value = 1.75ms up rounded  else {  	int nbits = 1 + sp.DataBits;  	nbits += sp.Parity == Parity.None ? 0 : 1;  	switch (sp.StopBits) {  	case StopBits.One:  		nbits += 1;  		break;  	case StopBits.OnePointFive:  	// Ceiling  	case StopBits.Two:  		nbits += 2;  		break;  	}  	ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 3.5d)) / 1000)));  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: if (sp.BaudRate > 19200)  	ret_val = 2;  // Fixed value = 1.75ms up rounded  else {  	int nbits = 1 + sp.DataBits;  	nbits += sp.Parity == Parity.None ? 0 : 1;  	switch (sp.StopBits) {  	case StopBits.One:  		nbits += 1;  		break;  	case StopBits.OnePointFive:  	// Ceiling  	case StopBits.Two:  		nbits += 2;  		break;  	}  	ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 3.5d)) / 1000)));  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: ret_val = 2;  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: switch (sp.StopBits) {  case StopBits.One:  	nbits += 1;  	break;  case StopBits.OnePointFive:  // Ceiling  case StopBits.Two:  	nbits += 2;  	break;  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: nbits += 2;  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following statement contains a magic number: ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 3.5d)) / 1000)));  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,The following statement contains a magic number: if (sp.BaudRate > 19200)  	ret_val = 1;  // Fixed value = 0.75 ms up rounded  else {  	int nbits = 1 + sp.DataBits;  	nbits += sp.Parity == Parity.None ? 0 : 1;  	switch (sp.StopBits) {  	case StopBits.One:  		nbits += 1;  		break;  	case StopBits.OnePointFive:  	// Ceiling  	case StopBits.Two:  		nbits += 2;  		break;  	}  	ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 1.5d)) / 1000)));  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,The following statement contains a magic number: if (sp.BaudRate > 19200)  	ret_val = 1;  // Fixed value = 0.75 ms up rounded  else {  	int nbits = 1 + sp.DataBits;  	nbits += sp.Parity == Parity.None ? 0 : 1;  	switch (sp.StopBits) {  	case StopBits.One:  		nbits += 1;  		break;  	case StopBits.OnePointFive:  	// Ceiling  	case StopBits.Two:  		nbits += 2;  		break;  	}  	ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 1.5d)) / 1000)));  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,The following statement contains a magic number: if (sp.BaudRate > 19200)  	ret_val = 1;  // Fixed value = 0.75 ms up rounded  else {  	int nbits = 1 + sp.DataBits;  	nbits += sp.Parity == Parity.None ? 0 : 1;  	switch (sp.StopBits) {  	case StopBits.One:  		nbits += 1;  		break;  	case StopBits.OnePointFive:  	// Ceiling  	case StopBits.Two:  		nbits += 2;  		break;  	}  	ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 1.5d)) / 1000)));  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,The following statement contains a magic number: switch (sp.StopBits) {  case StopBits.One:  	nbits += 1;  	break;  case StopBits.OnePointFive:  // Ceiling  case StopBits.Two:  	nbits += 2;  	break;  }  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,The following statement contains a magic number: nbits += 2;  
Magic Number,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,The following statement contains a magic number: ret_val = Convert.ToInt32 (Math.Ceiling (1 / (((double)sp.BaudRate / ((double)nbits * 1.5d)) / 1000)));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildMBAPHeader,The following statement contains a magic number: send_buffer.InsertRange (2' GetBytes (PROTOCOL_ID));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildMBAPHeader,The following statement contains a magic number: send_buffer.InsertRange (4' GetBytes (message_len));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildMBAPHeader,The following statement contains a magic number: send_buffer.Insert (6' dest_address);  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (tmo >= rx_timeout) {  	error = Errors.RX_TIMEOUT;  	return;  }  else {  	int min_frame_length;  	switch (connection_type) {  	default:  	case ConnectionType.SERIAL_RTU:  		min_frame_length = 5;  		break;  	case ConnectionType.SERIAL_ASCII:  		min_frame_length = 11;  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		min_frame_length = 9;  		break;  	}  	if (receive_buffer.Count < min_frame_length) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	switch (connection_type) {  	case ConnectionType.SERIAL_ASCII:  		// Check and remove start char  		if (receive_buffer [0] != send_buffer [0]) {  			error = Errors.START_CHAR_NOT_FOUND;  			return;  		}  		receive_buffer.RemoveRange (0' 1);  		// Check and remove stop chars  		char[] orig_end_frame = new char[] {  			ASCII_STOP_FRAME_1ST'  			ASCII_STOP_FRAME_2ND  		};  		char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  		if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  			error = Errors.END_CHARS_NOT_FOUND;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		// Convert receive buffer from ASCII to binary  		receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  		// Check and remove message LRC  		byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  		byte lrc_received = receive_buffer [receive_buffer.Count - 1];  		if (lrc_calculated != lrc_received) {  			error = Errors.WRONG_LRC;  			break;  		}  		receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  		// Remove address byte  		receive_buffer.RemoveRange (0' 1);  		break;  	case ConnectionType.SERIAL_RTU:  		// Check message 16-bit CRC  		ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  		ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  		if (rec_crc != calc_crc) {  			error = Errors.WRONG_CRC;  			return;  		}  		// Check message consistency  		byte addr = receive_buffer [0];  		if (addr != send_buffer [0]) {  			error = Errors.WRONG_RESPONSE_ADDRESS;  			return;  		}  		// Remove address  		receive_buffer.RemoveRange (0' 1);  		// Remove CRC  		receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  		break;  	case ConnectionType.UDP_IP:  	case ConnectionType.TCP_IP:  		// Check MBAP header  		ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  		if (tid != transaction_id) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  		if (pid != PROTOCOL_ID) {  			error = Errors.WRONG_TRANSACTION_ID;  			return;  		}  		ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  		if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  			error = Errors.WRONG_MESSAGE_LEN;  			return;  		}  		byte uid = receive_buffer [6];  		if (uid != send_buffer [6]) {  			error = Errors.WRONG_RESPONSE_UNIT_ID;  			return;  		}  		// Let only useful bytes in receive buffer                         		receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  		break;  	}  	// Controllo eventuali messaggi di errore  	if (receive_buffer [0] > 0x80) {  		// E' stato segnalato un errore' controllo l'exception code  		switch (receive_buffer [1]) {  		case 1:  			error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  			break;  		case 2:  			error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  			break;  		case 3:  			error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  			break;  		case 4:  			error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  			break;  		}  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  default:  case ConnectionType.SERIAL_RTU:  	min_frame_length = 5;  	break;  case ConnectionType.SERIAL_ASCII:  	min_frame_length = 11;  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	min_frame_length = 9;  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  default:  case ConnectionType.SERIAL_RTU:  	min_frame_length = 5;  	break;  case ConnectionType.SERIAL_ASCII:  	min_frame_length = 11;  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	min_frame_length = 9;  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  default:  case ConnectionType.SERIAL_RTU:  	min_frame_length = 5;  	break;  case ConnectionType.SERIAL_ASCII:  	min_frame_length = 11;  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	min_frame_length = 9;  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: min_frame_length = 5;  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: min_frame_length = 11;  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: min_frame_length = 9;  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (uid != send_buffer [6]) {  	error = Errors.WRONG_RESPONSE_UNIT_ID;  	return;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (receive_buffer [0] > 0x80) {  	// E' stato segnalato un errore' controllo l'exception code  	switch (receive_buffer [1]) {  	case 1:  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		break;  	case 2:  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		break;  	case 3:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		break;  	case 4:  		error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  		break;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (receive_buffer [0] > 0x80) {  	// E' stato segnalato un errore' controllo l'exception code  	switch (receive_buffer [1]) {  	case 1:  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		break;  	case 2:  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		break;  	case 3:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		break;  	case 4:  		error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  		break;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: if (receive_buffer [0] > 0x80) {  	// E' stato segnalato un errore' controllo l'exception code  	switch (receive_buffer [1]) {  	case 1:  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		break;  	case 2:  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		break;  	case 3:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		break;  	case 4:  		error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  		break;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (receive_buffer [1]) {  case 1:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	break;  case 2:  	error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  	break;  case 3:  	error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  	break;  case 4:  	error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (receive_buffer [1]) {  case 1:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	break;  case 2:  	error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  	break;  case 3:  	error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  	break;  case 4:  	error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following statement contains a magic number: switch (receive_buffer [1]) {  case 1:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	break;  case 2:  	error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  	break;  case 3:  	error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  	break;  case 4:  	error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  	break;  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadHoldingRegisters,The following statement contains a magic number: for (int ii = 0; ii < receive_buffer [1]; ii += 2)  	ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadHoldingRegisters,The following statement contains a magic number: for (int ii = 0; ii < receive_buffer [1]; ii += 2)  	ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadHoldingRegisters,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadHoldingRegisters,The following statement contains a magic number: ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadInputRegisters,The following statement contains a magic number: for (int ii = 0; ii < receive_buffer [1]; ii += 2)  	ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadInputRegisters,The following statement contains a magic number: for (int ii = 0; ii < receive_buffer [1]; ii += 2)  	ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadInputRegisters,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadInputRegisters,The following statement contains a magic number: ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,WriteSingleCoil,The following statement contains a magic number: if (error == Errors.NO_ERROR) {  	ushort addr = ToUInt16 (receive_buffer.ToArray ()' 1);  	ushort regval = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (addr != address) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	if ((regval == 0xFF00) && !value) {  		error = Errors.WRONG_RESPONSE_VALUE;  		return;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,WriteMultipleCoils,The following statement contains a magic number: if (error == Errors.NO_ERROR) {  	ushort sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	ushort nr = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (sa != start_address) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	if (nr != values.Length) {  		error = Errors.WRONG_RESPONSE_REGISTERS;  		return;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,WriteMultipleRegisters,The following statement contains a magic number: send_buffer.Add ((byte)(values.Length * 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,WriteMultipleRegisters,The following statement contains a magic number: if (error == Errors.NO_ERROR) {  	ushort sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	ushort nr = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (sa != start_address) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	if (nr != values.Length) {  		error = Errors.WRONG_RESPONSE_REGISTERS;  		return;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,MaskWriteRegister,The following statement contains a magic number: if (error == Errors.NO_ERROR) {  	// Check address  	ushort addr = ToUInt16 (receive_buffer.ToArray ()' 1);  	if (address != addr) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Check AND mask  	ushort am = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (and_mask != am) {  		error = Errors.WRONG_RESPONSE_AND_MASK;  		return;  	}  	// Check OR mask  	ushort om = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (or_mask != om) {  		error = Errors.WRONG_RESPONSE_OR_MASK;  		return;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,MaskWriteRegister,The following statement contains a magic number: if (error == Errors.NO_ERROR) {  	// Check address  	ushort addr = ToUInt16 (receive_buffer.ToArray ()' 1);  	if (address != addr) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Check AND mask  	ushort am = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (and_mask != am) {  		error = Errors.WRONG_RESPONSE_AND_MASK;  		return;  	}  	// Check OR mask  	ushort om = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (or_mask != om) {  		error = Errors.WRONG_RESPONSE_OR_MASK;  		return;  	}  }  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,The following statement contains a magic number: send_buffer.Add ((byte)(values.Length * 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,The following statement contains a magic number: for (int ii = 0; ii < receive_buffer [1]; ii += 2)  	ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,The following statement contains a magic number: for (int ii = 0; ii < receive_buffer [1]; ii += 2)  	ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadWriteMultipleRegisters,The following statement contains a magic number: ret.Add (ToUInt16 (receive_buffer.ToArray ()' ii + 2));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,The following statement contains a magic number: switch (error) {  case Errors.EXCEPTION_ILLEGAL_FUNCTION:  	exception_code = 1;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS:  	exception_code = 2;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_VALUE:  	exception_code = 3;  	break;  case Errors.EXCEPTION_SLAVE_DEVICE_FAILURE:  	exception_code = 4;  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,The following statement contains a magic number: switch (error) {  case Errors.EXCEPTION_ILLEGAL_FUNCTION:  	exception_code = 1;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS:  	exception_code = 2;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_VALUE:  	exception_code = 3;  	break;  case Errors.EXCEPTION_SLAVE_DEVICE_FAILURE:  	exception_code = 4;  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,The following statement contains a magic number: switch (error) {  case Errors.EXCEPTION_ILLEGAL_FUNCTION:  	exception_code = 1;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS:  	exception_code = 2;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_VALUE:  	exception_code = 3;  	break;  case Errors.EXCEPTION_SLAVE_DEVICE_FAILURE:  	exception_code = 4;  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,The following statement contains a magic number: exception_code = 2;  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,The following statement contains a magic number: exception_code = 3;  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,The following statement contains a magic number: exception_code = 4;  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: if (receive_buffer.Count < 3) {  	error = Errors.WRONG_MESSAGE_LEN;  	return;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: if ((receive_buffer.Count - 6) != len) {  	error = Errors.WRONG_MESSAGE_LEN;  	return;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following statement contains a magic number: unit_id = receive_buffer [6];  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: switch (mdbcode) {  case ModbusCodes.READ_COILS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_COILS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_DISCRETE_INPUTS:  	// Read received commands                      	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_DISCRETE_INPUTS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.DISCRETE_INPUTS_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_DISCRETE_INPUTS);  	bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  	send_buffer.Add ((byte)bytes);  	ret_vals = new bool[bytes * 8];  	try {  		modbus_db.Single (x => x.UnitID == unit_id).DiscreteInputs.ToList ().GetRange (sa' qor).CopyTo (ret_vals);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	for (int ii = 0; ii < bytes; ii++)  		send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  	break;  case ModbusCodes.READ_HOLDING_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_HOLDING_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.READ_INPUT_REGISTERS:  	// Read received commands  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_INPUT_REGISTERS_IN_READ_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.INPUT_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.READ_INPUT_REGISTERS);  	send_buffer.Add ((byte)(2 * qor));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  case ModbusCodes.WRITE_SINGLE_COIL:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	switch (val) {  	case 0x0000:  		cv = false;  		break;  	case 0xFF00:  		cv = true;  		break;  	default:  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		cv = false;  		// Dummy  		break;  	}  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.EXCEPTION_ILLEGAL_DATA_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (error == Errors.WRONG_WRITE_SINGLE_COIL_VALUE) {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_ILLEGAL_DATA_VALUE);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).Coils [sa] = cv;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_COIL);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_SINGLE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	val = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((val >= 0x0000) && (val <= 0xFFFF))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = val;  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_SINGLE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (val));  	break;  case ModbusCodes.WRITE_MULTIPLE_COILS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).Coils.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_COILS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.COIL_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	byte[] buffer = receive_buffer.GetRange (6' bc).ToArray ();  	BitArray ba = new BitArray (buffer);  	try {  		ba.CopyTo (modbus_db.Single (x => x.UnitID == unit_id).Coils' sa);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_COILS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_IN_WRITE_MSG))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [5];  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (qor));  	break;  case ModbusCodes.MASK_WRITE_REGISTER:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  	or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((and_mask >= 0x0000) && (and_mask <= 0xFFFF)) || ((and_mask >= 0x0000) && (and_mask <= 0xFFFF)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' 1)) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	try {  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] = (ushort)((modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa] & and_mask) | (or_mask & (~and_mask)));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Reply  	send_buffer.Add ((byte)ModbusCodes.MASK_WRITE_REGISTER);  	send_buffer.AddRange (GetBytes (sa));  	send_buffer.AddRange (GetBytes (and_mask));  	send_buffer.AddRange (GetBytes (or_mask));  	break;  case ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS:  	// Adjusting  	sa = ToUInt16 (receive_buffer.ToArray ()' 1);  	qor = ToUInt16 (receive_buffer.ToArray ()' 3);  	sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  	qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  	if (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters.Length == 0) {  		error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if (!(((qor >= 1) && (qor <= MAX_HOLDING_REGISTERS_TO_READ_IN_READWRITE_MSG)) || ((qor1 >= 1) && (qor1 <= MAX_HOLDING_REGISTERS_TO_WRITE_IN_READWRITE_MSG)))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	if ((!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa' qor)) || (!IsAllRegistersPresent (unit_id' ModbusDBTables.HOLDING_REGISTERS' sa1' qor1))) {  		error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  		BuildExceptionMessage (send_buffer' mdbcode' error);  		break;  	}  	bc = receive_buffer [9];  	// First: Exec writing...  	try {  		for (int ii = 0; ii < bc; ii += 2)  			modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	// Second: Exec reading and prepare the reply  	send_buffer.Add ((byte)ModbusCodes.READ_WRITE_MULTIPLE_REGISTERS);  	send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  	try {  		for (int ii = 0; ii < (qor * 2); ii += 2)  			send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  	}  	catch {  		BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  		break;  	}  	break;  default:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	BuildExceptionMessage (send_buffer' mdbcode' error);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: ret_vals = new bool[bytes * 8];  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bytes; ii++)  	send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: bytes = (qor / 8) + (qor % 8 == 0 ? 0 : 1);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: ret_vals = new bool[bytes * 8];  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bytes; ii++)  	send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.Add (EightBitToByte (ret_vals' ii * 8));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.Add ((byte)(2 * qor));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.Add ((byte)(2 * qor));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).InputRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: val = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: val = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: bc = receive_buffer [5];  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: bc = receive_buffer [5];  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < bc; ii += 2)  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < bc; ii += 2)  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < bc; ii += 2)  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bc; ii += 2)  	modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bc; ii += 2)  	modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bc; ii += 2)  	modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 6 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: and_mask = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: or_mask = ToUInt16 (receive_buffer.ToArray ()' 5);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor = ToUInt16 (receive_buffer.ToArray ()' 3);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: sa1 = ToUInt16 (receive_buffer.ToArray ()' 5);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: qor1 = ToUInt16 (receive_buffer.ToArray ()' 7);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: bc = receive_buffer [9];  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < bc; ii += 2)  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < bc; ii += 2)  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < bc; ii += 2)  		modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bc; ii += 2)  	modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bc; ii += 2)  	modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < bc; ii += 2)  	modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa1 + (ii / 2)] = ToUInt16 (receive_buffer.ToArray ()' 10 + ii);  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.AddRange (GetBytes ((ushort)(qor * 2)));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: try {  	for (int ii = 0; ii < (qor * 2); ii += 2)  		send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  }  catch {  	BuildExceptionMessage (send_buffer' mdbcode' Errors.EXCEPTION_SLAVE_DEVICE_FAILURE);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: for (int ii = 0; ii < (qor * 2); ii += 2)  	send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: ii += 2
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,AdjAndReply,The following statement contains a magic number: send_buffer.AddRange (GetBytes (modbus_db.Single (x => x.UnitID == unit_id).HoldingRegisters [sa + (ii / 2)]));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue LRC  	send_buffer.Add (LRC.CalcLRC (send_buffer.ToArray ()' 0' send_buffer.Count));  	// ASCII encoding  	send_buffer = GetASCIIBytesFromBinaryBuffer (send_buffer.ToArray ()).ToList ();  	// Add START character  	send_buffer.Insert (0' Encoding.ASCII.GetBytes (new char[] {  		ASCII_START_FRAME  	}).First ());  	// Enqueue STOP chars  	send_buffer.AddRange (Encoding.ASCII.GetBytes (new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	}));  	break;  case ConnectionType.SERIAL_RTU:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue CRC  	send_buffer.AddRange (BitConverter.GetBytes (CRC16.CalcCRC16 (send_buffer.ToArray ()' 0' send_buffer.Count)));  	// Wait for interframe delay  	Thread.Sleep (interframe_delay);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Build MBAP header  	send_buffer.InsertRange (0' GetBytes (transaction_id));  	send_buffer.InsertRange (2' GetBytes (PROTOCOL_ID));  	send_buffer.InsertRange (4' GetBytes ((ushort)(1 + send_buffer.Count - 4)));  	send_buffer.Insert (6' unit_id);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue LRC  	send_buffer.Add (LRC.CalcLRC (send_buffer.ToArray ()' 0' send_buffer.Count));  	// ASCII encoding  	send_buffer = GetASCIIBytesFromBinaryBuffer (send_buffer.ToArray ()).ToList ();  	// Add START character  	send_buffer.Insert (0' Encoding.ASCII.GetBytes (new char[] {  		ASCII_START_FRAME  	}).First ());  	// Enqueue STOP chars  	send_buffer.AddRange (Encoding.ASCII.GetBytes (new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	}));  	break;  case ConnectionType.SERIAL_RTU:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue CRC  	send_buffer.AddRange (BitConverter.GetBytes (CRC16.CalcCRC16 (send_buffer.ToArray ()' 0' send_buffer.Count)));  	// Wait for interframe delay  	Thread.Sleep (interframe_delay);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Build MBAP header  	send_buffer.InsertRange (0' GetBytes (transaction_id));  	send_buffer.InsertRange (2' GetBytes (PROTOCOL_ID));  	send_buffer.InsertRange (4' GetBytes ((ushort)(1 + send_buffer.Count - 4)));  	send_buffer.Insert (6' unit_id);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue LRC  	send_buffer.Add (LRC.CalcLRC (send_buffer.ToArray ()' 0' send_buffer.Count));  	// ASCII encoding  	send_buffer = GetASCIIBytesFromBinaryBuffer (send_buffer.ToArray ()).ToList ();  	// Add START character  	send_buffer.Insert (0' Encoding.ASCII.GetBytes (new char[] {  		ASCII_START_FRAME  	}).First ());  	// Enqueue STOP chars  	send_buffer.AddRange (Encoding.ASCII.GetBytes (new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	}));  	break;  case ConnectionType.SERIAL_RTU:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue CRC  	send_buffer.AddRange (BitConverter.GetBytes (CRC16.CalcCRC16 (send_buffer.ToArray ()' 0' send_buffer.Count)));  	// Wait for interframe delay  	Thread.Sleep (interframe_delay);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Build MBAP header  	send_buffer.InsertRange (0' GetBytes (transaction_id));  	send_buffer.InsertRange (2' GetBytes (PROTOCOL_ID));  	send_buffer.InsertRange (4' GetBytes ((ushort)(1 + send_buffer.Count - 4)));  	send_buffer.Insert (6' unit_id);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue LRC  	send_buffer.Add (LRC.CalcLRC (send_buffer.ToArray ()' 0' send_buffer.Count));  	// ASCII encoding  	send_buffer = GetASCIIBytesFromBinaryBuffer (send_buffer.ToArray ()).ToList ();  	// Add START character  	send_buffer.Insert (0' Encoding.ASCII.GetBytes (new char[] {  		ASCII_START_FRAME  	}).First ());  	// Enqueue STOP chars  	send_buffer.AddRange (Encoding.ASCII.GetBytes (new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	}));  	break;  case ConnectionType.SERIAL_RTU:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue CRC  	send_buffer.AddRange (BitConverter.GetBytes (CRC16.CalcCRC16 (send_buffer.ToArray ()' 0' send_buffer.Count)));  	// Wait for interframe delay  	Thread.Sleep (interframe_delay);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Build MBAP header  	send_buffer.InsertRange (0' GetBytes (transaction_id));  	send_buffer.InsertRange (2' GetBytes (PROTOCOL_ID));  	send_buffer.InsertRange (4' GetBytes ((ushort)(1 + send_buffer.Count - 4)));  	send_buffer.Insert (6' unit_id);  	break;  }  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: send_buffer.InsertRange (2' GetBytes (PROTOCOL_ID));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: send_buffer.InsertRange (4' GetBytes ((ushort)(1 + send_buffer.Count - 4)));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: send_buffer.InsertRange (4' GetBytes ((ushort)(1 + send_buffer.Count - 4)));  
Magic Number,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following statement contains a magic number: send_buffer.Insert (6' unit_id);  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,InitCRC16Tab,The following statement contains a magic number: if (crc_tab16 == null) {  	crc_tab16 = new ushort[256];  	for (int ii = 0; ii < 256; ii++) {  		crc = 0;  		c = (ushort)ii;  		for (int jj = 0; jj < 8; jj++) {  			if (((crc ^ c) & 0x0001) == 0x0001)  				crc = (ushort)((crc >> 1) ^ POLY);  			else  				crc = (ushort)(crc >> 1);  			c = (ushort)(c >> 1);  		}  		crc_tab16 [ii] = crc;  	}  }  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,InitCRC16Tab,The following statement contains a magic number: if (crc_tab16 == null) {  	crc_tab16 = new ushort[256];  	for (int ii = 0; ii < 256; ii++) {  		crc = 0;  		c = (ushort)ii;  		for (int jj = 0; jj < 8; jj++) {  			if (((crc ^ c) & 0x0001) == 0x0001)  				crc = (ushort)((crc >> 1) ^ POLY);  			else  				crc = (ushort)(crc >> 1);  			c = (ushort)(c >> 1);  		}  		crc_tab16 [ii] = crc;  	}  }  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,InitCRC16Tab,The following statement contains a magic number: if (crc_tab16 == null) {  	crc_tab16 = new ushort[256];  	for (int ii = 0; ii < 256; ii++) {  		crc = 0;  		c = (ushort)ii;  		for (int jj = 0; jj < 8; jj++) {  			if (((crc ^ c) & 0x0001) == 0x0001)  				crc = (ushort)((crc >> 1) ^ POLY);  			else  				crc = (ushort)(crc >> 1);  			c = (ushort)(c >> 1);  		}  		crc_tab16 [ii] = crc;  	}  }  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,InitCRC16Tab,The following statement contains a magic number: crc_tab16 = new ushort[256];  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,InitCRC16Tab,The following statement contains a magic number: for (int ii = 0; ii < 256; ii++) {  	crc = 0;  	c = (ushort)ii;  	for (int jj = 0; jj < 8; jj++) {  		if (((crc ^ c) & 0x0001) == 0x0001)  			crc = (ushort)((crc >> 1) ^ POLY);  		else  			crc = (ushort)(crc >> 1);  		c = (ushort)(c >> 1);  	}  	crc_tab16 [ii] = crc;  }  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,InitCRC16Tab,The following statement contains a magic number: for (int ii = 0; ii < 256; ii++) {  	crc = 0;  	c = (ushort)ii;  	for (int jj = 0; jj < 8; jj++) {  		if (((crc ^ c) & 0x0001) == 0x0001)  			crc = (ushort)((crc >> 1) ^ POLY);  		else  			crc = (ushort)(crc >> 1);  		c = (ushort)(c >> 1);  	}  	crc_tab16 [ii] = crc;  }  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,InitCRC16Tab,The following statement contains a magic number: for (int jj = 0; jj < 8; jj++) {  	if (((crc ^ c) & 0x0001) == 0x0001)  		crc = (ushort)((crc >> 1) ^ POLY);  	else  		crc = (ushort)(crc >> 1);  	c = (ushort)(c >> 1);  }  
Magic Number,Modbus,CRC16,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,UpdateCRC16,The following statement contains a magic number: crc = (ushort)((crc >> 8) ^ crc_tab16 [tmp & 0xff]);  
Missing Default,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,EightBitToByte,The following switch statement is missing a default case: switch (array [offset + ii]) {  case true:  	ret |= (byte)(1 << ii);  	break;  case false:  	ret &= (byte)(~(1 << ii));  	break;  }  
Missing Default,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetInterframeDelay,The following switch statement is missing a default case: switch (sp.StopBits) {  case StopBits.One:  	nbits += 1;  	break;  case StopBits.OnePointFive:  // Ceiling  case StopBits.Two:  	nbits += 2;  	break;  }  
Missing Default,Modbus,ModbusBase,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,GetIntercharDelay,The following switch statement is missing a default case: switch (sp.StopBits) {  case StopBits.One:  	nbits += 1;  	break;  case StopBits.OnePointFive:  // Ceiling  case StopBits.Two:  	nbits += 2;  	break;  }  
Missing Default,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following switch statement is missing a default case: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Add destination device address  	send_buffer.Insert (0' unit_id);  	// Calc message LCR  	byte[] lrc = GetASCIIBytesFromBinaryBuffer (new byte[] {  		LRC.CalcLRC (send_buffer.ToArray ()' 0' send_buffer.Count)  	});  	// Convert 'send_buffer' from binary to ASCII  	send_buffer = GetASCIIBytesFromBinaryBuffer (send_buffer.ToArray ()).ToList ();  	// Add LRC at the end of the message  	send_buffer.AddRange (lrc);  	// Insert the start frame char  	send_buffer.Insert (0' Encoding.ASCII.GetBytes (new char[] {  		ASCII_START_FRAME  	}).First ());  	// Insert stop frame chars  	char[] end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	send_buffer.AddRange (Encoding.ASCII.GetBytes (end_frame));  	break;  case ConnectionType.SERIAL_RTU:  	// Insert 'unit_id' in front of the message  	send_buffer.Insert (0' unit_id);  	// Append CRC16  	send_buffer.AddRange (BitConverter.GetBytes (CRC16.CalcCRC16 (send_buffer.ToArray ()' 0' send_buffer.Count)));  	// Wait for interframe delay  	Thread.Sleep (interframe_delay);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	BuildMBAPHeader (unit_id' msg_len);  	break;  }  
Missing Default,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following switch statement is missing a default case: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and remove start char  	if (receive_buffer [0] != send_buffer [0]) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (0' 1);  	// Check and remove stop chars  	char[] orig_end_frame = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] rec_end_frame = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!orig_end_frame.SequenceEqual (rec_end_frame)) {  		error = Errors.END_CHARS_NOT_FOUND;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Convert receive buffer from ASCII to binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Check and remove message LRC  	byte lrc_calculated = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	byte lrc_received = receive_buffer [receive_buffer.Count - 1];  	if (lrc_calculated != lrc_received) {  		error = Errors.WRONG_LRC;  		break;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 1' 1);  	// Remove address byte  	receive_buffer.RemoveRange (0' 1);  	break;  case ConnectionType.SERIAL_RTU:  	// Check message 16-bit CRC  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	ushort rec_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	if (rec_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Check message consistency  	byte addr = receive_buffer [0];  	if (addr != send_buffer [0]) {  		error = Errors.WRONG_RESPONSE_ADDRESS;  		return;  	}  	// Remove address  	receive_buffer.RemoveRange (0' 1);  	// Remove CRC  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Check MBAP header  	ushort tid = ToUInt16 (receive_buffer.ToArray ()' 0);  	if (tid != transaction_id) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort pid = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (pid != PROTOCOL_ID) {  		error = Errors.WRONG_TRANSACTION_ID;  		return;  	}  	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - MBAP_HEADER_LEN + 1) < len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	byte uid = receive_buffer [6];  	if (uid != send_buffer [6]) {  		error = Errors.WRONG_RESPONSE_UNIT_ID;  		return;  	}  	// Let only useful bytes in receive buffer                         	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Missing Default,Modbus,ModbusMaster,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,Query,The following switch statement is missing a default case: switch (receive_buffer [1]) {  case 1:  	error = Errors.EXCEPTION_ILLEGAL_FUNCTION;  	break;  case 2:  	error = Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS;  	break;  case 3:  	error = Errors.EXCEPTION_ILLEGAL_DATA_VALUE;  	break;  case 4:  	error = Errors.EXCEPTION_SLAVE_DEVICE_FAILURE;  	break;  }  
Missing Default,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,BuildExceptionMessage,The following switch statement is missing a default case: switch (error) {  case Errors.EXCEPTION_ILLEGAL_FUNCTION:  	exception_code = 1;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_ADDRESS:  	exception_code = 2;  	break;  case Errors.EXCEPTION_ILLEGAL_DATA_VALUE:  	exception_code = 3;  	break;  case Errors.EXCEPTION_SLAVE_DEVICE_FAILURE:  	exception_code = 4;  	break;  }  
Missing Default,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ReadByte,The following switch statement is missing a default case: switch (connection_type) {  case ConnectionType.UDP_IP:  	UDPData udpd = (UDPData)flux;  	if (udpd.Length > 0)  		ret = udpd.ReadByte ();  	break;  case ConnectionType.TCP_IP:  	NetworkStream ns = (NetworkStream)flux;  	if (ns.DataAvailable)  		ret = ns.ReadByte ();  	break;  case ConnectionType.SERIAL_ASCII:  case ConnectionType.SERIAL_RTU:  	SerialPort sp = (SerialPort)flux;  	bool done = false;  	// Await 1 char...  	if (!sw_ch.IsRunning)  		sw_ch.Start ();  	do {  		if (sp.BytesToRead > 0) {  			ret = sp.ReadByte ();  			done = true;  		}  		else  			ret = -1;  	}  	while ((!done) && ((sw_ch.ElapsedMilliseconds - char_tmo) < interchar_delay));  	if (done)  		char_tmo = sw_ch.ElapsedMilliseconds;  	// Char received with no errors...reset timeout counter for next char!  	break;  }  
Missing Default,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,WriteBuffer,The following switch statement is missing a default case: switch (connection_type) {  case ConnectionType.UDP_IP:  	UDPData udpd = (UDPData)flux;  	udpd.WriteResp (buffer' offset' size);  	break;  case ConnectionType.TCP_IP:  	NetworkStream ns = (NetworkStream)flux;  	ns.Write (buffer' offset' size);  	break;  case ConnectionType.SERIAL_ASCII:  case ConnectionType.SERIAL_RTU:  	SerialPort sp = (SerialPort)flux;  	sp.Write (buffer' offset' size);  	break;  }  
Missing Default,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,IncomingMessagePolling,The following switch statement is missing a default case: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Check and delete start char  	if (Encoding.ASCII.GetChars (receive_buffer.ToArray ()).FirstOrDefault () != ASCII_START_FRAME) {  		error = Errors.START_CHAR_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveAt (0);  	// Check and delete stop chars  	char[] end_chars = new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	};  	char[] last_two = Encoding.ASCII.GetChars (receive_buffer.GetRange (receive_buffer.Count - 2' 2).ToArray ());  	if (!end_chars.SequenceEqual (last_two)) {  		error = Errors.END_CHARS_NOT_FOUND;  		return;  	}  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	// Recode message in binary  	receive_buffer = GetBinaryBufferFromASCIIBytes (receive_buffer.ToArray ()).ToList ();  	// Calc and remove LRC  	byte msg_lrc = receive_buffer [receive_buffer.Count - 1];  	byte calc_lrc = LRC.CalcLRC (receive_buffer.ToArray ()' 0' receive_buffer.Count - 1);  	if (msg_lrc != calc_lrc) {  		error = Errors.WRONG_LRC;  		return;  	}  	receive_buffer.RemoveAt (receive_buffer.Count - 1);  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	receive_buffer.RemoveAt (0);  	break;  case ConnectionType.SERIAL_RTU:  	// Check CRC  	ushort msg_crc = BitConverter.ToUInt16 (receive_buffer.ToArray ()' receive_buffer.Count - 2);  	ushort calc_crc = CRC16.CalcCRC16 (receive_buffer.ToArray ()' 0' receive_buffer.Count - 2);  	if (msg_crc != calc_crc) {  		error = Errors.WRONG_CRC;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [0];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove unit_id and CRC                      	receive_buffer.RemoveRange (0' 1);  	receive_buffer.RemoveRange (receive_buffer.Count - 2' 2);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Decode MBAP Header  	transaction_id = ToUInt16 (receive_buffer.ToArray ()' 0);  	// Check protocol ID  	ushort protocol_id = ToUInt16 (receive_buffer.ToArray ()' 2);  	if (protocol_id != PROTOCOL_ID) {  		error = Errors.WRONG_PROTOCOL_ID;  		return;  	}  	// Acquire data length and check it                      	ushort len = ToUInt16 (receive_buffer.ToArray ()' 4);  	if ((receive_buffer.Count - 6) != len) {  		error = Errors.WRONG_MESSAGE_LEN;  		return;  	}  	// Analize destination address' if not present in database' discard message and continue  	unit_id = receive_buffer [6];  	if (!modbus_db.Any (x => x.UnitID == unit_id))  		return;  	// Message is ok' remove MBAP header for reception buffer                      	receive_buffer.RemoveRange (0' MBAP_HEADER_LEN);  	break;  }  
Missing Default,Modbus,ModbusSlave,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,SendReply,The following switch statement is missing a default case: switch (connection_type) {  case ConnectionType.SERIAL_ASCII:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue LRC  	send_buffer.Add (LRC.CalcLRC (send_buffer.ToArray ()' 0' send_buffer.Count));  	// ASCII encoding  	send_buffer = GetASCIIBytesFromBinaryBuffer (send_buffer.ToArray ()).ToList ();  	// Add START character  	send_buffer.Insert (0' Encoding.ASCII.GetBytes (new char[] {  		ASCII_START_FRAME  	}).First ());  	// Enqueue STOP chars  	send_buffer.AddRange (Encoding.ASCII.GetBytes (new char[] {  		ASCII_STOP_FRAME_1ST'  		ASCII_STOP_FRAME_2ND  	}));  	break;  case ConnectionType.SERIAL_RTU:  	// Add unit ID  	send_buffer.Insert (0' unit_id);  	// Enqueue CRC  	send_buffer.AddRange (BitConverter.GetBytes (CRC16.CalcCRC16 (send_buffer.ToArray ()' 0' send_buffer.Count)));  	// Wait for interframe delay  	Thread.Sleep (interframe_delay);  	break;  case ConnectionType.UDP_IP:  case ConnectionType.TCP_IP:  	// Build MBAP header  	send_buffer.InsertRange (0' GetBytes (transaction_id));  	send_buffer.InsertRange (2' GetBytes (PROTOCOL_ID));  	send_buffer.InsertRange (4' GetBytes ((ushort)(1 + send_buffer.Count - 4)));  	send_buffer.Insert (6' unit_id);  	break;  }  
Missing Default,Modbus,ModbusSlaveSerial,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ModbusSlaveSerial,The following switch statement is missing a default case: switch (type) {  case ModbusSerialType.ASCII:  	connection_type = ConnectionType.SERIAL_ASCII;  	break;  case ModbusSerialType.RTU:  	connection_type = ConnectionType.SERIAL_RTU;  	break;  }  
Missing Default,Modbus,ModbusMasterSerial,C:\repos\edelgiudice_iBoardingPass\modbus_v1_0_2_0.src.bin\Modbus\Modbus.cs,ModbusMasterSerial,The following switch statement is missing a default case: switch (type) {  case ModbusSerialType.RTU:  	connection_type = ConnectionType.SERIAL_RTU;  	break;  case ModbusSerialType.ASCII:  	connection_type = ConnectionType.SERIAL_ASCII;  	break;  }  
