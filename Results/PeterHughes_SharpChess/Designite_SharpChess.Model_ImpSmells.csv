Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The method has 149 lines of code.
Long Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The method has 313 lines of code.
Long Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The method has 116 lines of code.
Long Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Quiesce,The method has 104 lines of code.
Long Method,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,The method has 112 lines of code.
Long Method,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The method has 103 lines of code.
Long Method,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,LoadGame,The method has 117 lines of code.
Long Method,SharpChess.Model,PGNtoXML,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PGNtoXML.cs,Go,The method has 128 lines of code.
Long Method,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The method has 121 lines of code.
Long Method,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,The method has 113 lines of code.
Long Method,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The method has 559 lines of code.
Complex Method,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,Cyclomatic complexity of the method is 11
Complex Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,Cyclomatic complexity of the method is 30
Complex Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,Cyclomatic complexity of the method is 15
Complex Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,Cyclomatic complexity of the method is 10
Complex Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Quiesce,Cyclomatic complexity of the method is 14
Complex Method,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,SEE,Cyclomatic complexity of the method is 9
Complex Method,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,Cyclomatic complexity of the method is 13
Complex Method,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,Cyclomatic complexity of the method is 9
Complex Method,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,Game,Cyclomatic complexity of the method is 9
Complex Method,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,LoadGame,Cyclomatic complexity of the method is 19
Complex Method,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,MoveNameFromString,Cyclomatic complexity of the method is 10
Complex Method,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,Cyclomatic complexity of the method is 8
Complex Method,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,Cyclomatic complexity of the method is 9
Complex Method,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,Cyclomatic complexity of the method is 9
Complex Method,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,Cyclomatic complexity of the method is 15
Long Parameter List,SharpChess.Model.AI,HashTable,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HashTable.cs,ProbeForScore,The method has 6 parameters. Parameters: hashCodeA' hashCodeB' depth' alpha' beta' colour
Long Parameter List,SharpChess.Model.AI,HashTable,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HashTable.cs,RecordHash,The method has 9 parameters. Parameters: hashCodeA' hashCodeB' depth' val' type' from' to' moveName' colour
Long Parameter List,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,RecordHash,The method has 6 parameters. Parameters: hashCodeA' hashCodeB' from' to' moveName' colour
Long Parameter List,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The method has 9 parameters. Parameters: player' ply' variableDepth' alpha' beta' parentMove' principalVariation' totalExtensionsOrReductions' analysisParentBranch
Long Parameter List,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The method has 11 parameters. Parameters: extensionOrReduction' totalExtensionsOrReductions' ply' variableDepth' isPvNode' isInCheck' alpha' player' moveMade' legalMovesAttempted' movesPv
Long Parameter List,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The method has 9 parameters. Parameters: move' variableDepth' movePv' moveHash' moveKillerA' moveKillerA2' moveKillerB' moveKillerB2' player
Long Parameter List,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Quiesce,The method has 8 parameters. Parameters: player' ply' variableDepth' alpha' beta' parentMove' principalVariation' analysisParentBranch
Long Parameter List,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,SortBestMoves,The method has 9 parameters. Parameters: movesToSort' variableDepth' movePv' moveHash' moveKillerA' moveKillerA2' moveKillerB' moveKillerB2' player
Long Parameter List,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,AppendPiecePath,The method has 5 parameters. Parameters: moves' piece' player' offset' movesType
Long Parameter List,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,MovePieceToFenPosition,The method has 5 parameters. Parameters: charToken' intFile' intRank' blnAnyLocation' blnAllowPromotion
Long Parameter List,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Move,The method has 9 parameters. Parameters: turnNo' lastMoveTurnNo' moveName' piece' from' to' pieceCaptured' pieceCapturedOrdinal' score
Long Parameter List,SharpChess.Model,Moves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Moves.cs,Add,The method has 9 parameters. Parameters: turnNo' lastMoveTurnNo' moveName' piece' from' to' pieceCaptured' pieceCapturedOrdinal' score
Long Parameter List,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Piece,The method has 5 parameters. Parameters: name' player' file' rank' identifier
Long Parameter List,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,DoesLeaperPieceTypeAttackSquare,The method has 5 parameters. Parameters: square' player' pieceName' vector' attackingPiece
Long Parameter List,SharpChess.Model,PlayerDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerDebug.cs,DebugMatchLine,The method has 5 parameters. Parameters: strVariation' iPly' moveThis' intSearchDepth' intMaxSearchDepth
Long Parameter List,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SendThinking,The method has 5 parameters. Parameters: ply' score' thinkingTime' nodes' prinicalVariation
Long Parameter List,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SendAnalyzeStatus,The method has 6 parameters. Parameters: thinkingTime' nodes' ply' movesRemaining' totalMoves' moveCurrent
Long Statement,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The length of the statement  "                        // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection " is 128.
Long Statement,SharpChess.Model.AI,HashTable,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HashTable.cs,ProbeForBestMove,The length of the statement  "            // TODO Unit test Hash Table. What happens when same position stored at different depths in diffenent slots with the same hash? " is 127.
Long Statement,SharpChess.Model.AI,HistoryHeuristic,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HistoryHeuristic.cs,Retrieve,The length of the statement  "            return colour == Player.PlayerColourNames.White ? HistoryTableEntriesforWhite[ordinalFrom' ordinalTo] : HistoryTableEntriesforBlack[ordinalFrom' ordinalTo]; " is 156.
Long Statement,SharpChess.Model.AI,KillerMoves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\KillerMoves.cs,RecordPossibleKillerMove,The length of the statement  "            else if ((moveMade.Score > moveKillerA.Score && !Move.MovesMatch(moveMade' moveKillerB)) || Move.MovesMatch(moveMade' moveKillerA)) " is 131.
Long Statement,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,LoadOpeningBook,The length of the statement  "                RecordHash(Board.HashCodeA' Board.HashCodeB' (byte)(intScanMove >> 8 & 0xff)' (byte)(intScanMove & 0xff)' Move.MoveNames.Standard' player.Colour); " is 146.
Long Statement,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,ProbeForBestMove,The length of the statement  "                    return new Move(0' 0' phashEntry->MoveName' Board.GetPiece(phashEntry->From)' Board.GetSquare(phashEntry->From)' Board.GetSquare(phashEntry->To)' null' 0' 0); " is 158.
Long Statement,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,ScanPly,The length of the statement  "                Move.MoveNames movename = xmlnodeMove.GetAttribute("N") == null ? Move.MoveNames.Standard : Move.MoveNameFromString(xmlnodeMove.GetAttribute("N")); " is 147.
Long Statement,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,ScanPly,The length of the statement  "                    RecordHash(Board.HashCodeA' Board.HashCodeB' (byte)(intScanMove >> 8 & 0xff)' (byte)(intScanMove & 0xff)' movename' player.OpposingPlayer.Colour); " is 146.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='b2' t='b4'><m f='g8' t='h6' /><m f='c7' t='c6' /></m><m f='g2' t='g3'><m f='h7' t='h5' /><m f='e7' t='e5'><m f='g1' t='f3' /></m></m><m f='g2' t='g4'><m f='d7' t='d5'><m f='f1' t='g2'><m f='c7' t='c6'><m f='g4' t='g5' /></m><m f='c8' t='g4'><m f='c2' t='c4'><m f='d5' t='d4' /></m></m></m></m></m><m f='h2' t='h3'><m f='e7' t='e5'><m f='a2' t='a3' /></m></m><m f='g1' t='h3'><m f='d7' t='d5'><m f='g2' t='g3'><m f='e7' t='e5'><m f='f2' t='f4'><m f='c8' t='h3'><m f='f1' t='h3'><m f='e5' t='f4' /></m></m></m></m></m></m></m><m f='b1' t='c3'><m f='e7' t='e5'><m f='a2' t='a3' /></m><m f='c7' t='c5'><m f='d2' t='d4'><m f='c5' t='d4'><m f='d1' t='d4'><m f='b8' t='c6'><m f='d4' t='h4' /></m></m></m></m></m></m><m f='a2' t='a4'><m f='e7' t='e5'><m f='h2' t='h4' /></m></m><m f='d2' t='d3'><m f='e7' t='e5'><m f='b1' t='d2' /></m><m f='c7' t='c5'><m f='b1' t='c3'>"; " is 881.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='b8' t='c6'><m f='g2' t='g3' /></m></m></m></m><m f='e2' t='e3'><m f='e7' t='e5'><m f='c2' t='c4'><m f='d7' t='d6'><m f='b1' t='c3'><m f='b8' t='c6'><m f='b2' t='b3'><m f='g8' t='f6' /></m></m></m></m></m></m></m><m f='f2' t='f3'><m f='e7' t='e5'><m f='e1' t='f2' /></m></m><m f='b2' t='b3'><m f='e7' t='e5' /><m f='g8' t='f6' /><m f='d7' t='d5' /><m f='c7' t='c5' /><m f='f7' t='f5' /></m><m f='f2' t='f4'><m f='e7' t='e5'><m f='f4' t='e5'><m f='d7' t='d6'><m f='e5' t='d6'><m f='f8' t='d6'><m f='g1' t='f3'><m f='g7' t='g5' /><m f='g8' t='h6' /></m></m></m></m></m></m><m f='f7' t='f5'><m f='e2' t='e4'><m f='f5' t='e4'><m f='b1' t='c3'><m f='g8' t='f6'><m f='g2' t='g4' /></m></m></m></m></m><m f='g7' t='g5' /><m f='d7' t='d5'><m f='c2' t='c4' /><m f='e2' t='e4' /><m f='g1' t='f3'><m f='g8' t='f6'><m f='e2' t='e3'><m f='c7' t='c5' /></m></m></m></m></m><m f='g1' t='f3'>"; " is 895.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='f7' t='f5'><m f='e2' t='e4' /><m f='d2' t='d3'><m f='g8' t='f6'><m f='e2' t='e4' /></m></m></m><m f='d7' t='d6'><m f='e2' t='e4'><m f='c8' t='g4' /></m></m><m f='g7' t='g5' /><m f='g8' t='f6'><m f='g2' t='g3'><m f='b7' t='b5' /><m f='g7' t='g6'><m f='b2' t='b4' /></m></m></m><m f='d7' t='d5'><m f='d2' t='d3' /><m f='b2' t='b4' /><m f='e2' t='e4' /><m f='g2' t='g3'><m f='g8' t='f6'><m f='f1' t='g2'><m f='c7' t='c6'><m f='e1' t='g1' n='CastleKingSide'><m f='c8' t='g4' /></m></m></m></m><m f='c8' t='g4'><m f='f1' t='g2'><m f='b8' t='d7' /></m></m><m f='g7' t='g6'><m f='f1' t='g2'><m f='f8' t='g7'><m f='e1' t='g1' n='CastleKingSide'><m f='e7' t='e5' /></m></m></m></m><m f='c7' t='c5'><m f='f1' t='g2'><m f='b8' t='c6'><m f='e1' t='g1' n='CastleKingSide'><m f='e7' t='e6' /></m></m></m></m></m><m f='c2' t='c4'><m f='d5' t='d4' /><m f='d5' t='c4'><m f='e2' t='e3'><m f='c8' t='e6' /></m></m></m></m></m>"; " is 927.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='c2' t='c4'><m f='g7' t='g6'><m f='e2' t='e4'><m f='e7' t='e5' /></m></m><m f='c7' t='c6'><m f='g1' t='f3'><m f='d7' t='d5'><m f='b2' t='b3'><m f='g8' t='f6'><m f='g2' t='g3'><m f='c8' t='g4' /><m f='c8' t='f5' /></m><m f='c1' t='b2'><m f='g7' t='g6' /><m f='c8' t='f5' /><m f='c8' t='g4' /></m></m><m f='c8' t='g4' /></m></m></m></m><m f='e7' t='e6'><m f='g1' t='f3'><m f='g8' t='f6'><m f='g2' t='g3'><m f='a7' t='a6'><m f='f1' t='g2'><m f='b7' t='b5' /></m></m></m></m><m f='d7' t='d5'><m f='b2' t='b3'><m f='g8' t='f6'><m f='c1' t='b2'><m f='c7' t='c5' /></m></m></m><m f='g2' t='g3'><m f='c7' t='c6' /><m f='g8' t='f6'><m f='f1' t='g2'><m f='d5' t='c4' /><m f='f8' t='e7' /></m></m></m></m></m></m><m f='g8' t='f6'><m f='b2' t='b4' /><m f='g1' t='f3' /><m f='b1' t='c3'><m f='d7' t='d5'><m f='c4' t='d5'><m f='f6' t='d5'><m f='g2' t='g3'><m f='g7' t='g6' /></m>"; " is 884.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g1' t='f3'><m f='g7' t='g6' /></m></m></m></m><m f='e7' t='e6'><m f='g1' t='f3'><m f='b7' t='b6'><m f='e2' t='e4'><m f='c8' t='b7' /></m></m><m f='f8' t='b4' /></m><m f='e2' t='e4'><m f='d7' t='d5'><m f='e4' t='e5' /></m><m f='b8' t='c6' /><m f='c7' t='c5' /></m></m></m></m><m f='e7' t='e5'><m f='g1' t='f3'><m f='e5' t='e4' /></m><m f='b1' t='c3'><m f='d7' t='d6'><m f='g2' t='g3'><m f='c8' t='e6'><m f='f1' t='g2'><m f='b8' t='c6' /></m></m><m f='c7' t='c6' /></m><m f='g1' t='f3'><m f='c8' t='g4' /></m></m><m f='f8' t='b4' /><m f='g8' t='f6'><m f='g1' t='f3'><m f='e5' t='e4'><m f='f3' t='g5'><m f='b7' t='b5' /></m></m></m><m f='g2' t='g3'><m f='d7' t='d5' /><m f='f8' t='b4' /><m f='c7' t='c6' /><m f='g7' t='g6' /></m></m><m f='b8' t='c6'><m f='g2' t='g3'><m f='g7' t='g6'><m f='f1' t='g2'><m f='f8' t='g7' /></m></m></m><m f='g1' t='f3'><m f='g8' t='f6'>"; " is 883.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='d2' t='d4'><m f='e5' t='d4' /><m f='e5' t='e4' /></m><m f='e2' t='e4' /><m f='a2' t='a3' /><m f='d2' t='d3' /><m f='e2' t='e3'><m f='f8' t='b4' /></m><m f='g2' t='g3' /></m></m></m></m></m><m f='c7' t='c5'><m f='g1' t='f3'><m f='g8' t='f6'><m f='g2' t='g3'><m f='b7' t='b6'><m f='f1' t='g2'><m f='c8' t='b7' /></m></m></m><m f='d2' t='d4'><m f='c5' t='d4'><m f='f3' t='d4'><m f='e7' t='e6' /></m></m></m></m></m><m f='b1' t='c3'><m f='g8' t='f6'><m f='g1' t='f3'><m f='d7' t='d5'><m f='c4' t='d5'><m f='f6' t='d5' /></m></m></m><m f='g2' t='g3'><m f='d7' t='d5'><m f='c4' t='d5'><m f='f6' t='d5' /></m></m></m></m><m f='b8' t='c6'><m f='g1' t='f3'><m f='g8' t='f6' /></m><m f='g2' t='g3'><m f='g7' t='g6'><m f='f1' t='g2'><m f='f8' t='g7' /></m></m></m></m></m></m></m><m f='e2' t='e4'><m f='g8' t='h6'><m f='d2' t='d4'><m f='g7' t='g6'><m f='c2' t='c4'><m f='f7' t='f6' /></m></m></m></m>"; " is 909.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='f7' t='f6'><m f='d2' t='d4'><m f='e8' t='f7' /></m></m><m f='b7' t='b6'><m f='d2' t='d4'><m f='c8' t='a6' /></m></m><m f='b8' t='c6'><m f='b2' t='b4'><m f='c6' t='b4'><m f='c2' t='c3'><m f='b4' t='c6'><m f='d2' t='d4' /></m></m></m></m><m f='g1' t='f3'><m f='f7' t='f5' /></m><m f='d2' t='d4'><m f='d7' t='d5'><m f='e4' t='d5'><m f='d8' t='d5'><m f='b1' t='c3' /></m></m><m f='b1' t='c3' /></m><m f='f7' t='f6' /></m></m><m f='d7' t='d5'><m f='e4' t='d5'><m f='d8' t='d5'><m f='b1' t='c3'><m f='d5' t='a5'><m f='d2' t='d4'><m f='g8' t='f6' /><m f='e7' t='e5' /></m><m f='b2' t='b4' /></m><m f='d5' t='d6' /></m></m><m f='g8' t='f6'><m f='c2' t='c4'><m f='e7' t='e6' /><m f='c7' t='c6' /></m><m f='d2' t='d4'><m f='f6' t='d5'><m f='c2' t='c4'><m f='d5' t='b4' /></m></m><m f='g7' t='g6' /></m></m></m></m><m f='g8' t='f6'><m f='b1' t='c3'><m f='d7' t='d5'><m f='e4' t='e5'>"; " is 892.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='f6' t='d7'><m f='e5' t='e6' /></m></m></m></m><m f='d2' t='d3' /><m f='f1' t='c4' /><m f='e4' t='e5'><m f='f6' t='e4' /><m f='f6' t='g8' /><m f='f6' t='d5'><m f='f1' t='c4'><m f='d5' t='b6'><m f='c4' t='b3'><m f='c7' t='c5' /></m></m></m><m f='b1' t='c3' /><m f='b2' t='b3' /><m f='c2' t='c4'><m f='d5' t='b6'><m f='b2' t='b3' /><m f='c4' t='c5'><m f='b6' t='d5' /></m></m></m><m f='d2' t='d4'><m f='b7' t='b5' /><m f='d7' t='d6'><m f='f1' t='c4' /><m f='c2' t='c4'><m f='d5' t='b6' /></m><m f='g1' t='f3'><m f='d6' t='e5' /><m f='d5' t='b6' /><m f='g7' t='g6' /><m f='c8' t='g4' /></m></m></m></m></m></m><m f='g7' t='g6'><m f='d2' t='d4'><m f='g8' t='f6'><m f='e4' t='e5'><m f='f6' t='h5'><m f='g2' t='g4'><m f='h5' t='g7' /></m></m></m></m><m f='f8' t='g7'><m f='f2' t='f4' /><m f='b1' t='c3'><m f='c7' t='c6'><m f='f2' t='f4'><m f='d7' t='d5' /></m></m><m f='d7' t='d6'>"; " is 894.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g1' t='f3'><m f='c7' t='c6' /></m><m f='f2' t='f4' /></m></m><m f='g1' t='f3'><m f='d7' t='d6'><m f='c2' t='c4'><m f='c8' t='g4' /></m><m f='c2' t='c3' /></m></m></m></m></m><m f='d7' t='d6'><m f='d2' t='d4'><m f='g8' t='f6'><m f='b1' t='c3'><m f='c7' t='c6' /><m f='g7' t='g6'><m f='c1' t='e3'><m f='c7' t='c6' /></m><m f='g2' t='g3' /><m f='f1' t='c4' /><m f='c1' t='g5' /><m f='f1' t='e2'><m f='f8' t='g7' /></m><m f='g1' t='f3'><m f='f8' t='g7' /></m><m f='f2' t='f4'><m f='f8' t='g7' /></m></m></m></m></m></m><m f='c7' t='c6'><m f='f1' t='c4' /><m f='c2' t='c4'><m f='d7' t='d5' /></m><m f='d2' t='d3' /><m f='b1' t='c3'><m f='d7' t='d5'><m f='d1' t='f3' /><m f='g1' t='f3'><m f='c8' t='g4' /></m></m></m><m f='d2' t='d4'><m f='b8' t='a6'><m f='b1' t='c3'><m f='a6' t='c7' /></m></m><m f='g8' t='f6' /><m f='d7' t='d5'><m f='f2' t='f3' /><m f='b1' t='d2'><m f='d8' t='b6' /></m>"; " is 904.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='e4' t='e5'><m f='c8' t='f5'><m f='c2' t='c3'><m f='e7' t='e6' /></m></m></m><m f='e4' t='d5'><m f='c6' t='d5'><m f='f1' t='d3'><m f='b8' t='c6' /></m><m f='c2' t='c4'><m f='g8' t='f6' /></m></m></m><m f='b1' t='c3'><m f='b7' t='b5' /><m f='g7' t='g6' /><m f='d5' t='e4'><m f='f2' t='f3' /><m f='c3' t='e4'><m f='g8' t='f6' /><m f='b8' t='d7' /><m f='c8' t='f5' /></m></m></m></m></m></m><m f='c7' t='c5'><m f='c2' t='c4'><m f='d7' t='d6'><m f='b1' t='c3'><m f='b8' t='c6'><m f='g2' t='g3'><m f='h7' t='h5' /></m></m></m></m></m><m f='b2' t='b4'><m f='c5' t='b4'><m f='c2' t='c4' /><m f='a2' t='a3'><m f='d7' t='d5'><m f='e4' t='d5'><m f='d8' t='d5' /></m></m><m f='b4' t='a3' /></m></m></m><m f='d2' t='d4'><m f='c5' t='d4'><m f='g1' t='f3'><m f='e7' t='e5'><m f='c2' t='c3' /></m></m><m f='c2' t='c3'><m f='d4' t='c3'><m f='b1' t='c3'><m f='b8' t='c6' /></m></m></m></m></m><m f='c2' t='c3'>"; " is 912.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g8' t='f6'><m f='e4' t='e5'><m f='f6' t='d5'><m f='g1' t='f3'><m f='b8' t='c6' /></m></m></m></m></m><m f='b1' t='c3'><m f='e7' t='e6'><m f='g2' t='g3'><m f='d7' t='d5' /></m></m><m f='b8' t='c6'><m f='g1' t='e2' /><m f='f2' t='f4'><m f='g7' t='g6'><m f='g1' t='f3'><m f='f8' t='g7' /></m></m></m><m f='g2' t='g3'><m f='g7' t='g6'><m f='f1' t='g2'><m f='f8' t='g7' /></m></m></m></m></m><m f='g1' t='f3'><m f='d8' t='a5' /><m f='d8' t='c7' /><m f='b7' t='b6' /><m f='g7' t='g6'><m f='c2' t='c4'><m f='f8' t='h6' /></m></m><m f='a7' t='a6' /><m f='g8' t='f6'><m f='e4' t='e5'><m f='f6' t='d5'><m f='b1' t='c3'><m f='e7' t='e6' /></m></m></m></m><m f='e7' t='e6'><m f='d2' t='d4'><m f='d7' t='d5' /><m f='c5' t='d4'><m f='f3' t='d4'><m f='g8' t='f6' /><m f='a7' t='a6' /><m f='b8' t='c6' /></m></m></m></m><m f='b8' t='c6'><m f='f1' t='b5'><m f='g7' t='g6'><m f='e1' t='g1' n='CastleKingSide'>"; " is 911.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='f8' t='g7' /></m></m></m><m f='d2' t='d4'><m f='c5' t='d4'><m f='f3' t='d4'><m f='d8' t='c7' /><m f='d7' t='d5' /><m f='e7' t='e5' /><m f='g7' t='g6' /><m f='g8' t='f6' /></m></m></m></m><m f='d7' t='d6'><m f='b2' t='b4' /><m f='f1' t='b5'><m f='c8' t='d7'><m f='b5' t='d7'><m f='d8' t='d7' /></m></m></m><m f='d2' t='d4'><m f='c5' t='d4'><m f='d1' t='d4'><m f='b8' t='c6' /></m><m f='f3' t='d4'><m f='g8' t='f6' /></m></m></m></m></m></m><m f='e7' t='e6'><m f='c2' t='c4' /><m f='g1' t='f3'><m f='d7' t='d5'><m f='e4' t='e5'><m f='c7' t='c5'><m f='b2' t='b4' /></m></m></m></m><m f='b1' t='c3'><m f='d7' t='d5'><m f='f2' t='f4' /><m f='g1' t='f3' /></m></m><m f='d2' t='d3'><m f='d7' t='d5'><m f='b1' t='d2'><m f='g8' t='f6'><m f='g1' t='f3'><m f='b8' t='c6' /></m></m></m></m></m><m f='d2' t='d4'><m f='d7' t='d6' /><m f='a7' t='a6' /><m f='d7' t='d5'><m f='f1' t='d3' /><m f='c1' t='e3' />"; " is 912.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='e4' t='d5'><m f='e6' t='d5'><m f='b1' t='c3'><m f='g8' t='f6' /></m></m></m><m f='e4' t='e5'><m f='c7' t='c5'><m f='d4' t='c5' /><m f='d1' t='g4' /><m f='g1' t='f3' /><m f='c2' t='c3'><m f='d8' t='b6' /><m f='b8' t='c6' /></m></m></m><m f='b1' t='d2'><m f='f7' t='f5' /><m f='b8' t='c6'><m f='g1' t='f3'><m f='g8' t='f6' /></m></m><m f='g8' t='f6'><m f='e4' t='e5'><m f='f6' t='d7' /></m></m><m f='c7' t='c5'><m f='e4' t='d5'><m f='d8' t='d5' /><m f='e6' t='d5' /></m></m></m><m f='b1' t='c3'><m f='c7' t='c5' /><m f='d5' t='e4'><m f='c3' t='e4'><m f='c8' t='d7' /><m f='b8' t='d7' /><m f='d8' t='d5' /></m></m><m f='g8' t='f6'><m f='f1' t='d3' /><m f='c1' t='e3' /><m f='e4' t='e5'><m f='f6' t='d7' /></m><m f='c1' t='g5'><m f='d5' t='e4' /><m f='f8' t='b4' /><m f='f8' t='e7' /></m></m><m f='f8' t='b4'><m f='f1' t='d3'><m f='c7' t='c5' /></m><m f='c1' t='d2' /><m f='g1' t='e2'>"; " is 901.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='d5' t='e4' /></m><m f='e4' t='e5'><m f='d8' t='d7' /><m f='c7' t='c5' /></m></m></m></m></m></m><m f='e7' t='e5'><m f='d2' t='d4'><m f='e5' t='d4'><m f='g1' t='f3'><m f='c7' t='c5'><m f='f1' t='c4'><m f='b7' t='b5' /></m></m></m><m f='f2' t='f4' /><m f='c2' t='c3'><m f='d4' t='c3'><m f='f1' t='c4'><m f='c3' t='b2' /></m></m><m f='d7' t='d5' /></m><m f='d1' t='d4'><m f='b8' t='c6'><m f='d4' t='e3'><m f='f8' t='b4' /><m f='f7' t='f5' /><m f='g8' t='f6' /></m><m f='d4' t='c4' /></m></m></m></m><m f='f1' t='c4'><m f='c7' t='c6'><m f='d2' t='d4'><m f='d7' t='d5'><m f='e4' t='d5'><m f='c6' t='d5' /></m></m></m></m><m f='f7' t='f5'><m f='d2' t='d3' /></m><m f='f8' t='c5'><m f='d1' t='e2'><m f='b8' t='c6'><m f='c2' t='c3'><m f='g8' t='f6' /></m></m></m><m f='c2' t='c3'><m f='g8' t='f6'><m f='d2' t='d4'><m f='e5' t='d4' /></m></m><m f='d7' t='d5' /><m f='d8' t='g5' /></m><m f='d2' t='d4' />"; " is 914.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='b2' t='b4'><m f='c5' t='b4'><m f='f2' t='f4'><m f='e5' t='f4' /></m></m></m></m><m f='g8' t='f6'><m f='f2' t='f4' /><m f='d2' t='d4'><m f='e5' t='d4'><m f='g1' t='f3'><m f='d7' t='d5' /></m></m></m></m></m><m f='b1' t='c3'><m f='f8' t='b4'><m f='d1' t='g4'><m f='g8' t='f6' /></m></m><m f='b8' t='c6'><m f='g2' t='g3' /><m f='d2' t='d4' /><m f='f2' t='f4'><m f='e5' t='f4'><m f='d2' t='d4'><m f='d8' t='h4' /></m><m f='g1' t='f3'><m f='g7' t='g5' /></m></m></m></m><m f='g8' t='f6'><m f='a2' t='a3' /><m f='g2' t='g3' /><m f='f1' t='c4'><m f='f6' t='e4'><m f='d1' t='h5'><m f='e4' t='d6' /></m><m f='g1' t='f3'><m f='d7' t='d5' /></m></m><m f='b8' t='c6' /></m><m f='f2' t='f4'><m f='d7' t='d5'><m f='f4' t='e5'><m f='f6' t='e4' /></m><m f='d2' t='d3' /></m></m></m></m><m f='f2' t='f4'><m f='d8' t='h4'><m f='g2' t='g3'><m f='h4' t='e7' /></m></m><m f='c7' t='c5' /><m f='d8' t='f6'>"; " is 904.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g1' t='f3'><m f='f6' t='f4'><m f='b1' t='c3'><m f='f8' t='b4' /></m></m></m></m><m f='f8' t='c5'><m f='g1' t='f3'><m f='d7' t='d6'><m f='b1' t='c3'><m f='g8' t='f6' /><m f='b8' t='d7' /></m><m f='c2' t='c3'><m f='c8' t='g4' /><m f='f7' t='f5' /></m><m f='f4' t='e5' /><m f='b2' t='b4' /></m></m></m><m f='g8' t='f6' /><m f='d7' t='d5'><m f='g1' t='f3' /><m f='b1' t='c3' /><m f='e4' t='d5'><m f='c7' t='c6' /><m f='e5' t='e4'><m f='b1' t='c3'><m f='g8' t='f6' /></m><m f='f1' t='b5' /><m f='d2' t='d3'><m f='g8' t='f6' /></m></m></m></m><m f='e5' t='f4'><m f='e1' t='f2' /><m f='b2' t='b3' /><m f='h2' t='h4' /><m f='f1' t='d3' /><m f='d1' t='e2' /><m f='d2' t='d4' /><m f='b1' t='c3' /><m f='d1' t='f3' /><m f='f1' t='e2' /><m f='f1' t='c4'><m f='d8' t='h4'><m f='e1' t='f1'><m f='d7' t='d5' /><m f='f8' t='c5' /><m f='g7' t='g5' /><m f='b8' t='c6' /><m f='b7' t='b5' /></m></m>"; " is 899.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='b7' t='b5' /><m f='g8' t='e7' /><m f='b8' t='c6' /><m f='c7' t='c6' /><m f='f7' t='f5'><m f='d1' t='e2'><m f='d8' t='h4' /></m></m><m f='d7' t='d5'><m f='c4' t='d5'><m f='d8' t='h4' /><m f='c7' t='c6' /><m f='g8' t='f6' /></m></m><m f='g8' t='f6'><m f='b1' t='c3'><m f='f8' t='b4' /><m f='c7' t='c6' /></m></m></m><m f='g1' t='f3'><m f='g8' t='e7' /><m f='f7' t='f5' /><m f='d7' t='d6' /><m f='h7' t='h6' /><m f='g8' t='f6' /><m f='f8' t='e7'><m f='f1' t='c4'><m f='e7' t='h4' /><m f='g8' t='f6' /></m></m><m f='d7' t='d5'><m f='e4' t='d5'><m f='g8' t='f6' /></m></m><m f='g7' t='g5'><m f='b1' t='c3' /><m f='d2' t='d4'><m f='g5' t='g4' /></m><m f='f1' t='c4'><m f='b8' t='c6' /><m f='g5' t='g4' /><m f='f8' t='g7' /></m><m f='h2' t='h4'><m f='g5' t='g4' /></m></m></m></m></m><m f='g1' t='f3'><m f='d8' t='e7' /><m f='d8' t='f6' /><m f='f7' t='f6' /><m f='d7' t='d5'><m f='e4' t='d5'>"; " is 905.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='f8' t='d6' /></m></m><m f='f7' t='f5'><m f='f3' t='e5'><m f='d8' t='f6'><m f='d2' t='d4'><m f='d7' t='d6' /></m></m><m f='b8' t='c6' /></m><m f='f1' t='c4'><m f='f5' t='e4'><m f='f3' t='e5'><m f='d8' t='g5' /><m f='d7' t='d5' /><m f='g8' t='f6' /></m></m></m></m><m f='d7' t='d6'><m f='f1' t='c4'><m f='f8' t='e7'><m f='c2' t='c3' /></m><m f='f7' t='f5'><m f='d2' t='d4'><m f='e5' t='d4' /></m></m></m><m f='d2' t='d4'><m f='f7' t='f5'><m f='d4' t='e5'><m f='f5' t='e4' /></m><m f='b1' t='c3' /></m><m f='e5' t='d4'><m f='d1' t='d4'><m f='c8' t='d7' /></m><m f='f3' t='d4'><m f='d6' t='d5' /><m f='g8' t='f6' /><m f='g7' t='g6' /></m></m><m f='g8' t='f6'><m f='b1' t='c3'><m f='b8' t='d7' /></m><m f='d4' t='e5'><m f='f6' t='e4' /></m><m f='f3' t='g5' /><m f='f1' t='c4' /></m><m f='b8' t='d7'><m f='f1' t='c4'><m f='c7' t='c6' /></m></m></m></m><m f='g8' t='f6'><m f='f3' t='e5'>"; " is 900.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='d7' t='d6'><m f='e5' t='f3'><m f='f6' t='e4' /></m><m f='e5' t='f7' /><m f='e5' t='c4' /></m><m f='f6' t='e4' /></m><m f='b1' t='c3' /><m f='f1' t='c4' /><m f='d2' t='d4'><m f='e5' t='d4'><m f='e4' t='e5'><m f='f6' t='e4' /></m><m f='f1' t='c4' /></m><m f='f6' t='e4'><m f='f1' t='d3'><m f='d7' t='d5' /></m></m></m></m><m f='b8' t='c6'><m f='f3' t='e5'><m f='c6' t='e5'><m f='d2' t='d4' /></m></m><m f='g2' t='g3' /><m f='c2' t='c4' /><m f='f1' t='e2'><m f='g8' t='f6'><m f='d2' t='d3'><m f='d7' t='d5' /></m><m f='d2' t='d4' /></m></m><m f='c2' t='c3'><m f='d7' t='d5'><m f='d1' t='a4'><m f='c8' t='d7' /><m f='g8' t='f6' /><m f='f7' t='f6' /></m></m><m f='g8' t='f6'><m f='d2' t='d4'><m f='f6' t='e4' /></m></m><m f='g8' t='e7' /><m f='f8' t='e7' /><m f='f7' t='f5'><m f='d2' t='d4'><m f='d7' t='d6' /></m></m></m><m f='d2' t='d4'><m f='c6' t='d4'><m f='f3' t='e5'><m f='d4' t='e6' />"; " is 907.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "</m></m><m f='e5' t='d4'><m f='f1' t='b5' /><m f='c2' t='c3'><m f='d4' t='c3' /></m><m f='f1' t='c4'><m f='f8' t='c5' /><m f='f8' t='b4' /><m f='f8' t='e7' /><m f='g8' t='f6' /></m><m f='f3' t='d4'><m f='c6' t='d4' /><m f='d8' t='h4' /><m f='g8' t='f6' /><m f='f8' t='c5' /></m></m></m><m f='b1' t='c3'><m f='f8' t='b4'><m f='c3' t='d5'><m f='g8' t='f6' /></m></m><m f='f7' t='f5' /><m f='g7' t='g6'><m f='d2' t='d4'><m f='e5' t='d4' /></m></m><m f='g8' t='f6'><m f='f3' t='e5' /><m f='f1' t='c4' /><m f='a2' t='a3' /><m f='d2' t='d4'><m f='f8' t='b4' /><m f='e5' t='d4' /></m><m f='f1' t='b5'><m f='a7' t='a6' /><m f='f8' t='c5' /><m f='c6' t='d4' /><m f='f8' t='b4' /></m></m></m><m f='f1' t='c4'><m f='c6' t='d4'><m f='f3' t='e5'><m f='d8' t='g5' /></m></m><m f='f7' t='f5' /><m f='f8' t='e7'><m f='d2' t='d4'><m f='e5' t='d4' /></m></m><m f='f8' t='c5'><m f='b1' t='c3'><m f='g8' t='f6' />"; " is 907.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "</m><m f='c4' t='f7' /><m f='d2' t='d3'><m f='f7' t='f5' /><m f='g8' t='f6' /></m><m f='b2' t='b4'><m f='c5' t='b6' /><m f='d7' t='d5' /><m f='c5' t='b4' /></m><m f='c2' t='c3'><m f='d7' t='d6' /><m f='d8' t='e7' /><m f='g8' t='f6' /></m></m><m f='g8' t='f6'><m f='e1' t='g1' n='CastleKingSide'><m f='f8' t='c5' /></m><m f='d2' t='d3' /><m f='d2' t='d4'><m f='e5' t='d4' /></m><m f='f3' t='g5'><m f='f8' t='c5' /><m f='d7' t='d5' /></m></m></m><m f='f1' t='b5'><m f='f7' t='f6' /><m f='c6' t='a5' /><m f='f8' t='e7' /><m f='d8' t='e7' /><m f='g7' t='g5' /><m f='g7' t='g6' /><m f='g8' t='e7'><m f='b1' t='c3'><m f='g7' t='g6' /></m></m><m f='c6' t='d4'><m f='f3' t='d4'><m f='e5' t='d4' /></m></m><m f='d7' t='d6'><m f='d2' t='d4'><m f='c8' t='d7' /></m></m><m f='f7' t='f5'><m f='b1' t='c3' /></m><m f='f8' t='c5'><m f='e1' t='g1' n='CastleKingSide'><m f='c6' t='d4' /></m><m f='c2' t='c3'>"; " is 905.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g8' t='f6' /><m f='c5' t='b6' /><m f='d8' t='e7' /><m f='f7' t='f5' /></m></m><m f='g8' t='f6'><m f='d2' t='d4'><m f='e5' t='d4' /></m><m f='d2' t='d3'><m f='c6' t='e7' /><m f='d7' t='d6' /><m f='f8' t='c5' /></m><m f='e1' t='g1' n='CastleKingSide'><m f='f8' t='c5' /><m f='d7' t='d6' /><m f='f6' t='e4' /></m></m><m f='a7' t='a6'><m f='b5' t='c6'><m f='d7' t='c6' /></m><m f='b5' t='a4'><m f='g7' t='g6' /><m f='g8' t='e7' /><m f='c6' t='d4' /><m f='f8' t='b4' /><m f='f8' t='c5' /><m f='b7' t='b5' /><m f='f7' t='f5' /><m f='d7' t='d6' /><m f='g8' t='f6' /></m></m></m></m></m></m></m><m f='d2' t='d4'><m f='e7' t='e5'><m f='d4' t='e5'><m f='b8' t='c6'><m f='g1' t='f3'><m f='d8' t='e7'><m f='d1' t='d5'><m f='f7' t='f6' /></m></m></m></m></m></m><m f='e7' t='e6'><m f='c2' t='c4'><m f='b7' t='b6' /><m f='f8' t='b4' /></m></m><m f='g7' t='g6'><m f='c2' t='c4'><m f='f8' t='g7'>"; " is 900.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='b1' t='c3'><m f='c7' t='c5'><m f='d4' t='d5'><m f='g7' t='c3' /></m></m></m></m></m></m><m f='d7' t='d6'><m f='g1' t='f3'><m f='c8' t='g4' /></m><m f='c2' t='c4'><m f='g7' t='g6'><m f='b1' t='c3'><m f='f8' t='g7'><m f='e2' t='e4'><m f='c7' t='c5' /><m f='f7' t='f5' /><m f='b8' t='c6' /></m></m></m></m></m></m><m f='c7' t='c5'><m f='d4' t='d5'><m f='e7' t='e6'><m f='e2' t='e4' /></m><m f='f7' t='f5' /><m f='g8' t='f6'><m f='b1' t='c3'><m f='d8' t='a5' /></m><m f='g1' t='f3'><m f='c5' t='c4' /></m></m><m f='d7' t='d6'><m f='b1' t='c3'><m f='g7' t='g6' /></m></m><m f='e7' t='e5'><m f='e2' t='e4'><m f='d7' t='d6' /></m></m></m></m><m f='f7' t='f5'><m f='b1' t='c3'><m f='g8' t='f6'><m f='g2' t='g4' /></m></m><m f='d1' t='d3'><m f='e7' t='e6'><m f='g2' t='g4' /></m></m><m f='g2' t='g3'><m f='g8' t='f6'><m f='f1' t='g2'><m f='e7' t='e6'><m f='g1' t='h3' /></m><m f='g7' t='g6' /></m></m>"; " is 912.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g7' t='g6'><m f='f1' t='g2'><m f='f8' t='g7'><m f='g1' t='f3'><m f='c7' t='c6' /></m><m f='g1' t='h3' /></m></m></m></m><m f='e2' t='e4'><m f='d7' t='d6' /><m f='f5' t='e4'><m f='b1' t='c3'><m f='g8' t='f6'><m f='g2' t='g4' /><m f='c1' t='g5'><m f='g7' t='g6' /><m f='c7' t='c6' /><m f='b7' t='b6' /></m></m></m></m></m><m f='c2' t='c4'><m f='g7' t='g6'><m f='b1' t='c3'><m f='g8' t='h6' /></m></m><m f='e7' t='e6'><m f='b1' t='c3' /><m f='e2' t='e4' /></m><m f='g8' t='f6'><m f='b1' t='c3' /><m f='g2' t='g3'><m f='d7' t='d6'><m f='f1' t='g2'><m f='c7' t='c6' /></m></m><m f='g7' t='g6'><m f='f1' t='g2'><m f='f8' t='g7' /></m></m><m f='e7' t='e6'><m f='f1' t='g2'><m f='f8' t='b4' /><m f='f8' t='e7' /></m></m></m></m></m></m><m f='d7' t='d5'><m f='c1' t='f4'><m f='c7' t='c5' /></m><m f='e2' t='e3'><m f='g8' t='f6'><m f='f1' t='d3' /></m></m><m f='b1' t='c3'><m f='c8' t='g4' />"; " is 902.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g8' t='f6'><m f='e2' t='e4'><m f='d5' t='e4'><m f='f2' t='f3'><m f='e4' t='f3' /></m></m><m f='e7' t='e5' /></m><m f='c1' t='g5'><m f='c8' t='f5'><m f='g5' t='f6' /><m f='f2' t='f3' /></m></m></m></m><m f='g1' t='f3'><m f='b8' t='c6' /><m f='c7' t='c5' /><m f='g8' t='f6'><m f='c1' t='f4' /><m f='c1' t='g5' /><m f='e2' t='e3'><m f='e7' t='e6'><m f='b1' t='d2'><m f='c7' t='c5' /></m><m f='f1' t='d3'><m f='c7' t='c5' /></m></m></m></m></m><m f='c2' t='c4'><m f='c8' t='f5' /><m f='g8' t='f6' /><m f='c7' t='c5' /><m f='b8' t='c6'><m f='b1' t='c3'><m f='d5' t='c4'><m f='g1' t='f3' /></m></m></m><m f='e7' t='e5'><m f='d4' t='e5'><m f='d5' t='d4'><m f='e2' t='e3'><m f='f8' t='b4' /></m><m f='g1' t='f3'><m f='b8' t='c6' /></m></m></m></m><m f='c7' t='c6'><m f='b1' t='c3'><m f='d5' t='c4'><m f='e2' t='e4' /></m><m f='e7' t='e5' /></m><m f='c4' t='d5' /><m f='g1' t='f3'>"; " is 892.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g8' t='f6'><m f='b1' t='d2' /><m f='e2' t='e3'><m f='c8' t='f5' /></m><m f='c4' t='d5'><m f='c6' t='d5' /></m><m f='b1' t='c3'><m f='d8' t='b6' /><m f='g7' t='g6' /><m f='d5' t='c4' /></m></m></m></m><m f='d5' t='c4'><m f='e2' t='e4'><m f='c7' t='c5'><m f='d4' t='d5'><m f='g8' t='f6' /></m></m><m f='f7' t='f5' /></m><m f='g1' t='f3'><m f='b7' t='b5' /><m f='a7' t='a6'><m f='e2' t='e4' /><m f='e2' t='e3'><m f='c8' t='g4' /><m f='b7' t='b5' /></m></m><m f='g8' t='f6'><m f='d1' t='a4' /><m f='b1' t='c3'><m f='a7' t='a6' /></m><m f='e2' t='e3'><m f='g7' t='g6' /><m f='c8' t='g4' /><m f='c8' t='e6' /><m f='e7' t='e6' /></m></m></m></m><m f='e7' t='e6'><m f='g1' t='f3'><m f='g8' t='f6'><m f='e2' t='e3'><m f='c7' t='c6' /></m><m f='c1' t='g5'><m f='b8' t='d7' /><m f='f8' t='b4' /><m f='h7' t='h6' /></m></m></m><m f='b1' t='c3'><m f='a7' t='a6' /><m f='b7' t='b6' />"; " is 890.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='f8' t='e7' /><m f='c7' t='c6'><m f='g1' t='f3'><m f='d5' t='c4' /></m><m f='e2' t='e4' /></m><m f='c7' t='c5'><m f='c4' t='d5'><m f='c5' t='d4' /><m f='e6' t='d5' /></m></m><m f='g8' t='f6'><m f='c1' t='f4' /><m f='c4' t='d5'><m f='e6' t='d5' /></m><m f='g1' t='f3'><m f='f8' t='e7' /><m f='f8' t='b4' /><m f='c7' t='c5' /><m f='c7' t='c6' /></m><m f='c1' t='g5'><m f='c7' t='c5' /><m f='b8' t='d7' /><m f='f8' t='e7' /></m></m></m></m></m></m><m f='g8' t='f6'><m f='g2' t='g4' /><m f='f2' t='f4' /><m f='f2' t='f3'><m f='d7' t='d5'><m f='e2' t='e4' /><m f='g2' t='g4' /></m></m><m f='g1' t='f3'><m f='e7' t='e6'><m f='c1' t='g5'><m f='c7' t='c5'><m f='e2' t='e4' /></m></m><m f='e2' t='e3' /></m><m f='f6' t='e4' /><m f='b7' t='b6'><m f='g2' t='g3'><m f='c8' t='b7'><m f='f1' t='g2'><m f='c7' t='c5' /></m></m></m></m><m f='g7' t='g6'><m f='c1' t='g5' /><m f='c1' t='f4' />"; " is 894.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='g2' t='g3' /></m></m><m f='c2' t='c4'><m f='b8' t='c6' /><m f='b7' t='b6' /><m f='e7' t='e5'><m f='d4' t='e5'><m f='f6' t='e4'><m f='d1' t='c2' /></m><m f='f6' t='g4'><m f='g1' t='f3' /><m f='c1' t='f4' /><m f='e2' t='e4'><m f='g4' t='e5' /><m f='d7' t='d6' /></m></m></m></m><m f='d7' t='d6'><m f='b1' t='c3'><m f='c8' t='f5' /><m f='e7' t='e5'><m f='e2' t='e3'><m f='b8' t='d7' /></m><m f='g1' t='f3'><m f='b8' t='d7' /></m></m></m></m><m f='c7' t='c5'><m f='d4' t='d5'><m f='d7' t='d6' /><m f='f6' t='e4' /><m f='e7' t='e5'><m f='b1' t='c3'><m f='d7' t='d6' /></m></m><m f='b7' t='b5'><m f='c4' t='b5'><m f='a7' t='a6' /></m></m><m f='e7' t='e6'><m f='b1' t='c3'><m f='e6' t='d5' /></m></m></m></m><m f='e7' t='e6'><m f='c1' t='g5' /><m f='g2' t='g3'><m f='d7' t='d5'><m f='f1' t='g2'><m f='d5' t='c4' /><m f='f8' t='e7' /></m></m></m><m f='g1' t='f3'><m f='c7' t='c5'>"; " is 892.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='d4' t='d5'><m f='b7' t='b5' /></m></m><m f='a7' t='a6' /><m f='f6' t='e4' /><m f='f8' t='b4'><m f='b1' t='d2' /><m f='c1' t='d2'><m f='d8' t='e7' /><m f='b4' t='d2' /></m></m><m f='b7' t='b6'><m f='c1' t='f4' /><m f='a2' t='a3' /><m f='b1' t='c3'><m f='c8' t='b7' /></m><m f='e2' t='e3'><m f='c8' t='b7' /></m><m f='g2' t='g3'><m f='c8' t='a6' /><m f='c8' t='b7' /></m></m></m><m f='b1' t='c3'><m f='f8' t='b4'><m f='f2' t='f3' /><m f='d1' t='d3' /><m f='g2' t='g3' /><m f='g1' t='f3'><m f='c7' t='c5' /></m><m f='d1' t='b3'><m f='c7' t='c5' /></m><m f='a2' t='a3'><m f='b4' t='c3' /></m><m f='c1' t='g5'><m f='h7' t='h6' /></m><m f='d1' t='c2'><m f='e8' t='g8' n='CastleKingSide' /><m f='b8' t='c6' /><m f='d7' t='d5' /><m f='c7' t='c5' /></m><m f='e2' t='e3'><m f='b8' t='c6' /><m f='c7' t='c5' /><m f='b7' t='b6' /><m f='e8' t='g8' n='CastleKingSide' /></m></m></m></m><m f='g7' t='g6'>"; " is 909.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Initialise,The length of the statement  "            strBook += "<m f='f2' t='f3'><m f='d7' t='d5' /></m><m f='g1' t='f3' /><m f='d1' t='c2' /><m f='d4' t='d5'><m f='b7' t='b5' /></m><m f='g2' t='g3'><m f='d7' t='d5'><m f='f1' t='g2'><m f='f8' t='g7' /></m></m><m f='f8' t='g7'><m f='f1' t='g2'><m f='d7' t='d5' /></m></m></m><m f='b1' t='c3'><m f='d7' t='d5'><m f='g2' t='g4' /><m f='c1' t='g5'><m f='f6' t='e4' /></m><m f='d1' t='b3' /><m f='c1' t='f4'><m f='f8' t='g7' /></m><m f='c4' t='d5'><m f='f6' t='d5' /></m><m f='g1' t='f3'><m f='c7' t='c6' /><m f='f8' t='g7' /></m></m><m f='f8' t='g7'><m f='g1' t='f3'><m f='d7' t='d6' /></m><m f='e2' t='e4'><m f='d7' t='d6' /></m></m></m></m></m></m></m>"; " is 651.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,BuildHashtable,The length of the statement  "                Move moveThis = Board.GetSquare(xmlnodeMove.GetAttribute("f")).Piece.Move(Move.MoveNameFromString(xmlnodeMove.GetAttribute("n"))' Board.GetSquare(xmlnodeMove.GetAttribute("t"))); " is 178.
Long Statement,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Convert,The length of the statement  "                        XmlElement xmlnodeBookChild = (XmlElement)xmlnodeBookPos.SelectSingleNode("m[@f=\"" + xmlnodeMove.GetAttribute("From") + "\" and @t=\"" + xmlnodeMove.GetAttribute("To") + "\"]"); " is 178.
Long Statement,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The length of the statement  "            // Type of hash entry that will be stored in the Transposition Table. http://chessprogramming.wikispaces.com/Transposition+Table " is 128.
Long Statement,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The length of the statement  "            // Check if this node (position) is in the tranposition (hash) table' and if appropriate' return the score stored there. " is 120.
Long Statement,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The length of the statement  "                    // Attempt a Principal Variation Search (PVS) using a zero window. http://chessprogramming.wikispaces.com/Principal+Variation+Search " is 132.
Long Statement,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The length of the statement  "            // Reduce if move is 1) low in the search order and 2) has a poor history score and 3) not in check and 4) not already reduced or extended. " is 139.
Long Statement,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Quiesce,The length of the statement  "                // TODO Unit test that negative depths produce score that reduce as they get deeper. The purpose here is to make deeper checks score less than shallower ones. " is 158.
Long Statement,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The length of the statement  "                    "1000: A FEN string must 1 to 6 fields separated by spaces\n e.g. rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"); " is 125.
Long Statement,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,AddSaveGameNode,The length of the statement  "            xmlnodeMove.SetAttribute("SecondsElapsed"' Convert.ToInt32(move.TimeStamp.TotalSeconds).ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The length of the statement  "                Board.GetSquare(move.To.Ordinal - move.Piece.Player.PawnForwardOffset).Piece = move.PieceCaptured; // Return En Passent pawn taken " is 130.
Long Statement,SharpChess.Model,Moves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Moves.cs,Add,The length of the statement  "            this.moves.Add(new Move(turnNo' lastMoveTurnNo' moveName' piece' from' to' pieceCaptured' pieceCapturedOrdinal' score)); " is 120.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The length of the statement  "                        if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The length of the statement  "                        moves.Add(0' 0' Move.MoveNames.CastleKingSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal + 2)' null' 0' 0); " is 135.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The length of the statement  "                        moves.Add(Game.TurnNo' this.Base.LastMoveTurnNo' Move.MoveNames.CastleQueenSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal - 2)' null' 0' 0); " is 169.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The length of the statement  "                        if (square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The length of the statement  "            if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKnight,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKnight.cs,GenerateLazyMoves,The length of the statement  "                        if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,PieceKnight,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKnight.cs,GenerateLazyMoves,The length of the statement  "                        if (square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))) " is 133.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.  " is 142.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.  " is 133.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.  " is 250.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.  " is 154.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.  " is 290.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.  " is 123.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.  " is 239.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.  " is 216.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.  " is 182.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.  " is 665.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.  " is 270.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.  " is 153.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.  " is 203.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.  " is 136.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.  " is 352.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.  " is 201.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:  " is 416.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.  " is 395.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.  " is 472.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white   " is 374.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:  " is 130.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.  " is 158.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.  " is 377.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).  " is 248.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.  " is 303.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)  " is 336.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color. " is 236.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the  " is 123.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login  " is 124.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other  " is 128.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard  " is 127.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this " is 128.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on " is 123.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                        to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not " is 120.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS) " is 137.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature" " is 138.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The length of the statement  "                    // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.  " is 711.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SendThinking,The length of the statement  "                pv Freeform text giving current "best" line. You can continue the pv onto another line if you start each continuation line with at least four space characters.   " is 159.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The length of the statement  "                    See below for the syntax of moves. If the move is illegal' print an error message; see the section "Commands from the engine to xboard". If the move is legal and in turn' make it. If not in force mode' stop the opponent's clock' start the engine's clock' start thinking' and eventually make a move.  " is 298.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The length of the statement  "                    Beginning in protocol version 2' you can use the feature command to select SAN (standard algebraic notation) instead; for example' e4' Nf3' exd5' Bxf7+' Qxf7#' e8=Q' O-O' or P@h3. Note that the last form' P@h3' is a extension to the PGN standard's definition of SAN' which does not support bughouse or crazyhouse.  " is 313.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The length of the statement  "                    xboard doesn't reliably detect illegal moves' because it does not keep track of castling unavailability due to king or rook moves' or en passant availability. If xboard sends an illegal move' send back an error message so that xboard can retract it and inform the user; see the section "Commands from the engine to xboard".  " is 323.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SendAnalyzeStatus,The length of the statement  "                After 12.34 seconds' I've searched 7 ply/30000 nodes' there are a total of 30 legal moves' and I have 5 more moves to search before going to depth 8. In the second example' of the 30 legal moves' the one I am currently searching is Nf3. " is 236.
Long Statement,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SetLevel,The length of the statement  "                The 40 means that there are 40 moves per time control. The 5 means there are 5 minutes in the control. In the second example' the 0:30 means there are 30 seconds. The final 0 means that we are in conventional clock mode.  " is 220.
Complex Conditional,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,StartPondering,The conditional expression  "!this.IsThinking && !this.MyPlayer.OpposingPlayer.Brain.IsThinking                      && this.MyPlayer.OpposingPlayer.Intellegence == Player.PlayerIntellegenceNames.Computer                      && Game.PlayerToPlay == this.MyPlayer"  is complex.
Complex Conditional,SharpChess.Model.AI,HashTable,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HashTable.cs,ProbeForScore,The conditional expression  "phashEntry >= phashBase                         &&                         (phashEntry->HashCodeA != hashCodeA || phashEntry->HashCodeB != hashCodeB                          || phashEntry->Depth < depth)"  is complex.
Complex Conditional,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,IterativeDeepeningSearch,The conditional expression  "!Game.IsInAnalyseMode && Game.ClockFixedTimePerMove.TotalSeconds <= 0 && !this.MyBrain.IsPondering                      && this.MyBrain.ThinkingTimeElpased > searchTimeCutoff"  is complex.
Complex Conditional,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyExtensions,The conditional expression  "parentMove != null && parentMove.PieceCaptured != null && moveMade.PieceCaptured != null                           && parentMove.PieceCaptured.BasicValue == moveMade.PieceCaptured.BasicValue                           && parentMove.To == moveMade.To"  is complex.
Complex Conditional,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyExtensions,The conditional expression  "moveMade.Piece.Name == Piece.PieceNames.Pawn                           &&                           ((moveMade.Piece.Player.Colour == Player.PlayerColourNames.White && moveMade.To.Rank == 6)                            ||                            (moveMade.Piece.Player.Colour == Player.PlayerColourNames.Black && moveMade.To.Rank == 1))"  is complex.
Complex Conditional,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The conditional expression  "variableDepth > (r + 1) && parentMove != null && parentMove.Name != Move.MoveNames.NullMove                      && Game.Stage != Game.GameStageNames.End && !isInCheck"  is complex.
Complex Conditional,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The conditional expression  "!Game.IsInAnalyseMode && !this.MyBrain.IsPondering && this.SearchDepth > MinSearchDepth                      && this.MyBrain.ThinkingTimeElpased > this.MaxSearchTimeAllowed"  is complex.
Complex Conditional,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,OpenLinePenalty,The conditional expression  "intSquareCount <= 2                     &&                     ((square = GetSquare(intOrdinal)) != null                      &&                      (square.Piece == null                       || (square.Piece.Name != Piece.PieceNames.Pawn && square.Piece.Name != Piece.PieceNames.Rook)                       || square.Piece.Player.Colour != colour))"  is complex.
Complex Conditional,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The conditional expression  "(whiteQueen > 9) || (whiteBishop > 9) || (whiteKnight > 9) || (whitePawn > 8)"  is complex.
Complex Conditional,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The conditional expression  "(blackQueen > 9) || (blackBishop > 9) || (blackKnight > 9) || (blackPawn > 8)"  is complex.
Complex Conditional,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck3Castle,The conditional expression  "(whiteKing > 1) || (whiteQueen > 1) || (blackKing > 1) || (blackQueen > 1) || (dash > 1)"  is complex.
Complex Conditional,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck3Castle,The conditional expression  "(dash == 1) && ((whiteKing == 1) || (whiteQueen == 1) || (blackKing == 1) || (blackQueen == 1))"  is complex.
Complex Conditional,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck4EnPassant,The conditional expression  "((fenString[0] >= 'a') && (fenString[0] <= 'h'))                       &&                       (((fenString.Length == 2) && (fenString[1] != '3') && (fenString[1] != '6'))                        || (fenString.Length > 2))"  is complex.
Complex Conditional,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenGet4EnPassant,The conditional expression  "(Game.MoveHistory.Count > 0) && (Game.MoveHistory.Last.Piece.Name == Piece.PieceNames.Pawn)                  && (Game.MoveHistory.Last.From.File == Game.MoveHistory.Last.To.File)                  &&                  (((Game.MoveHistory.Last.From.Rank == Game.MoveHistory.Last.To.Rank + 2)                    && (Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.Black))                   ||                   ((Game.MoveHistory.Last.From.Rank == Game.MoveHistory.Last.To.Rank - 2)                    && (Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.White)))"  is complex.
Complex Conditional,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,MovePieceToFenPosition,The conditional expression  "(pieceCaptured.Name == piecename || (blnAllowPromotion && pieceCaptured.Name == Piece.PieceNames.Pawn))                      && (pieceCaptured.StartLocation == Board.GetSquare(intFile' intRank) || blnAnyLocation)"  is complex.
Complex Conditional,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Move,The conditional expression  "moveName != MoveNames.NullMove && pieceCaptured == null && piece != null && piece.Name != Piece.PieceNames.Pawn"  is complex.
Complex Conditional,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,CanBeDrivenAwayByPawn,The conditional expression  "piece != null && piece.Player.Colour != this.Player.Colour && piece.Name == PieceNames.Pawn                  && !piece.HasMoved"  is complex.
Complex Conditional,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,CanBeDrivenAwayByPawn,The conditional expression  "piece != null && piece.Player.Colour != this.Player.Colour && piece.Name == PieceNames.Pawn                  && !piece.HasMoved"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The conditional expression  "square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKnight,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKnight.cs,GenerateLazyMoves,The conditional expression  "square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PieceKnight,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKnight.cs,GenerateLazyMoves,The conditional expression  "square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable))"  is complex.
Complex Conditional,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,The conditional expression  "(this.Base.Square.Rank == 4 && this.Base.Player.Colour == Player.PlayerColourNames.White)                  || (this.Base.Square.Rank == 3 && this.Base.Player.Colour == Player.PlayerColourNames.Black)"  is complex.
Complex Conditional,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,The conditional expression  "(piecePassed = Board.GetPiece(this.Base.Square.Ordinal - 1)) != null && piecePassed.NoOfMoves == 1                      && piecePassed.LastMoveTurnNo == Game.TurnNo && piecePassed.Name == Piece.PieceNames.Pawn                      && piecePassed.Player.Colour != this.Base.Player.Colour"  is complex.
Complex Conditional,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,The conditional expression  "(piecePassed = Board.GetPiece(this.Base.Square.Ordinal + 1)) != null && piecePassed.NoOfMoves == 1                      && piecePassed.LastMoveTurnNo == Game.TurnNo && piecePassed.Name == Piece.PieceNames.Pawn                      && piecePassed.Player.Colour != this.Base.Player.Colour"  is complex.
Complex Conditional,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,PawnForkTwoMajorPiecesBonus,The conditional expression  "pieceLeft != null && pieceLeft.Player.Colour != this.Base.Player.Colour && pieceLeft.IsCapturable                      && pieceLeft.Name != Piece.PieceNames.Pawn"  is complex.
Complex Conditional,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,PawnForkTwoMajorPiecesBonus,The conditional expression  "pieceRight != null && pieceRight.Player.Colour != this.Base.Player.Colour                              && pieceRight.IsCapturable && pieceRight.Name != Piece.PieceNames.Pawn"  is complex.
Complex Conditional,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The conditional expression  "move.From.Name == strMove.Substring(0' 2) && move.To.Name == strMove.Substring(2' 2)                      && (movename == Move.MoveNames.NullMove || move.Name == movename)"  is complex.
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,ForceImmediateMove,The following statement contains a magic number: if (this.IsThinking)              {                  this.Search.SearchForceExitWithMove();                  while (this.threadThought != null)                  {                      Thread.Sleep(50);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,Brain,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Brain.cs,Think,The following statement contains a magic number: try              {                  if (!this.IsPondering && !Game.IsInAnalyseMode)                  {                      // Query Simple Opening Book                      if (Game.UseRandomOpeningMoves)                      {                          Move moveBook;                          if ((moveBook = OpeningBookSimple.SuggestRandomMove(player)) != null)                          {                              this.PrincipalVariation.Add(moveBook);                              this.MoveConsideredEvent();                              throw new ForceImmediateMoveException();                          }                      }                        /* Query Best Opening Book                          if ((m_moveBest = OpeningBook.SearchForGoodMove(Board.HashCodeA' Board.HashCodeB' this.Colour) )!=null)                           {                              m_moveCurrent = m_moveBest;                              this.MoveConsidered();                              throw new ForceImmediateMoveException();                          }                      */                  }                    // Time allowed for this player to think                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Absolute fixed time per move. No time is carried over from one move to the next.                      this.ThinkingTimeAllotted = Game.ClockFixedTimePerMove;                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockIncrementPerMove.TotalSeconds > 0)                  {                      // Incremental clock                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Game.ClockIncrementPerMove.Ticks                              +                              ((((Game.ClockIncrementPerMove.Ticks * Game.MoveNo)                                 + (Game.ClockTime.Ticks * Math.Min(Game.MoveNo' 40) / 40))                                - this.MyPlayer.Clock.TimeElapsed.Ticks) / 3));                        // Make sure we never think for less than half the "Increment" time                      this.ThinkingTimeAllotted =                          new TimeSpan(                              Math.Max(this.ThinkingTimeAllotted.Ticks' (Game.ClockIncrementPerMove.Ticks / 2) + 1));                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else if (Game.ClockMaxMoves == 0 && Game.ClockIncrementPerMove.TotalSeconds <= 0)                  {                      // Fixed game time                      this.ThinkingTimeAllotted = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / 30);                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove;                  }                  else                  {                      // Conventional n moves in x minutes time                      this.ThinkingTimeAllotted =                          new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks / this.MyPlayer.Clock.MovesRemaining);                        this.ThinkingTimeMaxAllowed = new TimeSpan(this.MyPlayer.Clock.TimeRemaining.Ticks)                                                    - new TimeSpan(0' 0' 0' 0' 100);                  }                    // Minimum of 100 milli-second thinking time                  if (this.ThinkingTimeAllotted.TotalMilliseconds < 100)                  {                      this.ThinkingTimeAllotted = new TimeSpan(0' 0' 0' 100);                  }                    // The computer only stops "thinking" when it has finished a full ply of thought'                   // UNLESS m_tsnThinkingTimeMaxAllowed is exceeded' or clock runs out' then it stops right away.                  if (Game.ClockFixedTimePerMove.TotalSeconds > 0)                  {                      // Fixed time per move                      this.ThinkingTimeMaxAllowed = Game.ClockFixedTimePerMove - new TimeSpan(0' 0' 0' 0' 100);                  }                  else                  {                      // Variable time per move                      this.ThinkingTimeMaxAllowed =                          new TimeSpan(                              Math.Min(                                  this.ThinkingTimeAllotted.Ticks * 2'                                  this.MyPlayer.Clock.TimeRemaining.Ticks - (new TimeSpan(0' 0' 0' 0' 100)).Ticks));                  }                    if (Game.IsInAnalyseMode)                  {                      HashTable.Clear();                      HashTableCheck.Clear();                      HashTablePawn.Clear();                      HistoryHeuristic.Clear();                  }                  else                  {                      if (this.MyPlayer.CanClaimMoveRepetitionDraw(2))                      {                          // See if' we're in a 2 move repetition position' and if so' clear the hashtable' as old hashtable entries corrupt 3MR detection                          HashTable.Clear();                      }                      else                      {                          HashTable.ResetStats(); // Reset the main hash table hit stats                      }                        HashTableCheck.ResetStats();                        // We also have a hash table in which we just store the check status for both players                      HashTablePawn.ResetStats();                        // And finally a hash table that stores the positional score of just the pawns.                      HistoryHeuristic.Clear(); // Clear down the History Heuristic info' at the start of each move.                  }                    if (!this.IsPondering)                  {                      this.MyPlayer.Clock.Start();                  }                    int score = this.Search.IterativeDeepeningSearch(                      this.MyPlayer' this.PrincipalVariation' this.ThinkingTimeAllotted' this.ThinkingTimeMaxAllowed);              }              catch (ForceImmediateMoveException x)              {                  // Undo any moves made during thinking                  Debug.WriteLine(x.ToString());                  while (Game.TurnNo > intTurnNo)                  {                      Move.Undo(Game.MoveHistory.Last);                  }              }
Magic Number,SharpChess.Model.AI,HashTable,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HashTable.cs,Initialise,The following statement contains a magic number: hashTableSize = Game.AvailableMegaBytes * 8000;
Magic Number,SharpChess.Model.AI,HashTableCheck,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HashTableCheck.cs,Initialise,The following statement contains a magic number: hashTableSize = Game.AvailableMegaBytes * 4000;
Magic Number,SharpChess.Model.AI,HashTablePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\HashTablePawnKing.cs,Initialise,The following statement contains a magic number: hashTableSize = Game.AvailableMegaBytes * 3000;
Magic Number,SharpChess.Model.AI,KillerMoves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\KillerMoves.cs,Clear,The following statement contains a magic number: for (int intIndex = 0; intIndex < 64; intIndex++)              {                  PrimaryKillerMovesA[intIndex] = null;                  SecondaryKillerMovesB[intIndex] = null;              }
Magic Number,SharpChess.Model.AI,KillerMoves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\KillerMoves.cs,RetrieveA,The following statement contains a magic number: return PrimaryKillerMovesA[depth + 32];
Magic Number,SharpChess.Model.AI,KillerMoves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\KillerMoves.cs,RetrieveB,The following statement contains a magic number: return SecondaryKillerMovesB[depth + 32];
Magic Number,SharpChess.Model.AI,KillerMoves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\KillerMoves.cs,AssignA,The following statement contains a magic number: PrimaryKillerMovesA[depth + 32] = move;
Magic Number,SharpChess.Model.AI,KillerMoves,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\KillerMoves.cs,AssignB,The following statement contains a magic number: SecondaryKillerMovesB[depth + 32] = move;
Magic Number,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,LoadOpeningBook,The following statement contains a magic number: if (intScanMove != 0)              {                  RecordHash(Board.HashCodeA' Board.HashCodeB' (byte)(intScanMove >> 8 & 0xff)' (byte)(intScanMove & 0xff)' Move.MoveNames.Standard' player.Colour);              }
Magic Number,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,ScanPly,The following statement contains a magic number: foreach (XmlElement xmlnodeMove in xmlnodeParent.ChildNodes)              {                  Move.MoveNames movename = xmlnodeMove.GetAttribute("N") == null ? Move.MoveNames.Standard : Move.MoveNameFromString(xmlnodeMove.GetAttribute("N"));                  Square from = Board.GetSquare(xmlnodeMove.GetAttribute("F"));                  Square to = Board.GetSquare(xmlnodeMove.GetAttribute("T"));                  Piece piece = from.Piece;                    int intScore = Convert.ToInt32(xmlnodeMove.GetAttribute(player.Colour == Player.PlayerColourNames.White ? "W" : "B"));                  if (intScore > intReturnScore)                  {                      intReturnScore = intScore;                      intReturnMove = from.Ordinal << 8 | to.Ordinal;                  }                    Move moveUndo = piece.Move(movename' to);                    int intScanMove = ScanPly(player.OpposingPlayer' xmlnodeMove);                  if (intScanMove != 0)                  {                      RecordHash(Board.HashCodeA' Board.HashCodeB' (byte)(intScanMove >> 8 & 0xff)' (byte)(intScanMove & 0xff)' movename' player.OpposingPlayer.Colour);                  }                    Move.Undo(moveUndo);              }
Magic Number,SharpChess.Model.AI,OpeningBook,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBook.cs,ScanPly,The following statement contains a magic number: foreach (XmlElement xmlnodeMove in xmlnodeParent.ChildNodes)              {                  Move.MoveNames movename = xmlnodeMove.GetAttribute("N") == null ? Move.MoveNames.Standard : Move.MoveNameFromString(xmlnodeMove.GetAttribute("N"));                  Square from = Board.GetSquare(xmlnodeMove.GetAttribute("F"));                  Square to = Board.GetSquare(xmlnodeMove.GetAttribute("T"));                  Piece piece = from.Piece;                    int intScore = Convert.ToInt32(xmlnodeMove.GetAttribute(player.Colour == Player.PlayerColourNames.White ? "W" : "B"));                  if (intScore > intReturnScore)                  {                      intReturnScore = intScore;                      intReturnMove = from.Ordinal << 8 | to.Ordinal;                  }                    Move moveUndo = piece.Move(movename' to);                    int intScanMove = ScanPly(player.OpposingPlayer' xmlnodeMove);                  if (intScanMove != 0)                  {                      RecordHash(Board.HashCodeA' Board.HashCodeB' (byte)(intScanMove >> 8 & 0xff)' (byte)(intScanMove & 0xff)' movename' player.OpposingPlayer.Colour);                  }                    Move.Undo(moveUndo);              }
Magic Number,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Prune,The following statement contains a magic number: for (int intIndex = xmlnodeParent.ChildNodes.Count - 1; intIndex >= 0; intIndex--)              {                  XmlElement xmlnode = (XmlElement)xmlnodeParent.ChildNodes[intIndex];                    if (xmlnode.ParentNode != null && (xmlnode.ChildNodes.Count == 0 && xmlnode.ParentNode.ChildNodes.Count > 5))                  {                      xmlnode.ParentNode.RemoveChild(xmlnode);                  }                  else                  {                      if (depth <= 2)                      {                          Prune(xmlnode' depth + 1);                      }                  }              }
Magic Number,SharpChess.Model.AI,OpeningBookSimple,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\OpeningBookSimple.cs,Prune,The following statement contains a magic number: for (int intIndex = xmlnodeParent.ChildNodes.Count - 1; intIndex >= 0; intIndex--)              {                  XmlElement xmlnode = (XmlElement)xmlnodeParent.ChildNodes[intIndex];                    if (xmlnode.ParentNode != null && (xmlnode.ChildNodes.Count == 0 && xmlnode.ParentNode.ChildNodes.Count > 5))                  {                      xmlnode.ParentNode.RemoveChild(xmlnode);                  }                  else                  {                      if (depth <= 2)                      {                          Prune(xmlnode' depth + 1);                      }                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Search,The following statement contains a magic number: this.MaxSearchDepth = 32;
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,IterativeDeepeningSearch,The following statement contains a magic number: TimeSpan searchTimeCutoff = new TimeSpan(recommendedSearchTime.Ticks / 3);
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,IterativeDeepeningSearch,The following statement contains a magic number: if (searchTimeCutoff.TotalMilliseconds < 100)              {                  searchTimeCutoff = new TimeSpan(0' 0' 0' 0' 100);              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,IterativeDeepeningSearch,The following statement contains a magic number: if (searchTimeCutoff.TotalMilliseconds < 100)              {                  searchTimeCutoff = new TimeSpan(0' 0' 0' 0' 100);              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,IterativeDeepeningSearch,The following statement contains a magic number: this.MaxSearchDepth = Game.MaximumSearchDepth == 0 ? 32 : Game.MaximumSearchDepth;
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,IterativeDeepeningSearch,The following statement contains a magic number: for (this.SearchDepth = MinSearchDepth; this.SearchDepth <= this.MaxSearchDepth; this.SearchDepth++)              {                  this.PositionsSearchedThisIteration = 0; // Reset positions searched this iteration.                  KillerMoves.Clear(); // Clear killer moves from previous iteration.                  HistoryHeuristic.Clear(); // Clear history when from previous iteration.                     if (Game.CaptureMoveAnalysisData && Game.MoveAnalysis.Count > 0)                  {                      Game.MoveAnalysis.Clear();                  }                    score = this.Aspirate(player' principalVariation' score' Game.MoveAnalysis);                    if (!Game.IsInAnalyseMode && Game.ClockFixedTimePerMove.TotalSeconds <= 0 && !this.MyBrain.IsPondering                      && this.MyBrain.ThinkingTimeElpased > searchTimeCutoff)                  {                      throw new ForceImmediateMoveException();                  }                    // Copy current PV to previous PV.                  this.LastPrincipalVariation.Clear();                  foreach (Move moveCopy in principalVariation)                  {                      this.LastPrincipalVariation.Add(moveCopy);                  }                    WinBoard.SendThinking(                      this.SearchDepth'                      score'                      DateTime.Now - player.Clock.TurnStartTime'                      this.PositionsSearchedThisIteration'                      this.MyBrain.PrincipalVariationText);                    if (score > 99999 || score < -99999)                  {                      break; // Checkmate found so dont bother searching any deeper                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,IterativeDeepeningSearch,The following statement contains a magic number: for (this.SearchDepth = MinSearchDepth; this.SearchDepth <= this.MaxSearchDepth; this.SearchDepth++)              {                  this.PositionsSearchedThisIteration = 0; // Reset positions searched this iteration.                  KillerMoves.Clear(); // Clear killer moves from previous iteration.                  HistoryHeuristic.Clear(); // Clear history when from previous iteration.                     if (Game.CaptureMoveAnalysisData && Game.MoveAnalysis.Count > 0)                  {                      Game.MoveAnalysis.Clear();                  }                    score = this.Aspirate(player' principalVariation' score' Game.MoveAnalysis);                    if (!Game.IsInAnalyseMode && Game.ClockFixedTimePerMove.TotalSeconds <= 0 && !this.MyBrain.IsPondering                      && this.MyBrain.ThinkingTimeElpased > searchTimeCutoff)                  {                      throw new ForceImmediateMoveException();                  }                    // Copy current PV to previous PV.                  this.LastPrincipalVariation.Clear();                  foreach (Move moveCopy in principalVariation)                  {                      this.LastPrincipalVariation.Add(moveCopy);                  }                    WinBoard.SendThinking(                      this.SearchDepth'                      score'                      DateTime.Now - player.Clock.TurnStartTime'                      this.PositionsSearchedThisIteration'                      this.MyBrain.PrincipalVariationText);                    if (score > 99999 || score < -99999)                  {                      break; // Checkmate found so dont bother searching any deeper                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyExtensions,The following statement contains a magic number: if (Game.EnableExtensions)              {                  if (movesPossible.Count == 1)                  {                      // Single Response                      extensionOrReduction = 1;                      Comment(moveMade' "E-1REP ");                  }                  else if (parentMove != null && parentMove.IsEnemyInCheck)                  {                      // Check evasion                      extensionOrReduction = 1;                      Comment(moveMade' "E-CHK ");                  }                  else if (parentMove != null && parentMove.PieceCaptured != null && moveMade.PieceCaptured != null                           && parentMove.PieceCaptured.BasicValue == moveMade.PieceCaptured.BasicValue                           && parentMove.To == moveMade.To)                  {                      // Recapture piece of same basic value (on the same square)                      extensionOrReduction = 1;                      Comment(moveMade' "E-RECAP ");                  }                  else if (moveMade.Piece.Name == Piece.PieceNames.Pawn                           &&                           ((moveMade.Piece.Player.Colour == Player.PlayerColourNames.White && moveMade.To.Rank == 6)                            ||                            (moveMade.Piece.Player.Colour == Player.PlayerColourNames.Black && moveMade.To.Rank == 1)))                  {                      // Pawn push to 7th rank                      extensionOrReduction = 1;                      Comment(moveMade' "E-PAWN7 ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The following statement contains a magic number: if (ply != this.SearchDepth                  &&                  (val = HashTable.ProbeForScore(Board.HashCodeA' Board.HashCodeB' ply' alpha' beta' player.Colour))                  != HashTable.NotFoundInHashTable)              {                  // High values of "val" indicate that a checkmate has been found                  if (val > 1000000 || val < -1000000)                  {                      Comment(parentMove' "Mate: " + (this.MaxSearchDepth - variableDepth) + " ");                      if (this.MaxSearchDepth - variableDepth > 0)                      {                          val /= this.MaxSearchDepth - variableDepth;                      }                  }                    return val;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The following statement contains a magic number: if (ply != this.SearchDepth                  &&                  (val = HashTable.ProbeForScore(Board.HashCodeA' Board.HashCodeB' ply' alpha' beta' player.Colour))                  != HashTable.NotFoundInHashTable)              {                  // High values of "val" indicate that a checkmate has been found                  if (val > 1000000 || val < -1000000)                  {                      Comment(parentMove' "Mate: " + (this.MaxSearchDepth - variableDepth) + " ");                      if (this.MaxSearchDepth - variableDepth > 0)                      {                          val /= this.MaxSearchDepth - variableDepth;                      }                  }                    return val;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The following statement contains a magic number: if (Game.EnableNullMovePruning)              {                  // Adaptive Null-move pruning                  // http://chessprogramming.wikispaces.com/Null+Move+Pruning                  int r = variableDepth > 6 ? 3 : 2;                  if (variableDepth > (r + 1) && parentMove != null && parentMove.Name != Move.MoveNames.NullMove                      && Game.Stage != Game.GameStageNames.End && !isInCheck)                  {                      Move moveNull = new Move(Game.TurnNo' 0' Move.MoveNames.NullMove' null' null' null' null' 0' 0);                      val =                          -this.AlphaBetaPvs(                              player.OpposingPlayer'                              ply - 1'                              variableDepth - r - 1'                              -beta'                              -beta + 1'                              moveNull'                              localPrincipalVariation'                              totalExtensionsOrReductions'                              null);                      if (val >= beta)                      {                          return beta;                      }                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The following statement contains a magic number: if (Game.EnableNullMovePruning)              {                  // Adaptive Null-move pruning                  // http://chessprogramming.wikispaces.com/Null+Move+Pruning                  int r = variableDepth > 6 ? 3 : 2;                  if (variableDepth > (r + 1) && parentMove != null && parentMove.Name != Move.MoveNames.NullMove                      && Game.Stage != Game.GameStageNames.End && !isInCheck)                  {                      Move moveNull = new Move(Game.TurnNo' 0' Move.MoveNames.NullMove' null' null' null' null' 0' 0);                      val =                          -this.AlphaBetaPvs(                              player.OpposingPlayer'                              ply - 1'                              variableDepth - r - 1'                              -beta'                              -beta + 1'                              moveNull'                              localPrincipalVariation'                              totalExtensionsOrReductions'                              null);                      if (val >= beta)                      {                          return beta;                      }                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The following statement contains a magic number: if (Game.EnableNullMovePruning)              {                  // Adaptive Null-move pruning                  // http://chessprogramming.wikispaces.com/Null+Move+Pruning                  int r = variableDepth > 6 ? 3 : 2;                  if (variableDepth > (r + 1) && parentMove != null && parentMove.Name != Move.MoveNames.NullMove                      && Game.Stage != Game.GameStageNames.End && !isInCheck)                  {                      Move moveNull = new Move(Game.TurnNo' 0' Move.MoveNames.NullMove' null' null' null' null' 0' 0);                      val =                          -this.AlphaBetaPvs(                              player.OpposingPlayer'                              ply - 1'                              variableDepth - r - 1'                              -beta'                              -beta + 1'                              moveNull'                              localPrincipalVariation'                              totalExtensionsOrReductions'                              null);                      if (val >= beta)                      {                          return beta;                      }                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The following statement contains a magic number: Move moveKillerA2 = KillerMoves.RetrieveA(ply + 2);
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AlphaBetaPvs,The following statement contains a magic number: Move moveKillerB2 = KillerMoves.RetrieveB(ply + 2);
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityMargin && variableDepth > 2)              {                  int[] margin =                                 {                                     0' 0' 0' 5000' 5000' 7000' 7000' 9000' 9000' 15000' 15000' 15000' 15000' 15000' 15000'                                     15000' 15000' 15000                                 };                    int intLazyEval = player.Score;                  if (alpha > intLazyEval + margin[variableDepth])                  {                      extensionOrReduction = -1;                      Comment(moveMade' "R-MARG" + (margin[variableDepth] / 1000) + " ");                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionFutilityFixedDepth && extensionOrReduction == 0)              {                  switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionLateMove && extensionOrReduction == 0)              {                  if (legalMovesAttempted > 3)                  {                      int historyScore = HistoryHeuristic.Retrieve(                          player.Colour' moveMade.From.Ordinal' moveMade.To.Ordinal);                        if (historyScore == 0)                      {                          int eval =                              -this.AlphaBetaPvs(                                  player.OpposingPlayer'                                  ply - 1'                                  variableDepth - 2'                                  -alpha - 1'                                  -alpha'                                  moveMade'                                  movesPv'                                  totalExtensionsOrReductions'                                  null);                            if (eval < alpha)                          {                              extensionOrReduction = -1;                              Comment(moveMade' "R-LMR ");                          }                      }                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following statement contains a magic number: if (Game.EnableReductionLateMove && extensionOrReduction == 0)              {                  if (legalMovesAttempted > 3)                  {                      int historyScore = HistoryHeuristic.Retrieve(                          player.Colour' moveMade.From.Ordinal' moveMade.To.Ordinal);                        if (historyScore == 0)                      {                          int eval =                              -this.AlphaBetaPvs(                                  player.OpposingPlayer'                                  ply - 1'                                  variableDepth - 2'                                  -alpha - 1'                                  -alpha'                                  moveMade'                                  movesPv'                                  totalExtensionsOrReductions'                                  null);                            if (eval < alpha)                          {                              extensionOrReduction = -1;                              Comment(moveMade' "R-LMR ");                          }                      }                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following statement contains a magic number: for (int intAttempt = Game.EnableAspiration ? 0 : 2; intAttempt < 3; intAttempt++)              {                  switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }                    val = this.AlphaBetaPvs(                      player'                      this.SearchDepth'                      this.SearchDepth'                      alpha'                      beta'                      null'                      principalVariation'                      0'                      analysisParentBranch);                  if (val > alpha && val < beta)                  {                      break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following statement contains a magic number: for (int intAttempt = Game.EnableAspiration ? 0 : 2; intAttempt < 3; intAttempt++)              {                  switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }                    val = this.AlphaBetaPvs(                      player'                      this.SearchDepth'                      this.SearchDepth'                      alpha'                      beta'                      null'                      principalVariation'                      0'                      analysisParentBranch);                  if (val > alpha && val < beta)                  {                      break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following statement contains a magic number: for (int intAttempt = Game.EnableAspiration ? 0 : 2; intAttempt < 3; intAttempt++)              {                  switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }                    val = this.AlphaBetaPvs(                      player'                      this.SearchDepth'                      this.SearchDepth'                      alpha'                      beta'                      null'                      principalVariation'                      0'                      analysisParentBranch);                  if (val > alpha && val < beta)                  {                      break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following statement contains a magic number: for (int intAttempt = Game.EnableAspiration ? 0 : 2; intAttempt < 3; intAttempt++)              {                  switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }                    val = this.AlphaBetaPvs(                      player'                      this.SearchDepth'                      this.SearchDepth'                      alpha'                      beta'                      null'                      principalVariation'                      0'                      analysisParentBranch);                  if (val > alpha && val < beta)                  {                      break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following statement contains a magic number: for (int intAttempt = Game.EnableAspiration ? 0 : 2; intAttempt < 3; intAttempt++)              {                  switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }                    val = this.AlphaBetaPvs(                      player'                      this.SearchDepth'                      this.SearchDepth'                      alpha'                      beta'                      null'                      principalVariation'                      0'                      analysisParentBranch);                  if (val > alpha && val < beta)                  {                      break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following statement contains a magic number: for (int intAttempt = Game.EnableAspiration ? 0 : 2; intAttempt < 3; intAttempt++)              {                  switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }                    val = this.AlphaBetaPvs(                      player'                      this.SearchDepth'                      this.SearchDepth'                      alpha'                      beta'                      null'                      principalVariation'                      0'                      analysisParentBranch);                  if (val > alpha && val < beta)                  {                      break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following statement contains a magic number: for (int intAttempt = Game.EnableAspiration ? 0 : 2; intAttempt < 3; intAttempt++)              {                  switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }                    val = this.AlphaBetaPvs(                      player'                      this.SearchDepth'                      this.SearchDepth'                      alpha'                      beta'                      null'                      principalVariation'                      0'                      analysisParentBranch);                  if (val > alpha && val < beta)                  {                      break;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: if (moveHash != null && Move.MovesMatch(move' moveHash))              {                  move.Score = 10000000;                  Comment(move' "O-HASH:" + move.Score + " ");                  return;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: switch (move.Name)              {                  case Move.MoveNames.PawnPromotionQueen:                      move.Score = 999999;                      break;                  case Move.MoveNames.PawnPromotionRook:                      move.Score = 999998;                      break;                  case Move.MoveNames.PawnPromotionBishop:                      move.Score = 999997;                      break;                  case Move.MoveNames.PawnPromotionKnight:                      move.Score = 999996;                      break;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: switch (move.Name)              {                  case Move.MoveNames.PawnPromotionQueen:                      move.Score = 999999;                      break;                  case Move.MoveNames.PawnPromotionRook:                      move.Score = 999998;                      break;                  case Move.MoveNames.PawnPromotionBishop:                      move.Score = 999997;                      break;                  case Move.MoveNames.PawnPromotionKnight:                      move.Score = 999996;                      break;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: switch (move.Name)              {                  case Move.MoveNames.PawnPromotionQueen:                      move.Score = 999999;                      break;                  case Move.MoveNames.PawnPromotionRook:                      move.Score = 999998;                      break;                  case Move.MoveNames.PawnPromotionBishop:                      move.Score = 999997;                      break;                  case Move.MoveNames.PawnPromotionKnight:                      move.Score = 999996;                      break;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: switch (move.Name)              {                  case Move.MoveNames.PawnPromotionQueen:                      move.Score = 999999;                      break;                  case Move.MoveNames.PawnPromotionRook:                      move.Score = 999998;                      break;                  case Move.MoveNames.PawnPromotionBishop:                      move.Score = 999997;                      break;                  case Move.MoveNames.PawnPromotionKnight:                      move.Score = 999996;                      break;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: if (move.PieceCaptured != null)              {                  // Result of Static exchange evaluation                  move.Score += this.SEE(move) * 100000;                  if (move.Score != 0)                  {                      Comment(move' "O-SEE:" + move.Score + " ");                      return;                  }                    // If in Quiescence and SEE is even' then sort by MVV/LVA                  move.Score = (move.PieceCaptured.Value * 100) - move.Piece.Value;                  if (move.Score != 0)                  {                      Comment(move' "O-MVV:" + move.Score + " ");                      return;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: if (move.PieceCaptured != null)              {                  // Result of Static exchange evaluation                  move.Score += this.SEE(move) * 100000;                  if (move.Score != 0)                  {                      Comment(move' "O-SEE:" + move.Score + " ");                      return;                  }                    // If in Quiescence and SEE is even' then sort by MVV/LVA                  move.Score = (move.PieceCaptured.Value * 100) - move.Piece.Value;                  if (move.Score != 0)                  {                      Comment(move' "O-MVV:" + move.Score + " ");                      return;                  }              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: if (moveKillerA != null && Move.MovesMatch(move' moveKillerA))              {                  move.Score += 90000;                  Comment(move' "O-KILLA:" + move.Score + " ");                  return;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: if (moveKillerB != null && Move.MovesMatch(move' moveKillerB))              {                  move.Score += 70000;                  Comment(move' "O-KILLB:" + move.Score + " ");                  return;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following statement contains a magic number: move.Score += ((int)Math.Sqrt(HistoryHeuristic.Retrieve(player.Colour' move.From.Ordinal' move.To.Ordinal)))                            * 100;
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Quiesce,The following statement contains a magic number: if (standPat > 1000000 || standPat < -1000000)              {                  // TODO Unit test that negative depths produce score that reduce as they get deeper. The purpose here is to make deeper checks score less than shallower ones.                  // TODO Investigate whether reduced mate scores are constantly reduced when going in and out of hashtable.                  standPat /= this.MaxSearchDepth - ply;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Quiesce,The following statement contains a magic number: if (standPat > 1000000 || standPat < -1000000)              {                  // TODO Unit test that negative depths produce score that reduce as they get deeper. The purpose here is to make deeper checks score less than shallower ones.                  // TODO Investigate whether reduced mate scores are constantly reduced when going in and out of hashtable.                  standPat /= this.MaxSearchDepth - ply;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,SEE,The following statement contains a magic number: foreach (Move move in movesFriendly)              {                  move.Score = 20 - move.Piece.BasicValue;              }
Magic Number,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,SEE,The following statement contains a magic number: if (movesEnemy.Count > 1)              {                  // sort remaining moves by piece value                  foreach (Move move in movesEnemy)                  {                      move.Score = 20 - move.Piece.BasicValue;                  }                    movesEnemy.SortByScore();              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,FileFromName,The following statement contains a magic number: switch (fileName)              {                  case "a":                      return 0;                  case "b":                      return 1;                  case "c":                      return 2;                  case "d":                      return 3;                  case "e":                      return 4;                  case "f":                      return 5;                  case "g":                      return 6;                  case "h":                      return 7;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,FileFromName,The following statement contains a magic number: switch (fileName)              {                  case "a":                      return 0;                  case "b":                      return 1;                  case "c":                      return 2;                  case "d":                      return 3;                  case "e":                      return 4;                  case "f":                      return 5;                  case "g":                      return 6;                  case "h":                      return 7;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,FileFromName,The following statement contains a magic number: switch (fileName)              {                  case "a":                      return 0;                  case "b":                      return 1;                  case "c":                      return 2;                  case "d":                      return 3;                  case "e":                      return 4;                  case "f":                      return 5;                  case "g":                      return 6;                  case "h":                      return 7;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,FileFromName,The following statement contains a magic number: switch (fileName)              {                  case "a":                      return 0;                  case "b":                      return 1;                  case "c":                      return 2;                  case "d":                      return 3;                  case "e":                      return 4;                  case "f":                      return 5;                  case "g":                      return 6;                  case "h":                      return 7;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,FileFromName,The following statement contains a magic number: switch (fileName)              {                  case "a":                      return 0;                  case "b":                      return 1;                  case "c":                      return 2;                  case "d":                      return 3;                  case "e":                      return 4;                  case "f":                      return 5;                  case "g":                      return 6;                  case "h":                      return 7;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,FileFromName,The following statement contains a magic number: switch (fileName)              {                  case "a":                      return 0;                  case "b":                      return 1;                  case "c":                      return 2;                  case "d":                      return 3;                  case "e":                      return 4;                  case "f":                      return 5;                  case "g":                      return 6;                  case "h":                      return 7;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,OpenLinePenalty,The following statement contains a magic number: while (intSquareCount <= 2                     &&                     ((square = GetSquare(intOrdinal)) != null                      &&                      (square.Piece == null                       || (square.Piece.Name != Piece.PieceNames.Pawn && square.Piece.Name != Piece.PieceNames.Rook)                       || square.Piece.Player.Colour != colour)))              {                  intPenalty += 75;                  intSquareCount++;                  intOrdinal += directionOffset;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,OpenLinePenalty,The following statement contains a magic number: while (intSquareCount <= 2                     &&                     ((square = GetSquare(intOrdinal)) != null                      &&                      (square.Piece == null                       || (square.Piece.Name != Piece.PieceNames.Pawn && square.Piece.Name != Piece.PieceNames.Rook)                       || square.Piece.Player.Colour != colour)))              {                  intPenalty += 75;                  intSquareCount++;                  intOrdinal += directionOffset;              }
Magic Number,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,OrdinalFromFileRank,The following statement contains a magic number: return (rank << 4) | file;
Magic Number,SharpChess.Model,BoardDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\BoardDebug.cs,DebugGameInfo,The following statement contains a magic number: switch (indRank)              {                  case 0:                  case 7:                      Pieces piecesCaptureList = (indRank == 7)                                                     ? Game.PlayerWhite.CapturedEnemyPieces                                                     : Game.PlayerBlack.CapturedEnemyPieces;                      if (piecesCaptureList.Count > 1)                      {                          strbBoard.Append("x ");                          foreach (Piece pieceCaptured in piecesCaptureList)                          {                              strbBoard.Append(                                  (pieceCaptured.Name == Piece.PieceNames.Pawn)                                      ? string.Empty                                      : pieceCaptured.Abbreviation + pieceCaptured.Square.Name + " ");                          }                      }                        break;                    case 5:                      int turnNumberOld = Game.TurnNo; // Backup TurNo                      Game.TurnNo -= Game.PlayerToPlay.Brain.Search.SearchDepth;                      for (int indMov = Math.Max(1' Game.MoveHistory.Count - Game.PlayerToPlay.Brain.Search.MaxSearchDepth);                           indMov < Game.MoveHistory.Count;                           indMov++)                      {                          Move moveThis = Game.MoveHistory[indMov];                          if (moveThis.Piece.Player.Colour == Player.PlayerColourNames.White)                          {                              strbBoard.Append(indMov >> 1);                              strbBoard.Append(". ");                          }                            // moveThis.PgnSanFormat(false); // Contextual to Game.TurNo                          strbBoard.Append(moveThis.Description + " ");                          Game.TurnNo++;                      }                        Game.TurnNo = turnNumberOld; // Restore TurNo                      break;              }
Magic Number,SharpChess.Model,BoardDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\BoardDebug.cs,DebugGameInfo,The following statement contains a magic number: switch (indRank)              {                  case 0:                  case 7:                      Pieces piecesCaptureList = (indRank == 7)                                                     ? Game.PlayerWhite.CapturedEnemyPieces                                                     : Game.PlayerBlack.CapturedEnemyPieces;                      if (piecesCaptureList.Count > 1)                      {                          strbBoard.Append("x ");                          foreach (Piece pieceCaptured in piecesCaptureList)                          {                              strbBoard.Append(                                  (pieceCaptured.Name == Piece.PieceNames.Pawn)                                      ? string.Empty                                      : pieceCaptured.Abbreviation + pieceCaptured.Square.Name + " ");                          }                      }                        break;                    case 5:                      int turnNumberOld = Game.TurnNo; // Backup TurNo                      Game.TurnNo -= Game.PlayerToPlay.Brain.Search.SearchDepth;                      for (int indMov = Math.Max(1' Game.MoveHistory.Count - Game.PlayerToPlay.Brain.Search.MaxSearchDepth);                           indMov < Game.MoveHistory.Count;                           indMov++)                      {                          Move moveThis = Game.MoveHistory[indMov];                          if (moveThis.Piece.Player.Colour == Player.PlayerColourNames.White)                          {                              strbBoard.Append(indMov >> 1);                              strbBoard.Append(". ");                          }                            // moveThis.PgnSanFormat(false); // Contextual to Game.TurNo                          strbBoard.Append(moveThis.Description + " ");                          Game.TurnNo++;                      }                        Game.TurnNo = turnNumberOld; // Restore TurNo                      break;              }
Magic Number,SharpChess.Model,BoardDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\BoardDebug.cs,DebugGameInfo,The following statement contains a magic number: switch (indRank)              {                  case 0:                  case 7:                      Pieces piecesCaptureList = (indRank == 7)                                                     ? Game.PlayerWhite.CapturedEnemyPieces                                                     : Game.PlayerBlack.CapturedEnemyPieces;                      if (piecesCaptureList.Count > 1)                      {                          strbBoard.Append("x ");                          foreach (Piece pieceCaptured in piecesCaptureList)                          {                              strbBoard.Append(                                  (pieceCaptured.Name == Piece.PieceNames.Pawn)                                      ? string.Empty                                      : pieceCaptured.Abbreviation + pieceCaptured.Square.Name + " ");                          }                      }                        break;                    case 5:                      int turnNumberOld = Game.TurnNo; // Backup TurNo                      Game.TurnNo -= Game.PlayerToPlay.Brain.Search.SearchDepth;                      for (int indMov = Math.Max(1' Game.MoveHistory.Count - Game.PlayerToPlay.Brain.Search.MaxSearchDepth);                           indMov < Game.MoveHistory.Count;                           indMov++)                      {                          Move moveThis = Game.MoveHistory[indMov];                          if (moveThis.Piece.Player.Colour == Player.PlayerColourNames.White)                          {                              strbBoard.Append(indMov >> 1);                              strbBoard.Append(". ");                          }                            // moveThis.PgnSanFormat(false); // Contextual to Game.TurNo                          strbBoard.Append(moveThis.Description + " ");                          Game.TurnNo++;                      }                        Game.TurnNo = turnNumberOld; // Restore TurNo                      break;              }
Magic Number,SharpChess.Model,BoardDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\BoardDebug.cs,DebugGetBoard,The following statement contains a magic number: var strbBoard = new StringBuilder(160);
Magic Number,SharpChess.Model,BoardDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\BoardDebug.cs,DebugGetBoard,The following statement contains a magic number: for (int indRank = 7; indRank >= 0; indRank--)              {                  strbBoard.Append(indRank + 1);                  strbBoard.Append(":");                  for (int indFile = 0; indFile < 8; indFile++)                  {                      Square square = Board.GetSquare(indFile' indRank);                      if (square != null)                      {                          if (square.Piece == null)                          {                              strbBoard.Append(". ");                          }                          else                          {                              switch (square.Piece.Player.Colour)                              {                                  case Player.PlayerColourNames.White:                                      strbBoard.Append(square.Piece.Abbreviation);                                      break;                                  default:                                      strbBoard.Append(square.Piece.Abbreviation.ToLower());                                      break;                              }                                strbBoard.Append(" ");                          }                      }                  }                    DebugGameInfo(indRank' ref strbBoard);              }
Magic Number,SharpChess.Model,BoardDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\BoardDebug.cs,DebugGetBoard,The following statement contains a magic number: for (int indRank = 7; indRank >= 0; indRank--)              {                  strbBoard.Append(indRank + 1);                  strbBoard.Append(":");                  for (int indFile = 0; indFile < 8; indFile++)                  {                      Square square = Board.GetSquare(indFile' indRank);                      if (square != null)                      {                          if (square.Piece == null)                          {                              strbBoard.Append(". ");                          }                          else                          {                              switch (square.Piece.Player.Colour)                              {                                  case Player.PlayerColourNames.White:                                      strbBoard.Append(square.Piece.Abbreviation);                                      break;                                  default:                                      strbBoard.Append(square.Piece.Abbreviation.ToLower());                                      break;                              }                                strbBoard.Append(" ");                          }                      }                  }                    DebugGameInfo(indRank' ref strbBoard);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,The following statement contains a magic number: if ((pieceRook = Board.GetPiece(7' 0)) != null && pieceRook.Name == Piece.PieceNames.Rook                  && pieceRook.Player.Colour == Player.PlayerColourNames.White)              {                  pieceRook.NoOfMoves = strCastlingRights.LastIndexOf("K") >= 0 ? 0 : 1;              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,The following statement contains a magic number: if ((pieceRook = Board.GetPiece(7' 7)) != null && pieceRook.Name == Piece.PieceNames.Rook                  && pieceRook.Player.Colour == Player.PlayerColourNames.Black)              {                  pieceRook.NoOfMoves = strCastlingRights.LastIndexOf("k") >= 0 ? 0 : 1;              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,The following statement contains a magic number: if ((pieceRook = Board.GetPiece(7' 7)) != null && pieceRook.Name == Piece.PieceNames.Rook                  && pieceRook.Player.Colour == Player.PlayerColourNames.Black)              {                  pieceRook.NoOfMoves = strCastlingRights.LastIndexOf("k") >= 0 ? 0 : 1;              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,The following statement contains a magic number: if ((pieceRook = Board.GetPiece(0' 7)) != null && pieceRook.Name == Piece.PieceNames.Rook                  && pieceRook.Player.Colour == Player.PlayerColourNames.Black)              {                  pieceRook.NoOfMoves = strCastlingRights.LastIndexOf("q") >= 0 ? 0 : 1;              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,The following statement contains a magic number: if (strEnPassant[0] != '-')              {                  int indFile = Board.FileFromName(Convert.ToString(strEnPassant[0]));                  int indRank = int.Parse(Convert.ToString(strEnPassant[1]));                  if (indRank == 6)                  {                      // if fenString = "e6"                      indRank = 4; // last move was e7-e5 so indRank = 6 - 2 = 4                  }                    // else if indRank = 3' fenString = "e3" last move was e2-e4 so indRank = 3                  Piece piecePassed = Board.GetPiece(indFile' indRank);                  piecePassed.NoOfMoves = 1;                  piecePassed.LastMoveTurnNo = Game.TurnNo;              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetBoardPosition,The following statement contains a magic number: if (strEnPassant[0] != '-')              {                  int indFile = Board.FileFromName(Convert.ToString(strEnPassant[0]));                  int indRank = int.Parse(Convert.ToString(strEnPassant[1]));                  if (indRank == 6)                  {                      // if fenString = "e6"                      indRank = 4; // last move was e7-e5 so indRank = 6 - 2 = 4                  }                    // else if indRank = 3' fenString = "e3" last move was e2-e4 so indRank = 3                  Piece piecePassed = Board.GetPiece(indFile' indRank);                  piecePassed.NoOfMoves = 1;                  piecePassed.LastMoveTurnNo = Game.TurnNo;              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount < 1 || fieldCount > 6)              {                  throw new ValidationException(                      "1000: A FEN string must 1 to 6 fields separated by spaces\n e.g. rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 2)              {                  FenCheck2Color(arrStrFen[1]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 3)              {                  FenCheck3Castle(arrStrFen[2]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 3)              {                  FenCheck3Castle(arrStrFen[2]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 4)              {                  FenCheck4EnPassant(arrStrFen[3]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 4)              {                  FenCheck4EnPassant(arrStrFen[3]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 5)              {                  FenCheck5Counter50MoveDraw(arrStrFen[4]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 5)              {                  FenCheck5Counter50MoveDraw(arrStrFen[4]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 6)              {                  FenCheck6NbrMove(arrStrFen[5]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,Validate,The following statement contains a magic number: if (fieldCount >= 6)              {                  FenCheck6NbrMove(arrStrFen[5]);              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: for (int indChar = 0; indChar < fenString.Length; indChar++)              {                  switch (fenString[indChar])                  {                      case 'K':                          whiteKing++;                          squareNumber++;                          break;                      case 'k':                          blackKing++;                          squareNumber++;                          break;                      case 'Q':                          whiteQueen++;                          squareNumber++;                          break;                      case 'q':                          blackQueen++;                          squareNumber++;                          break;                      case 'R':                          whiteRook++;                          squareNumber++;                          break;                      case 'r':                          blackRook++;                          squareNumber++;                          break;                      case 'B':                          whiteBishop++;                          squareNumber++;                          break;                      case 'b':                          blackBishop++;                          squareNumber++;                          break;                      case 'N':                          whiteKnight++;                          squareNumber++;                          break;                      case 'n':                          blackKnight++;                          squareNumber++;                          break;                      case 'P':                          whitePawn++;                          squareNumber++;                          break;                      case 'p':                          blackPawn++;                          squareNumber++;                          break;                      case '/':                          slashNumber++;                          if (squareNumber != 8)                          {                              throw new ValidationException(                                  "1010: " + FenHlpMsg(1)                                  + string.Format("The rank {0} does not contain 8 squares"' slashNumber));                          }                            squareNumber = 0;                          break;                        default:                          if ((fenString[indChar] < '1') || (fenString[indChar] > '8'))                          {                              throw new ValidationException(                                  "1020: " + FenHlpMsg(1) + "Expected character 'KQRBNP/kqrbnp' '1'..'8'");                          }                            squareNumber += Convert.ToInt32(fenString[indChar].ToString());                            break;                  }              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if (slashNumber != 7)              {                  throw new ValidationException("1030: " + FenHlpMsg(1) + "The string must have 7 slash separators");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if (squareNumber != 8)              {                  throw new ValidationException("1040: " + FenHlpMsg(1) + "The last rank does not contain 8 squares");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((whiteQueen > 9) || (whiteBishop > 9) || (whiteKnight > 9) || (whitePawn > 8))              {                  throw new ValidationException("1070: " + FenHlpMsg(1) + "Too many White Q or B or N or P");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((whiteQueen > 9) || (whiteBishop > 9) || (whiteKnight > 9) || (whitePawn > 8))              {                  throw new ValidationException("1070: " + FenHlpMsg(1) + "Too many White Q or B or N or P");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((whiteQueen > 9) || (whiteBishop > 9) || (whiteKnight > 9) || (whitePawn > 8))              {                  throw new ValidationException("1070: " + FenHlpMsg(1) + "Too many White Q or B or N or P");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((whiteQueen > 9) || (whiteBishop > 9) || (whiteKnight > 9) || (whitePawn > 8))              {                  throw new ValidationException("1070: " + FenHlpMsg(1) + "Too many White Q or B or N or P");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((blackQueen > 9) || (blackBishop > 9) || (blackKnight > 9) || (blackPawn > 8))              {                  throw new ValidationException("1080: " + FenHlpMsg(1) + "Too many Black q or b or n or p");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((blackQueen > 9) || (blackBishop > 9) || (blackKnight > 9) || (blackPawn > 8))              {                  throw new ValidationException("1080: " + FenHlpMsg(1) + "Too many Black q or b or n or p");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((blackQueen > 9) || (blackBishop > 9) || (blackKnight > 9) || (blackPawn > 8))              {                  throw new ValidationException("1080: " + FenHlpMsg(1) + "Too many Black q or b or n or p");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck1PiecePlace,The following statement contains a magic number: if ((blackQueen > 9) || (blackBishop > 9) || (blackKnight > 9) || (blackPawn > 8))              {                  throw new ValidationException("1080: " + FenHlpMsg(1) + "Too many Black q or b or n or p");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck2Color,The following statement contains a magic number: if ((fenString != "w") && (fenString != "b"))              {                  throw new ValidationException("1200: " + FenHlpMsg(2) + "The active color must be 'w' or 'b'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck3Castle,The following statement contains a magic number: foreach (char t in fenString)              {                  switch (t)                  {                      case 'K':                          whiteKing++;                          break;                      case 'k':                          blackKing++;                          break;                      case 'Q':                          whiteQueen++;                          break;                      case 'q':                          blackQueen++;                          break;                      case '-':                          dash++;                          break;                      default:                          throw new ValidationException("1300: " + FenHlpMsg(3) + "Expected character 'KQkq-'");                  }              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck3Castle,The following statement contains a magic number: if ((whiteKing > 1) || (whiteQueen > 1) || (blackKing > 1) || (blackQueen > 1) || (dash > 1))              {                  throw new ValidationException("1310: " + FenHlpMsg(3) + "At least one occurrence of 'KQkq-'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck3Castle,The following statement contains a magic number: if ((dash == 1) && ((whiteKing == 1) || (whiteQueen == 1) || (blackKing == 1) || (blackQueen == 1)))              {                  throw new ValidationException("1320: " + FenHlpMsg(3) + "'KQkq' or exclusive '-'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck4EnPassant,The following statement contains a magic number: if (((fenString[0] < 'a') || (fenString[0] > 'h')) && (fenString[0] != '-'))              {                  throw new ValidationException("1400: " + FenHlpMsg(4) + "Expected character 'abcdefgh-'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck4EnPassant,The following statement contains a magic number: if (fenString[0] == '-')              {                  if (fenString.Length > 1)                  {                      throw new ValidationException("1410: " + FenHlpMsg(4) + "No expected character after '-'");                  }              }              else if (((fenString[0] >= 'a') && (fenString[0] <= 'h'))                       &&                       (((fenString.Length == 2) && (fenString[1] != '3') && (fenString[1] != '6'))                        || (fenString.Length > 2)))              {                  throw new ValidationException(                      "1420: " + FenHlpMsg(4) + "After the pawn file' expect the rank '3' or '6'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck4EnPassant,The following statement contains a magic number: if (fenString[0] == '-')              {                  if (fenString.Length > 1)                  {                      throw new ValidationException("1410: " + FenHlpMsg(4) + "No expected character after '-'");                  }              }              else if (((fenString[0] >= 'a') && (fenString[0] <= 'h'))                       &&                       (((fenString.Length == 2) && (fenString[1] != '3') && (fenString[1] != '6'))                        || (fenString.Length > 2)))              {                  throw new ValidationException(                      "1420: " + FenHlpMsg(4) + "After the pawn file' expect the rank '3' or '6'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck4EnPassant,The following statement contains a magic number: if (fenString[0] == '-')              {                  if (fenString.Length > 1)                  {                      throw new ValidationException("1410: " + FenHlpMsg(4) + "No expected character after '-'");                  }              }              else if (((fenString[0] >= 'a') && (fenString[0] <= 'h'))                       &&                       (((fenString.Length == 2) && (fenString[1] != '3') && (fenString[1] != '6'))                        || (fenString.Length > 2)))              {                  throw new ValidationException(                      "1420: " + FenHlpMsg(4) + "After the pawn file' expect the rank '3' or '6'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck4EnPassant,The following statement contains a magic number: if (fenString[0] == '-')              {                  if (fenString.Length > 1)                  {                      throw new ValidationException("1410: " + FenHlpMsg(4) + "No expected character after '-'");                  }              }              else if (((fenString[0] >= 'a') && (fenString[0] <= 'h'))                       &&                       (((fenString.Length == 2) && (fenString[1] != '3') && (fenString[1] != '6'))                        || (fenString.Length > 2)))              {                  throw new ValidationException(                      "1420: " + FenHlpMsg(4) + "After the pawn file' expect the rank '3' or '6'");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck5Counter50MoveDraw,The following statement contains a magic number: if (fenString.Length > 2)              {                  throw new ValidationException(                      "1500: " + FenHlpMsg(5) + "1 or 2 digits for the nbr of ply for rule of 50 moves");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck5Counter50MoveDraw,The following statement contains a magic number: if (fenString.Length > 2)              {                  throw new ValidationException(                      "1500: " + FenHlpMsg(5) + "1 or 2 digits for the nbr of ply for rule of 50 moves");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck5Counter50MoveDraw,The following statement contains a magic number: try              {                  halfMove = int.Parse(fenString);              }              catch              {                  throw new ValidationException(                      "1510: " + FenHlpMsg(5) + "Expect a half move number for the rule of 50 moves");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck5Counter50MoveDraw,The following statement contains a magic number: if ((halfMove < 0) || (halfMove > 100))              {                  throw new ValidationException("1520: " + FenHlpMsg(5) + "Expect a non negative half move number <= 100");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck5Counter50MoveDraw,The following statement contains a magic number: if ((halfMove < 0) || (halfMove > 100))              {                  throw new ValidationException("1520: " + FenHlpMsg(5) + "Expect a non negative half move number <= 100");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck6NbrMove,The following statement contains a magic number: try              {                  fullMove = int.Parse(fenString);              }              catch              {                  throw new ValidationException("1600: " + FenHlpMsg(6) + "Expect a full move number");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck6NbrMove,The following statement contains a magic number: if ((fullMove < 1) || (fullMove > 200))              {                  throw new ValidationException("1610: " + FenHlpMsg(6) + "Expect a positive full move number <= 200");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenCheck6NbrMove,The following statement contains a magic number: if ((fullMove < 1) || (fullMove > 200))              {                  throw new ValidationException("1610: " + FenHlpMsg(6) + "Expect a positive full move number <= 200");              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenGet4EnPassant,The following statement contains a magic number: if ((Game.MoveHistory.Count > 0) && (Game.MoveHistory.Last.Piece.Name == Piece.PieceNames.Pawn)                  && (Game.MoveHistory.Last.From.File == Game.MoveHistory.Last.To.File)                  &&                  (((Game.MoveHistory.Last.From.Rank == Game.MoveHistory.Last.To.Rank + 2)                    && (Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.Black))                   ||                   ((Game.MoveHistory.Last.From.Rank == Game.MoveHistory.Last.To.Rank - 2)                    && (Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.White))))              {                  return " " + Game.MoveHistory.Last.From.FileName                         + ((Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.White) ? "3 " : "6 ");                                            // The case between From and To              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenGet4EnPassant,The following statement contains a magic number: if ((Game.MoveHistory.Count > 0) && (Game.MoveHistory.Last.Piece.Name == Piece.PieceNames.Pawn)                  && (Game.MoveHistory.Last.From.File == Game.MoveHistory.Last.To.File)                  &&                  (((Game.MoveHistory.Last.From.Rank == Game.MoveHistory.Last.To.Rank + 2)                    && (Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.Black))                   ||                   ((Game.MoveHistory.Last.From.Rank == Game.MoveHistory.Last.To.Rank - 2)                    && (Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.White))))              {                  return " " + Game.MoveHistory.Last.From.FileName                         + ((Game.MoveHistory.Last.Piece.Player.Colour == Player.PlayerColourNames.White) ? "3 " : "6 ");                                            // The case between From and To              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenHlpMsg,The following statement contains a magic number: switch (fieldNumber)              {                  case 1:                      return "FEN field 1: Piece placement data.\n";                  case 2:                      return "FEN field 2: Active color.\n";                  case 3:                      return "FEN field 3: Castling availability.\n";                  case 4:                      return "FEN field 4: En passant target square coordonates.\n";                  case 5:                      return "FEN field 5: Nbr of half move without capture or pawn move.\n";                  case 6:                      return "FEN field 6: Full move number.\n";              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenHlpMsg,The following statement contains a magic number: switch (fieldNumber)              {                  case 1:                      return "FEN field 1: Piece placement data.\n";                  case 2:                      return "FEN field 2: Active color.\n";                  case 3:                      return "FEN field 3: Castling availability.\n";                  case 4:                      return "FEN field 4: En passant target square coordonates.\n";                  case 5:                      return "FEN field 5: Nbr of half move without capture or pawn move.\n";                  case 6:                      return "FEN field 6: Full move number.\n";              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenHlpMsg,The following statement contains a magic number: switch (fieldNumber)              {                  case 1:                      return "FEN field 1: Piece placement data.\n";                  case 2:                      return "FEN field 2: Active color.\n";                  case 3:                      return "FEN field 3: Castling availability.\n";                  case 4:                      return "FEN field 4: En passant target square coordonates.\n";                  case 5:                      return "FEN field 5: Nbr of half move without capture or pawn move.\n";                  case 6:                      return "FEN field 6: Full move number.\n";              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenHlpMsg,The following statement contains a magic number: switch (fieldNumber)              {                  case 1:                      return "FEN field 1: Piece placement data.\n";                  case 2:                      return "FEN field 2: Active color.\n";                  case 3:                      return "FEN field 3: Castling availability.\n";                  case 4:                      return "FEN field 4: En passant target square coordonates.\n";                  case 5:                      return "FEN field 5: Nbr of half move without capture or pawn move.\n";                  case 6:                      return "FEN field 6: Full move number.\n";              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenHlpMsg,The following statement contains a magic number: switch (fieldNumber)              {                  case 1:                      return "FEN field 1: Piece placement data.\n";                  case 2:                      return "FEN field 2: Active color.\n";                  case 3:                      return "FEN field 3: Castling availability.\n";                  case 4:                      return "FEN field 4: En passant target square coordonates.\n";                  case 5:                      return "FEN field 5: Nbr of half move without capture or pawn move.\n";                  case 6:                      return "FEN field 6: Full move number.\n";              }
Magic Number,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,SetPiecePlacement,The following statement contains a magic number: int intRank = 7;
Magic Number,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,Game,The following statement contains a magic number: ClockTime = new TimeSpan(0' 5' 0);
Magic Number,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,Game,The following statement contains a magic number: ClockMaxMoves = 40;
Magic Number,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,LoadGame,The following statement contains a magic number: if (xmlnodelist != null)              {                  foreach (XmlElement xmlnode in xmlnodelist)                  {                      Square from;                      Square to;                      if (xmlnode.GetAttribute("FromFile") != string.Empty)                      {                          from = Board.GetSquare(                              Convert.ToInt32(xmlnode.GetAttribute("FromFile"))'                              Convert.ToInt32(xmlnode.GetAttribute("FromRank")));                          to = Board.GetSquare(                              Convert.ToInt32(xmlnode.GetAttribute("ToFile"))'                              Convert.ToInt32(xmlnode.GetAttribute("ToRank")));                      }                      else                      {                          from = Board.GetSquare(xmlnode.GetAttribute("From"));                          to = Board.GetSquare(xmlnode.GetAttribute("To"));                      }                        MakeAMoveInternal(Move.MoveNameFromString(xmlnode.GetAttribute("Name"))' from.Piece' to);                      TimeSpan tsnTimeStamp;                      if (xmlnode.GetAttribute("SecondsElapsed") == string.Empty)                      {                          if (MoveHistory.Count <= 2)                          {                              tsnTimeStamp = new TimeSpan(0);                          }                          else                          {                              tsnTimeStamp = MoveHistory.PenultimateForSameSide.TimeStamp + (new TimeSpan(0' 0' 30));                          }                      }                      else                      {                          tsnTimeStamp = new TimeSpan(0' 0' int.Parse(xmlnode.GetAttribute("SecondsElapsed")));                      }                        MoveHistory.Last.TimeStamp = tsnTimeStamp;                      MoveHistory.Last.Piece.Player.Clock.TimeElapsed = tsnTimeStamp;                  }                    int intTurnNo = xmlnodeGame.GetAttribute("TurnNo") != string.Empty                                      ? int.Parse(xmlnodeGame.GetAttribute("TurnNo"))                                      : xmlnodelist.Count;                    for (int intIndex = xmlnodelist.Count; intIndex > intTurnNo; intIndex--)                  {                      UndoMoveInternal();                  }              }
Magic Number,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,LoadGame,The following statement contains a magic number: if (xmlnodelist != null)              {                  foreach (XmlElement xmlnode in xmlnodelist)                  {                      Square from;                      Square to;                      if (xmlnode.GetAttribute("FromFile") != string.Empty)                      {                          from = Board.GetSquare(                              Convert.ToInt32(xmlnode.GetAttribute("FromFile"))'                              Convert.ToInt32(xmlnode.GetAttribute("FromRank")));                          to = Board.GetSquare(                              Convert.ToInt32(xmlnode.GetAttribute("ToFile"))'                              Convert.ToInt32(xmlnode.GetAttribute("ToRank")));                      }                      else                      {                          from = Board.GetSquare(xmlnode.GetAttribute("From"));                          to = Board.GetSquare(xmlnode.GetAttribute("To"));                      }                        MakeAMoveInternal(Move.MoveNameFromString(xmlnode.GetAttribute("Name"))' from.Piece' to);                      TimeSpan tsnTimeStamp;                      if (xmlnode.GetAttribute("SecondsElapsed") == string.Empty)                      {                          if (MoveHistory.Count <= 2)                          {                              tsnTimeStamp = new TimeSpan(0);                          }                          else                          {                              tsnTimeStamp = MoveHistory.PenultimateForSameSide.TimeStamp + (new TimeSpan(0' 0' 30));                          }                      }                      else                      {                          tsnTimeStamp = new TimeSpan(0' 0' int.Parse(xmlnode.GetAttribute("SecondsElapsed")));                      }                        MoveHistory.Last.TimeStamp = tsnTimeStamp;                      MoveHistory.Last.Piece.Player.Clock.TimeElapsed = tsnTimeStamp;                  }                    int intTurnNo = xmlnodeGame.GetAttribute("TurnNo") != string.Empty                                      ? int.Parse(xmlnodeGame.GetAttribute("TurnNo"))                                      : xmlnodelist.Count;                    for (int intIndex = xmlnodelist.Count; intIndex > intTurnNo; intIndex--)                  {                      UndoMoveInternal();                  }              }
Magic Number,SharpChess.Model,Game,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Game.cs,UndoMoveInternal,The following statement contains a magic number: if (MoveHistory.Count > 0)              {                  Move moveUndo = MoveHistory.Last;                  PlayerToPlay.Clock.Revert();                  MoveRedoList.Add(moveUndo);                  Move.Undo(moveUndo);                  PlayerToPlay = PlayerToPlay.OpposingPlayer;                  if (MoveHistory.Count > 1)                  {                      Move movePenultimate = MoveHistory[MoveHistory.Count - 2];                      PlayerToPlay.Clock.TimeElapsed = movePenultimate.TimeStamp;                  }                  else                  {                      PlayerToPlay.Clock.TimeElapsed = new TimeSpan(0);                  }                    if (!IsPaused)                  {                      PlayerToPlay.Clock.Start();                  }              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Move,The following statement contains a magic number: if (moveName != MoveNames.NullMove && pieceCaptured == null && piece != null && piece.Name != Piece.PieceNames.Pawn)              {                  this.FiftyMoveDrawCounter = Game.MoveHistory.Count > 0 ? Game.MoveHistory.Last.FiftyMoveDrawCounter + 1 : (Game.FiftyMoveDrawBase / 2) + 1;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: if (move.IsThreeMoveRepetition)              {                  Board.HashCodeA ^= 31;                  Board.HashCodeB ^= 29;              }
Magic Number,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following statement contains a magic number: if (move.IsThreeMoveRepetition)              {                  Board.HashCodeA ^= 31;                  Board.HashCodeB ^= 29;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeAForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 830859827498573475;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 37500384876452947;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 448573857309865743;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 294375032850265937;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeAForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 830859827498573475;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 37500384876452947;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 448573857309865743;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 294375032850265937;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeAForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 830859827498573475;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 37500384876452947;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 448573857309865743;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 294375032850265937;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeAForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 830859827498573475;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 37500384876452947;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 448573857309865743;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 294375032850265937;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeAForSquareOrdinal,The following statement contains a magic number: return PieceHashCodes.MasterHashCodesA[(((uint)this.IdentifierCode) << 7) + ordinal] + ulongPromotionModifier;
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeBForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 790423450762398573;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 394756026094872034;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 629385632983478593;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 283469276067858673;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeBForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 790423450762398573;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 394756026094872034;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 629385632983478593;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 283469276067858673;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeBForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 790423450762398573;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 394756026094872034;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 629385632983478593;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 283469276067858673;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeBForSquareOrdinal,The following statement contains a magic number: if (this.HasBeenPromoted)              {                  switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 790423450762398573;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 394756026094872034;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 629385632983478593;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 283469276067858673;                          break;                  }              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeBForSquareOrdinal,The following statement contains a magic number: return PieceHashCodes.MasterHashCodesB[(((uint)this.IdentifierCode) << 7) + ordinal] + ulongPromotionModifier;
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: if (move.Piece.Player.CanClaimThreeMoveRepetitionDraw)              {                  Board.HashCodeA ^= 31;                  Board.HashCodeB ^= 29;                  move.HashCodeA = Board.HashCodeA;                  move.HashCodeB = Board.HashCodeB;                  move.IsThreeMoveRepetition = true;              }
Magic Number,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following statement contains a magic number: if (move.Piece.Player.CanClaimThreeMoveRepetitionDraw)              {                  Board.HashCodeA ^= 31;                  Board.HashCodeB ^= 29;                  move.HashCodeA = Board.HashCodeA;                  move.HashCodeB = Board.HashCodeB;                  move.IsThreeMoveRepetition = true;              }
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The following statement contains a magic number: switch (movesType)              {                  case Moves.MoveListNames.All:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                         if (this.CanCastleKingSide)                      {                          moves.Add(0' 0' Move.MoveNames.CastleKingSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal + 2)' null' 0' 0);                      }                        if (this.CanCastleQueenSide)                      {                          moves.Add(Game.TurnNo' this.Base.LastMoveTurnNo' Move.MoveNames.CastleQueenSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal - 2)' null' 0' 0);                      }                        break;                    case Moves.MoveListNames.CapturesPromotions:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                      break;                                  }
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The following statement contains a magic number: switch (movesType)              {                  case Moves.MoveListNames.All:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                         if (this.CanCastleKingSide)                      {                          moves.Add(0' 0' Move.MoveNames.CastleKingSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal + 2)' null' 0' 0);                      }                        if (this.CanCastleQueenSide)                      {                          moves.Add(Game.TurnNo' this.Base.LastMoveTurnNo' Move.MoveNames.CastleQueenSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal - 2)' null' 0' 0);                      }                        break;                    case Moves.MoveListNames.CapturesPromotions:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                      break;                                  }
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The following statement contains a magic number: square = Board.GetSquare(this.Base.Square.Ordinal + 15);
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The following statement contains a magic number: square = Board.GetSquare(this.Base.Square.Ordinal + 16);
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The following statement contains a magic number: square = Board.GetSquare(this.Base.Square.Ordinal + 17);
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The following statement contains a magic number: square = Board.GetSquare(this.Base.Square.Ordinal - 15);
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The following statement contains a magic number: square = Board.GetSquare(this.Base.Square.Ordinal - 16);
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,MoveSquares,The following statement contains a magic number: square = Board.GetSquare(this.Base.Square.Ordinal - 17);
Magic Number,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,Openness,The following statement contains a magic number: for (int i = 0; i < moveVectors.Length; i++)              {                  intOpenness += Board.OpenLinePenalty(this.Base.Player.Colour' square' moveVectors[i]);                  if (intOpenness > 900)                      return intOpenness;              }
Magic Number,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,The following statement contains a magic number: bool isPromotion = (this.Base.Player.Colour == Player.PlayerColourNames.White && this.Base.Square.Rank == 6)                                 ||                                 (this.Base.Player.Colour == Player.PlayerColourNames.Black && this.Base.Square.Rank == 1);
Magic Number,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,The following statement contains a magic number: if ((this.Base.Square.Rank == 4 && this.Base.Player.Colour == Player.PlayerColourNames.White)                  || (this.Base.Square.Rank == 3 && this.Base.Player.Colour == Player.PlayerColourNames.Black))              {                  Piece piecePassed;                    // Left                  if ((piecePassed = Board.GetPiece(this.Base.Square.Ordinal - 1)) != null && piecePassed.NoOfMoves == 1                      && piecePassed.LastMoveTurnNo == Game.TurnNo && piecePassed.Name == Piece.PieceNames.Pawn                      && piecePassed.Player.Colour != this.Base.Player.Colour)                  {                      square = Board.GetSquare(this.Base.Square.Ordinal + this.Base.Player.PawnAttackLeftOffset);                      moves.Add(0' 0' Move.MoveNames.EnPassent' this.Base' this.Base.Square' square' piecePassed' 0' 0);                  }                    // Right                  if ((piecePassed = Board.GetPiece(this.Base.Square.Ordinal + 1)) != null && piecePassed.NoOfMoves == 1                      && piecePassed.LastMoveTurnNo == Game.TurnNo && piecePassed.Name == Piece.PieceNames.Pawn                      && piecePassed.Player.Colour != this.Base.Player.Colour)                  {                      square = Board.GetSquare(this.Base.Square.Ordinal + this.Base.Player.PawnAttackRightOffset);                      moves.Add(0' 0' Move.MoveNames.EnPassent' this.Base' this.Base.Square' square' piecePassed' 0' 0);                  }              }
Magic Number,SharpChess.Model,PiecePawn,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PiecePawn.cs,GenerateLazyMoves,The following statement contains a magic number: if ((this.Base.Square.Rank == 4 && this.Base.Player.Colour == Player.PlayerColourNames.White)                  || (this.Base.Square.Rank == 3 && this.Base.Player.Colour == Player.PlayerColourNames.Black))              {                  Piece piecePassed;                    // Left                  if ((piecePassed = Board.GetPiece(this.Base.Square.Ordinal - 1)) != null && piecePassed.NoOfMoves == 1                      && piecePassed.LastMoveTurnNo == Game.TurnNo && piecePassed.Name == Piece.PieceNames.Pawn                      && piecePassed.Player.Colour != this.Base.Player.Colour)                  {                      square = Board.GetSquare(this.Base.Square.Ordinal + this.Base.Player.PawnAttackLeftOffset);                      moves.Add(0' 0' Move.MoveNames.EnPassent' this.Base' this.Base.Square' square' piecePassed' 0' 0);                  }                    // Right                  if ((piecePassed = Board.GetPiece(this.Base.Square.Ordinal + 1)) != null && piecePassed.NoOfMoves == 1                      && piecePassed.LastMoveTurnNo == Game.TurnNo && piecePassed.Name == Piece.PieceNames.Pawn                      && piecePassed.Player.Colour != this.Base.Player.Colour)                  {                      square = Board.GetSquare(this.Base.Square.Ordinal + this.Base.Player.PawnAttackRightOffset);                      moves.Add(0' 0' Move.MoveNames.EnPassent' this.Base' this.Base.Square' square' piecePassed' 0' 0);                  }              }
Magic Number,SharpChess.Model,Player,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Player.cs,Player,The following statement contains a magic number: this.MaterialCount = 7;
Magic Number,SharpChess.Model,Player,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Player.cs,Player,The following statement contains a magic number: this.PawnCountInPlay = 8;
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(this.King = new Piece(Piece.PieceNames.King' this' 4' 7' Piece.PieceIdentifierCodes.BlackKing));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(this.King = new Piece(Piece.PieceNames.King' this' 4' 7' Piece.PieceIdentifierCodes.BlackKing));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Queen' this' 3' 7' Piece.PieceIdentifierCodes.BlackQueen));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Queen' this' 3' 7' Piece.PieceIdentifierCodes.BlackQueen));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Rook' this' 0' 7' Piece.PieceIdentifierCodes.BlackQueensRook));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Rook' this' 7' 7' Piece.PieceIdentifierCodes.BlackKingsRook));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Rook' this' 7' 7' Piece.PieceIdentifierCodes.BlackKingsRook));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Bishop' this' 2' 7' Piece.PieceIdentifierCodes.BlackQueensBishop));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Bishop' this' 2' 7' Piece.PieceIdentifierCodes.BlackQueensBishop));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Bishop' this' 5' 7' Piece.PieceIdentifierCodes.BlackKingsBishop));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Bishop' this' 5' 7' Piece.PieceIdentifierCodes.BlackKingsBishop));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Knight' this' 1' 7' Piece.PieceIdentifierCodes.BlackQueensKnight));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Knight' this' 6' 7' Piece.PieceIdentifierCodes.BlackKingsKnight));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Knight' this' 6' 7' Piece.PieceIdentifierCodes.BlackKingsKnight));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 0' 6' Piece.PieceIdentifierCodes.BlackPawn1));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 1' 6' Piece.PieceIdentifierCodes.BlackPawn2));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 2' 6' Piece.PieceIdentifierCodes.BlackPawn3));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 2' 6' Piece.PieceIdentifierCodes.BlackPawn3));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 3' 6' Piece.PieceIdentifierCodes.BlackPawn4));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 3' 6' Piece.PieceIdentifierCodes.BlackPawn4));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 4' 6' Piece.PieceIdentifierCodes.BlackPawn5));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 4' 6' Piece.PieceIdentifierCodes.BlackPawn5));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 5' 6' Piece.PieceIdentifierCodes.BlackPawn6));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 5' 6' Piece.PieceIdentifierCodes.BlackPawn6));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 6' 6' Piece.PieceIdentifierCodes.BlackPawn7));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 6' 6' Piece.PieceIdentifierCodes.BlackPawn7));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 7' 6' Piece.PieceIdentifierCodes.BlackPawn8));
Magic Number,SharpChess.Model,PlayerBlack,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerBlack.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 7' 6' Piece.PieceIdentifierCodes.BlackPawn8));
Magic Number,SharpChess.Model,PlayerDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerDebug.cs,DebugMatchLine,The following statement contains a magic number: const int iSAN_LENGTH = 5;
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(this.King = new Piece(Piece.PieceNames.King' this' 4' 0' Piece.PieceIdentifierCodes.WhiteKing));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Queen' this' 3' 0' Piece.PieceIdentifierCodes.WhiteQueen));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Rook' this' 7' 0' Piece.PieceIdentifierCodes.WhiteKingsRook));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Bishop' this' 2' 0' Piece.PieceIdentifierCodes.WhiteQueensBishop));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Bishop' this' 5' 0' Piece.PieceIdentifierCodes.WhiteKingsBishop));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Knight' this' 6' 0' Piece.PieceIdentifierCodes.WhiteKingsKnight));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 2' 1' Piece.PieceIdentifierCodes.WhitePawn3));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 3' 1' Piece.PieceIdentifierCodes.WhitePawn4));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 4' 1' Piece.PieceIdentifierCodes.WhitePawn5));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 5' 1' Piece.PieceIdentifierCodes.WhitePawn6));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 6' 1' Piece.PieceIdentifierCodes.WhitePawn7));
Magic Number,SharpChess.Model,PlayerWhite,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PlayerWhite.cs,SetPiecesAtStartingPositions,The following statement contains a magic number: this.Pieces.Add(new Piece(Piece.PieceNames.Pawn' this' 7' 1' Piece.PieceIdentifierCodes.WhitePawn8));
Magic Number,SharpChess.Model,Square,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Square.cs,Square,The following statement contains a magic number: this.Colour = (this.File % 2 == this.Rank % 2) ? ColourNames.Black : ColourNames.White;
Magic Number,SharpChess.Model,Square,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Square.cs,Square,The following statement contains a magic number: this.Colour = (this.File % 2 == this.Rank % 2) ? ColourNames.Black : ColourNames.White;
Magic Number,SharpChess.Model,Square,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Square.cs,DefencePointsForPlayer,The following statement contains a magic number: return 15000;
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,ProcessInputEvent,The following statement contains a magic number: try              {                  if (strMessage.StartsWith("xboard"))                  {                      /*                       * Chess Engine Communication Protocol                           This command will be sent once immediately after your engine process is started.                           You can use it to put your engine into "xboard mode" if that is needed.                           If your engine prints a prompt to ask for user input' you must turn off the prompt and output a                           newline when the "xboard" command comes in.                          This will be a false 2nd "ghost" message' so ignore it.                      */                  }                  else if (strMessage.StartsWith("protover "))                  {                      /*                       * Chess Engine Communication Protocol                          ping (boolean' default 0' recommended 1)                           If ping=1' xboard may use the protocol's new "ping" command; if ping=0' xboard will not use the command.                           setboard (boolean' default 0' recommended 1)                           If setboard=1' xboard will use the protocol's new "setboard" command to set up positions; if setboard=0' it will use the older "edit" command.                           playother (boolean' default 0' recommended 1)                           If playother=1' xboard will use the protocol's new "playother" command when appropriate; if playother=0' it will not use the command.                           san (boolean' default 0)                           If san=1' xboard will send moves to the engine in standard algebraic notation (SAN); for example' Nf3. If san=0' xboard will send moves in coordinate notation; for example' g1f3. See MOVE in section 8 above for more details of both kinds of notation.                           usermove (boolean' default 0)                           If usermove=1' xboard will send moves to the engine with the command "usermove MOVE"; if usermove=0' xboard will send just the move' with no command name.                           time (boolean' default 1' recommended 1)                           If time=1' xboard will send the "time" and "otim" commands to update the engine's clocks; if time=0' it will not.                           draw (boolean' default 1' recommended 1)                           If draw=1' xboard will send the "draw" command if the engine's opponent offers a draw; if draw=0' xboard will not inform the engine about draw offers. Note that if draw=1' you may receive a draw offer while you are on move; if this will cause you to move immediately' you should set draw=0.                           sigint (boolean' default 1)                           If sigint=1' xboard may send SIGINT (the interrupt signal) to the engine as section 7 above; if sigint=0' it will not.                           sigterm (boolean' default 1)                           If sigterm=1' xboard may send SIGTERM (the termination signal) to the engine as section 7 above; if sigterm=0' it will not.                           reuse (boolean' default 1' recommended 1)                           If reuse=1' xboard may reuse your engine for multiple games. If reuse=0 (or if the user has set the -xreuse option on xboard's command line)' xboard will kill the engine process after every game and start a fresh process for the next game.                           analyze (boolean' default 1' recommended 1)                           If analyze=0' xboard will not try to use the "analyze" command; it will pop up an error message if the user asks for analysis mode. If analyze=1' xboard will try to use the command if the user asks for analysis mode.                           myname (string' default determined from engine filename)                           This feature lets you set the name that xboard will use for your engine in window banners' in the PGN tags of saved game files' and when sending the "name" command to another engine.                           variants (string' see text below)                           This feature indicates which chess variants your engine accepts. It should be a comma-separated list of variant names. See the table under the "variant" command in section 8 above. If you do not set this feature' xboard will assume by default that your engine supports all variants. (However' the -zippyVariants command-line option still limits which variants will be accepted in Zippy mode.) It is recommended that you set this feature to the correct value for your engine (just "normal" in most cases) rather than leaving the default in place' so that the user will get an appropriate error message if he tries to play a variant that your engine does not support.                           colors (boolean' default 1' recommended 0)                           If colors=1' xboard uses the obsolete "white" and "black" commands in a stylized way that works with most older chess engines that require the commands. See the "Idioms" section below for details. If colors=0' xboard does not use the "white" and "black" commands at all.                           ics (boolean' default 0)                           If ics=1' xboard will use the protocol's new "ics" command to inform the engine of whether or not it is playing on a chess server; if ics=0' it will not.                           name (boolean' see text below)                           If name=1' xboard will use the protocol's "name" command to inform the engine of the opponent's name; if name=0' it will not. By default' name=1 if the engine is playing on a chess server; name=0 if not.                           pause (boolean' default 0)                           If pause=1' xboard may use the protocol's new "pause" command; if pause=0' xboard assumes that the engine does not support this command.                           done (integer' no default)                           If you set done=1 during the initial two-second timeout after xboard sends you the "xboard" command' the timeout will end and xboard will not look for any more feature commands before starting normal operation. If you set done=0' the initial timeout is increased to one hour; in this case' you must set done=1 before xboard will enter normal operation.                       */                      string strFeatures = string.Empty;                      strFeatures += " ping=1 ";                      strFeatures += " setboard=1";                      strFeatures += " playother=1";                      strFeatures += " san=0";                      strFeatures += " usermove=1";                      strFeatures += " time=1";                      strFeatures += " draw=0";                      strFeatures += " sigint=0";                      strFeatures += " sigterm=0";                      strFeatures += " reuse=1";                      strFeatures += " analyze=1";                      strFeatures += " myname=\"SharpChess\"";                      strFeatures += " variants=\"normal\"";                      strFeatures += " colors=0";                      strFeatures += " ics=0";                      strFeatures += " name=0";                      strFeatures += " pause=1";                      strFeatures += " done=1";                      SendOutputMessage("feature" + strFeatures);                  }                  else if (strMessage.StartsWith("accepted "))                  {                      // Feature request is accepted.                  }                  else if (strMessage.StartsWith("rejected "))                  {                      // Feature request is rejected.                  }                  else if (strMessage == "new")                  {                      Game.SuspendPondering();                      Game.DifficultyLevel = 0;                      Game.ClockMaxMoves = 40;                      Game.ClockTime = new TimeSpan(0' 5' 0);                      Game.UseRandomOpeningMoves = true;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = false;                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' 0);                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.New();                      Game.SuspendPondering();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.ResumePondering();                  }                  else if (strMessage.StartsWith("load "))                  {                      // Load saved game                      string strPath = strMessage.Substring(5);                      Active = false;                      if (Game.Load(strPath))                      {                          SendOutputMessage("Loaded save game: " + strPath);                      }                      else                      {                          throw new WinBoardInputException("Unable to load save game: " + strPath);                      }                        Active = true;                  }                  else if (strMessage.StartsWith("variant "))                  {                      // do nothing                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "quit")                  {                      // Kill sharpchess                      WinBoardQuitEvent();                  }                  else if (strMessage == "random")                  {                      // GNU Chess 4 specific - so ignore                  }                  else if (strMessage == "force")                  {                      // * Chess Engine Communication Protocol                      // Set the engine to play neither color ("force mode"). Stop clocks. The engine should check that moves                       // received in force mode are legal and made in the proper turn' but should not think' ponder' or make                       // moves of its own.                       Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage == "go")                  {                      // * Chess Engine Communication Protocol                      // Leave force mode and set the engine to play the color that is on move.                       // Associate the engine's clock with the color that is on move' the opponent's clock with the color that                       // is not on move. Start the engine's clock. Start thinking and eventually make a move.                       Game.SuspendPondering();                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == "playother")                  {                      /*                         * Chess Engine Communication Protocol                          (This command is new in protocol version 2. It is not sent unless you enable it with the feature command.)                           Leave force mode and set the engine to play the color that is not on move. Associate the opponent's                           clock with the color that is on move' the engine's clock with the color that is not on move. Start the                           opponent's clock. If pondering is enabled' the engine should begin pondering. If the engine later                           receives a move' it should start thinking and eventually reply.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay = Game.PlayerToPlay.OpposingPlayer;                      Game.PlayerToPlay.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerToPlay.OpposingPlayer.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerToPlay.OpposingPlayer.Clock.Stop();                      Game.PlayerToPlay.Clock.Start();                      Game.ResumePondering();                  }                  else if (strMessage == "white")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set White on move. Set the engine to play Black. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerWhite;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Human;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                  }                  else if (strMessage == "black")                  {                      // * Chess Engine Communication Protocol                      // (This command is obsolete as of protocol version 2' but is still sent in some situations to accommodate                       // older engines unless you disable it with the feature command.)                       // Set Black on move. Set the engine to play White. Stop clocks.                       Game.SuspendPondering();                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerToPlay = Game.PlayerBlack;                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Human;                  }                  else if (strMessage.StartsWith("level "))                  {                      SetLevel(strMessage.Substring("level ".Length));                      WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("st "))                  {                      // * Chess Engine Communication Protocol                      // Set time Absolute fixed time-per-move. No time is carried forward from one move to the next.                       // The commands "level" and "st" are not used together.                       Game.ClockMaxMoves = 1;                      Game.ClockTime = new TimeSpan(0' 0' 0);                      Game.ClockIncrementPerMove = new TimeSpan(0' 0' 0);                      Game.ClockFixedTimePerMove = new TimeSpan(0' 0' int.Parse(strMessage.Substring("st ".Length)));                      Game.DifficultyLevel = 0;                      Game.MaximumSearchDepth = 32;                      Game.EnablePondering = true;                      Game.UseRandomOpeningMoves = true;                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("depth "))                  {                      // * Chess Engine Communication Protocol                      // The engine should limit its thinking to DEPTH ply.                       Game.MaximumSearchDepth = int.Parse(strMessage.Substring("depth ".Length));                  }                  else if (strMessage.StartsWith("time "))                  {                      Game.SuspendPondering();                        /*                      // * Chess Engine Communication Protocol                          Set a clock that always belongs to the engine. N is a number in centiseconds (units of 1/100 second).                           Even if the engine changes to playing the opposite color' this clock remains with the engine.                      */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.OpposingPlayer.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.OpposingPlayer.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("otim "))                  {                      Game.SuspendPondering();                        /*                         * Chess Engine Communication Protocol                          Set a clock that always belongs to the opponent. N is a number in centiseconds (units of 1/100 second). Even if the opponent changes to playing the opposite color' this clock remains with the opponent.                           If needed for purposes of board display in force mode (where the engine is not participating in the                           game) the time clock should be associated with the last color that the engine was set to play' the                           otim clock with the opposite color.                             Beginning in protocol version 2' if you can't handle the time and otim commands' you can use the                           "feature" command to disable them; see below. The following techniques from older protocol versions                           also work: You can ignore the time and otim commands (that is' treat them as no-ops)'                           or send back "Error (unknown command): time" the first time you see "time".                       */                      if (Game.ClockFixedTimePerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockFixedTimePerMove.Ticks * Game.MoveNo))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else if (Game.ClockIncrementPerMove.Ticks > 0)                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks + (Game.ClockIncrementPerMove.Ticks * Game.MoveNo)))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                      else                      {                          Game.PlayerToPlay.Clock.TimeElapsed =                              (new TimeSpan(Game.ClockTime.Ticks * Game.PlayerToPlay.Clock.ControlPeriod))                              - (new TimeSpan(long.Parse(strMessage.Substring("time ".Length)) * 100000));                      }                        WinBoardTimeUpdatedEvent();                  }                  else if (strMessage.StartsWith("usermove "))                  {                      /*                         * Chess Engine Communication Protocol                          By default' moves are sent to the engine without a command name; the notation is just sent as a line                           by itself. Beginning in protocol version 2' you can use the feature command to cause the command name                          "usermove" to be sent before the move. Example: "usermove e2e4".                       */                      MakeMove(strMessage.Substring("usermove ".Length));                  }                  else if (strMessage == "?")                  {                      /*                           Move now. If your engine is thinking' it should move immediately; otherwise' the command should be                           ignored (treated as a no-op). It is permissible for your engine to always ignore the ? command.                           The only bad consequence is that xboard's Move Now menu command will do nothing.                       */                      if (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          Game.PlayerToPlay.Brain.ForceImmediateMove();                      }                  }                  else if (strMessage.StartsWith("ping "))                  {                      /*                         * Chess Engine Communication Protocol                          In this command' N is a decimal number. When you receive the command' reply by sending the string                           pong N' where N is the same number you received. Important: You must not reply to a "ping" command                           until you have finished executing all commands that you received before it. Pondering does not count;                           if you receive a ping while pondering' you should reply immediately and continue pondering. Because                           of the way xboard uses the ping command' if you implement the other commands in this protocol' you                           should never see a "ping" command when it is your move; however' if you do' you must not send the                           "pong" reply to xboard until after you send your move. For example' xboard may send "?" immediately                           followed by "ping". If you implement the "?" command' you will have moved by the time you see the                           subsequent ping command. Similarly' xboard may send a sequence like "force"' "new"' "ping". You must                           not send the pong response until after you have finished executing the "new" command and are ready                           for the new game to start. The ping command is new in protocol version 2 and will not be sent unless                           you enable it with the "feature" command. Its purpose is to allow several race conditions that could                           occur in previous versions of the protocol to be fixed' so it is highly recommended that you implement                           it. It is especially important in simple engines that do not ponder and do not poll for input while                           thinking' but it is needed in all engines.                       */                      while (Game.PlayerToPlay.Brain.IsThinking && !Game.PlayerToPlay.Brain.IsPondering)                      {                          // Wait for thinking to finish                          Thread.Sleep(250);                      }                        SendOutputMessage("pong " + strMessage.Substring(5));                  }                  else if (strMessage == "draw")                  {                      /*                          The engine's opponent offers the engine a draw. To accept the draw' send "offer draw".                           To decline' ignore the offer (that is' send nothing). If you're playing on ICS' it's possible for the                           draw offer to have been withdrawn by the time you accept it' so don't assume the game is over because                           you accept a draw offer. Continue playing until xboard tells you the game is over. See also                           "offer draw" below.                           Ignore all draw offers for now.                      */                  }                  else if (strMessage.StartsWith("result "))                  {                      /*                         * Chess Engine Communication Protocol                          After the end of each game' xboard will send you a result command. You can use this command to trigger learning. RESULT is either 1-0' 0-1' 1/2-1/2' or *' indicating whether white won' black won' the game was a draw' or the game was unfinished. The COMMENT string is purely a human-readable comment; its content is unspecified and subject to change. In ICS mode' it is passed through from ICS uninterpreted. Example:                           result 1-0 {White mates}                          Here are some notes on interpreting the "result" command. Some apply only to playing on ICS ("Zippy" mode).                             If you won but did not just play a mate' your opponent must have resigned or forfeited. If you lost but were not just mated' you probably forfeited on time' or perhaps the operator resigned manually. If there was a draw for some nonobvious reason' perhaps your opponent called your flag when he had insufficient mating material (or vice versa)' or perhaps the operator agreed to a draw manually.                             You will get a result command even if you already know the game ended -- for example' after you just checkmated your opponent. In fact' if you send the "RESULT {COMMENT}" command (discussed below)' you will simply get the same thing fed back to you with "result" tacked in front. You might not always get a "result *" command' however. In particular' you won't get one in local chess engine mode when the user stops playing by selecting Reset' Edit Game' Exit or the like.                       */                      Game.SuspendPondering();                      Game.PlayerToPlay.Clock.Stop();                  }                  else if (strMessage.StartsWith("setboard "))                  {                      /*                         * Chess Engine Communication Protocol                          The setboard command is the new way to set up positions' beginning in protocol version 2.                           It is not used unless it has been selected with the feature command.                           Here FEN is a position in Forsythe-Edwards Notation' as defined in the PGN standard.                           Illegal positions: N-o-t-e that either setboard or edit can be used to send an illegal position to the engine.                           The user can create any position with xboard's Edit Position command (even' say' an empty board' or a                           board with 64 white kings and no black ones). If your engine receives a position that it considers                           illegal' I suggest that you send the response "tellusererror Illegal position"' and then respond to                           any attempted move with "Illegal move" until the next new' edit' or setboard command.                      */                      try                      {                          Game.New(strMessage.Substring(9).Trim());                      }                      catch (Fen.ValidationException x)                      {                          SendOutputMessage("tellusererror Illegal position: " + x.FenMessage);                      }                  }                  else if (strMessage == "edit")                  {                      /*                         * Chess Engine Communication Protocol                          The edit command is the old way to set up positions. For compatibility with old engines' it is still used by default' but new engines may prefer to use the feature command (see below) to cause xboard to use setboard instead. The edit command puts the chess engine into a special mode' where it accepts the following subcommands: c change current piece color' initially white                            Pa4 (for example) place pawn of current color on a4                            xa4 (for example) empty the square a4 (not used by xboard)                            # clear board                            . leave edit mode                            See the Idioms section below for additional subcommands used in ChessBase's implementation of the protocol.                           The edit command does not change the side to move. To set up a black-on-move position' xboard uses the following command sequence:                                 new                              force                              a2a3                              edit                              <edit commands>                              .                            This sequence is used to avoid the "black" command' which is now considered obsolete and which many engines never did implement as specified in this document.                             After an edit command is complete' if a king and a rook are on their home squares' castling is assumed to be available to them. En passant capture is assumed to be illegal on the current move regardless of the positions of the pawns. The clock for the 50 move rule starts at zero' and for purposes of the draw by repetition rule' no prior positions are deemed to have occurred.                         */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "hint")                  {                      // * Chess Engine Communication Protocol                      // If the user asks for a hint' xboard sends your engine the command "hint". Your engine should respond with "Hint: xxx"' where xxx is a suggested move. If there is no move to suggest' you can ignore the hint command (that is' treat it as a no-op).                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "bk")                  {                      // * Chess Engine Communication Protocol                      // If the user selects "Book" from the xboard menu' xboard will send your engine the command "bk". You can send any text you like as the response' as long as each line begins with a blank space or tab (\t) character' and you send an empty line at the end. The text pops up in a modal information dialog.                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "undo")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to back up one move' xboard will send you the "undo" command. xboard will not send this command without putting you in "force" mode first' so you don't have to worry about what should happen if the user asks to undo a move your engine made. (GNU Chess 4 actually switches to playing the opposite color in this case.)                       Game.UndoMove();                  }                  else if (strMessage == "remove")                  {                      // * Chess Engine Communication Protocol                      // If the user asks to retract a move' xboard will send you the "remove" command. It sends this command only when the user is on move. Your engine should undo the last two moves (one for each player) and continue playing the same color.                      Game.UndoMove();                      Game.UndoMove();                  }                  else if (strMessage == "hard")                  {                      /*                         * Chess Engine Communication Protocol                          Turn on pondering (thinking on the opponent's time' also known as "permanent brain"). xboard will not                           make any assumption about what your default is for pondering or whether "new" affects this setting.                       */                      Game.EnablePondering = true;                  }                  else if (strMessage == "easy")                  {                      // * Chess Engine Communication Protocol                      // Turn off pondering.                       Game.EnablePondering = false;                  }                  else if (strMessage == "post")                  {                      // * Chess Engine Communication Protocol                      // Turn on thinking/pondering output. See Thinking Output section.                       Game.ShowThinking = true;                  }                  else if (strMessage == "nopost")                  {                      // Turn off thinking/pondering output.                       Game.ShowThinking = false;                  }                  else if (strMessage == "analyze")                  {                      // * Chess Engine Communication Protocol                      // Enter analyze mode.                       Game.SuspendPondering();                        Game.PlayerToPlay.Clock.Stop();                      Game.PlayerWhite.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.PlayerBlack.Intellegence = Player.PlayerIntellegenceNames.Computer;                      Game.IsInAnalyseMode = true;                        Game.PlayerToPlay.Brain.StartThinking();                  }                  else if (strMessage == ".")                  {                      // Status update                      if (Game.PlayerToPlay.Brain.IsThinking)                      {                          SendAnalyzeStatus(                              Game.PlayerToPlay.Brain.ThinkingTimeElpased'                              Game.PlayerToPlay.Brain.Search.PositionsSearchedThisIteration'                              Game.PlayerToPlay.Brain.Search.SearchDepth'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch - Game.PlayerToPlay.Brain.Search.SearchPositionNo'                              Game.PlayerToPlay.Brain.Search.TotalPositionsToSearch'                               Game.PlayerToPlay.Brain.Search.CurrentMoveSearched);                      }                  }                  else if (strMessage == "exit")                  {                      // Exit analyze mode.                      Game.SuspendPondering();                        if (Game.IsInAnalyseMode)                      {                          Game.IsInAnalyseMode = false;                      }                  }                  else if (strMessage.StartsWith("name "))                  {                      // * Chess Engine Communication Protocol                      // This command informs the engine of its opponent's name. When the engine is playing on a chess server' xboard obtains the                       // opponent's name from the server. When the engine is playing locally against a human user' xboard obtains the user's login                       // name from the local operating system. When the engine is playing locally against another engine' xboard uses either the other                       // engine's filename or the name that the other engine supplied in the myname option to the feature command. By default' xboard                       // uses the name command only when the engine is playing on a chess server. Beginning in protocol version 2' you can change this                      // with the name option to the feature command.                  }                  else if (strMessage == "rating")                  {                      /*                         * Chess Engine Communication Protocol                          In ICS mode' xboard obtains the ICS opponent's rating from the "Creating:" message that appears before each game.                           (This message may not appear on servers using outdated versions of the FICS code.) In Zippy mode' it sends these ratings on                          to the chess engine using the "rating" command. The chess engine's own rating comes first' and if either opponent is not                          rated' his rating is given as 0. In the future this command may also be used in other modes' if ratings are known.                           Example: rating 2600 1500                      */                      throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage.StartsWith("ics "))                  {                      // * Chess Engine Communication Protocol                      // If HOSTNAME is "-"' the engine is playing against a local opponent; otherwise' the engine is playing on an Internet Chess Server (ICS)                      //  with the given hostname. This command is new in protocol version 2 and is not sent unless the engine has enabled it with the "feature"                      //  command. Example: "ics freechess.org"                       throw new WinBoardInputException("Unknown command: " + strMessage);                  }                  else if (strMessage == "computer")                  {                      // * Chess Engine Communication Protocol                      // The opponent is also a computer chess engine. Some engines alter their playing style when they receive this command.                      Game.UseRandomOpeningMoves = false;                  }                  else if (strMessage == "pause")                  {                      // * Chess Engine Communication Protocol                      // See resume                      Game.PausePlay();                  }                  else if (strMessage == "resume")                  {                      // * Chess Engine Communication Protocol                      // (These commands are new in protocol version 2 and will not be sent unless feature pause=1 is set. At this writing' xboard actually does not use the commands at all' but it or other interfaces may use them in the future.) The "pause" command puts the engine into a special state where it does not think' ponder' or otherwise consume significant CPU time. The current thinking or pondering (if any) is suspended and both player's clocks are stopped. The only command that the interface may send to the engine while it is in the paused state is "resume". The paused thinking or pondering (if any) resumes from exactly where it left off' and the clock of the player on move resumes running from where it stopped.                       Game.ResumePlay();                  }                  else if (strMessage.Length == 4 || strMessage.Length == 5)                  {                      MakeMove(strMessage);                  }                  else                  {                      throw new WinBoardInputException("Error (unknown command): " + strMessage);                  }              }              catch (WinBoardInputException e)              {                  SendOutputMessage(e.WinBoardMessage);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SendThinking,The following statement contains a magic number: if (Active && Game.ShowThinking)              {                  int intScoreInCentipawns = score / 10;                  int intTimeIncentiseconds = Convert.ToInt32(thinkingTime.TotalMilliseconds / 100);                  SendOutputMessage(                      ply.ToString() + " " + intScoreInCentipawns.ToString() + " " + intTimeIncentiseconds.ToString()                      + " " + nodes.ToString() + " " + prinicalVariation);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SendThinking,The following statement contains a magic number: if (Active && Game.ShowThinking)              {                  int intScoreInCentipawns = score / 10;                  int intTimeIncentiseconds = Convert.ToInt32(thinkingTime.TotalMilliseconds / 100);                  SendOutputMessage(                      ply.ToString() + " " + intScoreInCentipawns.ToString() + " " + intTimeIncentiseconds.ToString()                      + " " + nodes.ToString() + " " + prinicalVariation);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,Listen,The following statement contains a magic number: while (true)              {                  string strMessage = Console.ReadLine();                  if (strMessage == null)                  {                      Thread.Sleep(500);                  }                  else                  {                      WinBoardInputEvent(strMessage);                  }              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The following statement contains a magic number: if (strMove.Length == 5)              {                  switch (strMove.Substring(4' 1))                  {                      case "q":                          movename = Move.MoveNames.PawnPromotionQueen;                          break;                        case "r":                          movename = Move.MoveNames.PawnPromotionRook;                          break;                        case "b":                          movename = Move.MoveNames.PawnPromotionBishop;                          break;                        case "n":                          movename = Move.MoveNames.PawnPromotionKnight;                          break;                  }              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The following statement contains a magic number: if (strMove.Length == 5)              {                  switch (strMove.Substring(4' 1))                  {                      case "q":                          movename = Move.MoveNames.PawnPromotionQueen;                          break;                        case "r":                          movename = Move.MoveNames.PawnPromotionRook;                          break;                        case "b":                          movename = Move.MoveNames.PawnPromotionBishop;                          break;                        case "n":                          movename = Move.MoveNames.PawnPromotionKnight;                          break;                  }              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The following statement contains a magic number: foreach (Move move in moves)              {                  if (move.From.Name == strMove.Substring(0' 2) && move.To.Name == strMove.Substring(2' 2)                      && (movename == Move.MoveNames.NullMove || move.Name == movename))                  {                      Game.MakeAMove(move.Name' move.Piece' move.To);                      return;                  }              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The following statement contains a magic number: foreach (Move move in moves)              {                  if (move.From.Name == strMove.Substring(0' 2) && move.To.Name == strMove.Substring(2' 2)                      && (movename == Move.MoveNames.NullMove || move.Name == movename))                  {                      Game.MakeAMove(move.Name' move.Piece' move.To);                      return;                  }              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The following statement contains a magic number: foreach (Move move in moves)              {                  if (move.From.Name == strMove.Substring(0' 2) && move.To.Name == strMove.Substring(2' 2)                      && (movename == Move.MoveNames.NullMove || move.Name == movename))                  {                      Game.MakeAMove(move.Name' move.Piece' move.To);                      return;                  }              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SendAnalyzeStatus,The following statement contains a magic number: if (Active && Game.IsInAnalyseMode)              {                  int intTimeIncentiseconds = Convert.ToInt32(thinkingTime.TotalMilliseconds / 100);                  SendOutputMessage(                      "stat01:" + " " + intTimeIncentiseconds.ToString() + " " + nodes.ToString() + " " + ply.ToString()                      + " " + movesRemaining.ToString() + " " + totalMoves.ToString() + " " + moveCurrent.From.Name                      + moveCurrent.To.Name);              }
Magic Number,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,SetLevel,The following statement contains a magic number: Game.MaximumSearchDepth = 32;
Missing Default,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following switch statement is missing a default case: switch (variableDepth)                  {                      case 2:                      case 3:                          // case 4:                          int intLazyEval = player.Score;                            switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }                            break;                  }
Missing Default,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,ApplyReductions,The following switch statement is missing a default case: switch (variableDepth)                          {                              case 2:                                    // Standard Futility Pruning                                  if (intLazyEval + 3000 <= alpha)                                  {                                      extensionOrReduction = -2;                                      Comment(moveMade' "R-FUT3 ");                                  }                                    break;                                case 3:                                    // Extended Futility Pruning                                  if (intLazyEval + 5000 <= alpha)                                  {                                      extensionOrReduction = -3;                                      Comment(moveMade' "R-FUT5 ");                                  }                                    break;                                case 4:                                    // Deep Futility Pruning                                  if (intLazyEval + 9750 <= alpha)                                  {                                      extensionOrReduction = -4;                                      Comment(moveMade' "R-FUT9 ");                                  }                                    break;                          }
Missing Default,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,Aspirate,The following switch statement is missing a default case: switch (intAttempt)                  {                      case 0:                          alpha = lastIterationsScore - 250;                          beta = lastIterationsScore + 250;                          break;                        case 1:                          alpha = lastIterationsScore - 2000;                          beta = lastIterationsScore + 2000;                          break;                        case 2:                          alpha = MinScore;                          beta = MaxScore;                          break;                  }
Missing Default,SharpChess.Model.AI,Search,C:\repos\PeterHughes_SharpChess\SharpChess.Model\AI\Search.cs,AssignMoveOrderScore,The following switch statement is missing a default case: switch (move.Name)              {                  case Move.MoveNames.PawnPromotionQueen:                      move.Score = 999999;                      break;                  case Move.MoveNames.PawnPromotionRook:                      move.Score = 999998;                      break;                  case Move.MoveNames.PawnPromotionBishop:                      move.Score = 999997;                      break;                  case Move.MoveNames.PawnPromotionKnight:                      move.Score = 999996;                      break;              }
Missing Default,SharpChess.Model,Board,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Board.cs,FileFromName,The following switch statement is missing a default case: switch (fileName)              {                  case "a":                      return 0;                  case "b":                      return 1;                  case "c":                      return 2;                  case "d":                      return 3;                  case "e":                      return 4;                  case "f":                      return 5;                  case "g":                      return 6;                  case "h":                      return 7;              }
Missing Default,SharpChess.Model,BoardDebug,C:\repos\PeterHughes_SharpChess\SharpChess.Model\BoardDebug.cs,DebugGameInfo,The following switch statement is missing a default case: switch (indRank)              {                  case 0:                  case 7:                      Pieces piecesCaptureList = (indRank == 7)                                                     ? Game.PlayerWhite.CapturedEnemyPieces                                                     : Game.PlayerBlack.CapturedEnemyPieces;                      if (piecesCaptureList.Count > 1)                      {                          strbBoard.Append("x ");                          foreach (Piece pieceCaptured in piecesCaptureList)                          {                              strbBoard.Append(                                  (pieceCaptured.Name == Piece.PieceNames.Pawn)                                      ? string.Empty                                      : pieceCaptured.Abbreviation + pieceCaptured.Square.Name + " ");                          }                      }                        break;                    case 5:                      int turnNumberOld = Game.TurnNo; // Backup TurNo                      Game.TurnNo -= Game.PlayerToPlay.Brain.Search.SearchDepth;                      for (int indMov = Math.Max(1' Game.MoveHistory.Count - Game.PlayerToPlay.Brain.Search.MaxSearchDepth);                           indMov < Game.MoveHistory.Count;                           indMov++)                      {                          Move moveThis = Game.MoveHistory[indMov];                          if (moveThis.Piece.Player.Colour == Player.PlayerColourNames.White)                          {                              strbBoard.Append(indMov >> 1);                              strbBoard.Append(". ");                          }                            // moveThis.PgnSanFormat(false); // Contextual to Game.TurNo                          strbBoard.Append(moveThis.Description + " ");                          Game.TurnNo++;                      }                        Game.TurnNo = turnNumberOld; // Restore TurNo                      break;              }
Missing Default,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,FenHlpMsg,The following switch statement is missing a default case: switch (fieldNumber)              {                  case 1:                      return "FEN field 1: Piece placement data.\n";                  case 2:                      return "FEN field 2: Active color.\n";                  case 3:                      return "FEN field 3: Castling availability.\n";                  case 4:                      return "FEN field 4: En passant target square coordonates.\n";                  case 5:                      return "FEN field 5: Nbr of half move without capture or pawn move.\n";                  case 6:                      return "FEN field 6: Full move number.\n";              }
Missing Default,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,MovePieceToFenPosition,The following switch statement is missing a default case: switch (charToken.ToString().ToUpper())              {                  case "K":                      piecename = Piece.PieceNames.King;                      break;                  case "Q":                      piecename = Piece.PieceNames.Queen;                      break;                  case "R":                      piecename = Piece.PieceNames.Rook;                      break;                  case "B":                      piecename = Piece.PieceNames.Bishop;                      break;                  case "N":                      piecename = Piece.PieceNames.Knight;                      break;                  case "P":                      piecename = Piece.PieceNames.Pawn;                      break;              }
Missing Default,SharpChess.Model,Fen,C:\repos\PeterHughes_SharpChess\SharpChess.Model\FEN.cs,VerifyPiecePlacement,The following switch statement is missing a default case: switch (t)                  {                      case 'K':                          strPieceName += " White King";                          break;                      case 'Q':                          strPieceName += " White Queen";                          break;                      case 'R':                          strPieceName += " White Rook";                          break;                      case 'B':                          strPieceName += " White Bishop";                          break;                      case 'N':                          strPieceName += " White Knight";                          break;                      case 'P':                          strPieceName += " White Pawn";                          break;                      case 'k':                          strPieceName += " Black King";                          break;                      case 'q':                          strPieceName += " Black Queen";                          break;                      case 'r':                          strPieceName += " Black Rook";                          break;                      case 'b':                          strPieceName += " Black Bishop";                          break;                      case 'n':                          strPieceName += " Black Knight";                          break;                      case 'p':                          strPieceName += " Black Pawn";                          break;                  }
Missing Default,SharpChess.Model,Move,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Move.cs,Undo,The following switch statement is missing a default case: switch (move.Name)              {                  case MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(5' 0) : Board.GetPiece(5' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(7' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(7' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(5' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White ? Board.GetPiece(3' 0) : Board.GetPiece(3' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square = Board.GetSquare(0' move.Piece.Square.Rank);                      pieceRook.LastMoveTurnNo = move.LastMoveTurnNo;                      pieceRook.NoOfMoves--;                      Board.GetSquare(0' move.Piece.Square.Rank).Piece = pieceRook;                      Board.GetSquare(3' move.Piece.Square.Rank).Piece = null;                      move.Piece.Player.HasCastled = false;                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      break;                    case MoveNames.PawnPromotionQueen:                  case MoveNames.PawnPromotionRook:                  case MoveNames.PawnPromotionBishop:                  case MoveNames.PawnPromotionKnight:                      move.Piece.Demote();                      break;              }
Missing Default,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Piece,The following switch statement is missing a default case: switch (name)              {                  case PieceNames.Pawn:                      this.Top = new PiecePawn(this);                      break;                    case PieceNames.Bishop:                      this.Top = new PieceBishop(this);                      break;                    case PieceNames.Knight:                      this.Top = new PieceKnight(this);                      break;                    case PieceNames.Rook:                      this.Top = new PieceRook(this);                      break;                    case PieceNames.Queen:                      this.Top = new PieceQueen(this);                      break;                    case PieceNames.King:                      this.Top = new PieceKing(this);                      break;              }
Missing Default,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,CanPlayerPieceNameAttackSquare,The following switch statement is missing a default case: switch (PieceName)              {                  case PieceNames.Bishop:                      return PieceBishop.DoesPieceAttackSquare(square' player);                  case PieceNames.King:                      return PieceKing.DoesPieceAttackSquare(square' player);                  case PieceNames.Knight:                      return PieceKnight.DoesPieceAttackSquare(square' player);                  case PieceNames.Pawn:                      return PiecePawn.DoesPieceAttackSquare(square' player);                  case PieceNames.Queen:                      return PieceQueen.DoesPieceAttackSquare(square' player);                  case PieceNames.Rook:                      return PieceRook.DoesPieceAttackSquare(square' player);              }
Missing Default,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,CanPlayerPieceNameAttackSquare,The following switch statement is missing a default case: switch (PieceName)              {                  case PieceNames.Bishop:                      return PieceBishop.DoesPieceAttackSquare(square' player'out attackingPiece);                  case PieceNames.King:                      return PieceKing.DoesPieceAttackSquare(square' player' out attackingPiece);                  case PieceNames.Knight:                      return PieceKnight.DoesPieceAttackSquare(square' player' out attackingPiece);                  case PieceNames.Pawn:                      return PiecePawn.DoesPieceAttackSquare(square' player' out attackingPiece);                  case PieceNames.Queen:                      return PieceQueen.DoesPieceAttackSquare(square' player' out attackingPiece);                  case PieceNames.Rook:                      return PieceRook.DoesPieceAttackSquare(square' player' out attackingPiece);              }
Missing Default,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeAForSquareOrdinal,The following switch statement is missing a default case: switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 830859827498573475;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 37500384876452947;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 448573857309865743;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 294375032850265937;                          break;                  }
Missing Default,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,HashCodeBForSquareOrdinal,The following switch statement is missing a default case: switch (this.Top.Name)                  {                      case PieceNames.Queen:                          ulongPromotionModifier = 790423450762398573;                          break;                      case PieceNames.Rook:                          ulongPromotionModifier = 394756026094872034;                          break;                      case PieceNames.Bishop:                          ulongPromotionModifier = 629385632983478593;                          break;                      case PieceNames.Knight:                          ulongPromotionModifier = 283469276067858673;                          break;                  }
Missing Default,SharpChess.Model,Piece,C:\repos\PeterHughes_SharpChess\SharpChess.Model\Piece.cs,Move,The following switch statement is missing a default case: switch (moveName)              {                  case Model.Move.MoveNames.CastleKingSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(7' 0)                                      : Board.GetPiece(7' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(5' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(5' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.CastleQueenSide:                      pieceRook = move.Piece.Player.Colour == Player.PlayerColourNames.White                                      ? Board.GetPiece(0' 0)                                      : Board.GetPiece(0' 7);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      pieceRook.Square.Piece = null;                      pieceRook.LastMoveTurnNo = Game.TurnNo;                      pieceRook.NoOfMoves++;                      Board.GetSquare(3' square.Rank).Piece = pieceRook;                      pieceRook.Square = Board.GetSquare(3' square.Rank);                      Board.HashCodeA ^= pieceRook.HashCodeA;                      Board.HashCodeB ^= pieceRook.HashCodeB;                      this.Player.HasCastled = true;                      break;                    case Model.Move.MoveNames.PawnPromotionQueen:                      this.Promote(PieceNames.Queen);                      break;                    case Model.Move.MoveNames.PawnPromotionRook:                      this.Promote(PieceNames.Rook);                      break;                    case Model.Move.MoveNames.PawnPromotionBishop:                      this.Promote(PieceNames.Bishop);                      break;                    case Model.Move.MoveNames.PawnPromotionKnight:                      this.Promote(PieceNames.Knight);                      break;                    case Model.Move.MoveNames.EnPassent:                      Board.HashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.HashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.PawnHashCodeA ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeA;                      Board.PawnHashCodeB ^= Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).HashCodeB;                      Board.GetPiece(this.Square.Ordinal - this.Player.PawnForwardOffset).Capture();                                                    // Take enemy pawn that is now behind us                      break;              }
Missing Default,SharpChess.Model,PieceKing,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKing.cs,GenerateLazyMoves,The following switch statement is missing a default case: switch (movesType)              {                  case Moves.MoveListNames.All:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                         if (this.CanCastleKingSide)                      {                          moves.Add(0' 0' Move.MoveNames.CastleKingSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal + 2)' null' 0' 0);                      }                        if (this.CanCastleQueenSide)                      {                          moves.Add(Game.TurnNo' this.Base.LastMoveTurnNo' Move.MoveNames.CastleQueenSide' this.Base' this.Base.Square' Board.GetSquare(this.Base.Square.Ordinal - 2)' null' 0' 0);                      }                        break;                    case Moves.MoveListNames.CapturesPromotions:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                      break;                                  }
Missing Default,SharpChess.Model,PieceKnight,C:\repos\PeterHughes_SharpChess\SharpChess.Model\PieceKnight.cs,GenerateLazyMoves,The following switch statement is missing a default case: switch (movesType)              {                  case Moves.MoveListNames.All:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece == null || (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                      break;                    case Moves.MoveListNames.CapturesPromotions:                      for (int i = 0; i < moveVectors.Length; i++)                      {                          square = Board.GetSquare(this.Base.Square.Ordinal + moveVectors[i]);                          if (square != null && (square.Piece != null && (square.Piece.Player.Colour != this.Base.Player.Colour && square.Piece.IsCapturable)))                          {                              moves.Add(0' 0' Move.MoveNames.Standard' this.Base' this.Base.Square' square' square.Piece' 0' 0);                          }                      }                      break;              }
Missing Default,SharpChess.Model,WinBoard,C:\repos\PeterHughes_SharpChess\SharpChess.Model\WinBoard.cs,MakeMove,The following switch statement is missing a default case: switch (strMove.Substring(4' 1))                  {                      case "q":                          movename = Move.MoveNames.PawnPromotionQueen;                          break;                        case "r":                          movename = Move.MoveNames.PawnPromotionRook;                          break;                        case "b":                          movename = Move.MoveNames.PawnPromotionBishop;                          break;                        case "n":                          movename = Move.MoveNames.PawnPromotionKnight;                          break;                  }
