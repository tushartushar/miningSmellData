Implementation smell,Namespace,Class,File,Method,Description
Long Method,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The method has 146 lines of code.
Long Method,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The method has 247 lines of code.
Long Method,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The method has 156 lines of code.
Long Method,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The method has 196 lines of code.
Complex Method,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,ExtractData,Cyclomatic complexity of the method is 11
Long Statement,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutBox)); " is 128.
Long Statement,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 33F)); " is 121.
Long Statement,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 67F)); " is 121.
Long Statement,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The length of the statement  "            this.labelDonate.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.labelDonate_LinkClicked); " is 120.
Long Statement,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The length of the statement  "            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,ExtractData,The length of the statement  "                throw new InvalidDataException(String.Format("Possible error ({0}) at offset: {1:X8}"' chunkCount' reader.BaseStream.Position)); " is 128.
Long Statement,CASCExplorer,CASCConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,Load,The length of the statement  "                string buildCfgPath = Path.Combine(wowPath' "Data\\config\\"' buildKey.Substring(0' 2)' buildKey.Substring(2' 2)' buildKey); " is 124.
Long Statement,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The length of the statement  "            this.backgroundWorker1.ProgressChanged += new System.ComponentModel.ProgressChangedEventHandler(this.backgroundWorker1_ProgressChanged); " is 136.
Long Statement,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The length of the statement  "            this.backgroundWorker1.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.backgroundWorker1_RunWorkerCompleted); " is 145.
Long Statement,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,loadDataWorker_RunWorkerCompleted,The length of the statement  "                MessageBox.Show("Error initializing required data files:\n" + e.Error.Message' "Error!"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 133.
Long Statement,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,loadDataWorker_RunWorkerCompleted,The length of the statement  "                statusLabel.Text = String.Format("Loaded {0} files ({1} names missing)"' numFileNames' cascHandler.NumRootEntries - numFileNames); " is 130.
Long Statement,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,UpdateListView,The length of the statement  "                orderedEntries = baseEntry.SubEntries.OrderByDescending(v => v.Value).ToDictionary(pair => pair.Key' pair => pair.Value); " is 121.
Long Statement,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The length of the statement  "            this.fileList.RetrieveVirtualItem += new System.Windows.Forms.RetrieveVirtualItemEventHandler(this.listView1_RetrieveVirtualItem); " is 130.
Long Statement,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The length of the statement  "            this.loadDataWorker.ProgressChanged += new System.ComponentModel.ProgressChangedEventHandler(this.loadDataWorker_ProgressChanged); " is 130.
Long Statement,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The length of the statement  "            this.loadDataWorker.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.loadDataWorker_RunWorkerCompleted); " is 139.
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.ColumnCount = 2;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.labelCopyright' 1' 2);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.labelDonate' 1' 3);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.textBoxDescription' 1' 4);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.okButton' 1' 5);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Location = new System.Drawing.Point(9' 9);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Location = new System.Drawing.Point(9' 9);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.RowCount = 6;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Size = new System.Drawing.Size(417' 265);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Size = new System.Drawing.Size(417' 265);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.SetRowSpan(this.logoPictureBox' 6);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Size = new System.Drawing.Size(131' 259);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Size = new System.Drawing.Size(131' 259);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.TabIndex = 12;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Location = new System.Drawing.Point(143' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.TabIndex = 19;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Location = new System.Drawing.Point(143' 26);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Location = new System.Drawing.Point(143' 26);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Location = new System.Drawing.Point(143' 52);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Location = new System.Drawing.Point(143' 52);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.TabIndex = 21;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.Location = new System.Drawing.Point(143' 78);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.Location = new System.Drawing.Point(143' 78);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.Size = new System.Drawing.Size(271' 17);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelDonate.TabIndex = 22;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Location = new System.Drawing.Point(143' 107);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Location = new System.Drawing.Point(143' 107);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Size = new System.Drawing.Size(271' 126);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Size = new System.Drawing.Size(271' 126);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.TabIndex = 23;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Location = new System.Drawing.Point(339' 239);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Location = new System.Drawing.Point(339' 239);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.TabIndex = 24;
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(435' 283);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(435' 283);
Magic Number,CASCExplorer,AboutBox,C:\repos\tomrus88_CASCExplorer\CASCExplorer\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.Padding = new System.Windows.Forms.Padding(9);
Magic Number,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,ExtractData,The following statement contains a magic number: if (frameHeaderSize == 0)              {                  totalSize = size - 8;                  chunkCount = 1;              }              else              {                  byte unk1 = reader.ReadByte(); // byte                    if (unk1 != 0x0F)                      throw new InvalidDataException("unk1 != 0x0F");                    byte v1 = reader.ReadByte();                  byte v2 = reader.ReadByte();                  byte v3 = reader.ReadByte();                  chunkCount = v1 << 16 | v2 << 8 | v3 << 0; // 3-byte              }
Magic Number,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,ExtractData,The following statement contains a magic number: if (frameHeaderSize == 0)              {                  totalSize = size - 8;                  chunkCount = 1;              }              else              {                  byte unk1 = reader.ReadByte(); // byte                    if (unk1 != 0x0F)                      throw new InvalidDataException("unk1 != 0x0F");                    byte v1 = reader.ReadByte();                  byte v2 = reader.ReadByte();                  byte v3 = reader.ReadByte();                  chunkCount = v1 << 16 | v2 << 8 | v3 << 0; // 3-byte              }
Magic Number,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,ExtractData,The following statement contains a magic number: if (frameHeaderSize == 0)              {                  totalSize = size - 8;                  chunkCount = 1;              }              else              {                  byte unk1 = reader.ReadByte(); // byte                    if (unk1 != 0x0F)                      throw new InvalidDataException("unk1 != 0x0F");                    byte v1 = reader.ReadByte();                  byte v2 = reader.ReadByte();                  byte v3 = reader.ReadByte();                  chunkCount = v1 << 16 | v2 << 8 | v3 << 0; // 3-byte              }
Magic Number,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,ExtractData,The following statement contains a magic number: for (int i = 0; i < chunkCount; ++i)              {                  chunks[i] = new BLTEChunk();                    if (frameHeaderSize != 0)                  {                      chunks[i].CompSize = reader.ReadInt32BE();                      chunks[i].DecompSize = reader.ReadInt32BE();                      chunks[i].Hash = reader.ReadBytes(16);                  }                  else                  {                      chunks[i].CompSize = totalSize;                      chunks[i].DecompSize = totalSize - 1;                      chunks[i].Hash = null;                  }              }
Magic Number,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,Decompress,The following statement contains a magic number: using (var ms = new MemoryStream(data' 3' data.Length - 3))              using (var dStream = new DeflateStream(ms' CompressionMode.Decompress))                  dStream.CopyTo(outS);
Magic Number,CASCExplorer,BLTEHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\BLTEHandler.cs,Decompress,The following statement contains a magic number: using (var ms = new MemoryStream(data' 3' data.Length - 3))              using (var dStream = new DeflateStream(ms' CompressionMode.Decompress))                  dStream.CopyTo(outS);
Magic Number,CASCExplorer,KeyValueConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,KeyValueConfig,The following statement contains a magic number: using (var sr = new StreamReader(stream))              {                  string line;                    while ((line = sr.ReadLine()) != null)                  {                      if (line.StartsWith("#")) // skip comments                          continue;                        string[] tokens = line.Split(new char[] { '=' }' StringSplitOptions.RemoveEmptyEntries);                        if (tokens.Length != 2)                          throw new Exception("KeyValueConfig: tokens.Length != 2");                        var values = tokens[1].Trim().Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      var valuesList = new List<string>();                      valuesList.AddRange(values);                      Data.Add(tokens[0].Trim()' valuesList);                  }              }
Magic Number,CASCExplorer,CASCConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,Load,The following statement contains a magic number: if (online)              {                  using (var cdnsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/cdns"))                      _CDNData = new VerBarConfig(cdnsStream);                    using (var versionsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/versions"))                      _VersionsData = new VerBarConfig(versionsStream);                    string buildKey = _VersionsData["BuildConfig"][0];                  using (Stream buildConfigStream = CDNHandler.OpenConfigFileDirect(buildKey))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _VersionsData["CDNConfig"][0];                  using (Stream CDNConfigStream = CDNHandler.OpenConfigFileDirect(cdnKey))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }              else              {                  string buildInfoPath = Path.Combine(wowPath' ".build.info");                    using (Stream buildInfoStream = new FileStream(buildInfoPath' FileMode.Open))                      _BuildInfo = new VerBarConfig(buildInfoStream);                    string buildKey = _BuildInfo["Build Key"][0];                  string buildCfgPath = Path.Combine(wowPath' "Data\\config\\"' buildKey.Substring(0' 2)' buildKey.Substring(2' 2)' buildKey);                  using (Stream buildConfigStream = new FileStream(buildCfgPath' FileMode.Open))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _BuildInfo["CDN Key"][0];                  string cdnCfgPath = Path.Combine(wowPath' "Data\\config\\"' cdnKey.Substring(0' 2)' cdnKey.Substring(2' 2)' cdnKey);                  using (Stream CDNConfigStream = new FileStream(cdnCfgPath' FileMode.Open))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }
Magic Number,CASCExplorer,CASCConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,Load,The following statement contains a magic number: if (online)              {                  using (var cdnsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/cdns"))                      _CDNData = new VerBarConfig(cdnsStream);                    using (var versionsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/versions"))                      _VersionsData = new VerBarConfig(versionsStream);                    string buildKey = _VersionsData["BuildConfig"][0];                  using (Stream buildConfigStream = CDNHandler.OpenConfigFileDirect(buildKey))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _VersionsData["CDNConfig"][0];                  using (Stream CDNConfigStream = CDNHandler.OpenConfigFileDirect(cdnKey))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }              else              {                  string buildInfoPath = Path.Combine(wowPath' ".build.info");                    using (Stream buildInfoStream = new FileStream(buildInfoPath' FileMode.Open))                      _BuildInfo = new VerBarConfig(buildInfoStream);                    string buildKey = _BuildInfo["Build Key"][0];                  string buildCfgPath = Path.Combine(wowPath' "Data\\config\\"' buildKey.Substring(0' 2)' buildKey.Substring(2' 2)' buildKey);                  using (Stream buildConfigStream = new FileStream(buildCfgPath' FileMode.Open))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _BuildInfo["CDN Key"][0];                  string cdnCfgPath = Path.Combine(wowPath' "Data\\config\\"' cdnKey.Substring(0' 2)' cdnKey.Substring(2' 2)' cdnKey);                  using (Stream CDNConfigStream = new FileStream(cdnCfgPath' FileMode.Open))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }
Magic Number,CASCExplorer,CASCConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,Load,The following statement contains a magic number: if (online)              {                  using (var cdnsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/cdns"))                      _CDNData = new VerBarConfig(cdnsStream);                    using (var versionsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/versions"))                      _VersionsData = new VerBarConfig(versionsStream);                    string buildKey = _VersionsData["BuildConfig"][0];                  using (Stream buildConfigStream = CDNHandler.OpenConfigFileDirect(buildKey))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _VersionsData["CDNConfig"][0];                  using (Stream CDNConfigStream = CDNHandler.OpenConfigFileDirect(cdnKey))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }              else              {                  string buildInfoPath = Path.Combine(wowPath' ".build.info");                    using (Stream buildInfoStream = new FileStream(buildInfoPath' FileMode.Open))                      _BuildInfo = new VerBarConfig(buildInfoStream);                    string buildKey = _BuildInfo["Build Key"][0];                  string buildCfgPath = Path.Combine(wowPath' "Data\\config\\"' buildKey.Substring(0' 2)' buildKey.Substring(2' 2)' buildKey);                  using (Stream buildConfigStream = new FileStream(buildCfgPath' FileMode.Open))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _BuildInfo["CDN Key"][0];                  string cdnCfgPath = Path.Combine(wowPath' "Data\\config\\"' cdnKey.Substring(0' 2)' cdnKey.Substring(2' 2)' cdnKey);                  using (Stream CDNConfigStream = new FileStream(cdnCfgPath' FileMode.Open))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }
Magic Number,CASCExplorer,CASCConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,Load,The following statement contains a magic number: if (online)              {                  using (var cdnsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/cdns"))                      _CDNData = new VerBarConfig(cdnsStream);                    using (var versionsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/versions"))                      _VersionsData = new VerBarConfig(versionsStream);                    string buildKey = _VersionsData["BuildConfig"][0];                  using (Stream buildConfigStream = CDNHandler.OpenConfigFileDirect(buildKey))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _VersionsData["CDNConfig"][0];                  using (Stream CDNConfigStream = CDNHandler.OpenConfigFileDirect(cdnKey))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }              else              {                  string buildInfoPath = Path.Combine(wowPath' ".build.info");                    using (Stream buildInfoStream = new FileStream(buildInfoPath' FileMode.Open))                      _BuildInfo = new VerBarConfig(buildInfoStream);                    string buildKey = _BuildInfo["Build Key"][0];                  string buildCfgPath = Path.Combine(wowPath' "Data\\config\\"' buildKey.Substring(0' 2)' buildKey.Substring(2' 2)' buildKey);                  using (Stream buildConfigStream = new FileStream(buildCfgPath' FileMode.Open))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _BuildInfo["CDN Key"][0];                  string cdnCfgPath = Path.Combine(wowPath' "Data\\config\\"' cdnKey.Substring(0' 2)' cdnKey.Substring(2' 2)' cdnKey);                  using (Stream CDNConfigStream = new FileStream(cdnCfgPath' FileMode.Open))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }
Magic Number,CASCExplorer,CASCConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,Load,The following statement contains a magic number: if (online)              {                  using (var cdnsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/cdns"))                      _CDNData = new VerBarConfig(cdnsStream);                    using (var versionsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/versions"))                      _VersionsData = new VerBarConfig(versionsStream);                    string buildKey = _VersionsData["BuildConfig"][0];                  using (Stream buildConfigStream = CDNHandler.OpenConfigFileDirect(buildKey))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _VersionsData["CDNConfig"][0];                  using (Stream CDNConfigStream = CDNHandler.OpenConfigFileDirect(cdnKey))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }              else              {                  string buildInfoPath = Path.Combine(wowPath' ".build.info");                    using (Stream buildInfoStream = new FileStream(buildInfoPath' FileMode.Open))                      _BuildInfo = new VerBarConfig(buildInfoStream);                    string buildKey = _BuildInfo["Build Key"][0];                  string buildCfgPath = Path.Combine(wowPath' "Data\\config\\"' buildKey.Substring(0' 2)' buildKey.Substring(2' 2)' buildKey);                  using (Stream buildConfigStream = new FileStream(buildCfgPath' FileMode.Open))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _BuildInfo["CDN Key"][0];                  string cdnCfgPath = Path.Combine(wowPath' "Data\\config\\"' cdnKey.Substring(0' 2)' cdnKey.Substring(2' 2)' cdnKey);                  using (Stream CDNConfigStream = new FileStream(cdnCfgPath' FileMode.Open))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }
Magic Number,CASCExplorer,CASCConfig,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCConfig.cs,Load,The following statement contains a magic number: if (online)              {                  using (var cdnsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/cdns"))                      _CDNData = new VerBarConfig(cdnsStream);                    using (var versionsStream = CDNHandler.OpenFileDirect("http://us.patch.battle.net/wow_beta/versions"))                      _VersionsData = new VerBarConfig(versionsStream);                    string buildKey = _VersionsData["BuildConfig"][0];                  using (Stream buildConfigStream = CDNHandler.OpenConfigFileDirect(buildKey))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _VersionsData["CDNConfig"][0];                  using (Stream CDNConfigStream = CDNHandler.OpenConfigFileDirect(cdnKey))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }              else              {                  string buildInfoPath = Path.Combine(wowPath' ".build.info");                    using (Stream buildInfoStream = new FileStream(buildInfoPath' FileMode.Open))                      _BuildInfo = new VerBarConfig(buildInfoStream);                    string buildKey = _BuildInfo["Build Key"][0];                  string buildCfgPath = Path.Combine(wowPath' "Data\\config\\"' buildKey.Substring(0' 2)' buildKey.Substring(2' 2)' buildKey);                  using (Stream buildConfigStream = new FileStream(buildCfgPath' FileMode.Open))                      _BuildConfig = new KeyValueConfig(buildConfigStream);                    string cdnKey = _BuildInfo["CDN Key"][0];                  string cdnCfgPath = Path.Combine(wowPath' "Data\\config\\"' cdnKey.Substring(0' 2)' cdnKey.Substring(2' 2)' cdnKey);                  using (Stream CDNConfigStream = new FileStream(cdnCfgPath' FileMode.Open))                      _CDNConfig = new KeyValueConfig(CDNConfigStream);              }
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,ParseIndex,The following statement contains a magic number: using (var br = new BinaryReader(stream))              {                  stream.Seek(-12' SeekOrigin.End);                  int count = br.ReadInt32();                  stream.Seek(0' SeekOrigin.Begin);                    for (int j = 0; j < count; ++j)                  {                      byte[] key = br.ReadBytes(16);                        if (key.IsZeroed()) // wtf?                          key = br.ReadBytes(16);                        if (key.IsZeroed()) // wtf?                          throw new Exception("key.IsZeroed()");                        IndexEntry entry = new IndexEntry();                      entry.Index = i;                      entry.Size = br.ReadInt32BE();                      entry.Offset = br.ReadInt32BE();                        CDNIndexData.Add(key' entry);                  }              }
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,ParseIndex,The following statement contains a magic number: using (var br = new BinaryReader(stream))              {                  stream.Seek(-12' SeekOrigin.End);                  int count = br.ReadInt32();                  stream.Seek(0' SeekOrigin.Begin);                    for (int j = 0; j < count; ++j)                  {                      byte[] key = br.ReadBytes(16);                        if (key.IsZeroed()) // wtf?                          key = br.ReadBytes(16);                        if (key.IsZeroed()) // wtf?                          throw new Exception("key.IsZeroed()");                        IndexEntry entry = new IndexEntry();                      entry.Index = i;                      entry.Size = br.ReadInt32BE();                      entry.Offset = br.ReadInt32BE();                        CDNIndexData.Add(key' entry);                  }              }
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,ParseIndex,The following statement contains a magic number: using (var br = new BinaryReader(stream))              {                  stream.Seek(-12' SeekOrigin.End);                  int count = br.ReadInt32();                  stream.Seek(0' SeekOrigin.Begin);                    for (int j = 0; j < count; ++j)                  {                      byte[] key = br.ReadBytes(16);                        if (key.IsZeroed()) // wtf?                          key = br.ReadBytes(16);                        if (key.IsZeroed()) // wtf?                          throw new Exception("key.IsZeroed()");                        IndexEntry entry = new IndexEntry();                      entry.Index = i;                      entry.Size = br.ReadInt32BE();                      entry.Offset = br.ReadInt32BE();                        CDNIndexData.Add(key' entry);                  }              }
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,DownloadFile,The following statement contains a magic number: try              {                  var url = CASCConfig.CDNUrl + "/data/" + index.Substring(0' 2) + "/" + index.Substring(2' 2) + "/" + index + ".index";                    using (WebClient webClient = new WebClient())                  using (Stream s = webClient.OpenRead(url))                  using (MemoryStream ms = new MemoryStream())                  {                      s.CopyTo(ms);                        ParseIndex(ms' i);                  }              }              catch              {                  throw new Exception("DownloadFile failed!");              }
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,DownloadFile,The following statement contains a magic number: try              {                  var url = CASCConfig.CDNUrl + "/data/" + index.Substring(0' 2) + "/" + index.Substring(2' 2) + "/" + index + ".index";                    using (WebClient webClient = new WebClient())                  using (Stream s = webClient.OpenRead(url))                  using (MemoryStream ms = new MemoryStream())                  {                      s.CopyTo(ms);                        ParseIndex(ms' i);                  }              }              catch              {                  throw new Exception("DownloadFile failed!");              }
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,DownloadFile,The following statement contains a magic number: try              {                  var url = CASCConfig.CDNUrl + "/data/" + index.Substring(0' 2) + "/" + index.Substring(2' 2) + "/" + index + ".index";                    using (WebClient webClient = new WebClient())                  using (Stream s = webClient.OpenRead(url))                  using (MemoryStream ms = new MemoryStream())                  {                      s.CopyTo(ms);                        ParseIndex(ms' i);                  }              }              catch              {                  throw new Exception("DownloadFile failed!");              }
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenDataFile,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/data/" + index.Substring(0' 2) + "/" + index.Substring(2' 2) + "/" + index;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenDataFile,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/data/" + index.Substring(0' 2) + "/" + index.Substring(2' 2) + "/" + index;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenDataFile,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/data/" + index.Substring(0' 2) + "/" + index.Substring(2' 2) + "/" + index;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenDataFileDirect,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/data/" + file.Substring(0' 2) + "/" + file.Substring(2' 2) + "/" + file;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenDataFileDirect,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/data/" + file.Substring(0' 2) + "/" + file.Substring(2' 2) + "/" + file;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenDataFileDirect,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/data/" + file.Substring(0' 2) + "/" + file.Substring(2' 2) + "/" + file;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenConfigFileDirect,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/config/" + key.Substring(0' 2) + "/" + key.Substring(2' 2) + "/" + key;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenConfigFileDirect,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/config/" + key.Substring(0' 2) + "/" + key.Substring(2' 2) + "/" + key;
Magic Number,CASCExplorer,CDNHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CDNHandler.cs,OpenConfigFileDirect,The following statement contains a magic number: var url = CASCConfig.CDNUrl + "/config/" + key.Substring(0' 2) + "/" + key.Substring(2' 2) + "/" + key;
Magic Number,CASCExplorer,Extensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ReadInt32BE,The following statement contains a magic number: var bytes = reader.ReadBytes(4);
Magic Number,CASCExplorer,Extensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ReadInt32BE,The following statement contains a magic number: return bytes[3] | (bytes[2] << 8) | (bytes[1] << 16) | (bytes[0] << 24);
Magic Number,CASCExplorer,Extensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ReadInt32BE,The following statement contains a magic number: return bytes[3] | (bytes[2] << 8) | (bytes[1] << 16) | (bytes[0] << 24);
Magic Number,CASCExplorer,Extensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ReadInt32BE,The following statement contains a magic number: return bytes[3] | (bytes[2] << 8) | (bytes[1] << 16) | (bytes[0] << 24);
Magic Number,CASCExplorer,Extensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ReadInt32BE,The following statement contains a magic number: return bytes[3] | (bytes[2] << 8) | (bytes[1] << 16) | (bytes[0] << 24);
Magic Number,CASCExplorer,Extensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ReadInt32BE,The following statement contains a magic number: return bytes[3] | (bytes[2] << 8) | (bytes[1] << 16) | (bytes[0] << 24);
Magic Number,CASCExplorer,CStringExtensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ToByteArray,The following statement contains a magic number: var res = new byte[str.Length / 2];
Magic Number,CASCExplorer,CStringExtensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i)              {                  string temp = String.Concat(str[i * 2]' str[i * 2 + 1]);                  res[i] = Convert.ToByte(temp' 16);              }
Magic Number,CASCExplorer,CStringExtensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i)              {                  string temp = String.Concat(str[i * 2]' str[i * 2 + 1]);                  res[i] = Convert.ToByte(temp' 16);              }
Magic Number,CASCExplorer,CStringExtensions,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Extensions.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i)              {                  string temp = String.Concat(str[i * 2]' str[i * 2 + 1]);                  res[i] = Convert.ToByte(temp' 16);              }
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,ExtractFile,The following statement contains a magic number: backgroundWorker1.ReportProgress((int)((float)++NumExtracted / (float)NumFiles * 100));
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Location = new System.Drawing.Point(12' 39);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Location = new System.Drawing.Point(12' 39);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Size = new System.Drawing.Size(368' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Size = new System.Drawing.Size(368' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(337' 20);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(337' 20);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(355' 10);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(355' 10);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(25' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(25' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 2;
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(123' 68);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(123' 68);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(75' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(75' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button2.TabIndex = 3;
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button3.Location = new System.Drawing.Point(204' 68);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button3.Location = new System.Drawing.Point(204' 68);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button3.Size = new System.Drawing.Size(75' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button3.Size = new System.Drawing.Size(75' 23);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.button3.TabIndex = 4;
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Location = new System.Drawing.Point(12' 69);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Location = new System.Drawing.Point(12' 69);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Size = new System.Drawing.Size(105' 21);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Size = new System.Drawing.Size(105' 21);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.TabIndex = 5;
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(393' 102);
Magic Number,CASCExplorer,ExtractProgress,C:\repos\tomrus88_CASCExplorer\CASCExplorer\ExtractProgress.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(393' 102);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,listView1_RetrieveVirtualItem,The following statement contains a magic number: item.ImageIndex = entry is CASCFolder ? 0 : 2;
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(775' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(775' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 212;
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.folderTree.ItemHeight = 16;
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.folderTree.Size = new System.Drawing.Size(212' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.folderTree.Size = new System.Drawing.Size(212' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.iconsList.ImageSize = new System.Drawing.Size(15' 15);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.iconsList.ImageSize = new System.Drawing.Size(15' 15);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileList.Size = new System.Drawing.Size(559' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileList.Size = new System.Drawing.Size(559' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.columnHeader1.Width = 250;
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size(119' 26);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size(119' 26);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem1.Size = new System.Drawing.Size(118' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem1.Size = new System.Drawing.Size(118' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripContainer1.ContentPanel.Size = new System.Drawing.Size(775' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripContainer1.ContentPanel.Size = new System.Drawing.Size(775' 491);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripContainer1.Size = new System.Drawing.Size(775' 537);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripContainer1.Size = new System.Drawing.Size(775' 537);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripContainer1.TabIndex = 3;
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(775' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(775' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusLabel.Size = new System.Drawing.Size(118' 17);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusLabel.Size = new System.Drawing.Size(118' 17);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusProgress.Size = new System.Drawing.Size(100' 16);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusProgress.Size = new System.Drawing.Size(100' 16);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(775' 24);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(775' 24);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size(92' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size(92' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size(116' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size(116' 22);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.columnHeader3.Width = 100;
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(775' 537);
Magic Number,CASCExplorer,MainForm,C:\repos\tomrus88_CASCExplorer\CASCExplorer\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(775' 537);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,rot,The following statement contains a magic number: return (x << k) | (x >> (32 - k));
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Mix,The following statement contains a magic number: a ^= rot(c' 4);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Mix,The following statement contains a magic number: b ^= rot(a' 6);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Mix,The following statement contains a magic number: c ^= rot(b' 8);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Mix,The following statement contains a magic number: a ^= rot(c' 16);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Mix,The following statement contains a magic number: b ^= rot(a' 19);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Mix,The following statement contains a magic number: c ^= rot(b' 4);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Final,The following statement contains a magic number: c -= rot(b' 14);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Final,The following statement contains a magic number: a -= rot(c' 11);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Final,The following statement contains a magic number: b -= rot(a' 25);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Final,The following statement contains a magic number: c -= rot(b' 16);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Final,The following statement contains a magic number: a -= rot(c' 4);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Final,The following statement contains a magic number: b -= rot(a' 14);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,Final,The following statement contains a magic number: c -= rot(b' 24);
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following statement contains a magic number: fixed (byte* bb = array)              {                  uint* u = (uint*)bb;                    if ((*u & 0x3) == 0)                  {                      uint* k = u;                        while (length > 12)                      {                          a += k[0];                          b += k[1];                          c += k[2];                          Mix();                          length -= 12;                          k += 3;                      }                        switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }                  }                  else if ((*u & 0x1) == 0)                  {                      ushort* k = (ushort*)u;                        while (length > 12)                      {                          a += k[0] + (((uint)k[1]) << 16);                          b += k[2] + (((uint)k[3]) << 16);                          c += k[4] + (((uint)k[5]) << 16);                          Mix();                          length -= 12;                          k += 6;                      }                        byte* k8 = (byte*)k;                        switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                  else                  {                      byte* k = (byte*)u;                        while (length > 12)                      {                          a += k[0];                          a += ((uint)k[1]) << 8;                          a += ((uint)k[2]) << 16;                          a += ((uint)k[3]) << 24;                          b += k[4];                          b += ((uint)k[5]) << 8;                          b += ((uint)k[6]) << 16;                          b += ((uint)k[7]) << 24;                          c += k[8];                          c += ((uint)k[9]) << 8;                          c += ((uint)k[10]) << 16;                          c += ((uint)k[11]) << 24;                          Mix();                          length -= 12;                          k += 12;                      }                        switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }                  }                    Final();                  hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (!OnlineMode)              {                  var idxFiles = GetIdxFiles(Properties.Settings.Default.WowPath);                    if (idxFiles.Count == 0)                      throw new FileNotFoundException("idx files missing!");                    worker.ReportProgress(0);                    int idxIndex = 0;                    foreach (var idx in idxFiles)                  {                      using (var fs = new FileStream(idx' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      using (var br = new BinaryReader(fs))                      {                          int h2Len = br.ReadInt32();                          int h2Check = br.ReadInt32();                          byte[] h2 = br.ReadBytes(h2Len);                            long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;                          fs.Position = padPos;                            int dataLen = br.ReadInt32();                          int dataCheck = br.ReadInt32();                            int numBlocks = dataLen / 18;                            for (int i = 0; i < numBlocks; i++)                          {                              IndexEntry info = new IndexEntry();                              byte[] key = br.ReadBytes(9);                              int indexHigh = br.ReadByte();                              int indexLow = br.ReadInt32BE();                                info.Index = (int)((byte)(indexHigh << 2) | ((indexLow & 0xC0000000) >> 30));                              info.Offset = (indexLow & 0x3FFFFFFF);                              info.Size = br.ReadInt32();                                // duplicate keys wtf...                              //IndexData[key] = info; // use last key                              if (!LocalIndexData.ContainsKey(key)) // use first key                                  LocalIndexData.Add(key' info);                          }                            padPos = (dataLen + 0x0FFF) & 0xFFFFF000;                          fs.Position = padPos;                            fs.Position += numBlocks * 18;                          //for (int i = 0; i < numBlocks; i++)                          //{                          //    var bytes = br.ReadBytes(18); // unknown data                          //}                            if (fs.Position != fs.Position)                              throw new Exception("idx file under read");                      }                        worker.ReportProgress((int)((float)++idxIndex / (float)idxFiles.Count * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} indexes"' LocalIndexData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (!OnlineMode)              {                  var idxFiles = GetIdxFiles(Properties.Settings.Default.WowPath);                    if (idxFiles.Count == 0)                      throw new FileNotFoundException("idx files missing!");                    worker.ReportProgress(0);                    int idxIndex = 0;                    foreach (var idx in idxFiles)                  {                      using (var fs = new FileStream(idx' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      using (var br = new BinaryReader(fs))                      {                          int h2Len = br.ReadInt32();                          int h2Check = br.ReadInt32();                          byte[] h2 = br.ReadBytes(h2Len);                            long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;                          fs.Position = padPos;                            int dataLen = br.ReadInt32();                          int dataCheck = br.ReadInt32();                            int numBlocks = dataLen / 18;                            for (int i = 0; i < numBlocks; i++)                          {                              IndexEntry info = new IndexEntry();                              byte[] key = br.ReadBytes(9);                              int indexHigh = br.ReadByte();                              int indexLow = br.ReadInt32BE();                                info.Index = (int)((byte)(indexHigh << 2) | ((indexLow & 0xC0000000) >> 30));                              info.Offset = (indexLow & 0x3FFFFFFF);                              info.Size = br.ReadInt32();                                // duplicate keys wtf...                              //IndexData[key] = info; // use last key                              if (!LocalIndexData.ContainsKey(key)) // use first key                                  LocalIndexData.Add(key' info);                          }                            padPos = (dataLen + 0x0FFF) & 0xFFFFF000;                          fs.Position = padPos;                            fs.Position += numBlocks * 18;                          //for (int i = 0; i < numBlocks; i++)                          //{                          //    var bytes = br.ReadBytes(18); // unknown data                          //}                            if (fs.Position != fs.Position)                              throw new Exception("idx file under read");                      }                        worker.ReportProgress((int)((float)++idxIndex / (float)idxFiles.Count * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} indexes"' LocalIndexData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (!OnlineMode)              {                  var idxFiles = GetIdxFiles(Properties.Settings.Default.WowPath);                    if (idxFiles.Count == 0)                      throw new FileNotFoundException("idx files missing!");                    worker.ReportProgress(0);                    int idxIndex = 0;                    foreach (var idx in idxFiles)                  {                      using (var fs = new FileStream(idx' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      using (var br = new BinaryReader(fs))                      {                          int h2Len = br.ReadInt32();                          int h2Check = br.ReadInt32();                          byte[] h2 = br.ReadBytes(h2Len);                            long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;                          fs.Position = padPos;                            int dataLen = br.ReadInt32();                          int dataCheck = br.ReadInt32();                            int numBlocks = dataLen / 18;                            for (int i = 0; i < numBlocks; i++)                          {                              IndexEntry info = new IndexEntry();                              byte[] key = br.ReadBytes(9);                              int indexHigh = br.ReadByte();                              int indexLow = br.ReadInt32BE();                                info.Index = (int)((byte)(indexHigh << 2) | ((indexLow & 0xC0000000) >> 30));                              info.Offset = (indexLow & 0x3FFFFFFF);                              info.Size = br.ReadInt32();                                // duplicate keys wtf...                              //IndexData[key] = info; // use last key                              if (!LocalIndexData.ContainsKey(key)) // use first key                                  LocalIndexData.Add(key' info);                          }                            padPos = (dataLen + 0x0FFF) & 0xFFFFF000;                          fs.Position = padPos;                            fs.Position += numBlocks * 18;                          //for (int i = 0; i < numBlocks; i++)                          //{                          //    var bytes = br.ReadBytes(18); // unknown data                          //}                            if (fs.Position != fs.Position)                              throw new Exception("idx file under read");                      }                        worker.ReportProgress((int)((float)++idxIndex / (float)idxFiles.Count * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} indexes"' LocalIndexData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (!OnlineMode)              {                  var idxFiles = GetIdxFiles(Properties.Settings.Default.WowPath);                    if (idxFiles.Count == 0)                      throw new FileNotFoundException("idx files missing!");                    worker.ReportProgress(0);                    int idxIndex = 0;                    foreach (var idx in idxFiles)                  {                      using (var fs = new FileStream(idx' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      using (var br = new BinaryReader(fs))                      {                          int h2Len = br.ReadInt32();                          int h2Check = br.ReadInt32();                          byte[] h2 = br.ReadBytes(h2Len);                            long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;                          fs.Position = padPos;                            int dataLen = br.ReadInt32();                          int dataCheck = br.ReadInt32();                            int numBlocks = dataLen / 18;                            for (int i = 0; i < numBlocks; i++)                          {                              IndexEntry info = new IndexEntry();                              byte[] key = br.ReadBytes(9);                              int indexHigh = br.ReadByte();                              int indexLow = br.ReadInt32BE();                                info.Index = (int)((byte)(indexHigh << 2) | ((indexLow & 0xC0000000) >> 30));                              info.Offset = (indexLow & 0x3FFFFFFF);                              info.Size = br.ReadInt32();                                // duplicate keys wtf...                              //IndexData[key] = info; // use last key                              if (!LocalIndexData.ContainsKey(key)) // use first key                                  LocalIndexData.Add(key' info);                          }                            padPos = (dataLen + 0x0FFF) & 0xFFFFF000;                          fs.Position = padPos;                            fs.Position += numBlocks * 18;                          //for (int i = 0; i < numBlocks; i++)                          //{                          //    var bytes = br.ReadBytes(18); // unknown data                          //}                            if (fs.Position != fs.Position)                              throw new Exception("idx file under read");                      }                        worker.ReportProgress((int)((float)++idxIndex / (float)idxFiles.Count * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} indexes"' LocalIndexData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (!OnlineMode)              {                  var idxFiles = GetIdxFiles(Properties.Settings.Default.WowPath);                    if (idxFiles.Count == 0)                      throw new FileNotFoundException("idx files missing!");                    worker.ReportProgress(0);                    int idxIndex = 0;                    foreach (var idx in idxFiles)                  {                      using (var fs = new FileStream(idx' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      using (var br = new BinaryReader(fs))                      {                          int h2Len = br.ReadInt32();                          int h2Check = br.ReadInt32();                          byte[] h2 = br.ReadBytes(h2Len);                            long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;                          fs.Position = padPos;                            int dataLen = br.ReadInt32();                          int dataCheck = br.ReadInt32();                            int numBlocks = dataLen / 18;                            for (int i = 0; i < numBlocks; i++)                          {                              IndexEntry info = new IndexEntry();                              byte[] key = br.ReadBytes(9);                              int indexHigh = br.ReadByte();                              int indexLow = br.ReadInt32BE();                                info.Index = (int)((byte)(indexHigh << 2) | ((indexLow & 0xC0000000) >> 30));                              info.Offset = (indexLow & 0x3FFFFFFF);                              info.Size = br.ReadInt32();                                // duplicate keys wtf...                              //IndexData[key] = info; // use last key                              if (!LocalIndexData.ContainsKey(key)) // use first key                                  LocalIndexData.Add(key' info);                          }                            padPos = (dataLen + 0x0FFF) & 0xFFFFF000;                          fs.Position = padPos;                            fs.Position += numBlocks * 18;                          //for (int i = 0; i < numBlocks; i++)                          //{                          //    var bytes = br.ReadBytes(18); // unknown data                          //}                            if (fs.Position != fs.Position)                              throw new Exception("idx file under read");                      }                        worker.ReportProgress((int)((float)++idxIndex / (float)idxFiles.Count * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} indexes"' LocalIndexData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (!OnlineMode)              {                  var idxFiles = GetIdxFiles(Properties.Settings.Default.WowPath);                    if (idxFiles.Count == 0)                      throw new FileNotFoundException("idx files missing!");                    worker.ReportProgress(0);                    int idxIndex = 0;                    foreach (var idx in idxFiles)                  {                      using (var fs = new FileStream(idx' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      using (var br = new BinaryReader(fs))                      {                          int h2Len = br.ReadInt32();                          int h2Check = br.ReadInt32();                          byte[] h2 = br.ReadBytes(h2Len);                            long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;                          fs.Position = padPos;                            int dataLen = br.ReadInt32();                          int dataCheck = br.ReadInt32();                            int numBlocks = dataLen / 18;                            for (int i = 0; i < numBlocks; i++)                          {                              IndexEntry info = new IndexEntry();                              byte[] key = br.ReadBytes(9);                              int indexHigh = br.ReadByte();                              int indexLow = br.ReadInt32BE();                                info.Index = (int)((byte)(indexHigh << 2) | ((indexLow & 0xC0000000) >> 30));                              info.Offset = (indexLow & 0x3FFFFFFF);                              info.Size = br.ReadInt32();                                // duplicate keys wtf...                              //IndexData[key] = info; // use last key                              if (!LocalIndexData.ContainsKey(key)) // use first key                                  LocalIndexData.Add(key' info);                          }                            padPos = (dataLen + 0x0FFF) & 0xFFFFF000;                          fs.Position = padPos;                            fs.Position += numBlocks * 18;                          //for (int i = 0; i < numBlocks; i++)                          //{                          //    var bytes = br.ReadBytes(18); // unknown data                          //}                            if (fs.Position != fs.Position)                              throw new Exception("idx file under read");                      }                        worker.ReportProgress((int)((float)++idxIndex / (float)idxFiles.Count * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} indexes"' LocalIndexData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (!OnlineMode)              {                  var idxFiles = GetIdxFiles(Properties.Settings.Default.WowPath);                    if (idxFiles.Count == 0)                      throw new FileNotFoundException("idx files missing!");                    worker.ReportProgress(0);                    int idxIndex = 0;                    foreach (var idx in idxFiles)                  {                      using (var fs = new FileStream(idx' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      using (var br = new BinaryReader(fs))                      {                          int h2Len = br.ReadInt32();                          int h2Check = br.ReadInt32();                          byte[] h2 = br.ReadBytes(h2Len);                            long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;                          fs.Position = padPos;                            int dataLen = br.ReadInt32();                          int dataCheck = br.ReadInt32();                            int numBlocks = dataLen / 18;                            for (int i = 0; i < numBlocks; i++)                          {                              IndexEntry info = new IndexEntry();                              byte[] key = br.ReadBytes(9);                              int indexHigh = br.ReadByte();                              int indexLow = br.ReadInt32BE();                                info.Index = (int)((byte)(indexHigh << 2) | ((indexLow & 0xC0000000) >> 30));                              info.Offset = (indexLow & 0x3FFFFFFF);                              info.Size = br.ReadInt32();                                // duplicate keys wtf...                              //IndexData[key] = info; // use last key                              if (!LocalIndexData.ContainsKey(key)) // use first key                                  LocalIndexData.Add(key' info);                          }                            padPos = (dataLen + 0x0FFF) & 0xFFFFF000;                          fs.Position = padPos;                            fs.Position += numBlocks * 18;                          //for (int i = 0; i < numBlocks; i++)                          //{                          //    var bytes = br.ReadBytes(18); // unknown data                          //}                            if (fs.Position != fs.Position)                              throw new Exception("idx file under read");                      }                        worker.ReportProgress((int)((float)++idxIndex / (float)idxFiles.Count * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} indexes"' LocalIndexData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: using (var fs = OpenEncodingFile())              using (var br = new BinaryReader(fs))              {                  br.ReadBytes(2); // EN                  byte b1 = br.ReadByte();                  byte b2 = br.ReadByte();                  byte b3 = br.ReadByte();                  ushort s1 = br.ReadUInt16();                  ushort s2 = br.ReadUInt16();                  int numEntries = br.ReadInt32BE();                  int i1 = br.ReadInt32BE();                  byte b4 = br.ReadByte();                  int entriesOfs = br.ReadInt32BE();                    fs.Position += entriesOfs; // skip strings                    fs.Position += numEntries * 32;                  //for (int i = 0; i < numEntries; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                    for (int i = 0; i < numEntries; ++i)                  {                      ushort keysCount;                        while ((keysCount = br.ReadUInt16()) != 0)                      {                          int fileSize = br.ReadInt32BE();                          byte[] md5 = br.ReadBytes(16);                            var entry = new EncodingEntry();                          entry.Size = fileSize;                            for (int ki = 0; ki < keysCount; ++ki)                          {                              byte[] key = br.ReadBytes(16);                                entry.Keys.Add(key);                          }                            //Encodings[md5] = entry;                          EncodingData.Add(md5' entry);                      }                        //br.ReadBytes(28);                      while (br.PeekChar() == 0)                          fs.Position++;                        worker.ReportProgress((int)((float)fs.Position / (float)fs.Length * 100));                  }                  //var pos = br.BaseStream.Position;                  //for (int i = 0; i < i1; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                  Logger.WriteLine("CASCHandler: loaded {0} encoding data"' EncodingData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: using (var fs = OpenEncodingFile())              using (var br = new BinaryReader(fs))              {                  br.ReadBytes(2); // EN                  byte b1 = br.ReadByte();                  byte b2 = br.ReadByte();                  byte b3 = br.ReadByte();                  ushort s1 = br.ReadUInt16();                  ushort s2 = br.ReadUInt16();                  int numEntries = br.ReadInt32BE();                  int i1 = br.ReadInt32BE();                  byte b4 = br.ReadByte();                  int entriesOfs = br.ReadInt32BE();                    fs.Position += entriesOfs; // skip strings                    fs.Position += numEntries * 32;                  //for (int i = 0; i < numEntries; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                    for (int i = 0; i < numEntries; ++i)                  {                      ushort keysCount;                        while ((keysCount = br.ReadUInt16()) != 0)                      {                          int fileSize = br.ReadInt32BE();                          byte[] md5 = br.ReadBytes(16);                            var entry = new EncodingEntry();                          entry.Size = fileSize;                            for (int ki = 0; ki < keysCount; ++ki)                          {                              byte[] key = br.ReadBytes(16);                                entry.Keys.Add(key);                          }                            //Encodings[md5] = entry;                          EncodingData.Add(md5' entry);                      }                        //br.ReadBytes(28);                      while (br.PeekChar() == 0)                          fs.Position++;                        worker.ReportProgress((int)((float)fs.Position / (float)fs.Length * 100));                  }                  //var pos = br.BaseStream.Position;                  //for (int i = 0; i < i1; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                  Logger.WriteLine("CASCHandler: loaded {0} encoding data"' EncodingData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: using (var fs = OpenEncodingFile())              using (var br = new BinaryReader(fs))              {                  br.ReadBytes(2); // EN                  byte b1 = br.ReadByte();                  byte b2 = br.ReadByte();                  byte b3 = br.ReadByte();                  ushort s1 = br.ReadUInt16();                  ushort s2 = br.ReadUInt16();                  int numEntries = br.ReadInt32BE();                  int i1 = br.ReadInt32BE();                  byte b4 = br.ReadByte();                  int entriesOfs = br.ReadInt32BE();                    fs.Position += entriesOfs; // skip strings                    fs.Position += numEntries * 32;                  //for (int i = 0; i < numEntries; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                    for (int i = 0; i < numEntries; ++i)                  {                      ushort keysCount;                        while ((keysCount = br.ReadUInt16()) != 0)                      {                          int fileSize = br.ReadInt32BE();                          byte[] md5 = br.ReadBytes(16);                            var entry = new EncodingEntry();                          entry.Size = fileSize;                            for (int ki = 0; ki < keysCount; ++ki)                          {                              byte[] key = br.ReadBytes(16);                                entry.Keys.Add(key);                          }                            //Encodings[md5] = entry;                          EncodingData.Add(md5' entry);                      }                        //br.ReadBytes(28);                      while (br.PeekChar() == 0)                          fs.Position++;                        worker.ReportProgress((int)((float)fs.Position / (float)fs.Length * 100));                  }                  //var pos = br.BaseStream.Position;                  //for (int i = 0; i < i1; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                  Logger.WriteLine("CASCHandler: loaded {0} encoding data"' EncodingData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: using (var fs = OpenEncodingFile())              using (var br = new BinaryReader(fs))              {                  br.ReadBytes(2); // EN                  byte b1 = br.ReadByte();                  byte b2 = br.ReadByte();                  byte b3 = br.ReadByte();                  ushort s1 = br.ReadUInt16();                  ushort s2 = br.ReadUInt16();                  int numEntries = br.ReadInt32BE();                  int i1 = br.ReadInt32BE();                  byte b4 = br.ReadByte();                  int entriesOfs = br.ReadInt32BE();                    fs.Position += entriesOfs; // skip strings                    fs.Position += numEntries * 32;                  //for (int i = 0; i < numEntries; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                    for (int i = 0; i < numEntries; ++i)                  {                      ushort keysCount;                        while ((keysCount = br.ReadUInt16()) != 0)                      {                          int fileSize = br.ReadInt32BE();                          byte[] md5 = br.ReadBytes(16);                            var entry = new EncodingEntry();                          entry.Size = fileSize;                            for (int ki = 0; ki < keysCount; ++ki)                          {                              byte[] key = br.ReadBytes(16);                                entry.Keys.Add(key);                          }                            //Encodings[md5] = entry;                          EncodingData.Add(md5' entry);                      }                        //br.ReadBytes(28);                      while (br.PeekChar() == 0)                          fs.Position++;                        worker.ReportProgress((int)((float)fs.Position / (float)fs.Length * 100));                  }                  //var pos = br.BaseStream.Position;                  //for (int i = 0; i < i1; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                  Logger.WriteLine("CASCHandler: loaded {0} encoding data"' EncodingData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: using (var fs = OpenEncodingFile())              using (var br = new BinaryReader(fs))              {                  br.ReadBytes(2); // EN                  byte b1 = br.ReadByte();                  byte b2 = br.ReadByte();                  byte b3 = br.ReadByte();                  ushort s1 = br.ReadUInt16();                  ushort s2 = br.ReadUInt16();                  int numEntries = br.ReadInt32BE();                  int i1 = br.ReadInt32BE();                  byte b4 = br.ReadByte();                  int entriesOfs = br.ReadInt32BE();                    fs.Position += entriesOfs; // skip strings                    fs.Position += numEntries * 32;                  //for (int i = 0; i < numEntries; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                    for (int i = 0; i < numEntries; ++i)                  {                      ushort keysCount;                        while ((keysCount = br.ReadUInt16()) != 0)                      {                          int fileSize = br.ReadInt32BE();                          byte[] md5 = br.ReadBytes(16);                            var entry = new EncodingEntry();                          entry.Size = fileSize;                            for (int ki = 0; ki < keysCount; ++ki)                          {                              byte[] key = br.ReadBytes(16);                                entry.Keys.Add(key);                          }                            //Encodings[md5] = entry;                          EncodingData.Add(md5' entry);                      }                        //br.ReadBytes(28);                      while (br.PeekChar() == 0)                          fs.Position++;                        worker.ReportProgress((int)((float)fs.Position / (float)fs.Length * 100));                  }                  //var pos = br.BaseStream.Position;                  //for (int i = 0; i < i1; ++i)                  //{                  //    br.ReadBytes(16);                  //    br.ReadBytes(16);                  //}                  Logger.WriteLine("CASCHandler: loaded {0} encoding data"' EncodingData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: using (var fs = OpenRootFile())              using (var br = new BinaryReader(fs))              {                  while (fs.Position < fs.Length)                  {                      int count = br.ReadInt32();                        RootBlock block = new RootBlock();                      block.Unk1 = br.ReadUInt32();                      block.Flags = (LocaleFlags)br.ReadUInt32();                        if (block.Flags == LocaleFlags.None)                          throw new Exception("block.Flags == LocaleFlags.None");                        RootEntry[] entries = new RootEntry[count];                        for (var i = 0; i < count; ++i)                      {                          entries[i] = new RootEntry();                          entries[i].Block = block;                          entries[i].Unk1 = br.ReadInt32();                      }                        for (var i = 0; i < count; ++i)                      {                          entries[i].MD5 = br.ReadBytes(16);                            ulong hash = br.ReadUInt64();                          entries[i].Hash = hash;                            // don't load other locales                          //if (block.Flags != LocaleFlags.All && (block.Flags & LocaleFlags.enUS) == 0)                          //    continue;                            if (!RootData.ContainsKey(hash))                          {                              RootData[hash] = new List<RootEntry>();                              RootData[hash].Add(entries[i]);                          }                          else                              RootData[hash].Add(entries[i]);                      }                        worker.ReportProgress((int)((float)fs.Position / (float)fs.Length * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} root data"' RootData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: using (var fs = OpenRootFile())              using (var br = new BinaryReader(fs))              {                  while (fs.Position < fs.Length)                  {                      int count = br.ReadInt32();                        RootBlock block = new RootBlock();                      block.Unk1 = br.ReadUInt32();                      block.Flags = (LocaleFlags)br.ReadUInt32();                        if (block.Flags == LocaleFlags.None)                          throw new Exception("block.Flags == LocaleFlags.None");                        RootEntry[] entries = new RootEntry[count];                        for (var i = 0; i < count; ++i)                      {                          entries[i] = new RootEntry();                          entries[i].Block = block;                          entries[i].Unk1 = br.ReadInt32();                      }                        for (var i = 0; i < count; ++i)                      {                          entries[i].MD5 = br.ReadBytes(16);                            ulong hash = br.ReadUInt64();                          entries[i].Hash = hash;                            // don't load other locales                          //if (block.Flags != LocaleFlags.All && (block.Flags & LocaleFlags.enUS) == 0)                          //    continue;                            if (!RootData.ContainsKey(hash))                          {                              RootData[hash] = new List<RootEntry>();                              RootData[hash].Add(entries[i]);                          }                          else                              RootData[hash].Add(entries[i]);                      }                        worker.ReportProgress((int)((float)fs.Position / (float)fs.Length * 100));                  }                    Logger.WriteLine("CASCHandler: loaded {0} root data"' RootData.Count);              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (File.Exists(listFile))              {                  FolderNames[Hasher.ComputeHash("root")] = "root";                    using (StreamReader sr = new StreamReader(listFile))                  {                      string file;                      int filesCount = 0;                        CASCFolder folder = root;                        while ((file = sr.ReadLine()) != null)                      {                          ulong fileHash = Hasher.ComputeHash(file);                            // skip invalid names                          if (!RootData.ContainsKey(fileHash))                          {                              Logger.WriteLine("Invalid file name: {0}"' file);                              continue;                          }                            filesCount++;                            string[] parts = file.Split('\\');                            for (int i = 0; i < parts.Length; ++i)                          {                              bool isFile = (i == parts.Length - 1);                                ulong hash = isFile ? fileHash : Hasher.ComputeHash(parts[i]);                                ICASCEntry entry = folder.GetEntry(hash);                                if (entry == null)                              {                                  if (isFile)                                  {                                      entry = new CASCFile(hash);                                      FileNames[hash] = file;                                  }                                  else                                  {                                      entry = new CASCFolder(hash);                                      FolderNames[hash] = parts[i];                                  }                                    folder.SubEntries[hash] = entry;                                    if (isFile)                                  {                                      folder = root;                                      break;                                  }                              }                                folder = entry as CASCFolder;                          }                            if ((filesCount % 1000) == 0)                              worker.ReportProgress((int)((float)sr.BaseStream.Position / (float)sr.BaseStream.Length * 100));                      }                        Logger.WriteLine("CASCHandler: loaded {0} file names"' FileNames.Count);                  }              }              else              {                  throw new FileNotFoundException("list file missing!");              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,CASCHandler,The following statement contains a magic number: if (File.Exists(listFile))              {                  FolderNames[Hasher.ComputeHash("root")] = "root";                    using (StreamReader sr = new StreamReader(listFile))                  {                      string file;                      int filesCount = 0;                        CASCFolder folder = root;                        while ((file = sr.ReadLine()) != null)                      {                          ulong fileHash = Hasher.ComputeHash(file);                            // skip invalid names                          if (!RootData.ContainsKey(fileHash))                          {                              Logger.WriteLine("Invalid file name: {0}"' file);                              continue;                          }                            filesCount++;                            string[] parts = file.Split('\\');                            for (int i = 0; i < parts.Length; ++i)                          {                              bool isFile = (i == parts.Length - 1);                                ulong hash = isFile ? fileHash : Hasher.ComputeHash(parts[i]);                                ICASCEntry entry = folder.GetEntry(hash);                                if (entry == null)                              {                                  if (isFile)                                  {                                      entry = new CASCFile(hash);                                      FileNames[hash] = file;                                  }                                  else                                  {                                      entry = new CASCFolder(hash);                                      FolderNames[hash] = parts[i];                                  }                                    folder.SubEntries[hash] = entry;                                    if (isFile)                                  {                                      folder = root;                                      break;                                  }                              }                                folder = entry as CASCFolder;                          }                            if ((filesCount % 1000) == 0)                              worker.ReportProgress((int)((float)sr.BaseStream.Position / (float)sr.BaseStream.Length * 100));                      }                        Logger.WriteLine("CASCHandler: loaded {0} file names"' FileNames.Count);                  }              }              else              {                  throw new FileNotFoundException("list file missing!");              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,OpenFile,The following statement contains a magic number: try              {                  if (OnlineMode)                      throw new Exception();                    var idxInfo = GetLocalIndexInfo(key);                    if (idxInfo == null)                      throw new Exception("local index missing");                    var stream = GetDataStream(idxInfo.Index);                    stream.Position = idxInfo.Offset;                    stream.Position += 30;                  //byte[] unkHash = reader.ReadBytes(16);                  //int __size = reader.ReadInt32();                  //byte[] unkData1 = reader.ReadBytes(2);                  //byte[] unkData2 = reader.ReadBytes(8);                    using (BLTEHandler blte = new BLTEHandler(stream' idxInfo.Size - 30))                      return blte.OpenFile();              }              catch              {                  if (key.EqualsTo(CASCConfig.EncodingKey))                  {                      using (Stream s = CDNHandler.OpenDataFileDirect(key' out int len))                      using (BLTEHandler blte = new BLTEHandler(s' len))                          return blte.OpenFile();                  }                  else                  {                      var idxInfo = CDNHandler.GetCDNIndexInfo(key);                        if (idxInfo == null)                          throw new Exception("CDN index missing");                        using (Stream s = CDNHandler.OpenDataFile(key))                      using (BLTEHandler blte = new BLTEHandler(s' idxInfo.Size))                          return blte.OpenFile();                  }              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,OpenFile,The following statement contains a magic number: try              {                  if (OnlineMode)                      throw new Exception();                    var idxInfo = GetLocalIndexInfo(key);                    if (idxInfo == null)                      throw new Exception("local index missing");                    var stream = GetDataStream(idxInfo.Index);                    stream.Position = idxInfo.Offset;                    stream.Position += 30;                  //byte[] unkHash = reader.ReadBytes(16);                  //int __size = reader.ReadInt32();                  //byte[] unkData1 = reader.ReadBytes(2);                  //byte[] unkData2 = reader.ReadBytes(8);                    using (BLTEHandler blte = new BLTEHandler(stream' idxInfo.Size - 30))                      return blte.OpenFile();              }              catch              {                  if (key.EqualsTo(CASCConfig.EncodingKey))                  {                      using (Stream s = CDNHandler.OpenDataFileDirect(key' out int len))                      using (BLTEHandler blte = new BLTEHandler(s' len))                          return blte.OpenFile();                  }                  else                  {                      var idxInfo = CDNHandler.GetCDNIndexInfo(key);                        if (idxInfo == null)                          throw new Exception("CDN index missing");                        using (Stream s = CDNHandler.OpenDataFile(key))                      using (BLTEHandler blte = new BLTEHandler(s' idxInfo.Size))                          return blte.OpenFile();                  }              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,ExtractFile,The following statement contains a magic number: try              {                  if (OnlineMode)                      throw new Exception();                    var idxInfo = GetLocalIndexInfo(key);                    if (idxInfo == null)                      throw new Exception("local index missing");                    var stream = GetDataStream(idxInfo.Index);                    stream.Position = idxInfo.Offset;                    stream.Position += 30;                  //byte[] unkHash = reader.ReadBytes(16);                  //int __size = reader.ReadInt32();                  //byte[] unkData1 = reader.ReadBytes(2);                  //byte[] unkData2 = reader.ReadBytes(8);                    using (BLTEHandler blte = new BLTEHandler(stream' idxInfo.Size - 30))                      blte.ExtractToFile(path' name);              }              catch              {                  if (key.EqualsTo(CASCConfig.EncodingKey))                  {                      using (Stream s = CDNHandler.OpenDataFileDirect(key' out int len))                      using (BLTEHandler blte = new BLTEHandler(s' len))                          blte.ExtractToFile(path' name);                  }                  else                  {                      var idxInfo = CDNHandler.GetCDNIndexInfo(key);                        if (idxInfo == null)                          throw new Exception("CDN index missing");                        using (Stream s = CDNHandler.OpenDataFile(key))                      using (BLTEHandler blte = new BLTEHandler(s' idxInfo.Size))                          blte.ExtractToFile(path' name);                  }              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,ExtractFile,The following statement contains a magic number: try              {                  if (OnlineMode)                      throw new Exception();                    var idxInfo = GetLocalIndexInfo(key);                    if (idxInfo == null)                      throw new Exception("local index missing");                    var stream = GetDataStream(idxInfo.Index);                    stream.Position = idxInfo.Offset;                    stream.Position += 30;                  //byte[] unkHash = reader.ReadBytes(16);                  //int __size = reader.ReadInt32();                  //byte[] unkData1 = reader.ReadBytes(2);                  //byte[] unkData2 = reader.ReadBytes(8);                    using (BLTEHandler blte = new BLTEHandler(stream' idxInfo.Size - 30))                      blte.ExtractToFile(path' name);              }              catch              {                  if (key.EqualsTo(CASCConfig.EncodingKey))                  {                      using (Stream s = CDNHandler.OpenDataFileDirect(key' out int len))                      using (BLTEHandler blte = new BLTEHandler(s' len))                          blte.ExtractToFile(path' name);                  }                  else                  {                      var idxInfo = CDNHandler.GetCDNIndexInfo(key);                        if (idxInfo == null)                          throw new Exception("CDN index missing");                        using (Stream s = CDNHandler.OpenDataFile(key))                      using (BLTEHandler blte = new BLTEHandler(s' idxInfo.Size))                          blte.ExtractToFile(path' name);                  }              }
Magic Number,CASCExplorer,CASCHandler,C:\repos\tomrus88_CASCExplorer\CASCExplorer\CASCHandler.cs,GetLocalIndexInfo,The following statement contains a magic number: byte[] temp = key.Copy(9);
Missing Default,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following switch statement is missing a default case: switch (length)                      {                          case 12: c += k[2]; b += k[1]; a += k[0]; break;                          case 11: c += k[2] & 0xffffff; b += k[1]; a += k[0]; break;                          case 10: c += k[2] & 0xffff; b += k[1]; a += k[0]; break;                          case 9: c += k[2] & 0xff; b += k[1]; a += k[0]; break;                          case 8: b += k[1]; a += k[0]; break;                          case 7: b += k[1] & 0xffffff; a += k[0]; break;                          case 6: b += k[1] & 0xffff; a += k[0]; break;                          case 5: b += k[1] & 0xff; a += k[0]; break;                          case 4: a += k[0]; break;                          case 3: a += k[0] & 0xffffff; break;                          case 2: a += k[0] & 0xffff; break;                          case 1: a += k[0] & 0xff; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)c);                              return;                      }
Missing Default,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following switch statement is missing a default case: switch (length)                      {                          case 12:                              c += k[4] + (((uint)k[5]) << 16);                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 11:                              c += ((uint)k8[10]) << 16;                              goto case 10;                          case 10:                              c += k[4];                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 9:                              c += k8[8];                              goto case 8;                          case 8:                              b += k[2] + (((uint)k[3]) << 16);                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 7:                              b += ((uint)k8[6]) << 16;                              goto case 6;                          case 6:                              b += k[2];                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 5:                              b += k8[4];                              goto case 4;                          case 4:                              a += k[0] + (((uint)k[1]) << 16);                              break;                          case 3:                              a += ((uint)k8[2]) << 16;                              goto case 2;                          case 2:                              a += k[0];                              break;                          case 1:                              a += k8[0];                              break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }
Missing Default,CASCExplorer,Jenkins96,C:\repos\tomrus88_CASCExplorer\CASCExplorer\Jenkins96.cs,HashCore,The following switch statement is missing a default case: switch (length)                      {                          case 12:                              c += (((uint)k[11]) << 24); goto case 11;                          case 11:                              c += (((uint)k[10]) << 16); goto case 10;                          case 10:                              c += (((uint)k[9]) << 8); goto case 9;                          case 9:                              c += k[8]; goto case 8;                          case 8:                              b += (((uint)k[7]) << 24); goto case 7;                          case 7:                              b += (((uint)k[6]) << 16); goto case 6;                          case 6:                              b += (((uint)k[5]) << 8); goto case 5;                          case 5:                              b += k[4]; goto case 4;                          case 4:                              a += (((uint)k[3]) << 24); goto case 3;                          case 3:                              a += (((uint)k[2]) << 16); goto case 2;                          case 2:                              a += (((uint)k[1]) << 8); goto case 1;                          case 1:                              a += k[0]; break;                          case 0:                              hash = BitConverter.GetBytes(((ulong)c << 32) | (ulong)b);                              return;                      }
