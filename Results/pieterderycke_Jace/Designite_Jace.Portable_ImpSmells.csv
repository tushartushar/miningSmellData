Implementation smell,Namespace,Class,File,Method,Description
Long Method,Jace.Execution,DynamicCompiler,C:\repos\pieterderycke_Jace\Jace\Execution\DynamicCompiler.cs,GenerateMethodBody,The method has 168 lines of code.
Long Method,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The method has 102 lines of code.
Long Method,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The method has 139 lines of code.
Complex Method,Jace.Execution,FunctionRegistry,C:\repos\pieterderycke_Jace\Jace\Execution\FunctionRegistry.cs,RegisterFunction,Cyclomatic complexity of the method is 9
Complex Method,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,Cyclomatic complexity of the method is 11
Long Statement,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,RequiredDataType,The length of the statement  "            return (argument1.DataType == DataType.FloatingPoint || argument2.DataType == DataType.FloatingPoint) ? DataType.FloatingPoint : DataType.Integer; " is 146.
Long Statement,Jace,CalculationEngine,C:\repos\pieterderycke_Jace\Jace\CalculationEngine.cs,RegisterDefaultFunctions,The length of the statement  "            FunctionRegistry.RegisterFunction("if"' (Func<double' double' double' double>)((a' b' c) => (a != 0.0 ? b : c))' false); " is 120.
Long Statement,Jace,CalculationEngine,C:\repos\pieterderycke_Jace\Jace\CalculationEngine.cs,RegisterDefaultFunctions,The length of the statement  "            FunctionRegistry.RegisterFunction("ifless"' (Func<double' double' double' double' double>)((a' b' c' d) => (a < b ? c : d))' false); " is 132.
Long Statement,Jace,CalculationEngine,C:\repos\pieterderycke_Jace\Jace\CalculationEngine.cs,RegisterDefaultFunctions,The length of the statement  "            FunctionRegistry.RegisterFunction("ifmore"' (Func<double' double' double' double' double>)((a' b' c' d) => (a > b ? c : d))' false); " is 132.
Long Statement,Jace,CalculationEngine,C:\repos\pieterderycke_Jace\Jace\CalculationEngine.cs,RegisterDefaultFunctions,The length of the statement  "            FunctionRegistry.RegisterFunction("ifequal"' (Func<double' double' double' double' double>)((a' b' c' d) => (a == b ? c : d))' false); " is 134.
Long Statement,Jace,CalculationEngine,C:\repos\pieterderycke_Jace\Jace\CalculationEngine.cs,VerifyVariableNames,The length of the statement  "                    throw new ArgumentException(string.Format("The name \"{0}\" is a reservered variable name that cannot be overwritten."' variableName)' "variables"); " is 148.
Long Statement,Jace,CalculationEngine,C:\repos\pieterderycke_Jace\Jace\CalculationEngine.cs,VerifyVariableNames,The length of the statement  "                    throw new ArgumentException(string.Format("The name \"{0}\" is a function name. Parameters cannot have this name."' variableName)' "variables"); " is 144.
Long Statement,Jace.Execution,DynamicCompiler,C:\repos\pieterderycke_Jace\Jace\Execution\DynamicCompiler.cs,GenerateMethodBody,The length of the statement  "                return Expression.Call(null' typeof(Math).GetRuntimeMethod("Pow"' new Type[] { typeof(double)' typeof(double) })' @base' exponent); " is 131.
Long Statement,Jace.Execution,DynamicCompiler,C:\repos\pieterderycke_Jace\Jace\Execution\DynamicCompiler.cs,GenerateMethodBody,The length of the statement  "                        Expression.Call(getFunctionRegistry' typeof(IFunctionRegistry).GetRuntimeMethod("GetFunctionInfo"' new Type[] { typeof(string) })' Expression.Constant(function.FunctionName)) " is 174.
Long Statement,Jace.Execution,DynamicCompiler,C:\repos\pieterderycke_Jace\Jace\Execution\DynamicCompiler.cs,GenerateMethodBody,The length of the statement  "                throw new ArgumentException(string.Format("Unsupported operation \"{0}\"."' operation.GetType().FullName)' "operation"); " is 120.
Long Statement,Jace.Execution,FormulaBuilder,C:\repos\pieterderycke_Jace\Jace\Execution\FormulaBuilder.cs,Parameter,The length of the statement  "                throw new ArgumentException(string.Format("The name \"{0}\" is a function name. Parameters cannot have this name."' name)' "name"); " is 131.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return Execute(multiplication.Argument1' functionRegistry' variables) * Execute(multiplication.Argument2' functionRegistry' variables); " is 135.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return Execute(addition.Argument1' functionRegistry' variables) + Execute(addition.Argument2' functionRegistry' variables); " is 123.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return Execute(addition.Argument1' functionRegistry' variables) - Execute(addition.Argument2' functionRegistry' variables); " is 123.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return Execute(division.Dividend' functionRegistry' variables) / Execute(division.Divisor' functionRegistry' variables); " is 120.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return Execute(division.Dividend' functionRegistry' variables) % Execute(division.Divisor' functionRegistry' variables); " is 120.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return Math.Pow(Execute(exponentiation.Base' functionRegistry' variables)' Execute(exponentiation.Exponent' functionRegistry' variables)); " is 138.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return (Execute(lessThan.Argument1' functionRegistry' variables) < Execute(lessThan.Argument2' functionRegistry' variables)) ? 1.0 : 0.0; " is 137.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return (Execute(lessOrEqualThan.Argument1' functionRegistry' variables) <= Execute(lessOrEqualThan.Argument2' functionRegistry' variables)) ? 1.0 : 0.0; " is 152.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return (Execute(greaterThan.Argument1' functionRegistry' variables) > Execute(greaterThan.Argument2' functionRegistry' variables)) ? 1.0 : 0.0; " is 143.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return (Execute(greaterOrEqualThan.Argument1' functionRegistry' variables) >= Execute(greaterOrEqualThan.Argument2' functionRegistry' variables)) ? 1.0 : 0.0; " is 158.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return (Execute(equal.Argument1' functionRegistry' variables) == Execute(equal.Argument2' functionRegistry' variables)) ? 1.0 : 0.0; " is 132.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                return (Execute(notEqual.Argument1' functionRegistry' variables) != Execute(notEqual.Argument2' functionRegistry' variables)) ? 1.0 : 0.0; " is 138.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Execute,The length of the statement  "                throw new ArgumentException(string.Format("Unsupported operation \"{0}\"."' operation.GetType().FullName)' "operation"); " is 120.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The length of the statement  "                return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]); " is 127.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The length of the statement  "                return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]); " is 149.
Long Statement,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The length of the statement  "                return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]); " is 171.
Long Statement,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The length of the statement  "                        tokens.Add(new Token() { TokenType = TokenType.Integer' Value = intValue' StartPosition = startPosition' Length = i - startPosition }); " is 135.
Long Statement,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The length of the statement  "                            tokens.Add(new Token() { TokenType = TokenType.FloatingPoint' Value = doubleValue' StartPosition = startPosition' Length = i - startPosition }); " is 144.
Long Statement,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The length of the statement  "                    tokens.Add(new Token() { TokenType = TokenType.Text' Value = buffer' StartPosition = startPosition' Length = i -startPosition }); " is 129.
Long Statement,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The length of the statement  "                    tokens.Add(new Token() { TokenType = Tokenizer.TokenType.ArgumentSeparator' Value = characters[i]' StartPosition = i' Length = 1 }); " is 132.
Long Statement,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,IsPartOfNumeric,The length of the statement  "            return character == decimalSeparator || (character >= '0' && character <= '9') || (isFormulaSubPart && isFirstCharacter && character == '-'); " is 141.
Long Statement,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,IsPartOfVariable,The length of the statement  "            return (character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z') || (!isFirstCharacter && character >= '0' && character <= '9') || (!isFirstCharacter && character == '_'); " is 194.
Complex Conditional,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,PopOperations,The conditional expression  "operatorStack.Count > 0 && operatorStack.Peek().TokenType == TokenType.LeftBracket                       && !(currentToken.HasValue && currentToken.Value.TokenType == TokenType.ArgumentSeparator)"  is complex.
Magic Number,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,AstBuilder,The following statement contains a magic number: operationPrecedence.Add('+'' 2);
Magic Number,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,AstBuilder,The following statement contains a magic number: operationPrecedence.Add('-'' 2);
Magic Number,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,AstBuilder,The following statement contains a magic number: operationPrecedence.Add('*'' 3);
Magic Number,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,AstBuilder,The following statement contains a magic number: operationPrecedence.Add('/'' 3);
Magic Number,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,AstBuilder,The following statement contains a magic number: operationPrecedence.Add('%'' 3);
Magic Number,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,AstBuilder,The following statement contains a magic number: operationPrecedence.Add('_'' 5);
Magic Number,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,AstBuilder,The following statement contains a magic number: operationPrecedence.Add('^'' 4);
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Execution,Interpreter,C:\repos\pieterderycke_Jace\Jace\Execution\Interpreter.cs,Invoke,The following statement contains a magic number: if (function is Func<double>)              {                  return ((Func<double>)function).Invoke();              }              else if (function is Func<double' double>)              {                  return ((Func<double' double>)function).Invoke(arguments[0]);              }              else if (function is Func<double' double' double>)              {                  return ((Func<double' double' double>)function).Invoke(arguments[0]' arguments[1]);              }              else if (function is Func<double' double' double' double>)              {                  return ((Func<double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]);              }              else if (function is Func<double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]);              }  #if !WINDOWS_PHONE_7              else if (function is Func<double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]);              }              else if (function is Func<double' double' double' double' double' double' double>)              {                  return ((Func<double' double' double' double' double' double' double>)function).Invoke(arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]' arguments[5]);              }  #endif              else              {                  return (double)function.DynamicInvoke((from s in arguments select (object)s).ToArray());              }
Magic Number,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The following statement contains a magic number: for(int i = 0; i < characters.Length; i++)              {                  if (IsPartOfNumeric(characters[i]' true' isFormulaSubPart))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfNumeric(characters[i]' false' isFormulaSubPart))                      {                          buffer += characters[i];                      }                        // Verify if we do not have an int                      int intValue;                      if (int.TryParse(buffer' out intValue))                      {                          tokens.Add(new Token() { TokenType = TokenType.Integer' Value = intValue' StartPosition = startPosition' Length = i - startPosition });                          isFormulaSubPart = false;                      }                      else                      {                          double doubleValue;                          if (double.TryParse(buffer' NumberStyles.Float | NumberStyles.AllowThousands'                              cultureInfo' out doubleValue))                          {                              tokens.Add(new Token() { TokenType = TokenType.FloatingPoint' Value = doubleValue' StartPosition = startPosition' Length = i - startPosition });                              isFormulaSubPart = false;                          }                          else if (buffer == "-")                          {                              // Verify if we have a unary minus' we use the token '_' for a unary minus in the AST builder                              tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = startPosition' Length = 1 });                          }                          // Else we skip                      }                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                    if (IsPartOfVariable(characters[i]' true))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfVariable(characters[i]' false))                      {                          buffer += characters[i];                      }                        tokens.Add(new Token() { TokenType = TokenType.Text' Value = buffer' StartPosition = startPosition' Length = i -startPosition });                      isFormulaSubPart = false;                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                  if (characters[i] == this.argumentSeparator)                  {                      tokens.Add(new Token() { TokenType = Tokenizer.TokenType.ArgumentSeparator' Value = characters[i]' StartPosition = i' Length = 1 });                      isFormulaSubPart = false;                  }                  else                  {                      switch (characters[i])                      {                           case ' ':                              continue;                          case '+':                          case '-':                          case '*':                          case '/':                          case '^':                          case '%':                          case '≤':                          case '≥':                          case '≠':                              if (IsUnaryMinus(characters[i]' tokens))                              {                                  // We use the token '_' for a unary minus in the AST builder                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = i' Length = 1 });                              }                              else                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = characters[i]' StartPosition = i' Length = 1 });                                                          }                              isFormulaSubPart = true;                              break;                          case '(':                              tokens.Add(new Token() { TokenType = TokenType.LeftBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = true;                              break;                          case ')':                              tokens.Add(new Token() { TokenType = TokenType.RightBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '<':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≤'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '<'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '>':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≥'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '>'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '!':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≠'' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          case '=':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '='' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          default:                              throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                      }                  }              }
Magic Number,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The following statement contains a magic number: for(int i = 0; i < characters.Length; i++)              {                  if (IsPartOfNumeric(characters[i]' true' isFormulaSubPart))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfNumeric(characters[i]' false' isFormulaSubPart))                      {                          buffer += characters[i];                      }                        // Verify if we do not have an int                      int intValue;                      if (int.TryParse(buffer' out intValue))                      {                          tokens.Add(new Token() { TokenType = TokenType.Integer' Value = intValue' StartPosition = startPosition' Length = i - startPosition });                          isFormulaSubPart = false;                      }                      else                      {                          double doubleValue;                          if (double.TryParse(buffer' NumberStyles.Float | NumberStyles.AllowThousands'                              cultureInfo' out doubleValue))                          {                              tokens.Add(new Token() { TokenType = TokenType.FloatingPoint' Value = doubleValue' StartPosition = startPosition' Length = i - startPosition });                              isFormulaSubPart = false;                          }                          else if (buffer == "-")                          {                              // Verify if we have a unary minus' we use the token '_' for a unary minus in the AST builder                              tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = startPosition' Length = 1 });                          }                          // Else we skip                      }                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                    if (IsPartOfVariable(characters[i]' true))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfVariable(characters[i]' false))                      {                          buffer += characters[i];                      }                        tokens.Add(new Token() { TokenType = TokenType.Text' Value = buffer' StartPosition = startPosition' Length = i -startPosition });                      isFormulaSubPart = false;                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                  if (characters[i] == this.argumentSeparator)                  {                      tokens.Add(new Token() { TokenType = Tokenizer.TokenType.ArgumentSeparator' Value = characters[i]' StartPosition = i' Length = 1 });                      isFormulaSubPart = false;                  }                  else                  {                      switch (characters[i])                      {                           case ' ':                              continue;                          case '+':                          case '-':                          case '*':                          case '/':                          case '^':                          case '%':                          case '≤':                          case '≥':                          case '≠':                              if (IsUnaryMinus(characters[i]' tokens))                              {                                  // We use the token '_' for a unary minus in the AST builder                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = i' Length = 1 });                              }                              else                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = characters[i]' StartPosition = i' Length = 1 });                                                          }                              isFormulaSubPart = true;                              break;                          case '(':                              tokens.Add(new Token() { TokenType = TokenType.LeftBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = true;                              break;                          case ')':                              tokens.Add(new Token() { TokenType = TokenType.RightBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '<':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≤'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '<'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '>':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≥'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '>'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '!':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≠'' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          case '=':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '='' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          default:                              throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                      }                  }              }
Magic Number,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The following statement contains a magic number: for(int i = 0; i < characters.Length; i++)              {                  if (IsPartOfNumeric(characters[i]' true' isFormulaSubPart))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfNumeric(characters[i]' false' isFormulaSubPart))                      {                          buffer += characters[i];                      }                        // Verify if we do not have an int                      int intValue;                      if (int.TryParse(buffer' out intValue))                      {                          tokens.Add(new Token() { TokenType = TokenType.Integer' Value = intValue' StartPosition = startPosition' Length = i - startPosition });                          isFormulaSubPart = false;                      }                      else                      {                          double doubleValue;                          if (double.TryParse(buffer' NumberStyles.Float | NumberStyles.AllowThousands'                              cultureInfo' out doubleValue))                          {                              tokens.Add(new Token() { TokenType = TokenType.FloatingPoint' Value = doubleValue' StartPosition = startPosition' Length = i - startPosition });                              isFormulaSubPart = false;                          }                          else if (buffer == "-")                          {                              // Verify if we have a unary minus' we use the token '_' for a unary minus in the AST builder                              tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = startPosition' Length = 1 });                          }                          // Else we skip                      }                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                    if (IsPartOfVariable(characters[i]' true))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfVariable(characters[i]' false))                      {                          buffer += characters[i];                      }                        tokens.Add(new Token() { TokenType = TokenType.Text' Value = buffer' StartPosition = startPosition' Length = i -startPosition });                      isFormulaSubPart = false;                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                  if (characters[i] == this.argumentSeparator)                  {                      tokens.Add(new Token() { TokenType = Tokenizer.TokenType.ArgumentSeparator' Value = characters[i]' StartPosition = i' Length = 1 });                      isFormulaSubPart = false;                  }                  else                  {                      switch (characters[i])                      {                           case ' ':                              continue;                          case '+':                          case '-':                          case '*':                          case '/':                          case '^':                          case '%':                          case '≤':                          case '≥':                          case '≠':                              if (IsUnaryMinus(characters[i]' tokens))                              {                                  // We use the token '_' for a unary minus in the AST builder                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = i' Length = 1 });                              }                              else                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = characters[i]' StartPosition = i' Length = 1 });                                                          }                              isFormulaSubPart = true;                              break;                          case '(':                              tokens.Add(new Token() { TokenType = TokenType.LeftBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = true;                              break;                          case ')':                              tokens.Add(new Token() { TokenType = TokenType.RightBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '<':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≤'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '<'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '>':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≥'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '>'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '!':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≠'' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          case '=':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '='' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          default:                              throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                      }                  }              }
Magic Number,Jace.Tokenizer,TokenReader,C:\repos\pieterderycke_Jace\Jace\Tokenizer\TokenReader.cs,Read,The following statement contains a magic number: for(int i = 0; i < characters.Length; i++)              {                  if (IsPartOfNumeric(characters[i]' true' isFormulaSubPart))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfNumeric(characters[i]' false' isFormulaSubPart))                      {                          buffer += characters[i];                      }                        // Verify if we do not have an int                      int intValue;                      if (int.TryParse(buffer' out intValue))                      {                          tokens.Add(new Token() { TokenType = TokenType.Integer' Value = intValue' StartPosition = startPosition' Length = i - startPosition });                          isFormulaSubPart = false;                      }                      else                      {                          double doubleValue;                          if (double.TryParse(buffer' NumberStyles.Float | NumberStyles.AllowThousands'                              cultureInfo' out doubleValue))                          {                              tokens.Add(new Token() { TokenType = TokenType.FloatingPoint' Value = doubleValue' StartPosition = startPosition' Length = i - startPosition });                              isFormulaSubPart = false;                          }                          else if (buffer == "-")                          {                              // Verify if we have a unary minus' we use the token '_' for a unary minus in the AST builder                              tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = startPosition' Length = 1 });                          }                          // Else we skip                      }                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                    if (IsPartOfVariable(characters[i]' true))                  {                      string buffer = "" + characters[i];                      int startPosition = i;                        while (++i < characters.Length && IsPartOfVariable(characters[i]' false))                      {                          buffer += characters[i];                      }                        tokens.Add(new Token() { TokenType = TokenType.Text' Value = buffer' StartPosition = startPosition' Length = i -startPosition });                      isFormulaSubPart = false;                        if (i == characters.Length)                      {                          // Last character read                          continue;                      }                  }                  if (characters[i] == this.argumentSeparator)                  {                      tokens.Add(new Token() { TokenType = Tokenizer.TokenType.ArgumentSeparator' Value = characters[i]' StartPosition = i' Length = 1 });                      isFormulaSubPart = false;                  }                  else                  {                      switch (characters[i])                      {                           case ' ':                              continue;                          case '+':                          case '-':                          case '*':                          case '/':                          case '^':                          case '%':                          case '≤':                          case '≥':                          case '≠':                              if (IsUnaryMinus(characters[i]' tokens))                              {                                  // We use the token '_' for a unary minus in the AST builder                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '_'' StartPosition = i' Length = 1 });                              }                              else                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = characters[i]' StartPosition = i' Length = 1 });                                                          }                              isFormulaSubPart = true;                              break;                          case '(':                              tokens.Add(new Token() { TokenType = TokenType.LeftBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = true;                              break;                          case ')':                              tokens.Add(new Token() { TokenType = TokenType.RightBracket' Value = characters[i]' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '<':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≤'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '<'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '>':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≥'' StartPosition = i++' Length = 2 });                              else                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '>'' StartPosition = i' Length = 1 });                              isFormulaSubPart = false;                              break;                          case '!':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '≠'' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          case '=':                              if (i + 1 < characters.Length && characters[i + 1] == '=')                              {                                  tokens.Add(new Token() { TokenType = TokenType.Operation' Value = '='' StartPosition = i++' Length = 2 });                                  isFormulaSubPart = false;                              }                              else                                  throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                              break;                          default:                              throw new ParseException(string.Format("Invalid token \"{0}\" detected at position {1}."' characters[i]' i));                      }                  }              }
Missing Default,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,Build,The following switch statement is missing a default case: switch (token.TokenType)                  {                      case TokenType.Integer:                          resultStack.Push(new IntegerConstant((int)token.Value));                          break;                      case TokenType.FloatingPoint:                          resultStack.Push(new FloatingPointConstant((double)token.Value));                          break;                      case TokenType.Text:                          if (functionRegistry.IsFunctionName((string)token.Value))                          {                              operatorStack.Push(token);                          }                          else                          {                              resultStack.Push(new Variable(((string)token.Value).ToLowerInvariant()));                          }                          break;                      case TokenType.LeftBracket:                          operatorStack.Push(token);                          break;                      case TokenType.RightBracket:                          PopOperations(true' token);                          break;                      case TokenType.ArgumentSeparator:                          PopOperations(false' token);                          break;                      case TokenType.Operation:                          Token operation1Token = token;                          char operation1 = (char)operation1Token.Value;                            while (operatorStack.Count > 0 && (operatorStack.Peek().TokenType == TokenType.Operation ||                              operatorStack.Peek().TokenType == TokenType.Text))                          {                              Token operation2Token = operatorStack.Peek();                              bool isFunctionOnTopOfStack = operation2Token.TokenType == TokenType.Text;                                if (!isFunctionOnTopOfStack)                              {                                  char operation2 = (char)operation2Token.Value;                                    if ((IsLeftAssociativeOperation(operation1) &&                                          operationPrecedence[operation1] <= operationPrecedence[operation2]) ||                                      (operationPrecedence[operation1] < operationPrecedence[operation2]))                                  {                                      operatorStack.Pop();                                      resultStack.Push(ConvertOperation(operation2Token));                                  }                                  else                                  {                                      break;                                  }                              }                              else                              {                                  operatorStack.Pop();                                  resultStack.Push(ConvertFunction(operation2Token));                              }                          }                            operatorStack.Push(operation1Token);                          break;                  }
Missing Default,Jace,AstBuilder,C:\repos\pieterderycke_Jace\Jace\AstBuilder.cs,PopOperations,The following switch statement is missing a default case: switch (token.TokenType)                  {                      case TokenType.Operation:                          resultStack.Push(ConvertOperation(token));                          break;                      case TokenType.Text:                          resultStack.Push(ConvertFunction(token));                          break;                  }
