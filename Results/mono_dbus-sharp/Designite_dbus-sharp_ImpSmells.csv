Implementation smell,Namespace,Class,File,Method,Description
Long Method,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The method has 164 lines of code.
Complex Method,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,SendMethodCall,Cyclomatic complexity of the method is 9
Complex Method,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,HandleMessage,Cyclomatic complexity of the method is 12
Complex Method,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,HandleMethodCall,Cyclomatic complexity of the method is 11
Complex Method,DBus,ExportObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\ExportObject.cs,HandleMethodCall,Cyclomatic complexity of the method is 9
Complex Method,DBus,Mapper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Mapper.cs,GetMethod,Cyclomatic complexity of the method is 11
Complex Method,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,Implement,Cyclomatic complexity of the method is 10
Complex Method,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,Cyclomatic complexity of the method is 17
Complex Method,DBus,AddressEntry,C:\research\architectureSmells\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,DBus.Authentication,SaslPeer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 10
Complex Method,DBus.Authentication,SaslClient,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 10
Complex Method,DBus.Authentication,SaslServer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,MatchRule,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Test,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,MatchRule,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Parse,Cyclomatic complexity of the method is 15
Complex Method,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadValue,Cyclomatic complexity of the method is 13
Complex Method,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadValue,Cyclomatic complexity of the method is 15
Complex Method,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,StepOver,Cyclomatic complexity of the method is 13
Complex Method,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,Write,Cyclomatic complexity of the method is 15
Complex Method,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteArray,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,Cyclomatic complexity of the method is 16
Complex Method,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,DataForDType,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,Cyclomatic complexity of the method is 9
Complex Method,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetFixedSize,Cyclomatic complexity of the method is 12
Complex Method,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,TypeCodeToDType,Cyclomatic complexity of the method is 19
Complex Method,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,TypeToDType,Cyclomatic complexity of the method is 13
Complex Method,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,ToType,Cyclomatic complexity of the method is 23
Complex Method,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSig,Cyclomatic complexity of the method is 13
Complex Method,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,Cyclomatic complexity of the method is 10
Complex Method,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,Cyclomatic complexity of the method is 11
Long Parameter List,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,SendSignal,The method has 6 parameters. Parameters: iface' member' inSigStr' writer' retType' exception
Long Parameter List,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,SendSignal,The method has 7 parameters. Parameters: iface' member' inSigStr' writer' retType' disposableList' exception
Long Parameter List,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,SendMethodCall,The method has 6 parameters. Parameters: iface' member' inSigStr' writer' retType' exception
Long Parameter List,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,SendMethodCall,The method has 7 parameters. Parameters: iface' member' inSigStr' writer' retType' disposableList' exception
Long Parameter List,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The method has 6 parameters. Parameters: methodBase' methodName' inArgs' outArgs' retVal' exception
Long Parameter List,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The method has 7 parameters. Parameters: methodBase' methodName' inArgs' disposableList' outArgs' retVal' exception
Long Parameter List,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The method has 5 parameters. Parameters: ilg' declMethod' invokeMethod' interface' member
Long Parameter List,DBus.Unix,UnixMonoStream,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,SendmsgShort,The method has 7 parameters. Parameters: buffer1' offset1' length1' buffer2' offset2' length2' fds
Long Parameter List,DBus.Unix,UnixMonoStream,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,Sendmsg,The method has 7 parameters. Parameters: buffer1' offset1' length1' buffer2' offset2' length2' fds
Long Identifier,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,,The length of the parameter argumentNullExceptionConstructor is 32.
Long Statement,DBus,Address,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Address.cs,GetSessionBusAddressFromSharedMemory,The length of the statement  "				result = OSHelpers.ReadSharedMemoryString ("DBusDaemonAddressInfoDebug"' 255); // a DEBUG build of the daemon uses this different address...            " is 140.
Long Statement,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,SendMethodCall,The length of the statement  "				throw new Exception ("Got unexpected message of type " + retMsg.Header.MessageType + " while waiting for a MethodReturn or Error");" is 131.
Long Statement,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,HandleMessage,The length of the statement  "							Console.Error.WriteLine ("Unexpected reply message received: MessageType='" + msg.Header.MessageType + "'' ReplySerial=" + reply_serial);" is 137.
Long Statement,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,HandleMethodCall,The length of the statement  "			//TODO: Ping and Introspect need to be abstracted and moved somewhere more appropriate once message filter infrastructure is complete" is 133.
Long Statement,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,HandleMethodCall,The length of the statement  "			//FIXME: these special cases are slightly broken for the case where the member but not the interface is specified in the message" is 128.
Long Statement,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,GetObject,The length of the statement  "					Console.Error.WriteLine ("Warning: Note that MarshalByRefObject use is not recommended; for best performance' define interfaces");" is 130.
Long Statement,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,Register,The length of the statement  "			//TODO: implement some kind of tree data structure or internal object hierarchy. right now we are ignoring the name and putting all object paths in one namespace' which is bad" is 175.
Long Statement,DBus,DProxy,C:\research\architectureSmells\repos\mono_dbus-sharp\src\DProxy.cs,Invoke,The length of the statement  "			busObject.Invoke (callMessage.MethodBase' callMessage.MethodName' callMessage.InArgs' out outArgs' out retVal' out exception);" is 126.
Long Statement,DBus,Introspector,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Introspection.cs,GetProductDescription,The length of the statement  "			AssemblyInformationalVersionAttribute iversion = Attribute.GetCustomAttribute (assembly' typeof (AssemblyInformationalVersionAttribute)) as AssemblyInformationalVersionAttribute;" is 178.
Long Statement,DBus,Introspector,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Introspection.cs,WriteArg,The length of the statement  "			//we can't rely on the default direction (qt-dbus requires a direction at time of writing)' so we use a boolean to reverse the parameter direction and make it explicit" is 167.
Long Statement,DBus,Introspector,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Introspection.cs,WriteInterface,The length of the statement  "						Console.Error.WriteLine ("Warning: Unhandled MemberType '{0}' encountered while introspecting {1}"' mbi.MemberType' type.FullName);" is 131.
Long Statement,DBus,Mapper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Mapper.cs,GetMethod,The length of the statement  "				//this could be made more efficient by using the given interface name earlier and avoiding walking through all public interfaces" is 128.
Long Statement,DBus,MessageHelper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "			//TODO: this validation check should provide better information' eg. message dump or a stack trace' or at least the interface/member" is 132.
Long Statement,DBus,MessageHelper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "					Console.Error.WriteLine ("Warning: The signature of the message does not match that of the handler: " + "Expected '" + expected + "'' got '" + actual + "'");" is 157.
Long Statement,DBus,MessageHelper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "			//TODO: this validation check should provide better information' eg. message dump or a stack trace' or at least the interface/member" is 132.
Long Statement,DBus,MessageHelper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "					Console.Error.WriteLine ("Warning: The signature of the message does not match that of the handler: " + "Expected '" + expected + "'' got '" + actual + "'");" is 157.
Long Statement,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,Implement,The length of the statement  "				PropertyBuilder prop_builder = typeB.DefineProperty (declProp.Name' declProp.Attributes' declProp.PropertyType' indexers.ToArray ());" is 133.
Long Statement,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GetHookupMethod,The length of the statement  "			DynamicMethod hookupMethod = new DynamicMethod ("Handle" + member' declMethod.ReturnType' hookupParms' typeof (MessageWriter));" is 127.
Long Statement,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GetWriteMethod,The length of the statement  "			DynamicMethod method_builder = new DynamicMethod ("Write" + t.Name' typeof (void)' new Type[] {typeof (MessageWriter)' t}' typeof (MessageWriter)' true);" is 153.
Long Statement,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenWriter,The length of the statement  "			MethodInfo exactWriteMethod = typeof (MessageWriter).GetMethod ("Write"' BindingFlags.ExactBinding | BindingFlags.Instance | BindingFlags.Public' null' new Type[] {tUnder}' null);" is 179.
Long Statement,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenWriter,The length of the statement  "			} else if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (IDictionary<'>) || type.GetGenericTypeDefinition () == typeof (Dictionary<'>))) {" is 159.
Long Statement,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenReadMethod,The length of the statement  "			Type[] parms = new Type[] { typeof (object)' typeof (MessageReader)' typeof (Message)' typeof (MessageWriter)' typeof (DisposableList) };" is 137.
Long Statement,DBus,UnixFD,C:\research\architectureSmells\repos\mono_dbus-sharp\src\UnixFD.cs,Dispose,The length of the statement  "					// Don't retry close() on EINTR' on a lot of systems (e.g. Linux) the FD will be already closed when EINTR is returned' see https://lwn.net/Articles/576478/" is 156.
Long Statement,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadValue,The length of the statement  "			} else if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (Dictionary<'>) || type.GetGenericTypeDefinition() == typeof(IDictionary<'>))) {" is 157.
Long Statement,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadSignature,The length of the statement  "				throw new Exception ("Signature length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxSignatureLength + " bytes");" is 129.
Long Statement,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadVariant,The length of the statement  "				throw new InvalidOperationException (string.Format ("ReadVariant need a single complete type signature' {0} was given"' sig.ToString ()));" is 138.
Long Statement,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadValue,The length of the statement  "				throw new ArgumentException (string.Format ("ReadVariant need a single complete type signature' {0} was given"' sig.ToString ()));" is 130.
Long Statement,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The length of the statement  "			MethodInfo mi = this.GetType ().GetMethod ("ReadDictionary"' Type.EmptyTypes).MakeGenericMethod (new [] { keyType' valType });" is 126.
Long Statement,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The length of the statement  "				throw new Exception ("Dict length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes");" is 120.
Long Statement,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadArray,The length of the statement  "				throw new Exception ("Array length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes");" is 121.
Long Statement,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,Write,The length of the statement  "				throw new Exception ("Signature length " + ascii_data.Length + " exceeds maximum allowed " + ProtocolInformation.MaxSignatureLength + " bytes");" is 144.
Long Statement,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,Write,The length of the statement  "			} else if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (IDictionary<'>) || type.GetGenericTypeDefinition () == typeof (Dictionary<'>))) {" is 159.
Long Statement,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteArray,The length of the statement  "			if (endianness == Connection.NativeEndianness && elemType.IsValueType && !sigElem.IsStruct && elemType != typeof(bool) && sigElem.GetFixedSize (ref fixedSize)) {" is 161.
Long Statement,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,ThrowArrayLengthException,The length of the statement  "			throw new Exception ("Array length " + ln.ToString () + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes");" is 133.
Long Statement,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteFromDict,The length of the statement  "				throw new Exception ("Dict length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes");" is 120.
Long Statement,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteHeaderFields,The length of the statement  "				throw new Exception ("Dict length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes");" is 120.
Long Statement,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,TypeToDType,The length of the statement  "			if (type.IsGenericType && (type.GetGenericTypeDefinition() == typeof(IDictionary<'>) || type.GetGenericTypeDefinition() == typeof(Dictionary<'>)))" is 146.
Long Statement,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,ToType,The length of the statement  "				throw new NotSupportedException ("Parsing or converting this signature is not yet supported (signature was '" + this + "')' at DType." + dtype);" is 144.
Long Statement,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSig,The length of the statement  "			if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (IDictionary<'>) || type.GetGenericTypeDefinition () == typeof (Dictionary<'>))) {" is 152.
Long Statement,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The length of the statement  "				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/" is 162.
Long Statement,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The length of the statement  "							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'");" is 134.
Long Statement,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The length of the statement  "						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon"); " is 125.
Long Statement,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The length of the statement  "					Console.Error.WriteLine ("Warning: Protocol version '" + version.ToString () + "' is not explicitly supported but may be compatible");" is 134.
Long Statement,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The length of the statement  "				throw new Exception ("Message length " + msgLength + " exceeds maximum allowed " + ProtocolInformation.MaxMessageLength + " bytes");" is 132.
Long Statement,DBus.Transports,UnixSendmsgTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixSendmsgTransport.cs,WriteMessage,The length of the statement  "				((DBus.Unix.UnixMonoStream) Stream).Sendmsg (header' 0' header.Length' msg.Body' 0' msg.Body == null ? 0 : msg.Body.Length' msg.UnixFDArray);" is 141.
Long Statement,DBus.Unix,UnixMonoStream,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,SendmsgShort,The length of the statement  "			//Console.WriteLine ("SendmsgShort (X' {0}' {1}' {2}' {3}' {4}' {5})"' offset1' length1' buffer2 == null ? "-" : "Y"' offset2' length2' fds == null ? "-" : "" + fds.FDs.Count);" is 176.
Long Statement,DBus.Unix,UnixMonoStream,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,Sendmsg,The length of the statement  "					written += SendmsgShort (buffer1' offset1 + written' length1 - written' buffer2' offset2' length2' written == 0 ? fds : null);" is 126.
Complex Conditional,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The conditional expression  "mi != null && mi.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))"  is complex.
Complex Conditional,DBus,AddressEntry,C:\research\architectureSmells\repos\mono_dbus-sharp\src\AddressEntry.cs,Escape,The conditional expression  "(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') 				    || c == '-' || c == '_' || c == '/' || c == '\\' || c == '.'"  is complex.
Complex Conditional,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteArray,The conditional expression  "endianness == Connection.NativeEndianness && elemType.IsValueType && !sigElem.IsStruct && elemType != typeof(bool) && sigElem.GetFixedSize (ref fixedSize)"  is complex.
Complex Conditional,DBus.Transports,UnixSendmsgTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixSendmsgTransport.cs,ReadShort,The conditional expression  "length < 0 || offset < 0 || length + offset < length || length + offset > buffer.Length"  is complex.
Magic Number,DBus,Address,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Address.cs,GetSessionBusAddressFromSharedMemory,The following statement contains a magic number: string result = OSHelpers.ReadSharedMemoryString ("DBusDaemonAddressInfo"' 255);
Magic Number,DBus,Address,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Address.cs,GetSessionBusAddressFromSharedMemory,The following statement contains a magic number: result = OSHelpers.ReadSharedMemoryString ("DBusDaemonAddressInfoDebug"' 255);
Magic Number,DBus,UUID,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder (ByteLength * 2);
Magic Number,DBus,UUID,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,Parse,The following statement contains a magic number: hex.Length != ByteLength * 2
Magic Number,DBus,UUID,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,Parse,The following statement contains a magic number: result[n] = (byte)(Sasl.FromHexChar (hex[i++]) << 4);
Magic Number,DBus,UUID,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,Generate,The following statement contains a magic number: id.c = p[2];
Magic Number,DBus,BusObject,C:\research\architectureSmells\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The following statement contains a magic number: string[] parts = methodName.Split (new char[]{'_'}' 2);
Magic Number,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,ReadMachineId,The following statement contains a magic number: data.Length < 33
Magic Number,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,ReadMachineId,The following statement contains a magic number: return UUID.Parse (System.Text.Encoding.ASCII.GetString (data' 0' 32));
Magic Number,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The following statement contains a magic number: string[] parts = declMethod.Name.Split (new char[]{'_'}' 2);
Magic Number,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The following statement contains a magic number: member = "Get" + member.Substring (4);
Magic Number,DBus,TypeImplementer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\TypeImplementer.cs,Gen,The following statement contains a magic number: ilg.Emit (OpCodes.Ldarg' 4);
Magic Number,DBus,AddressEntry,C:\research\architectureSmells\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: parts.Length < 2
Magic Number,DBus,AddressEntry,C:\research\architectureSmells\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: parts.Length > 2
Magic Number,DBus,AddressEntry,C:\research\architectureSmells\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: parts.Length < 2
Magic Number,DBus,AddressEntry,C:\research\architectureSmells\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: parts.Length > 2
Magic Number,DBus.Authentication,SaslServer,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,The following statement contains a magic number: string initialResponse = m.Groups[2].Value;
Magic Number,DBus.Authentication,Sasl,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,UnixToDateTime,The following statement contains a magic number: DateTime LocalUnixEpoch = new DateTime (1970' 1' 1);
Magic Number,DBus.Authentication,Sasl,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,DateTimeToUnix,The following statement contains a magic number: DateTime LocalUnixEpoch = new DateTime (1970' 1' 1);
Magic Number,DBus.Authentication,Sasl,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,ToHex,The following statement contains a magic number: StringBuilder sb = new StringBuilder (input.Length * 2);
Magic Number,DBus.Authentication,Sasl,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,FromHexChar,The following statement contains a magic number: return (byte) (c - 'a' + 10);
Magic Number,DBus.Authentication,Sasl,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,FromHexChar,The following statement contains a magic number: return (byte) (c - 'A' + 10);
Magic Number,DBus.Authentication,Sasl,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Authentication.cs,FromHex,The following statement contains a magic number: result [n] = (byte) (FromHexChar (hex [i++]) << 4);
Magic Number,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: innerTypes == null || innerTypes.Length == 0 || innerTypes.Length > 7
Magic Number,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) { 			case 1: 				structType = typeof (DBusStruct<>); 				break; 			case 2: 				structType = typeof (DBusStruct<'>); 				break; 			case 3: 				structType = typeof (DBusStruct<''>); 				break; 			case 4: 				structType = typeof (DBusStruct<'''>); 				break; 			case 5: 				structType = typeof (DBusStruct<''''>); 				break; 			case 6: 				structType = typeof (DBusStruct<'''''>); 				break; 			case 7: 				structType = typeof (DBusStruct<''''''>); 				break; 			}
Magic Number,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) { 			case 1: 				structType = typeof (DBusStruct<>); 				break; 			case 2: 				structType = typeof (DBusStruct<'>); 				break; 			case 3: 				structType = typeof (DBusStruct<''>); 				break; 			case 4: 				structType = typeof (DBusStruct<'''>); 				break; 			case 5: 				structType = typeof (DBusStruct<''''>); 				break; 			case 6: 				structType = typeof (DBusStruct<'''''>); 				break; 			case 7: 				structType = typeof (DBusStruct<''''''>); 				break; 			}
Magic Number,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) { 			case 1: 				structType = typeof (DBusStruct<>); 				break; 			case 2: 				structType = typeof (DBusStruct<'>); 				break; 			case 3: 				structType = typeof (DBusStruct<''>); 				break; 			case 4: 				structType = typeof (DBusStruct<'''>); 				break; 			case 5: 				structType = typeof (DBusStruct<''''>); 				break; 			case 6: 				structType = typeof (DBusStruct<'''''>); 				break; 			case 7: 				structType = typeof (DBusStruct<''''''>); 				break; 			}
Magic Number,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) { 			case 1: 				structType = typeof (DBusStruct<>); 				break; 			case 2: 				structType = typeof (DBusStruct<'>); 				break; 			case 3: 				structType = typeof (DBusStruct<''>); 				break; 			case 4: 				structType = typeof (DBusStruct<'''>); 				break; 			case 5: 				structType = typeof (DBusStruct<''''>); 				break; 			case 6: 				structType = typeof (DBusStruct<'''''>); 				break; 			case 7: 				structType = typeof (DBusStruct<''''''>); 				break; 			}
Magic Number,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) { 			case 1: 				structType = typeof (DBusStruct<>); 				break; 			case 2: 				structType = typeof (DBusStruct<'>); 				break; 			case 3: 				structType = typeof (DBusStruct<''>); 				break; 			case 4: 				structType = typeof (DBusStruct<'''>); 				break; 			case 5: 				structType = typeof (DBusStruct<''''>); 				break; 			case 6: 				structType = typeof (DBusStruct<'''''>); 				break; 			case 7: 				structType = typeof (DBusStruct<''''''>); 				break; 			}
Magic Number,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) { 			case 1: 				structType = typeof (DBusStruct<>); 				break; 			case 2: 				structType = typeof (DBusStruct<'>); 				break; 			case 3: 				structType = typeof (DBusStruct<''>); 				break; 			case 4: 				structType = typeof (DBusStruct<'''>); 				break; 			case 5: 				structType = typeof (DBusStruct<''''>); 				break; 			case 6: 				structType = typeof (DBusStruct<'''''>); 				break; 			case 7: 				structType = typeof (DBusStruct<''''''>); 				break; 			}
Magic Number,DBus.Protocol,Header,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Header.cs,FromBytes,The following statement contains a magic number: header.Flags = (HeaderFlag)data[2];
Magic Number,DBus.Protocol,Header,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Header.cs,FromBytes,The following statement contains a magic number: header.MajorVersion = data[3];
Magic Number,DBus.Protocol,Header,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Header.cs,FromBytes,The following statement contains a magic number: reader.Seek (4);
Magic Number,DBus.Protocol,MatchRule,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Parse,The following statement contains a magic number: string value = m.Groups[2].Value;
Magic Number,DBus.Protocol,MatchRule,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Parse,The following statement contains a magic number: string argType = mArg.Groups[2].Value;
Magic Number,DBus.Protocol,MessageDumper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,FromHexChar,The following statement contains a magic number: return (byte) (c - 'a' + 10);
Magic Number,DBus.Protocol,MessageDumper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,FromHexChar,The following statement contains a magic number: return (byte) (c - 'A' + 10);
Magic Number,DBus.Protocol,MessageDumper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,ReadFromHex,The following statement contains a magic number: byte res = (byte) (FromHexChar (hex [i++]) << 4);
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUShort,The following statement contains a magic number: ReadPad (2);
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUShort,The following statement contains a magic number: data.Length < pos + 2
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUShort,The following statement contains a magic number: pos += 2;
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: ReadPad (4);
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: data.Length < pos + 4
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: pos += 4;
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: data.Length < pos + 8
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: pos += 8;
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The following statement contains a magic number: var val = new Dictionary<TKey' TValue> ((int)(ln / 8));
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadStruct,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageReader,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadStruct,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,CloseWrite,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUShort,The following statement contains a magic number: WritePad (2);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUShort,The following statement contains a magic number: stream.Write (dst' 0' 2);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: WritePad (4);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: stream.Write (dst' 0' 4);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalULong,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalULong,The following statement contains a magic number: stream.Write (dst' 0' 8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteStructure,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteFromDict,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteFromDict,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteHeaderFields,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteHeaderFields,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 					return 4; 				case DType.UnixFD: 					return 4; 				case DType.ObjectPath: 					return 4; 				case DType.Signature: 					return 1; 				case DType.Array: 					return 4; 				case DType.StructBegin: 					return 8; 				case DType.Variant: 					return 1; 				case DType.DictEntryBegin: 					return 8; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine alignment of " + dtype); 			}
Magic Number,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 				case DType.UnixFD: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 				case DType.ObjectPath: 				case DType.Signature: 				case DType.Array: 				case DType.StructBegin: 				case DType.Variant: 				case DType.DictEntryBegin: 					return -1; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine size of " + dtype); 			}
Magic Number,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 				case DType.UnixFD: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 				case DType.ObjectPath: 				case DType.Signature: 				case DType.Array: 				case DType.StructBegin: 				case DType.Variant: 				case DType.DictEntryBegin: 					return -1; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine size of " + dtype); 			}
Magic Number,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 				case DType.UnixFD: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 				case DType.ObjectPath: 				case DType.Signature: 				case DType.Array: 				case DType.StructBegin: 				case DType.Variant: 				case DType.DictEntryBegin: 					return -1; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine size of " + dtype); 			}
Magic Number,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 				case DType.UnixFD: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 				case DType.ObjectPath: 				case DType.Signature: 				case DType.Array: 				case DType.StructBegin: 				case DType.Variant: 				case DType.DictEntryBegin: 					return -1; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine size of " + dtype); 			}
Magic Number,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 				case DType.UnixFD: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 				case DType.ObjectPath: 				case DType.Signature: 				case DType.Array: 				case DType.StructBegin: 				case DType.Variant: 				case DType.DictEntryBegin: 					return -1; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine size of " + dtype); 			}
Magic Number,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) { 				case DType.Byte: 					return 1; 				case DType.Boolean: 					return 4; 				case DType.Int16: 				case DType.UInt16: 					return 2; 				case DType.Int32: 				case DType.UInt32: 				case DType.UnixFD: 					return 4; 				case DType.Int64: 				case DType.UInt64: 					return 8; #if !DISABLE_SINGLE 				case DType.Single: //Not yet supported! 					return 4; #endif 				case DType.Double: 					return 8; 				case DType.String: 				case DType.ObjectPath: 				case DType.Signature: 				case DType.Array: 				case DType.StructBegin: 				case DType.Variant: 				case DType.DictEntryBegin: 					return -1; 				case DType.Invalid: 				default: 					throw new Exception ("Cannot determine size of " + dtype); 			}
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The following statement contains a magic number: switch (entry.Method) { 				case "tcp": 				{ 					Transport transport = new SocketTransport (); 					transport.Open (entry); 					return transport; 				}  				case "unix": 				{ 					if (OSHelpers.PlatformIsUnixoid) { 						Transport transport; 						if (UnixSendmsgTransport.Available ()) { 							transport = new UnixSendmsgTransport (); 						} else { 							if (ProtocolInformation.Verbose) 								Console.Error.WriteLine ("Warning: Syscall.sendmsg() not available' transfering unix FDs will not work"); 							transport = new UnixNativeTransport (); 						} 						transport.Open (entry); 						return transport; 					} 					break; 				}  #if ENABLE_PIPES 				case "win": 				{ 					Transport transport = new PipeTransport (); 					transport.Open (entry); 					return transport; 				} #endif  				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/ 				case "autolaunch": 				{ 					if (OSHelpers.PlatformIsUnixoid) 						break;  					string addr = Address.GetSessionBusAddressFromSharedMemory ();  					if (string.IsNullOrEmpty (addr)) { // we have to launch the daemon ourselves 						string oldDir = Directory.GetCurrentDirectory (); 						// Without this' the "current" folder for the new process will be the one where the current 						// executable resides' and as a consequence'that folder cannot be relocated/deleted unless the daemon is stopped 						Directory.SetCurrentDirectory (Environment.GetFolderPath (Environment.SpecialFolder.System));  						Process process = Process.Start (DBUS_DAEMON_LAUNCH_COMMAND); 						if (process == null) { 							Directory.SetCurrentDirectory (oldDir); 							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'"); 						}  						// wait for daemon 						Stopwatch stopwatch = new Stopwatch (); 						stopwatch.Start (); 						do { 							addr = Address.GetSessionBusAddressFromSharedMemory (); 							if (String.IsNullOrEmpty (addr)) 								Thread.Sleep (100); 						} while (String.IsNullOrEmpty (addr) && stopwatch.ElapsedMilliseconds <= 5000);  						Directory.SetCurrentDirectory (oldDir); 					}  					if (string.IsNullOrEmpty (addr)) 						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon");  					return Create (AddressEntry.Parse (addr)); 				}  			}
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The following statement contains a magic number: switch (entry.Method) { 				case "tcp": 				{ 					Transport transport = new SocketTransport (); 					transport.Open (entry); 					return transport; 				}  				case "unix": 				{ 					if (OSHelpers.PlatformIsUnixoid) { 						Transport transport; 						if (UnixSendmsgTransport.Available ()) { 							transport = new UnixSendmsgTransport (); 						} else { 							if (ProtocolInformation.Verbose) 								Console.Error.WriteLine ("Warning: Syscall.sendmsg() not available' transfering unix FDs will not work"); 							transport = new UnixNativeTransport (); 						} 						transport.Open (entry); 						return transport; 					} 					break; 				}  #if ENABLE_PIPES 				case "win": 				{ 					Transport transport = new PipeTransport (); 					transport.Open (entry); 					return transport; 				} #endif  				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/ 				case "autolaunch": 				{ 					if (OSHelpers.PlatformIsUnixoid) 						break;  					string addr = Address.GetSessionBusAddressFromSharedMemory ();  					if (string.IsNullOrEmpty (addr)) { // we have to launch the daemon ourselves 						string oldDir = Directory.GetCurrentDirectory (); 						// Without this' the "current" folder for the new process will be the one where the current 						// executable resides' and as a consequence'that folder cannot be relocated/deleted unless the daemon is stopped 						Directory.SetCurrentDirectory (Environment.GetFolderPath (Environment.SpecialFolder.System));  						Process process = Process.Start (DBUS_DAEMON_LAUNCH_COMMAND); 						if (process == null) { 							Directory.SetCurrentDirectory (oldDir); 							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'"); 						}  						// wait for daemon 						Stopwatch stopwatch = new Stopwatch (); 						stopwatch.Start (); 						do { 							addr = Address.GetSessionBusAddressFromSharedMemory (); 							if (String.IsNullOrEmpty (addr)) 								Thread.Sleep (100); 						} while (String.IsNullOrEmpty (addr) && stopwatch.ElapsedMilliseconds <= 5000);  						Directory.SetCurrentDirectory (oldDir); 					}  					if (string.IsNullOrEmpty (addr)) 						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon");  					return Create (AddressEntry.Parse (addr)); 				}  			}
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: readBuffer = new byte[16];
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: read = Read (hbuf' 0' 16' fdArray);
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: read != 16
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: reader.Seek (3);
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: toRead = ProtocolInformation.Padded (toRead' 8);
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: header = new byte[16 + toRead];
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: Array.Copy (hbuf' header' 16);
Magic Number,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: read = Read (header' 16' toRead' fdArray);
Magic Number,DBus.Transports,UnixNativeTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddr,The following statement contains a magic number: byte[] sa = new byte[2 + p.Length + 1];
Magic Number,DBus.Transports,UnixNativeTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddr,The following statement contains a magic number: sa[2 + i] = p[i];
Magic Number,DBus.Transports,UnixNativeTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddr,The following statement contains a magic number: sa[2 + p.Length] = 0;
Magic Number,DBus.Transports,UnixNativeTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddrAbstract,The following statement contains a magic number: byte[] sa = new byte[2 + 1 + p.Length];
Magic Number,DBus.Transports,UnixNativeTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddrAbstract,The following statement contains a magic number: sa[2] = 0;
Magic Number,DBus.Transports,UnixNativeTransport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddrAbstract,The following statement contains a magic number: sa[3 + i] = p[i];
Magic Number,DBus.Unix,UnixMonoStream,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,SendmsgShort,The following statement contains a magic number: var msghdr = new Msghdr { 						msg_iov = iovecs' 						msg_iovlen = length2 == 0 ? 1 : 2' 						msg_control = cmsg' 						msg_controllen = cmsg == null ? 0 : cmsg.Length' 					};
Magic Number,DBus.Unix,UnixSocket,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Unix\UnixSocket.cs,Accept,The following statement contains a magic number: byte[] addr = new byte[110];
Missing Default,DBus,Connection,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Connection.cs,HandleMethodCall,The following switch statement is missing a default case: switch (method_call.Member) { 					case "Ping": 						Send (MessageHelper.ConstructReply (method_call)); 						return; 					case "GetMachineId": 						if (MachineId != UUID.Zero) { 							Send (MessageHelper.ConstructReply (method_call' MachineId.ToString ())); 							return; 						} else { 							// Might want to send back an error here? 						} 						break; 				}
Missing Default,DBus,Mapper,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Mapper.cs,GetTypes,The following switch statement is missing a default case: switch (dir) { 					case ArgDirection.In: 						//docs say IsIn isn't reliable' and this is indeed true 						//if (parms[i].IsIn) 						if (!parms[i].IsOut) 							types.Add (parms[i].ParameterType); 						break; 					case ArgDirection.Out: 						if (parms[i].IsOut) { 							//TODO: note that IsOut is optional to the compiler' we may want to use IsByRef instead 						//eg: if (parms[i].ParameterType.IsByRef) 							types.Add (parms[i].ParameterType.GetElementType ()); 						} 						break; 				}
Missing Default,DBus.Protocol,DBusStruct,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following switch statement is missing a default case: switch (innerTypes.Length) { 			case 1: 				structType = typeof (DBusStruct<>); 				break; 			case 2: 				structType = typeof (DBusStruct<'>); 				break; 			case 3: 				structType = typeof (DBusStruct<''>); 				break; 			case 4: 				structType = typeof (DBusStruct<'''>); 				break; 			case 5: 				structType = typeof (DBusStruct<''''>); 				break; 			case 6: 				structType = typeof (DBusStruct<'''''>); 				break; 			case 7: 				structType = typeof (DBusStruct<''''''>); 				break; 			}
Missing Default,DBus.Protocol,Signature,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,IsValid,The following switch statement is missing a default case: switch ((DType)c) { 				case DType.StructBegin: 					structCount++; 					break; 				case DType.StructEnd: 					structCount--; 					break; 				case DType.DictEntryBegin: 					dictCount++; 					break; 				case DType.DictEntryEnd: 					dictCount--; 					break; 				}
Missing Default,DBus.Protocol,SignatureChecker,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Signature.cs,SingleType,The following switch statement is missing a default case: switch ((DType)data[pos]) { 				// Simple Type 				case DType.Byte: 				case DType.Boolean: 				case DType.Int16: 				case DType.UInt16: 				case DType.Int32: 				case DType.UInt32: 				case DType.Int64: 				case DType.UInt64: 				case DType.Single: 				case DType.Double: 				case DType.String: 				case DType.UnixFD: 				case DType.ObjectPath: 				case DType.Signature: 				case DType.Variant: 					pos += 1; 					return true; 				case DType.Array: 					pos += 1; 					return ArrayType (); 				case DType.StructBegin: 					pos += 1; 					return StructType (); 				case DType.DictEntryBegin: 					pos += 1; 					return DictType (); 				}
Missing Default,DBus.Transports,Transport,C:\research\architectureSmells\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The following switch statement is missing a default case: switch (entry.Method) { 				case "tcp": 				{ 					Transport transport = new SocketTransport (); 					transport.Open (entry); 					return transport; 				}  				case "unix": 				{ 					if (OSHelpers.PlatformIsUnixoid) { 						Transport transport; 						if (UnixSendmsgTransport.Available ()) { 							transport = new UnixSendmsgTransport (); 						} else { 							if (ProtocolInformation.Verbose) 								Console.Error.WriteLine ("Warning: Syscall.sendmsg() not available' transfering unix FDs will not work"); 							transport = new UnixNativeTransport (); 						} 						transport.Open (entry); 						return transport; 					} 					break; 				}  #if ENABLE_PIPES 				case "win": 				{ 					Transport transport = new PipeTransport (); 					transport.Open (entry); 					return transport; 				} #endif  				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/ 				case "autolaunch": 				{ 					if (OSHelpers.PlatformIsUnixoid) 						break;  					string addr = Address.GetSessionBusAddressFromSharedMemory ();  					if (string.IsNullOrEmpty (addr)) { // we have to launch the daemon ourselves 						string oldDir = Directory.GetCurrentDirectory (); 						// Without this' the "current" folder for the new process will be the one where the current 						// executable resides' and as a consequence'that folder cannot be relocated/deleted unless the daemon is stopped 						Directory.SetCurrentDirectory (Environment.GetFolderPath (Environment.SpecialFolder.System));  						Process process = Process.Start (DBUS_DAEMON_LAUNCH_COMMAND); 						if (process == null) { 							Directory.SetCurrentDirectory (oldDir); 							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'"); 						}  						// wait for daemon 						Stopwatch stopwatch = new Stopwatch (); 						stopwatch.Start (); 						do { 							addr = Address.GetSessionBusAddressFromSharedMemory (); 							if (String.IsNullOrEmpty (addr)) 								Thread.Sleep (100); 						} while (String.IsNullOrEmpty (addr) && stopwatch.ElapsedMilliseconds <= 5000);  						Directory.SetCurrentDirectory (oldDir); 					}  					if (string.IsNullOrEmpty (addr)) 						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon");  					return Create (AddressEntry.Parse (addr)); 				}  			}
