Implementation smell,Namespace,Class,File,Method,Description
Long Method,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The method has 124 lines of code.
Complex Method,DBus,SaslPeer,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 10
Complex Method,DBus,SaslClient,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 9
Complex Method,DBus,SaslServer,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,DBus,Mapper,C:\repos\mono_dbus-sharp\src\Mapper.cs,GetMethod,Cyclomatic complexity of the method is 8
Complex Method,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,Implement,Cyclomatic complexity of the method is 10
Complex Method,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,Cyclomatic complexity of the method is 15
Complex Method,DBus,AddressEntry,C:\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,DBus.Authentication,SaslPeer,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 10
Complex Method,DBus.Authentication,SaslClient,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 9
Complex Method,DBus.Authentication,SaslServer,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,MatchRule,C:\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Test,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,MatchRule,C:\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,StepOver,Cyclomatic complexity of the method is 13
Complex Method,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteArray,Cyclomatic complexity of the method is 8
Complex Method,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetFixedSize,Cyclomatic complexity of the method is 12
Complex Method,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,TypeToDType,Cyclomatic complexity of the method is 13
Complex Method,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSig,Cyclomatic complexity of the method is 13
Complex Method,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,Cyclomatic complexity of the method is 11
Long Parameter List,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,SendSignal,The method has 6 parameters. Parameters: iface' member' inSigStr' writer' retType' exception
Long Parameter List,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,SendSignal,The method has 7 parameters. Parameters: iface' member' inSigStr' writer' retType' disposableList' exception
Long Parameter List,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,SendMethodCall,The method has 6 parameters. Parameters: iface' member' inSigStr' writer' retType' exception
Long Parameter List,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,SendMethodCall,The method has 7 parameters. Parameters: iface' member' inSigStr' writer' retType' disposableList' exception
Long Parameter List,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The method has 6 parameters. Parameters: methodBase' methodName' inArgs' outArgs' retVal' exception
Long Parameter List,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The method has 7 parameters. Parameters: methodBase' methodName' inArgs' disposableList' outArgs' retVal' exception
Long Parameter List,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The method has 5 parameters. Parameters: ilg' declMethod' invokeMethod' interface' member
Long Parameter List,DBus.Unix,UnixMonoStream,C:\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,SendmsgShort,The method has 7 parameters. Parameters: buffer1' offset1' length1' buffer2' offset2' length2' fds
Long Parameter List,DBus.Unix,UnixMonoStream,C:\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,Sendmsg,The method has 7 parameters. Parameters: buffer1' offset1' length1' buffer2' offset2' length2' fds
Long Identifier,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,,The length of the parameter argumentNullExceptionConstructor is 32.
Long Statement,DBus,Address,C:\repos\mono_dbus-sharp\src\Address.cs,GetSessionBusAddressFromSharedMemory,The length of the statement  "				result = OSHelpers.ReadSharedMemoryString ("DBusDaemonAddressInfoDebug"' 255); // a DEBUG build of the daemon uses this different address...             " is 140.
Long Statement,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,SendMethodCall,The length of the statement  "				throw new Exception ("Got unexpected message of type " + retMsg.Header.MessageType + " while waiting for a MethodReturn or Error"); " is 131.
Long Statement,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,HandleMessage,The length of the statement  "							Console.Error.WriteLine ("Unexpected reply message received: MessageType='" + msg.Header.MessageType + "'' ReplySerial=" + reply_serial); " is 137.
Long Statement,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,HandleMethodCall,The length of the statement  "			//TODO: Ping and Introspect need to be abstracted and moved somewhere more appropriate once message filter infrastructure is complete " is 133.
Long Statement,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,HandleMethodCall,The length of the statement  "			//FIXME: these special cases are slightly broken for the case where the member but not the interface is specified in the message " is 128.
Long Statement,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,GetObject,The length of the statement  "					Console.Error.WriteLine ("Warning: Note that MarshalByRefObject use is not recommended; for best performance' define interfaces"); " is 130.
Long Statement,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,Register,The length of the statement  "			//TODO: implement some kind of tree data structure or internal object hierarchy. right now we are ignoring the name and putting all object paths in one namespace' which is bad " is 175.
Long Statement,DBus,DProxy,C:\repos\mono_dbus-sharp\src\DProxy.cs,Invoke,The length of the statement  "			busObject.Invoke (callMessage.MethodBase' callMessage.MethodName' callMessage.InArgs' out outArgs' out retVal' out exception); " is 126.
Long Statement,DBus,Introspector,C:\repos\mono_dbus-sharp\src\Introspection.cs,GetProductDescription,The length of the statement  "			AssemblyInformationalVersionAttribute iversion = Attribute.GetCustomAttribute (assembly' typeof (AssemblyInformationalVersionAttribute)) as AssemblyInformationalVersionAttribute; " is 178.
Long Statement,DBus,Introspector,C:\repos\mono_dbus-sharp\src\Introspection.cs,WriteArg,The length of the statement  "			//we can't rely on the default direction (qt-dbus requires a direction at time of writing)' so we use a boolean to reverse the parameter direction and make it explicit " is 167.
Long Statement,DBus,Introspector,C:\repos\mono_dbus-sharp\src\Introspection.cs,WriteInterface,The length of the statement  "						Console.Error.WriteLine ("Warning: Unhandled MemberType '{0}' encountered while introspecting {1}"' mbi.MemberType' type.FullName); " is 131.
Long Statement,DBus,Mapper,C:\repos\mono_dbus-sharp\src\Mapper.cs,GetMethod,The length of the statement  "				//this could be made more efficient by using the given interface name earlier and avoiding walking through all public interfaces " is 128.
Long Statement,DBus,MessageHelper,C:\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "			//TODO: this validation check should provide better information' eg. message dump or a stack trace' or at least the interface/member " is 132.
Long Statement,DBus,MessageHelper,C:\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "					Console.Error.WriteLine ("Warning: The signature of the message does not match that of the handler: " + "Expected '" + expected + "'' got '" + actual + "'"); " is 157.
Long Statement,DBus,MessageHelper,C:\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "			//TODO: this validation check should provide better information' eg. message dump or a stack trace' or at least the interface/member " is 132.
Long Statement,DBus,MessageHelper,C:\repos\mono_dbus-sharp\src\Mapper.cs,GetDynamicValues,The length of the statement  "					Console.Error.WriteLine ("Warning: The signature of the message does not match that of the handler: " + "Expected '" + expected + "'' got '" + actual + "'"); " is 157.
Long Statement,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,Implement,The length of the statement  "				PropertyBuilder prop_builder = typeB.DefineProperty (declProp.Name' declProp.Attributes' declProp.PropertyType' indexers.ToArray ()); " is 133.
Long Statement,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GetHookupMethod,The length of the statement  "			DynamicMethod hookupMethod = new DynamicMethod ("Handle" + member' declMethod.ReturnType' hookupParms' typeof (MessageWriter)); " is 127.
Long Statement,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GetWriteMethod,The length of the statement  "			DynamicMethod method_builder = new DynamicMethod ("Write" + t.Name' typeof (void)' new Type[] {typeof (MessageWriter)' t}' typeof (MessageWriter)' true); " is 153.
Long Statement,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenWriter,The length of the statement  "			MethodInfo exactWriteMethod = typeof (MessageWriter).GetMethod ("Write"' BindingFlags.ExactBinding | BindingFlags.Instance | BindingFlags.Public' null' new Type[] {tUnder}' null); " is 179.
Long Statement,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenWriter,The length of the statement  "			} else if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (IDictionary<'>) || type.GetGenericTypeDefinition () == typeof (Dictionary<'>))) { " is 159.
Long Statement,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenReadMethod,The length of the statement  "			Type[] parms = new Type[] { typeof (object)' typeof (MessageReader)' typeof (Message)' typeof (MessageWriter)' typeof (DisposableList) }; " is 137.
Long Statement,DBus,UnixFD,C:\repos\mono_dbus-sharp\src\UnixFD.cs,Dispose,The length of the statement  "					// Don't retry close() on EINTR' on a lot of systems (e.g. Linux) the FD will be already closed when EINTR is returned' see https://lwn.net/Articles/576478/ " is 156.
Long Statement,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadValue,The length of the statement  "			} else if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (Dictionary<'>) || type.GetGenericTypeDefinition() == typeof(IDictionary<'>))) { " is 157.
Long Statement,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadSignature,The length of the statement  "				throw new Exception ("Signature length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxSignatureLength + " bytes"); " is 129.
Long Statement,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadVariant,The length of the statement  "				throw new InvalidOperationException (string.Format ("ReadVariant need a single complete type signature' {0} was given"' sig.ToString ())); " is 138.
Long Statement,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadValue,The length of the statement  "				throw new ArgumentException (string.Format ("ReadVariant need a single complete type signature' {0} was given"' sig.ToString ())); " is 130.
Long Statement,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The length of the statement  "			MethodInfo mi = this.GetType ().GetMethod ("ReadDictionary"' Type.EmptyTypes).MakeGenericMethod (new [] { keyType' valType }); " is 126.
Long Statement,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The length of the statement  "				throw new Exception ("Dict length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes"); " is 120.
Long Statement,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadArray,The length of the statement  "				throw new Exception ("Array length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes"); " is 121.
Long Statement,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,Write,The length of the statement  "				throw new Exception ("Signature length " + ascii_data.Length + " exceeds maximum allowed " + ProtocolInformation.MaxSignatureLength + " bytes"); " is 144.
Long Statement,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,Write,The length of the statement  "			} else if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (IDictionary<'>) || type.GetGenericTypeDefinition () == typeof (Dictionary<'>))) { " is 159.
Long Statement,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteArray,The length of the statement  "			if (endianness == Connection.NativeEndianness && elemType.IsValueType && !sigElem.IsStruct && elemType != typeof(bool) && sigElem.GetFixedSize (ref fixedSize)) { " is 161.
Long Statement,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,ThrowArrayLengthException,The length of the statement  "			throw new Exception ("Array length " + ln.ToString () + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes"); " is 133.
Long Statement,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteFromDict,The length of the statement  "				throw new Exception ("Dict length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes"); " is 120.
Long Statement,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteHeaderFields,The length of the statement  "				throw new Exception ("Dict length " + ln + " exceeds maximum allowed " + ProtocolInformation.MaxArrayLength + " bytes"); " is 120.
Long Statement,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,TypeToDType,The length of the statement  "			if (type.IsGenericType && (type.GetGenericTypeDefinition() == typeof(IDictionary<'>) || type.GetGenericTypeDefinition() == typeof(Dictionary<'>))) " is 146.
Long Statement,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,ToType,The length of the statement  "				throw new NotSupportedException ("Parsing or converting this signature is not yet supported (signature was '" + this + "')' at DType." + dtype); " is 144.
Long Statement,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSig,The length of the statement  "			if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (IDictionary<'>) || type.GetGenericTypeDefinition () == typeof (Dictionary<'>))) { " is 152.
Long Statement,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The length of the statement  "				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/ " is 162.
Long Statement,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The length of the statement  "							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'"); " is 134.
Long Statement,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The length of the statement  "						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon");  " is 125.
Long Statement,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The length of the statement  "					Console.Error.WriteLine ("Warning: Protocol version '" + version.ToString () + "' is not explicitly supported but may be compatible"); " is 134.
Long Statement,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The length of the statement  "				throw new Exception ("Message length " + msgLength + " exceeds maximum allowed " + ProtocolInformation.MaxMessageLength + " bytes"); " is 132.
Long Statement,DBus.Transports,UnixSendmsgTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixSendmsgTransport.cs,WriteMessage,The length of the statement  "				((DBus.Unix.UnixMonoStream) Stream).Sendmsg (header' 0' header.Length' msg.Body' 0' msg.Body == null ? 0 : msg.Body.Length' msg.UnixFDArray); " is 141.
Long Statement,DBus.Unix,UnixMonoStream,C:\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,SendmsgShort,The length of the statement  "			//Console.WriteLine ("SendmsgShort (X' {0}' {1}' {2}' {3}' {4}' {5})"' offset1' length1' buffer2 == null ? "-" : "Y"' offset2' length2' fds == null ? "-" : "" + fds.FDs.Count); " is 176.
Long Statement,DBus.Unix,UnixMonoStream,C:\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,Sendmsg,The length of the statement  "					written += SendmsgShort (buffer1' offset1 + written' length1 - written' buffer2' offset2' length2' written == 0 ? fds : null); " is 126.
Complex Conditional,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The conditional expression  "mi != null && mi.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))"  is complex.
Complex Conditional,DBus,AddressEntry,C:\repos\mono_dbus-sharp\src\AddressEntry.cs,Escape,The conditional expression  "(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')  				    || c == '-' || c == '_' || c == '/' || c == '\\' || c == '.'"  is complex.
Complex Conditional,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteArray,The conditional expression  "endianness == Connection.NativeEndianness && elemType.IsValueType && !sigElem.IsStruct && elemType != typeof(bool) && sigElem.GetFixedSize (ref fixedSize)"  is complex.
Complex Conditional,DBus.Transports,UnixSendmsgTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixSendmsgTransport.cs,ReadShort,The conditional expression  "length < 0 || offset < 0 || length + offset < length || length + offset > buffer.Length"  is complex.
Magic Number,DBus,Address,C:\repos\mono_dbus-sharp\src\Address.cs,GetSessionBusAddressFromSharedMemory,The following statement contains a magic number: string result = OSHelpers.ReadSharedMemoryString ("DBusDaemonAddressInfo"' 255);
Magic Number,DBus,Address,C:\repos\mono_dbus-sharp\src\Address.cs,GetSessionBusAddressFromSharedMemory,The following statement contains a magic number: if (String.IsNullOrEmpty(result))  				result = OSHelpers.ReadSharedMemoryString ("DBusDaemonAddressInfoDebug"' 255);
Magic Number,DBus,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder (ByteLength * 2);
Magic Number,DBus,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,Parse,The following statement contains a magic number: if (hex.Length != ByteLength * 2)  				throw new Exception ("Cannot parse UUID/GUID of invalid length");
Magic Number,DBus,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,Parse,The following statement contains a magic number: while (n < ByteLength) {  				result[n] = (byte)(Sasl.FromHexChar (hex[i++]) << 4);  				result[n++] += Sasl.FromHexChar (hex[i++]);  			}
Magic Number,DBus,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,Generate,The following statement contains a magic number: lock (buf) {  				rand.NextBytes (buf);  				fixed (byte* bp = &buf[0]) {  					int* p = (int*)bp;  					id.a = p[0];  					id.b = p[1];  					id.c = p[2];  				}  			}
Magic Number,DBus,SaslServer,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,The following statement contains a magic number: while (true) {  				Peer.isFinalRead = false;    				AuthCommand reply;  				if (!replies.MoveNext ()) {  					yield return null;  					yield break;  					//continue;  				}  				reply = replies.Current;    				Match m = authRegex.Match (reply.Value);  				if (!m.Success) {  					yield return new AuthCommand ("ERROR");  					continue;  				}    				string mechanism = m.Groups[1].Value;  				string initialResponse = m.Groups[2].Value;    				if (mechanism == "EXTERNAL") {  					try {  						byte[] bs = Sasl.FromHex (initialResponse);  						string authStr = Encoding.ASCII.GetString (bs);  						uid = UInt32.Parse (authStr);  					} catch {  						uid = 0;  					}  					//return RunExternal (Run ()' initialResponse);  				} else {  					yield return new AuthCommand ("REJECTED " + String.Join (" "' supportedMechanisms));  					continue;  				}    				if (Guid == UUID.Zero)  					yield return new AuthCommand ("OK");  				else  					yield return new AuthCommand ("OK " + Guid.ToString ());    				Peer.isFinalRead = true;    				if (!replies.MoveNext ()) {  					/*  					yield break;  					continue;  					*/  					yield return null;  					yield break;  				}    				reply = replies.Current;  				if (reply.Value != "BEGIN") {  					yield return new AuthCommand ("ERROR");  					continue;  				}    				yield break;  			}
Magic Number,DBus,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,UnixToDateTime,The following statement contains a magic number: DateTime LocalUnixEpoch = new DateTime (1970' 1' 1);
Magic Number,DBus,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,DateTimeToUnix,The following statement contains a magic number: DateTime LocalUnixEpoch = new DateTime (1970' 1' 1);
Magic Number,DBus,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,ToHex,The following statement contains a magic number: StringBuilder sb = new StringBuilder (input.Length * 2);
Magic Number,DBus,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'a') && (c <= 'f'))  				return (byte) (c - 'a' + 10);
Magic Number,DBus,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'A') && (c <= 'F'))  				return (byte) (c - 'A' + 10);
Magic Number,DBus,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,FromHex,The following statement contains a magic number: while (n < result.Length) {  				result [n] = (byte) (FromHexChar (hex [i++]) << 4);  				result [n++] += FromHexChar (hex [i++]);  			}
Magic Number,DBus,BusObject,C:\repos\mono_dbus-sharp\src\BusObject.cs,Invoke,The following statement contains a magic number: if (mi != null && mi.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  				string[] parts = methodName.Split (new char[]{'_'}' 2);  				string ename = parts[1];  				Delegate dlg = (Delegate)inArgs[0];    				ToggleSignal (Mapper.GetInterfaceName (mi)' ename' dlg' parts[0] == "add");    				return;  			}
Magic Number,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,ReadMachineId,The following statement contains a magic number: if (data.Length < 33)  				return UUID.Zero;
Magic Number,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,ReadMachineId,The following statement contains a magic number: return UUID.Parse (System.Text.Encoding.ASCII.GetString (data' 0' 32));
Magic Number,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The following statement contains a magic number: if (declMethod.IsSpecialName && (declMethod.Name.StartsWith ("add_") || declMethod.Name.StartsWith ("remove_"))) {  				string[] parts = declMethod.Name.Split (new char[]{'_'}' 2);  				string ename = parts[1];    				bool adding = parts[0] == "add";    				ilg.Emit (OpCodes.Ldstr' ename);    				ilg.Emit (OpCodes.Ldarg_1);    				ilg.Emit (OpCodes.Ldc_I4' adding ? 1 : 0);    				ilg.Emit (OpCodes.Tailcall);  				ilg.Emit (toggleSignalMethod.IsFinal ? OpCodes.Call : OpCodes.Callvirt' toggleSignalMethod);  				ilg.Emit (OpCodes.Ret);  				return;  			}
Magic Number,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The following statement contains a magic number: if (declMethod.IsSpecialName) {  				if (member.StartsWith ("get_"))  					member = "Get" + member.Substring (4);  				else if (member.StartsWith ("set_"))  					member = "Set" + member.Substring (4);  			}
Magic Number,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,GenHookupMethod,The following statement contains a magic number: if (declMethod.IsSpecialName) {  				if (member.StartsWith ("get_"))  					member = "Get" + member.Substring (4);  				else if (member.StartsWith ("set_"))  					member = "Set" + member.Substring (4);  			}
Magic Number,DBus,TypeImplementer,C:\repos\mono_dbus-sharp\src\TypeImplementer.cs,Gen,The following statement contains a magic number: foreach (ParameterInfo parm in parms) {  				Type parmType = parm.ParameterType;    				if (parm.Position == 0 && !parm.IsOut && parmType == typeof (DisposableList)) {  					ilg.Emit (OpCodes.Ldarg' 4); // disposableList  					continue;  				}    				if (parm.IsOut) {  					LocalBuilder parmLocal = ilg.DeclareLocal (parmType.GetElementType ());  					locals[parm] = parmLocal;  					ilg.Emit (OpCodes.Ldloca' parmLocal);  					continue;  				}    				ilg.Emit (OpCodes.Ldarg_1);  				GenReader (ilg' parmType);  			}
Magic Number,DBus,AddressEntry,C:\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: if (parts.Length < 2)  				throw new InvalidAddressException ("No colon found");
Magic Number,DBus,AddressEntry,C:\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: if (parts.Length > 2)  				throw new InvalidAddressException ("Too many colons found");
Magic Number,DBus,AddressEntry,C:\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: if (parts[1].Length > 0) {  				foreach (string propStr in parts[1].Split (''')) {  					parts = propStr.Split ('=');    					if (parts.Length < 2)  						throw new InvalidAddressException ("No equals sign found");  					if (parts.Length > 2)  						throw new InvalidAddressException ("Too many equals signs found");    					if (parts[0] == "guid") {  						try {  							entry.GUID = UUID.Parse (parts[1]);  						} catch {  							throw new InvalidAddressException ("Invalid guid specified");  						}  						continue;  					}    					entry.Properties[parts[0]] = Unescape (parts[1]);  				}  			}
Magic Number,DBus,AddressEntry,C:\repos\mono_dbus-sharp\src\AddressEntry.cs,Parse,The following statement contains a magic number: if (parts[1].Length > 0) {  				foreach (string propStr in parts[1].Split (''')) {  					parts = propStr.Split ('=');    					if (parts.Length < 2)  						throw new InvalidAddressException ("No equals sign found");  					if (parts.Length > 2)  						throw new InvalidAddressException ("Too many equals signs found");    					if (parts[0] == "guid") {  						try {  							entry.GUID = UUID.Parse (parts[1]);  						} catch {  							throw new InvalidAddressException ("Invalid guid specified");  						}  						continue;  					}    					entry.Properties[parts[0]] = Unescape (parts[1]);  				}  			}
Magic Number,DBus.Authentication,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder (ByteLength * 2);
Magic Number,DBus.Authentication,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,Parse,The following statement contains a magic number: if (hex.Length != ByteLength * 2)  				throw new Exception ("Cannot parse UUID/GUID of invalid length");
Magic Number,DBus.Authentication,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,Parse,The following statement contains a magic number: while (n < ByteLength) {  				result[n] = (byte)(Sasl.FromHexChar (hex[i++]) << 4);  				result[n++] += Sasl.FromHexChar (hex[i++]);  			}
Magic Number,DBus.Authentication,UUID,C:\repos\mono_dbus-sharp\src\Authentication.cs,Generate,The following statement contains a magic number: lock (buf) {  				rand.NextBytes (buf);  				fixed (byte* bp = &buf[0]) {  					int* p = (int*)bp;  					id.a = p[0];  					id.b = p[1];  					id.c = p[2];  				}  			}
Magic Number,DBus.Authentication,SaslServer,C:\repos\mono_dbus-sharp\src\Authentication.cs,GetEnumerator,The following statement contains a magic number: while (true) {  				Peer.isFinalRead = false;    				AuthCommand reply;  				if (!replies.MoveNext ()) {  					yield return null;  					yield break;  					//continue;  				}  				reply = replies.Current;    				Match m = authRegex.Match (reply.Value);  				if (!m.Success) {  					yield return new AuthCommand ("ERROR");  					continue;  				}    				string mechanism = m.Groups[1].Value;  				string initialResponse = m.Groups[2].Value;    				if (mechanism == "EXTERNAL") {  					try {  						byte[] bs = Sasl.FromHex (initialResponse);  						string authStr = Encoding.ASCII.GetString (bs);  						uid = UInt32.Parse (authStr);  					} catch {  						uid = 0;  					}  					//return RunExternal (Run ()' initialResponse);  				} else {  					yield return new AuthCommand ("REJECTED " + String.Join (" "' supportedMechanisms));  					continue;  				}    				if (Guid == UUID.Zero)  					yield return new AuthCommand ("OK");  				else  					yield return new AuthCommand ("OK " + Guid.ToString ());    				Peer.isFinalRead = true;    				if (!replies.MoveNext ()) {  					/*  					yield break;  					continue;  					*/  					yield return null;  					yield break;  				}    				reply = replies.Current;  				if (reply.Value != "BEGIN") {  					yield return new AuthCommand ("ERROR");  					continue;  				}    				yield break;  			}
Magic Number,DBus.Authentication,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,UnixToDateTime,The following statement contains a magic number: DateTime LocalUnixEpoch = new DateTime (1970' 1' 1);
Magic Number,DBus.Authentication,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,DateTimeToUnix,The following statement contains a magic number: DateTime LocalUnixEpoch = new DateTime (1970' 1' 1);
Magic Number,DBus.Authentication,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,ToHex,The following statement contains a magic number: StringBuilder sb = new StringBuilder (input.Length * 2);
Magic Number,DBus.Authentication,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'a') && (c <= 'f'))  				return (byte) (c - 'a' + 10);
Magic Number,DBus.Authentication,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'A') && (c <= 'F'))  				return (byte) (c - 'A' + 10);
Magic Number,DBus.Authentication,Sasl,C:\repos\mono_dbus-sharp\src\Authentication.cs,FromHex,The following statement contains a magic number: while (n < result.Length) {  				result [n] = (byte) (FromHexChar (hex [i++]) << 4);  				result [n++] += FromHexChar (hex [i++]);  			}
Magic Number,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: if (innerTypes == null || innerTypes.Length == 0 || innerTypes.Length > 7)  				throw new NotSupportedException ("Can't create a valid type for the provided signature");
Magic Number,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) {  			case 1:  				structType = typeof (DBusStruct<>);  				break;  			case 2:  				structType = typeof (DBusStruct<'>);  				break;  			case 3:  				structType = typeof (DBusStruct<''>);  				break;  			case 4:  				structType = typeof (DBusStruct<'''>);  				break;  			case 5:  				structType = typeof (DBusStruct<''''>);  				break;  			case 6:  				structType = typeof (DBusStruct<'''''>);  				break;  			case 7:  				structType = typeof (DBusStruct<''''''>);  				break;  			}
Magic Number,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) {  			case 1:  				structType = typeof (DBusStruct<>);  				break;  			case 2:  				structType = typeof (DBusStruct<'>);  				break;  			case 3:  				structType = typeof (DBusStruct<''>);  				break;  			case 4:  				structType = typeof (DBusStruct<'''>);  				break;  			case 5:  				structType = typeof (DBusStruct<''''>);  				break;  			case 6:  				structType = typeof (DBusStruct<'''''>);  				break;  			case 7:  				structType = typeof (DBusStruct<''''''>);  				break;  			}
Magic Number,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) {  			case 1:  				structType = typeof (DBusStruct<>);  				break;  			case 2:  				structType = typeof (DBusStruct<'>);  				break;  			case 3:  				structType = typeof (DBusStruct<''>);  				break;  			case 4:  				structType = typeof (DBusStruct<'''>);  				break;  			case 5:  				structType = typeof (DBusStruct<''''>);  				break;  			case 6:  				structType = typeof (DBusStruct<'''''>);  				break;  			case 7:  				structType = typeof (DBusStruct<''''''>);  				break;  			}
Magic Number,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) {  			case 1:  				structType = typeof (DBusStruct<>);  				break;  			case 2:  				structType = typeof (DBusStruct<'>);  				break;  			case 3:  				structType = typeof (DBusStruct<''>);  				break;  			case 4:  				structType = typeof (DBusStruct<'''>);  				break;  			case 5:  				structType = typeof (DBusStruct<''''>);  				break;  			case 6:  				structType = typeof (DBusStruct<'''''>);  				break;  			case 7:  				structType = typeof (DBusStruct<''''''>);  				break;  			}
Magic Number,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) {  			case 1:  				structType = typeof (DBusStruct<>);  				break;  			case 2:  				structType = typeof (DBusStruct<'>);  				break;  			case 3:  				structType = typeof (DBusStruct<''>);  				break;  			case 4:  				structType = typeof (DBusStruct<'''>);  				break;  			case 5:  				structType = typeof (DBusStruct<''''>);  				break;  			case 6:  				structType = typeof (DBusStruct<'''''>);  				break;  			case 7:  				structType = typeof (DBusStruct<''''''>);  				break;  			}
Magic Number,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following statement contains a magic number: switch (innerTypes.Length) {  			case 1:  				structType = typeof (DBusStruct<>);  				break;  			case 2:  				structType = typeof (DBusStruct<'>);  				break;  			case 3:  				structType = typeof (DBusStruct<''>);  				break;  			case 4:  				structType = typeof (DBusStruct<'''>);  				break;  			case 5:  				structType = typeof (DBusStruct<''''>);  				break;  			case 6:  				structType = typeof (DBusStruct<'''''>);  				break;  			case 7:  				structType = typeof (DBusStruct<''''''>);  				break;  			}
Magic Number,DBus.Protocol,Header,C:\repos\mono_dbus-sharp\src\Protocol\Header.cs,FromBytes,The following statement contains a magic number: header.Flags = (HeaderFlag)data[2];
Magic Number,DBus.Protocol,Header,C:\repos\mono_dbus-sharp\src\Protocol\Header.cs,FromBytes,The following statement contains a magic number: header.MajorVersion = data[3];
Magic Number,DBus.Protocol,Header,C:\repos\mono_dbus-sharp\src\Protocol\Header.cs,FromBytes,The following statement contains a magic number: reader.Seek (4);
Magic Number,DBus.Protocol,MatchRule,C:\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Parse,The following statement contains a magic number: for (Match m = matchRuleRegex.Match (text) ; m.Success ; m = m.NextMatch ()) {  				string key = m.Groups[1].Value;  				string value = m.Groups[2].Value;  				// This unescaping may not be perfect..  				value = value.Replace (@"\\"' @"\");  				value = value.Replace (@"\'"' @"'");    				if (key.StartsWith ("arg")) {  					Match mArg = argNRegex.Match (key);  					if (!mArg.Success)  						return null;  					int argNum = (int)UInt32.Parse (mArg.Groups[1].Value);    					if (argNum < 0 || argNum >= ProtocolInformation.MaxMatchRuleArgs)  						throw new Exception ("arg match must be between 0 and " + (ProtocolInformation.MaxMatchRuleArgs - 1) + " inclusive");    					//if (r.Args.ContainsKey (argNum))  					//	return null;    					string argType = mArg.Groups[2].Value;    					if (argType == "path")  						r.Args.Add (new ArgMatchTest (argNum' new ObjectPath (value)));  					else  						r.Args.Add (new ArgMatchTest (argNum' value));    					continue;  				}    				//TODO: more consistent error handling  				switch (key) {  					case "type":  						if (r.MessageType != MessageType.All)  							return null;  						r.MessageType = MessageFilter.StringToMessageType (value);  						break;  					case "interface":  						r.Fields[FieldCode.Interface] = new MatchTest (value);  						break;  					case "member":  						r.Fields[FieldCode.Member] = new MatchTest (value);  						break;  					case "path":  						r.Fields[FieldCode.Path] = new MatchTest (new ObjectPath (value));  						break;  					case "sender":  						r.Fields[FieldCode.Sender] = new MatchTest (value);  						break;  					case "destination":  						r.Fields[FieldCode.Destination] = new MatchTest (value);  						break;  					default:  						if (ProtocolInformation.Verbose)  							Console.Error.WriteLine ("Warning: Unrecognized match rule key: " + key);  						break;  				}  			}
Magic Number,DBus.Protocol,MatchRule,C:\repos\mono_dbus-sharp\src\Protocol\MatchRule.cs,Parse,The following statement contains a magic number: for (Match m = matchRuleRegex.Match (text) ; m.Success ; m = m.NextMatch ()) {  				string key = m.Groups[1].Value;  				string value = m.Groups[2].Value;  				// This unescaping may not be perfect..  				value = value.Replace (@"\\"' @"\");  				value = value.Replace (@"\'"' @"'");    				if (key.StartsWith ("arg")) {  					Match mArg = argNRegex.Match (key);  					if (!mArg.Success)  						return null;  					int argNum = (int)UInt32.Parse (mArg.Groups[1].Value);    					if (argNum < 0 || argNum >= ProtocolInformation.MaxMatchRuleArgs)  						throw new Exception ("arg match must be between 0 and " + (ProtocolInformation.MaxMatchRuleArgs - 1) + " inclusive");    					//if (r.Args.ContainsKey (argNum))  					//	return null;    					string argType = mArg.Groups[2].Value;    					if (argType == "path")  						r.Args.Add (new ArgMatchTest (argNum' new ObjectPath (value)));  					else  						r.Args.Add (new ArgMatchTest (argNum' value));    					continue;  				}    				//TODO: more consistent error handling  				switch (key) {  					case "type":  						if (r.MessageType != MessageType.All)  							return null;  						r.MessageType = MessageFilter.StringToMessageType (value);  						break;  					case "interface":  						r.Fields[FieldCode.Interface] = new MatchTest (value);  						break;  					case "member":  						r.Fields[FieldCode.Member] = new MatchTest (value);  						break;  					case "path":  						r.Fields[FieldCode.Path] = new MatchTest (new ObjectPath (value));  						break;  					case "sender":  						r.Fields[FieldCode.Sender] = new MatchTest (value);  						break;  					case "destination":  						r.Fields[FieldCode.Destination] = new MatchTest (value);  						break;  					default:  						if (ProtocolInformation.Verbose)  							Console.Error.WriteLine ("Warning: Unrecognized match rule key: " + key);  						break;  				}  			}
Magic Number,DBus.Protocol,MessageDumper,C:\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,WriteBlock,The following statement contains a magic number: if (Body != null)  			for (int i = 0 ; i != Body.Length ; i++) {  				if (i == 0) {}  				else if (i % 32 == 0)  					w.WriteLine ();  				else if (i % 4 == 0)  					w.Write (' ');    				w.Write (Body[i].ToString ("x2"' System.Globalization.CultureInfo.InvariantCulture));  			}
Magic Number,DBus.Protocol,MessageDumper,C:\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,WriteBlock,The following statement contains a magic number: if (Body != null)  			for (int i = 0 ; i != Body.Length ; i++) {  				if (i == 0) {}  				else if (i % 32 == 0)  					w.WriteLine ();  				else if (i % 4 == 0)  					w.Write (' ');    				w.Write (Body[i].ToString ("x2"' System.Globalization.CultureInfo.InvariantCulture));  			}
Magic Number,DBus.Protocol,MessageDumper,C:\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'a') && (c <= 'f'))  				return (byte) (c - 'a' + 10);
Magic Number,DBus.Protocol,MessageDumper,C:\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'A') && (c <= 'F'))  				return (byte) (c - 'A' + 10);
Magic Number,DBus.Protocol,MessageDumper,C:\repos\mono_dbus-sharp\src\Protocol\MessageDumper.cs,ReadFromHex,The following statement contains a magic number: while (i < hex.Length) {  				if (char.IsWhiteSpace (hex [i])) {  					i++;  					continue;  				}    				if (hex [i] == '.') {  					ms.Flush ();  					return false;  				}    				byte res = (byte) (FromHexChar (hex [i++]) << 4);  				res += FromHexChar (hex [i++]);  				ms.WriteByte (res);  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUShort,The following statement contains a magic number: ReadPad (2);
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUShort,The following statement contains a magic number: if (data.Length < pos + 2)  				throw new Exception ("Cannot read beyond end of data");
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUShort,The following statement contains a magic number: pos += 2;
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: ReadPad (4);
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: if (data.Length < pos + 4)  				throw new Exception ("Cannot read beyond end of data");
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &data[pos])  					*((uint*)dstPtr) = *((uint*)p);  			} else {  				byte* dst = (byte*)dstPtr;  				dst[0] = data[pos + 3];  				dst[1] = data[pos + 2];  				dst[2] = data[pos + 1];  				dst[3] = data[pos + 0];  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &data[pos])  					*((uint*)dstPtr) = *((uint*)p);  			} else {  				byte* dst = (byte*)dstPtr;  				dst[0] = data[pos + 3];  				dst[1] = data[pos + 2];  				dst[2] = data[pos + 1];  				dst[3] = data[pos + 0];  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &data[pos])  					*((uint*)dstPtr) = *((uint*)p);  			} else {  				byte* dst = (byte*)dstPtr;  				dst[0] = data[pos + 3];  				dst[1] = data[pos + 2];  				dst[2] = data[pos + 1];  				dst[3] = data[pos + 0];  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &data[pos])  					*((uint*)dstPtr) = *((uint*)p);  			} else {  				byte* dst = (byte*)dstPtr;  				dst[0] = data[pos + 3];  				dst[1] = data[pos + 2];  				dst[2] = data[pos + 1];  				dst[3] = data[pos + 0];  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalUInt,The following statement contains a magic number: pos += 4;
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: if (data.Length < pos + 8)  				throw new Exception ("Cannot read beyond end of data");
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &data[pos])  					*((ulong*)dstPtr) = *((ulong*)p);  			} else {  				byte* dst = (byte*)dstPtr;  				for (int i = 0; i < 8; ++i)  					dst[i] = data[pos + (7 - i)];  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &data[pos])  					*((ulong*)dstPtr) = *((ulong*)p);  			} else {  				byte* dst = (byte*)dstPtr;  				for (int i = 0; i < 8; ++i)  					dst[i] = data[pos + (7 - i)];  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,MarshalULong,The following statement contains a magic number: pos += 8;
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The following statement contains a magic number: var val = new Dictionary<TKey' TValue> ((int)(ln / 8));
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadDictionary,The following statement contains a magic number: while (pos < endPos) {  				ReadPad (8);  				TKey k = (TKey)ReadValue (typeof (TKey));  				TValue v = (TValue)ReadValue (typeof (TValue));  				val.Add (k' v);  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,DirectCopy,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				Marshal.Copy (data' pos' handle' (int)length);  			} else {  				byte* ptr = (byte*)(void*)handle;  				for (int i = pos; i < pos + length; i += sof)  					for (int j = i; j < i + sof; j++)  						ptr[2 * i - pos + (sof - 1) - j] = data[j];  			}
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadStruct,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageReader,C:\repos\mono_dbus-sharp\src\Protocol\MessageReader.cs,ReadStruct,The following statement contains a magic number: ReadPad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,CloseWrite,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUShort,The following statement contains a magic number: WritePad (2);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUShort,The following statement contains a magic number: stream.Write (dst' 0' 2);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: WritePad (4);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &dst[0])  					*((uint*)p) = *((uint*)dataPtr);  			} else {  				byte* data = (byte*)dataPtr;  				dst[0] = data[3];  				dst[1] = data[2];  				dst[2] = data[1];  				dst[3] = data[0];  			}
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &dst[0])  					*((uint*)p) = *((uint*)dataPtr);  			} else {  				byte* data = (byte*)dataPtr;  				dst[0] = data[3];  				dst[1] = data[2];  				dst[2] = data[1];  				dst[3] = data[0];  			}
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &dst[0])  					*((uint*)p) = *((uint*)dataPtr);  			} else {  				byte* data = (byte*)dataPtr;  				dst[0] = data[3];  				dst[1] = data[2];  				dst[2] = data[1];  				dst[3] = data[0];  			}
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &dst[0])  					*((uint*)p) = *((uint*)dataPtr);  			} else {  				byte* data = (byte*)dataPtr;  				dst[0] = data[3];  				dst[1] = data[2];  				dst[2] = data[1];  				dst[3] = data[0];  			}
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalUInt,The following statement contains a magic number: stream.Write (dst' 0' 4);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalULong,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalULong,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &dst[0])  					*((ulong*)p) = *((ulong*)dataPtr);  			} else {  				byte* data = (byte*)dataPtr;  				for (int i = 0; i < 8; ++i)  					dst[i] = data[7 - i];  			}
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalULong,The following statement contains a magic number: if (endianness == Connection.NativeEndianness) {  				fixed (byte* p = &dst[0])  					*((ulong*)p) = *((ulong*)dataPtr);  			} else {  				byte* data = (byte*)dataPtr;  				for (int i = 0; i < 8; ++i)  					dst[i] = data[7 - i];  			}
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,MarshalULong,The following statement contains a magic number: stream.Write (dst' 0' 8);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteStructure,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteFromDict,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteFromDict,The following statement contains a magic number: foreach (KeyValuePair<TKey'TValue> entry in val) {  				WritePad (8);  				keyWriter (this' entry.Key);  				valueWriter (this' entry.Value);  			}
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteHeaderFields,The following statement contains a magic number: WritePad (8);
Magic Number,DBus.Protocol,MessageWriter,C:\repos\mono_dbus-sharp\src\Protocol\MessageWriter.cs,WriteHeaderFields,The following statement contains a magic number: foreach (KeyValuePair<byte' object> entry in val) {  				WritePad (8);  				Write (entry.Key);  				switch ((FieldCode)entry.Key) {  					case FieldCode.Destination:  					case FieldCode.ErrorName:  					case FieldCode.Interface:  					case FieldCode.Member:  					case FieldCode.Sender:  						Write (Signature.StringSig);  						Write ((string)entry.Value);  						break;  					case FieldCode.Path:  						Write (Signature.ObjectPathSig);  						Write ((ObjectPath)entry.Value);  						break;  					case FieldCode.ReplySerial:  					case FieldCode.UnixFDs:  						Write (Signature.UInt32Sig);  						Write ((uint)entry.Value);  						break;  					default:  						Write (entry.Value);  						break;  				}  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,ProtocolInformation,C:\repos\mono_dbus-sharp\src\Protocol\ProtocolInformation.cs,GetAlignment,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  					return 4;  				case DType.UnixFD:  					return 4;  				case DType.ObjectPath:  					return 4;  				case DType.Signature:  					return 1;  				case DType.Array:  					return 4;  				case DType.StructBegin:  					return 8;  				case DType.Variant:  					return 1;  				case DType.DictEntryBegin:  					return 8;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine alignment of " + dtype);  			}
Magic Number,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  				case DType.UnixFD:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  				case DType.ObjectPath:  				case DType.Signature:  				case DType.Array:  				case DType.StructBegin:  				case DType.Variant:  				case DType.DictEntryBegin:  					return -1;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine size of " + dtype);  			}
Magic Number,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  				case DType.UnixFD:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  				case DType.ObjectPath:  				case DType.Signature:  				case DType.Array:  				case DType.StructBegin:  				case DType.Variant:  				case DType.DictEntryBegin:  					return -1;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine size of " + dtype);  			}
Magic Number,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  				case DType.UnixFD:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  				case DType.ObjectPath:  				case DType.Signature:  				case DType.Array:  				case DType.StructBegin:  				case DType.Variant:  				case DType.DictEntryBegin:  					return -1;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine size of " + dtype);  			}
Magic Number,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  				case DType.UnixFD:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  				case DType.ObjectPath:  				case DType.Signature:  				case DType.Array:  				case DType.StructBegin:  				case DType.Variant:  				case DType.DictEntryBegin:  					return -1;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine size of " + dtype);  			}
Magic Number,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  				case DType.UnixFD:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  				case DType.ObjectPath:  				case DType.Signature:  				case DType.Array:  				case DType.StructBegin:  				case DType.Variant:  				case DType.DictEntryBegin:  					return -1;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine size of " + dtype);  			}
Magic Number,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,GetSize,The following statement contains a magic number: switch (dtype) {  				case DType.Byte:  					return 1;  				case DType.Boolean:  					return 4;  				case DType.Int16:  				case DType.UInt16:  					return 2;  				case DType.Int32:  				case DType.UInt32:  				case DType.UnixFD:  					return 4;  				case DType.Int64:  				case DType.UInt64:  					return 8;  #if !DISABLE_SINGLE  				case DType.Single: //Not yet supported!  					return 4;  #endif  				case DType.Double:  					return 8;  				case DType.String:  				case DType.ObjectPath:  				case DType.Signature:  				case DType.Array:  				case DType.StructBegin:  				case DType.Variant:  				case DType.DictEntryBegin:  					return -1;  				case DType.Invalid:  				default:  					throw new Exception ("Cannot determine size of " + dtype);  			}
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The following statement contains a magic number: switch (entry.Method) {  				case "tcp":  				{  					Transport transport = new SocketTransport ();  					transport.Open (entry);  					return transport;  				}    				case "unix":  				{  					if (OSHelpers.PlatformIsUnixoid) {  						Transport transport;  						if (UnixSendmsgTransport.Available ()) {  							transport = new UnixSendmsgTransport ();  						} else {  							if (ProtocolInformation.Verbose)  								Console.Error.WriteLine ("Warning: Syscall.sendmsg() not available' transfering unix FDs will not work");  							transport = new UnixNativeTransport ();  						}  						transport.Open (entry);  						return transport;  					}  					break;  				}    #if ENABLE_PIPES  				case "win":  				{  					Transport transport = new PipeTransport ();  					transport.Open (entry);  					return transport;  				}  #endif    				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/  				case "autolaunch":  				{  					if (OSHelpers.PlatformIsUnixoid)  						break;    					string addr = Address.GetSessionBusAddressFromSharedMemory ();    					if (string.IsNullOrEmpty (addr)) { // we have to launch the daemon ourselves  						string oldDir = Directory.GetCurrentDirectory ();  						// Without this' the "current" folder for the new process will be the one where the current  						// executable resides' and as a consequence'that folder cannot be relocated/deleted unless the daemon is stopped  						Directory.SetCurrentDirectory (Environment.GetFolderPath (Environment.SpecialFolder.System));    						Process process = Process.Start (DBUS_DAEMON_LAUNCH_COMMAND);  						if (process == null) {  							Directory.SetCurrentDirectory (oldDir);  							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'");  						}    						// wait for daemon  						Stopwatch stopwatch = new Stopwatch ();  						stopwatch.Start ();  						do {  							addr = Address.GetSessionBusAddressFromSharedMemory ();  							if (String.IsNullOrEmpty (addr))  								Thread.Sleep (100);  						} while (String.IsNullOrEmpty (addr) && stopwatch.ElapsedMilliseconds <= 5000);    						Directory.SetCurrentDirectory (oldDir);  					}    					if (string.IsNullOrEmpty (addr))  						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon");   					return Create (AddressEntry.Parse (addr));  				}    			}
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The following statement contains a magic number: switch (entry.Method) {  				case "tcp":  				{  					Transport transport = new SocketTransport ();  					transport.Open (entry);  					return transport;  				}    				case "unix":  				{  					if (OSHelpers.PlatformIsUnixoid) {  						Transport transport;  						if (UnixSendmsgTransport.Available ()) {  							transport = new UnixSendmsgTransport ();  						} else {  							if (ProtocolInformation.Verbose)  								Console.Error.WriteLine ("Warning: Syscall.sendmsg() not available' transfering unix FDs will not work");  							transport = new UnixNativeTransport ();  						}  						transport.Open (entry);  						return transport;  					}  					break;  				}    #if ENABLE_PIPES  				case "win":  				{  					Transport transport = new PipeTransport ();  					transport.Open (entry);  					return transport;  				}  #endif    				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/  				case "autolaunch":  				{  					if (OSHelpers.PlatformIsUnixoid)  						break;    					string addr = Address.GetSessionBusAddressFromSharedMemory ();    					if (string.IsNullOrEmpty (addr)) { // we have to launch the daemon ourselves  						string oldDir = Directory.GetCurrentDirectory ();  						// Without this' the "current" folder for the new process will be the one where the current  						// executable resides' and as a consequence'that folder cannot be relocated/deleted unless the daemon is stopped  						Directory.SetCurrentDirectory (Environment.GetFolderPath (Environment.SpecialFolder.System));    						Process process = Process.Start (DBUS_DAEMON_LAUNCH_COMMAND);  						if (process == null) {  							Directory.SetCurrentDirectory (oldDir);  							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'");  						}    						// wait for daemon  						Stopwatch stopwatch = new Stopwatch ();  						stopwatch.Start ();  						do {  							addr = Address.GetSessionBusAddressFromSharedMemory ();  							if (String.IsNullOrEmpty (addr))  								Thread.Sleep (100);  						} while (String.IsNullOrEmpty (addr) && stopwatch.ElapsedMilliseconds <= 5000);    						Directory.SetCurrentDirectory (oldDir);  					}    					if (string.IsNullOrEmpty (addr))  						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon");   					return Create (AddressEntry.Parse (addr));  				}    			}
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: if (readBuffer == null)  				readBuffer = new byte[16];
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: read = Read (hbuf' 0' 16' fdArray);
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: if (read != 16)  				throw new Exception ("Header read length mismatch: " + read + " of expected " + "16");
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: reader.Seek (3);
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: toRead = ProtocolInformation.Padded (toRead' 8);
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: header = new byte[16 + toRead];
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: Array.Copy (hbuf' header' 16);
Magic Number,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,ReadMessageReal,The following statement contains a magic number: read = Read (header' 16' toRead' fdArray);
Magic Number,DBus.Transports,UnixNativeTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddr,The following statement contains a magic number: byte[] sa = new byte[2 + p.Length + 1];
Magic Number,DBus.Transports,UnixNativeTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddr,The following statement contains a magic number: for (int i = 0 ; i != p.Length ; i++)  				sa[2 + i] = p[i];
Magic Number,DBus.Transports,UnixNativeTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddr,The following statement contains a magic number: sa[2 + p.Length] = 0;
Magic Number,DBus.Transports,UnixNativeTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddrAbstract,The following statement contains a magic number: byte[] sa = new byte[2 + 1 + p.Length];
Magic Number,DBus.Transports,UnixNativeTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddrAbstract,The following statement contains a magic number: sa[2] = 0;
Magic Number,DBus.Transports,UnixNativeTransport,C:\repos\mono_dbus-sharp\src\Transports\UnixNativeTransport.cs,GetSockAddrAbstract,The following statement contains a magic number: for (int i = 0 ; i != p.Length ; i++)  				sa[3 + i] = p[i];
Magic Number,DBus.Unix,UnixMonoStream,C:\repos\mono_dbus-sharp\src\Unix\UnixMonoStream.cs,SendmsgShort,The following statement contains a magic number: fixed (byte* ptr1 = buffer1' ptr2 = buffer2) {  				var iovecs = new Iovec[] {  					new Iovec {  						iov_base = (IntPtr) (ptr1 + offset1)'  						iov_len = (ulong) length1'  					}'  					new Iovec {  						iov_base = (IntPtr) (ptr2 + offset2)'  						iov_len = (ulong) length2'  					}'  				};  				/* Simulate short writes  				if (iovecs[0].iov_len == 0) {  					iovecs[1].iov_len = Math.Min (iovecs[1].iov_len' 5);  				} else {  					iovecs[0].iov_len = Math.Min (iovecs[0].iov_len' 5);  					iovecs[1].iov_len = 0;  				}  				*/  				byte[] cmsg = null;    				// Create copy of FDs to prevent the user from Dispose()ing the  				// FDs in another thread between writing the FDs into the cmsg  				// buffer and calling sendmsg()  				using (var fds2 = fds == null ? null : fds.Clone ()) {  					int fdCount = fds2 == null ? 0 : fds2.FDs.Count;  					if (fdCount != 0) {  						// Create one SCM_RIGHTS control message  						cmsg = new byte[Syscall.CMSG_SPACE ((uint) fdCount * sizeof (int))];  					}  					var msghdr = new Msghdr {  						msg_iov = iovecs'  						msg_iovlen = length2 == 0 ? 1 : 2'  						msg_control = cmsg'  						msg_controllen = cmsg == null ? 0 : cmsg.Length'  					};  					if (fdCount != 0) {  						var hdr = new Cmsghdr {  							cmsg_len = (long) Syscall.CMSG_LEN ((uint) fdCount * sizeof (int))'  							cmsg_level = UnixSocketProtocol.SOL_SOCKET'  							cmsg_type = UnixSocketControlMessage.SCM_RIGHTS'  						};  						hdr.WriteToBuffer (msghdr' 0);  						var dataOffset = Syscall.CMSG_DATA (msghdr' 0);  						fixed (byte* ptr = cmsg) {  							for (int i = 0; i < fdCount; i++)  								((int*) (ptr + dataOffset))[i] = fds2.FDs[i].Handle;  						}  					}  					long r;  					do {  						r = Syscall.sendmsg (fd' msghdr' MessageFlags.MSG_NOSIGNAL);  					} while (UnixMarshal.ShouldRetrySyscall ((int) r));  					if (r < 0)  						UnixMarshal.ThrowExceptionForLastError ();  					if (r == 0)  						throw new Exception ("sendmsg() returned 0");  					return r;  				}  			}
Magic Number,DBus.Unix,UnixSocket,C:\repos\mono_dbus-sharp\src\Unix\UnixSocket.cs,Accept,The following statement contains a magic number: byte[] addr = new byte[110];
Missing Default,DBus,Connection,C:\repos\mono_dbus-sharp\src\Connection.cs,HandleMethodCall,The following switch statement is missing a default case: switch (method_call.Member) {  					case "Ping":  						Send (MessageHelper.ConstructReply (method_call));  						return;  					case "GetMachineId":  						if (MachineId != UUID.Zero) {  							Send (MessageHelper.ConstructReply (method_call' MachineId.ToString ()));  							return;  						} else {  							// Might want to send back an error here?  						}  						break;  				}
Missing Default,DBus,Mapper,C:\repos\mono_dbus-sharp\src\Mapper.cs,GetTypes,The following switch statement is missing a default case: switch (dir) {  					case ArgDirection.In:  						//docs say IsIn isn't reliable' and this is indeed true  						//if (parms[i].IsIn)  						if (!parms[i].IsOut)  							types.Add (parms[i].ParameterType);  						break;  					case ArgDirection.Out:  						if (parms[i].IsOut) {  							//TODO: note that IsOut is optional to the compiler' we may want to use IsByRef instead  						//eg: if (parms[i].ParameterType.IsByRef)  							types.Add (parms[i].ParameterType.GetElementType ());  						}  						break;  				}
Missing Default,DBus.Protocol,DBusStruct,C:\repos\mono_dbus-sharp\src\Protocol\DBusStruct.cs,FromInnerTypes,The following switch statement is missing a default case: switch (innerTypes.Length) {  			case 1:  				structType = typeof (DBusStruct<>);  				break;  			case 2:  				structType = typeof (DBusStruct<'>);  				break;  			case 3:  				structType = typeof (DBusStruct<''>);  				break;  			case 4:  				structType = typeof (DBusStruct<'''>);  				break;  			case 5:  				structType = typeof (DBusStruct<''''>);  				break;  			case 6:  				structType = typeof (DBusStruct<'''''>);  				break;  			case 7:  				structType = typeof (DBusStruct<''''''>);  				break;  			}
Missing Default,DBus.Protocol,Signature,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,IsValid,The following switch statement is missing a default case: switch ((DType)c) {  				case DType.StructBegin:  					structCount++;  					break;  				case DType.StructEnd:  					structCount--;  					break;  				case DType.DictEntryBegin:  					dictCount++;  					break;  				case DType.DictEntryEnd:  					dictCount--;  					break;  				}
Missing Default,DBus.Protocol,SignatureChecker,C:\repos\mono_dbus-sharp\src\Protocol\Signature.cs,SingleType,The following switch statement is missing a default case: switch ((DType)data[pos]) {  				// Simple Type  				case DType.Byte:  				case DType.Boolean:  				case DType.Int16:  				case DType.UInt16:  				case DType.Int32:  				case DType.UInt32:  				case DType.Int64:  				case DType.UInt64:  				case DType.Single:  				case DType.Double:  				case DType.String:  				case DType.UnixFD:  				case DType.ObjectPath:  				case DType.Signature:  				case DType.Variant:  					pos += 1;  					return true;  				case DType.Array:  					pos += 1;  					return ArrayType ();  				case DType.StructBegin:  					pos += 1;  					return StructType ();  				case DType.DictEntryBegin:  					pos += 1;  					return DictType ();  				}
Missing Default,DBus.Transports,Transport,C:\repos\mono_dbus-sharp\src\Protocol\Transport.cs,Create,The following switch statement is missing a default case: switch (entry.Method) {  				case "tcp":  				{  					Transport transport = new SocketTransport ();  					transport.Open (entry);  					return transport;  				}    				case "unix":  				{  					if (OSHelpers.PlatformIsUnixoid) {  						Transport transport;  						if (UnixSendmsgTransport.Available ()) {  							transport = new UnixSendmsgTransport ();  						} else {  							if (ProtocolInformation.Verbose)  								Console.Error.WriteLine ("Warning: Syscall.sendmsg() not available' transfering unix FDs will not work");  							transport = new UnixNativeTransport ();  						}  						transport.Open (entry);  						return transport;  					}  					break;  				}    #if ENABLE_PIPES  				case "win":  				{  					Transport transport = new PipeTransport ();  					transport.Open (entry);  					return transport;  				}  #endif    				// "autolaunch:" means: the first client user of the dbus library shall spawn the daemon on itself' see dbus 1.7.8 from http://dbus.freedesktop.org/releases/dbus/  				case "autolaunch":  				{  					if (OSHelpers.PlatformIsUnixoid)  						break;    					string addr = Address.GetSessionBusAddressFromSharedMemory ();    					if (string.IsNullOrEmpty (addr)) { // we have to launch the daemon ourselves  						string oldDir = Directory.GetCurrentDirectory ();  						// Without this' the "current" folder for the new process will be the one where the current  						// executable resides' and as a consequence'that folder cannot be relocated/deleted unless the daemon is stopped  						Directory.SetCurrentDirectory (Environment.GetFolderPath (Environment.SpecialFolder.System));    						Process process = Process.Start (DBUS_DAEMON_LAUNCH_COMMAND);  						if (process == null) {  							Directory.SetCurrentDirectory (oldDir);  							throw new NotSupportedException ("Transport method \"autolaunch:\" - cannot launch dbus daemon '" + DBUS_DAEMON_LAUNCH_COMMAND + "'");  						}    						// wait for daemon  						Stopwatch stopwatch = new Stopwatch ();  						stopwatch.Start ();  						do {  							addr = Address.GetSessionBusAddressFromSharedMemory ();  							if (String.IsNullOrEmpty (addr))  								Thread.Sleep (100);  						} while (String.IsNullOrEmpty (addr) && stopwatch.ElapsedMilliseconds <= 5000);    						Directory.SetCurrentDirectory (oldDir);  					}    					if (string.IsNullOrEmpty (addr))  						throw new NotSupportedException ("Transport method \"autolaunch:\" - timeout during access to freshly launched dbus daemon");   					return Create (AddressEntry.Parse (addr));  				}    			}
