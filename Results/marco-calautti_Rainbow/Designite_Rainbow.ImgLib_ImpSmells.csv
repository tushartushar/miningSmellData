Implementation smell,Namespace,Class,File,Method,Description
Long Method,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The method has 144 lines of code.
Complex Method,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,EncodeFromImages,Cyclomatic complexity of the method is 14
Complex Method,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,Cyclomatic complexity of the method is 8
Complex Method,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,Cyclomatic complexity of the method is 8
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,ImageEncoderIndexed,The method has 6 parameters. Parameters: palettes' referenceImage' codec' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,ImageEncoderIndexed,The method has 6 parameters. Parameters: image' codec' pixelComparer' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,ImageEncoderIndexed,The method has 6 parameters. Parameters: images' codec' pixelComparer' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,Init,The method has 5 parameters. Parameters: codec' pixelComparer' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,IndexCodec,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,GetPixelIndex,The method has 5 parameters. Parameters: pixelData' width' height' x' y
Long Parameter List,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The method has 7 parameters. Parameters: pixelData' width' height' codec' palette' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageDecoderDirectColor,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderDirectColor.cs,ImageDecoderDirectColor,The method has 5 parameters. Parameters: pixelData' width' height' decoder' imageFilter
Long Parameter List,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The method has 5 parameters. Parameters: pixelData' width' height' x' y
Long Parameter List,Rainbow.ImgLib.Encoding.Implementation,IndexCodec8Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec8Bpp.cs,GetPixelIndex,The method has 5 parameters. Parameters: pixelData' width' height' x' y
Long Parameter List,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,TileFilter,The method has 5 parameters. Parameters: bpp' tileWidth' tileHeight' width' height
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The method has 12 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' paletteCodec' indexCodec' imgFilter' palFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The method has 10 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' imageCodec' imgFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The method has 6 parameters. Parameters: reader' pos1' pos2' w' h' bpps
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The method has 6 parameters. Parameters: images' pos1' pos2' w' h' bpps
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,GetPalettedTools,The method has 12 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' paletteCodec' indexCodec' imgFilter' palFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,GetUnpalettedTools,The method has 10 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' imageCodec' imgFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The method has 5 parameters. Parameters: formatData' parameters' dataSize' paletteSize' colorEntries
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Serialization,SimpleTextureFormatSerializer<T>,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\SimpleTextureFormatSerializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Serialization,SimpleTextureFormatSerializer<T>,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\SimpleTextureFormatSerializer.cs,OnImportFrameMetadata,The method has 6 parameters. Parameters: texture' frame' metadata' images' referenceImage' mipmapsCount
Long Statement,Rainbow.ImgLib.Common,InteropUtils,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\InteropUtils.cs,WriteTo,The length of the statement  "                metadata.GetType().InvokeMember("Put"' BindingFlags.InvokeMethod' Type.DefaultBinder' metadata' new object[]{ key' value }); " is 124.
Long Statement,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,EncodeFromImages,The length of the statement  "            else //for multi palette images' quantization may break the pixel structure of the images. We must trust the work of the graphics editor. " is 137.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4])); " is 128.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3])); " is 132.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The length of the statement  "                data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F)); " is 145.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4])); " is 132.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2])); " is 132.
Long Statement,Rainbow.ImgLib.Filters,TIM2PaletteFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The length of the statement  "                            newColors[i++] = originalData[ index + part * colors * stripes * blocks + block * colors + stripe * stripes * colors + color ]; " is 127.
Long Statement,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,The length of the statement  "                    throw new TextureFormatException("This EFX file contains more colors then requested by bpp. Is this a multi-palette texture?"); " is 127.
Long Statement,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,The length of the statement  "                    throw new TextureFormatException("Not a valid EFX file' size of entry without header 1 not corresponding in header 2!"); " is 120.
Long Statement,Rainbow.ImgLib.Formats.Serialization.Metadata,XmlMetadataReader,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\Metadata\XmlMetadataReader.cs,EnterSection,The length of the statement  "                    throw new MetadataException("Expected section named " + name + " but found " + subSections.Current.Attribute("name").Value); " is 124.
Long Statement,Rainbow.ImgLib.Formats.Serialization.Metadata,XmlMetadataReader,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\Metadata\XmlMetadataReader.cs,GetDataStringRepresentation,The length of the statement  "                    throw new MetadataException("Data " + key + " not found or many occurrences found in section " + currentElement.Attribute("name").Value); " is 137.
Long Statement,Rainbow.ImgLib.Formats.Serialization.Metadata,XmlMetadataReader,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\Metadata\XmlMetadataReader.cs,GetAttributeStringRepresentation,The length of the statement  "                    throw new MetadataException("Attribute " + key + " not found or many occurrences found in section " + currentElement.Attribute("name").Value); " is 142.
Long Statement,Rainbow.ImgLib.Formats.Serialization,SimpleTextureFormatSerializer<T>,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\SimpleTextureFormatSerializer.cs,OnImportFrameMetadata,The length of the statement  "            TextureFormat segment = CreateFrameForGeneralTexture(texture' frame' formatSpecific' images' referenceImage' mipmapsCount); " is 123.
Virtual Method Call from Constructor,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The constructor "PE3DATTexture" calls a virtual method "DecodeColors".
Virtual Method Call from Constructor,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,TIM2Segment,The constructor "TIM2Segment" calls a virtual method "EncodeColors".
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt16,The following statement contains a magic number: reader.Read(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt16,The following statement contains a magic number: Array.Reverse(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt16,The following statement contains a magic number: reader.Read(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt16,The following statement contains a magic number: Array.Reverse(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt32,The following statement contains a magic number: reader.Read(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt32,The following statement contains a magic number: Array.Reverse(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt32,The following statement contains a magic number: reader.Read(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt32,The following statement contains a magic number: Array.Reverse(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt64,The following statement contains a magic number: reader.Read(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt64,The following statement contains a magic number: Array.Reverse(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt64,The following statement contains a magic number: reader.Read(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt64,The following statement contains a magic number: Array.Reverse(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadSingle,The following statement contains a magic number: reader.Read(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadSingle,The following statement contains a magic number: Array.Reverse(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,ImageUtils,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\ImageUtils.cs,ToGrayScale,The following statement contains a magic number: int intensity = (int)(color.R * 0.2126 + color.G * 0.7152 + color.B * 0.0722);
Magic Number,Rainbow.ImgLib.Common,ImageUtils,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\ImageUtils.cs,ToGrayScale,The following statement contains a magic number: int intensity = (int)(color.R * 0.2126 + color.G * 0.7152 + color.B * 0.0722);
Magic Number,Rainbow.ImgLib.Common,ImageUtils,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\ImageUtils.cs,ToGrayScale,The following statement contains a magic number: int intensity = (int)(color.R * 0.2126 + color.G * 0.7152 + color.B * 0.0722);
Magic Number,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,EncodeFromReference,The following statement contains a magic number: int[] indexes = referenceImage.GetColorArray().Select((c) => (c.R >> (8 - codec.BitDepth))).ToArray();
Magic Number,Rainbow.ImgLib.Encoding,IndexCodec,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,FromNumberOfColors,The following statement contains a magic number: if (colors <= 16)              {                  return new IndexCodec4Bpp(order);              }              else if (colors <= 256)              {                  return new IndexCodec8Bpp();              }              else              {                  throw new ArgumentException("Unsupported number of colors");              }
Magic Number,Rainbow.ImgLib.Encoding,IndexCodec,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,FromNumberOfColors,The following statement contains a magic number: if (colors <= 16)              {                  return new IndexCodec4Bpp(order);              }              else if (colors <= 256)              {                  return new IndexCodec8Bpp();              }              else              {                  throw new ArgumentException("Unsupported number of colors");              }
Magic Number,Rainbow.ImgLib.Encoding,IndexCodec,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int bytes = totalPixel * BitDepth / 8;
Magic Number,Rainbow.ImgLib.Encoding,IndexCodec,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int remainder = (totalPixel * BitDepth) % 8;
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: for (int i = 0; i < grayScale.Length; i++)              {                  grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));              }
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: for (int i = 0; i < grayScale.Length; i++)              {                  grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));              }
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: for (int i = 0; i < grayScale.Length; i++)              {                  grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));              }
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: for (int i = 0; i < grayScale.Length; i++)              {                  grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));              }
Magic Number,Rainbow.ImgLib.Encoding,ColorCodec,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int bytes = totalPixel * BitDepth / 8;
Magic Number,Rainbow.ImgLib.Encoding,ColorCodec,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int remainder = (totalPixel * BitDepth) % 8;
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c1 = (uint)(x.A << 24 | x.B << 16 | x.G << 8 | x.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c1 = (uint)(x.A << 24 | x.B << 16 | x.G << 8 | x.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c1 = (uint)(x.A << 24 | x.B << 16 | x.G << 8 | x.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c2 = (uint)(y.A << 24 | y.B << 16 | y.G << 8 | y.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c2 = (uint)(y.A << 24 | y.B << 16 | y.G << 8 | y.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c2 = (uint)(y.A << 24 | y.B << 16 | y.G << 8 | y.R);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i+=4)              {                  encoded[i]      = colors[start + i / 4].A;                  encoded[i+1]    = colors[start + i / 4].B;                  encoded[i+2]    = colors[start + i / 4].G;                  encoded[i+3]    = colors[start + i / 4].R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i+=4)              {                  encoded[i]      = colors[start + i / 4].A;                  encoded[i+1]    = colors[start + i / 4].B;                  encoded[i+2]    = colors[start + i / 4].G;                  encoded[i+3]    = colors[start + i / 4].R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i+=4)              {                  encoded[i]      = colors[start + i / 4].A;                  encoded[i+1]    = colors[start + i / 4].B;                  encoded[i+2]    = colors[start + i / 4].G;                  encoded[i+3]    = colors[start + i / 4].R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i+=4)              {                  encoded[i]      = colors[start + i / 4].A;                  encoded[i+1]    = colors[start + i / 4].B;                  encoded[i+2]    = colors[start + i / 4].G;                  encoded[i+3]    = colors[start + i / 4].R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i+=4)              {                  encoded[i]      = colors[start + i / 4].A;                  encoded[i+1]    = colors[start + i / 4].B;                  encoded[i+2]    = colors[start + i / 4].G;                  encoded[i+3]    = colors[start + i / 4].R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i+=4)              {                  encoded[i]      = colors[start + i / 4].A;                  encoded[i+1]    = colors[start + i / 4].B;                  encoded[i+2]    = colors[start + i / 4].G;                  encoded[i+3]    = colors[start + i / 4].R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i+=4)              {                  encoded[i]      = colors[start + i / 4].A;                  encoded[i+1]    = colors[start + i / 4].B;                  encoded[i+2]    = colors[start + i / 4].G;                  encoded[i+3]    = colors[start + i / 4].R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].A;                  encoded[i + 1] = colors[start + i / 4].R;                  encoded[i + 2] = colors[start + i / 4].G;                  encoded[i + 3] = colors[start + i / 4].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].A;                  encoded[i + 1] = colors[start + i / 4].R;                  encoded[i + 2] = colors[start + i / 4].G;                  encoded[i + 3] = colors[start + i / 4].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].A;                  encoded[i + 1] = colors[start + i / 4].R;                  encoded[i + 2] = colors[start + i / 4].G;                  encoded[i + 3] = colors[start + i / 4].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].A;                  encoded[i + 1] = colors[start + i / 4].R;                  encoded[i + 2] = colors[start + i / 4].G;                  encoded[i + 3] = colors[start + i / 4].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].A;                  encoded[i + 1] = colors[start + i / 4].R;                  encoded[i + 2] = colors[start + i / 4].G;                  encoded[i + 3] = colors[start + i / 4].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].A;                  encoded[i + 1] = colors[start + i / 4].R;                  encoded[i + 2] = colors[start + i / 4].G;                  encoded[i + 3] = colors[start + i / 4].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].A;                  encoded[i + 1] = colors[start + i / 4].R;                  encoded[i + 2] = colors[start + i / 4].G;                  encoded[i + 3] = colors[start + i / 4].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: Color[] tile = new Color[4 * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: Color[] tile = new Color[4 * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: for (int y = 0; y < FullHeight; y += 4)              {                  for (int x = 0; x < FullWidth; x += 4)                  {                      DecodeDXT1Block(reader' tile);                      for (int line = 0; line < 4; line++)                      {                          Array.Copy(tile' line * 4' decoded' FullWidth * (y + line) + x' 4);                        }                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: for (int y = 0; y < FullHeight; y += 4)              {                  for (int x = 0; x < FullWidth; x += 4)                  {                      DecodeDXT1Block(reader' tile);                      for (int line = 0; line < 4; line++)                      {                          Array.Copy(tile' line * 4' decoded' FullWidth * (y + line) + x' 4);                        }                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: for (int y = 0; y < FullHeight; y += 4)              {                  for (int x = 0; x < FullWidth; x += 4)                  {                      DecodeDXT1Block(reader' tile);                      for (int line = 0; line < 4; line++)                      {                          Array.Copy(tile' line * 4' decoded' FullWidth * (y + line) + x' 4);                        }                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: for (int y = 0; y < FullHeight; y += 4)              {                  for (int x = 0; x < FullWidth; x += 4)                  {                      DecodeDXT1Block(reader' tile);                      for (int line = 0; line < 4; line++)                      {                          Array.Copy(tile' line * 4' decoded' FullWidth * (y + line) + x' 4);                        }                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: for (int y = 0; y < FullHeight; y += 4)              {                  for (int x = 0; x < FullWidth; x += 4)                  {                      DecodeDXT1Block(reader' tile);                      for (int line = 0; line < 4; line++)                      {                          Array.Copy(tile' line * 4' decoded' FullWidth * (y + line) + x' 4);                        }                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetBytesNeededForEncode,The following statement contains a magic number: return GetFullWidth(width) * GetFullHeight(height) * BitDepth / 8;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: table = reader.ReadBytes(4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green1 = ImageUtils.Conv6To8((color1 >> 5) & 0x3F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green2 = ImageUtils.Conv6To8((color2 >> 5) & 0x3F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red1 = ImageUtils.Conv5To8((color1 >> 11) & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red2 = ImageUtils.Conv5To8((color2 >> 11) & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[0] = Color.FromArgb(255'red1' green1' blue1);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[1] = Color.FromArgb(255' red2' green2' blue2);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: if (color1 > color2)              {                  int blue3 = (2 * blue1 + blue2) / 3;                  int green3 = (2 * green1 + green2) / 3;                  int red3 = (2 * red1 + red2) / 3;                    int blue4 = (2 * blue2 + blue1) / 3;                  int green4 = (2 * green2 + green1) / 3;                  int red4 = (2 * red2 + red1) / 3;                    clut[2] = Color.FromArgb(255' red3'green3'blue3);                  clut[3] = Color.FromArgb(255'red4'green4'blue4);              }              else              {                  clut[2] = Color.FromArgb(255' (red1 + red2)  / 2' // Average                                                (green1 + green2) / 2'                                                (blue1 + blue2) / 2);                  clut[3] = Color.FromArgb(0' 0' 0' 0);  // Color2 but transparent              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: for (int y = 0; y < 4; y++)              {                  int val = table[y];                  for (int x = 0; x < 4; x++)                  {                      tile[k++] = clut[(val >> 6) & 3];                      val <<= 2;                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: for (int y = 0; y < 4; y++)              {                  int val = table[y];                  for (int x = 0; x < 4; x++)                  {                      tile[k++] = clut[(val >> 6) & 3];                      val <<= 2;                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: for (int y = 0; y < 4; y++)              {                  int val = table[y];                  for (int x = 0; x < 4; x++)                  {                      tile[k++] = clut[(val >> 6) & 3];                      val <<= 2;                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: for (int y = 0; y < 4; y++)              {                  int val = table[y];                  for (int x = 0; x < 4; x++)                  {                      tile[k++] = clut[(val >> 6) & 3];                      val <<= 2;                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: for (int y = 0; y < 4; y++)              {                  int val = table[y];                  for (int x = 0; x < 4; x++)                  {                      tile[k++] = clut[(val >> 6) & 3];                      val <<= 2;                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 2; i++)              {                  ushort data = reader.ReadUInt16();                    int red = data & 0x1F;                  data >>= 5;                  int green = data & 0x1F;                  data >>= 5;                  int blue = data & 0x1F;                  int alpha = data == 0 ? 0 : 255;                    pal.Add(Color.FromArgb(alpha' ImageUtils.Conv5To8(red)' ImageUtils.Conv5To8(green)' ImageUtils.Conv5To8(blue)));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 2; i++)              {                  ushort data = reader.ReadUInt16();                    int red = data & 0x1F;                  data >>= 5;                  int green = data & 0x1F;                  data >>= 5;                  int blue = data & 0x1F;                  int alpha = data == 0 ? 0 : 255;                    pal.Add(Color.FromArgb(alpha' ImageUtils.Conv5To8(red)' ImageUtils.Conv5To8(green)' ImageUtils.Conv5To8(blue)));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 2; i++)              {                  ushort data = reader.ReadUInt16();                    int red = data & 0x1F;                  data >>= 5;                  int green = data & 0x1F;                  data >>= 5;                  int blue = data & 0x1F;                  int alpha = data == 0 ? 0 : 255;                    pal.Add(Color.FromArgb(alpha' ImageUtils.Conv5To8(red)' ImageUtils.Conv5To8(green)' ImageUtils.Conv5To8(blue)));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 2; i++)              {                  ushort data = reader.ReadUInt16();                    int red = data & 0x1F;                  data >>= 5;                  int green = data & 0x1F;                  data >>= 5;                  int blue = data & 0x1F;                  int alpha = data == 0 ? 0 : 255;                    pal.Add(Color.FromArgb(alpha' ImageUtils.Conv5To8(red)' ImageUtils.Conv5To8(green)' ImageUtils.Conv5To8(blue)));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: byte[] palette = new byte[colors.Length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  ushort data = (ushort)(colors[i].A > 127 ? 0x8000 : 0);                    data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));                  palette[(i - start) * 2] = (byte)(data & 0xFF);                  palette[(i - start) * 2 + 1] = (byte)(data >> 8);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  ushort data = (ushort)(colors[i].A > 127 ? 0x8000 : 0);                    data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));                  palette[(i - start) * 2] = (byte)(data & 0xFF);                  palette[(i - start) * 2 + 1] = (byte)(data >> 8);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  ushort data = (ushort)(colors[i].A > 127 ? 0x8000 : 0);                    data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));                  palette[(i - start) * 2] = (byte)(data & 0xFF);                  palette[(i - start) * 2 + 1] = (byte)(data >> 8);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  ushort data = (ushort)(colors[i].A > 127 ? 0x8000 : 0);                    data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));                  palette[(i - start) * 2] = (byte)(data & 0xFF);                  palette[(i - start) * 2 + 1] = (byte)(data >> 8);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  ushort data = (ushort)(colors[i].A > 127 ? 0x8000 : 0);                    data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));                  palette[(i - start) * 2] = (byte)(data & 0xFF);                  palette[(i - start) * 2 + 1] = (byte)(data >> 8);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  ushort data = (ushort)(colors[i].A > 127 ? 0x8000 : 0);                    data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));                  palette[(i - start) * 2] = (byte)(data & 0xFF);                  palette[(i - start) * 2 + 1] = (byte)(data >> 8);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 3; i++)              {                  pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 3; i++)              {                  pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 3; i++)              {                  pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 3; i++)              {                  pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 3; i++)              {                  pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 3; i++)              {                  pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: byte[] palette = new byte[colors.Length * 3];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  palette[(i - start) * 3] = colors[i].R;                  palette[(i - start) * 3 + 1] = colors[i].G;                  palette[(i - start) * 3 + 2] = colors[i].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  palette[(i - start) * 3] = colors[i].R;                  palette[(i - start) * 3 + 1] = colors[i].G;                  palette[(i - start) * 3 + 2] = colors[i].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  palette[(i - start) * 3] = colors[i].R;                  palette[(i - start) * 3 + 1] = colors[i].G;                  palette[(i - start) * 3 + 2] = colors[i].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: for (int i = start; i < colors.Length; i++)              {                  palette[(i - start) * 3] = colors[i].R;                  palette[(i - start) * 3 + 1] = colors[i].G;                  palette[(i - start) * 3 + 2] = colors[i].B;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].B;                  encoded[i + 1] = colors[start + i / 4].G;                  encoded[i + 2] = colors[start + i / 4].R;                  encoded[i + 3] = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].B;                  encoded[i + 1] = colors[start + i / 4].G;                  encoded[i + 2] = colors[start + i / 4].R;                  encoded[i + 3] = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].B;                  encoded[i + 1] = colors[start + i / 4].G;                  encoded[i + 2] = colors[start + i / 4].R;                  encoded[i + 3] = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].B;                  encoded[i + 1] = colors[start + i / 4].G;                  encoded[i + 2] = colors[start + i / 4].R;                  encoded[i + 3] = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].B;                  encoded[i + 1] = colors[start + i / 4].G;                  encoded[i + 2] = colors[start + i / 4].R;                  encoded[i + 3] = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].B;                  encoded[i + 1] = colors[start + i / 4].G;                  encoded[i + 2] = colors[start + i / 4].R;                  encoded[i + 3] = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i] = colors[start + i / 4].B;                  encoded[i + 1] = colors[start + i / 4].G;                  encoded[i + 2] = colors[start + i / 4].R;                  encoded[i + 3] = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < size / 4; i++)              {                  pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i]      = colors[start + i / 4].R;                  encoded[i + 1]  = colors[start + i / 4].G;                  encoded[i + 2]  = colors[start + i / 4].B;                  encoded[i + 3]  = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i]      = colors[start + i / 4].R;                  encoded[i + 1]  = colors[start + i / 4].G;                  encoded[i + 2]  = colors[start + i / 4].B;                  encoded[i + 3]  = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i]      = colors[start + i / 4].R;                  encoded[i + 1]  = colors[start + i / 4].G;                  encoded[i + 2]  = colors[start + i / 4].B;                  encoded[i + 3]  = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i]      = colors[start + i / 4].R;                  encoded[i + 1]  = colors[start + i / 4].G;                  encoded[i + 2]  = colors[start + i / 4].B;                  encoded[i + 3]  = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i]      = colors[start + i / 4].R;                  encoded[i + 1]  = colors[start + i / 4].G;                  encoded[i + 2]  = colors[start + i / 4].B;                  encoded[i + 3]  = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i]      = colors[start + i / 4].R;                  encoded[i + 1]  = colors[start + i / 4].G;                  encoded[i + 2]  = colors[start + i / 4].B;                  encoded[i + 3]  = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i += 4)              {                  encoded[i]      = colors[start + i / 4].R;                  encoded[i + 1]  = colors[start + i / 4].G;                  encoded[i + 2]  = colors[start + i / 4].B;                  encoded[i + 3]  = colors[start + i / 4].A;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: Color[] decoded = new Color[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  byte value=colors[start+i];                  int first   = ByteOrder == ByteOrder.LittleEndian ? value & 0xF : (value >> 4) & 0xF;                  int second = ByteOrder == ByteOrder.LittleEndian ? (value >> 4) & 0xF : value & 0xF;                    first = ImageUtils.Conv4To8(first);                  second = ImageUtils.Conv4To8(second);                    decoded[i * 2]  = Color.FromArgb(255' first' first' first);                  decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  byte value=colors[start+i];                  int first   = ByteOrder == ByteOrder.LittleEndian ? value & 0xF : (value >> 4) & 0xF;                  int second = ByteOrder == ByteOrder.LittleEndian ? (value >> 4) & 0xF : value & 0xF;                    first = ImageUtils.Conv4To8(first);                  second = ImageUtils.Conv4To8(second);                    decoded[i * 2]  = Color.FromArgb(255' first' first' first);                  decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  byte value=colors[start+i];                  int first   = ByteOrder == ByteOrder.LittleEndian ? value & 0xF : (value >> 4) & 0xF;                  int second = ByteOrder == ByteOrder.LittleEndian ? (value >> 4) & 0xF : value & 0xF;                    first = ImageUtils.Conv4To8(first);                  second = ImageUtils.Conv4To8(second);                    decoded[i * 2]  = Color.FromArgb(255' first' first' first);                  decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  byte value=colors[start+i];                  int first   = ByteOrder == ByteOrder.LittleEndian ? value & 0xF : (value >> 4) & 0xF;                  int second = ByteOrder == ByteOrder.LittleEndian ? (value >> 4) & 0xF : value & 0xF;                    first = ImageUtils.Conv4To8(first);                  second = ImageUtils.Conv4To8(second);                    decoded[i * 2]  = Color.FromArgb(255' first' first' first);                  decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  byte value=colors[start+i];                  int first   = ByteOrder == ByteOrder.LittleEndian ? value & 0xF : (value >> 4) & 0xF;                  int second = ByteOrder == ByteOrder.LittleEndian ? (value >> 4) & 0xF : value & 0xF;                    first = ImageUtils.Conv4To8(first);                  second = ImageUtils.Conv4To8(second);                    decoded[i * 2]  = Color.FromArgb(255' first' first' first);                  decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  byte value=colors[start+i];                  int first   = ByteOrder == ByteOrder.LittleEndian ? value & 0xF : (value >> 4) & 0xF;                  int second = ByteOrder == ByteOrder.LittleEndian ? (value >> 4) & 0xF : value & 0xF;                    first = ImageUtils.Conv4To8(first);                  second = ImageUtils.Conv4To8(second);                    decoded[i * 2]  = Color.FromArgb(255' first' first' first);                  decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[(length +1)/ 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i+=2)              {                  Color first = ImageUtils.ToGrayScale(colors[start + i]);                  Color second = i == length - 1 ? Color.Black : ImageUtils.ToGrayScale(colors[start + i + 1]);                    int firstNibble = ImageUtils.Conv8To4(first.R);                  int secondNibble = ImageUtils.Conv8To4(second.R);                    byte value = 0;                    if(ByteOrder == ByteOrder.LittleEndian)                  {                      value = (byte)((firstNibble & 0xF) | ((secondNibble & 0xF) << 4));                  }else                  {                      value = (byte)((secondNibble & 0xF) | ((firstNibble & 0xF) << 4));                  }                    encoded[i / 2] = value;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i+=2)              {                  Color first = ImageUtils.ToGrayScale(colors[start + i]);                  Color second = i == length - 1 ? Color.Black : ImageUtils.ToGrayScale(colors[start + i + 1]);                    int firstNibble = ImageUtils.Conv8To4(first.R);                  int secondNibble = ImageUtils.Conv8To4(second.R);                    byte value = 0;                    if(ByteOrder == ByteOrder.LittleEndian)                  {                      value = (byte)((firstNibble & 0xF) | ((secondNibble & 0xF) << 4));                  }else                  {                      value = (byte)((secondNibble & 0xF) | ((firstNibble & 0xF) << 4));                  }                    encoded[i / 2] = value;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i+=2)              {                  Color first = ImageUtils.ToGrayScale(colors[start + i]);                  Color second = i == length - 1 ? Color.Black : ImageUtils.ToGrayScale(colors[start + i + 1]);                    int firstNibble = ImageUtils.Conv8To4(first.R);                  int secondNibble = ImageUtils.Conv8To4(second.R);                    byte value = 0;                    if(ByteOrder == ByteOrder.LittleEndian)                  {                      value = (byte)((firstNibble & 0xF) | ((secondNibble & 0xF) << 4));                  }else                  {                      value = (byte)((secondNibble & 0xF) | ((firstNibble & 0xF) << 4));                  }                    encoded[i / 2] = value;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i+=2)              {                  Color first = ImageUtils.ToGrayScale(colors[start + i]);                  Color second = i == length - 1 ? Color.Black : ImageUtils.ToGrayScale(colors[start + i + 1]);                    int firstNibble = ImageUtils.Conv8To4(first.R);                  int secondNibble = ImageUtils.Conv8To4(second.R);                    byte value = 0;                    if(ByteOrder == ByteOrder.LittleEndian)                  {                      value = (byte)((firstNibble & 0xF) | ((secondNibble & 0xF) << 4));                  }else                  {                      value = (byte)((secondNibble & 0xF) | ((firstNibble & 0xF) << 4));                  }                    encoded[i / 2] = value;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI8,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI8.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<decoded.Length;i++)              {                  int intensity = reader.ReadByte();                  decoded[i] = Color.FromArgb(255' intensity' intensity' intensity);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<decoded.Length;i++)              {                  byte data = reader.ReadByte();                    int alpha = ByteOrder == ByteOrder.LittleEndian ? data & 0xF : (data >> 4) & 0xF;                  int intensity = ByteOrder == ByteOrder.LittleEndian ? (data>>4) & 0xF : data & 0xF;                    alpha = ImageUtils.Conv4To8(alpha);                  intensity = ImageUtils.Conv4To8(intensity);                  decoded[i] = Color.FromArgb(alpha' intensity' intensity' intensity);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA4.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<decoded.Length;i++)              {                  byte data = reader.ReadByte();                    int alpha = ByteOrder == ByteOrder.LittleEndian ? data & 0xF : (data >> 4) & 0xF;                  int intensity = ByteOrder == ByteOrder.LittleEndian ? (data>>4) & 0xF : data & 0xF;                    alpha = ImageUtils.Conv4To8(alpha);                  intensity = ImageUtils.Conv4To8(intensity);                  decoded[i] = Color.FromArgb(alpha' intensity' intensity' intensity);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA4.cs,EncodeColors,The following statement contains a magic number: for(int i=0; i<length; i++)              {                  Color gray = ImageUtils.ToGrayScale(colors[start + i]);                    int alphaNibble = ImageUtils.Conv8To4(gray.A);                  int intensityNibble = ImageUtils.Conv8To4(gray.R);                    byte value = 0;                  if(ByteOrder == ByteOrder.LittleEndian)                  {                      value = (byte)((alphaNibble & 0xF) | ((intensityNibble & 0xF) << 4));                  }else                  {                      value = (byte)((intensityNibble & 0xF) | ((alphaNibble & 0xF) << 4));                  }                    encoded[i] = value;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA4,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA4.cs,EncodeColors,The following statement contains a magic number: for(int i=0; i<length; i++)              {                  Color gray = ImageUtils.ToGrayScale(colors[start + i]);                    int alphaNibble = ImageUtils.Conv8To4(gray.A);                  int intensityNibble = ImageUtils.Conv8To4(gray.R);                    byte value = 0;                  if(ByteOrder == ByteOrder.LittleEndian)                  {                      value = (byte)((alphaNibble & 0xF) | ((intensityNibble & 0xF) << 4));                  }else                  {                      value = (byte)((intensityNibble & 0xF) | ((alphaNibble & 0xF) << 4));                  }                    encoded[i] = value;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,DecodeColors,The following statement contains a magic number: Color[] decoded = new Color[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,DecodeColors,The following statement contains a magic number: for(int i=0;i<decoded.Length;i++)              {                  ushort data=reader.ReadUInt16(ByteOrder);                  int alpha=(data>>8)&0xFF;                  int intensity=data&0xFF;                  decoded[i] = Color.FromArgb(alpha' intensity' intensity' intensity);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,EncodeColors,The following statement contains a magic number: for(int i=0; i<length; i++)              {                  Color gray = ImageUtils.ToGrayScale(colors[start + i]);                    encoded[i * 2] = ByteOrder == ByteOrder.LittleEndian ? gray.R : gray.A;                  encoded[i * 2 + 1] = ByteOrder == ByteOrder.LittleEndian ? gray.A : gray.R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,EncodeColors,The following statement contains a magic number: for(int i=0; i<length; i++)              {                  Color gray = ImageUtils.ToGrayScale(colors[start + i]);                    encoded[i * 2] = ByteOrder == ByteOrder.LittleEndian ? gray.R : gray.A;                  encoded[i * 2 + 1] = ByteOrder == ByteOrder.LittleEndian ? gray.A : gray.R;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: Color[] encoded = new Color[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue;                  red = ImageUtils.Conv5To8((color >> 11) & 0x1f);                  green = ImageUtils.Conv6To8((color >> 5) & 0x3f);                  blue = ImageUtils.Conv5To8((color) & 0x1f);                    encoded[i] = Color.FromArgb(255' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue;                  red = ImageUtils.Conv5To8((color >> 11) & 0x1f);                  green = ImageUtils.Conv6To8((color >> 5) & 0x3f);                  blue = ImageUtils.Conv5To8((color) & 0x1f);                    encoded[i] = Color.FromArgb(255' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue;                  red = ImageUtils.Conv5To8((color >> 11) & 0x1f);                  green = ImageUtils.Conv6To8((color >> 5) & 0x3f);                  blue = ImageUtils.Conv5To8((color) & 0x1f);                    encoded[i] = Color.FromArgb(255' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  int red = ImageUtils.Conv8To5(colors[start + i].R);                  int green = ImageUtils.Conv8To6(colors[start + i].G);                  int blue = ImageUtils.Conv8To5(colors[start + i].B);                    ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));                  encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  int red = ImageUtils.Conv8To5(colors[start + i].R);                  int green = ImageUtils.Conv8To6(colors[start + i].G);                  int blue = ImageUtils.Conv8To5(colors[start + i].B);                    ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));                  encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  int red = ImageUtils.Conv8To5(colors[start + i].R);                  int green = ImageUtils.Conv8To6(colors[start + i].G);                  int blue = ImageUtils.Conv8To5(colors[start + i].B);                    ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));                  encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  int red = ImageUtils.Conv8To5(colors[start + i].R);                  int green = ImageUtils.Conv8To6(colors[start + i].G);                  int blue = ImageUtils.Conv8To5(colors[start + i].B);                    ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));                  encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  int red = ImageUtils.Conv8To5(colors[start + i].R);                  int green = ImageUtils.Conv8To6(colors[start + i].G);                  int blue = ImageUtils.Conv8To5(colors[start + i].B);                    ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));                  encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  int red = ImageUtils.Conv8To5(colors[start + i].R);                  int green = ImageUtils.Conv8To6(colors[start + i].G);                  int blue = ImageUtils.Conv8To5(colors[start + i].B);                    ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));                  encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: Color[] encoded = new Color[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue' alpha;                  if ((color & 0x8000) != 0) //no alpha                  {                      red = ImageUtils.Conv5To8((color >> 10) & 0x1F);                      green = ImageUtils.Conv5To8((color >> 5) & 0x1F);                      blue = ImageUtils.Conv5To8((color) & 0x1F);                      alpha = 255;                  }                  else // with alpha                  {                      alpha = ImageUtils.Conv3To8((color >> 12) & 0x7);                      red = ImageUtils.Conv4To8((color >> 8) & 0xf);                      green = ImageUtils.Conv4To8((color >> 4) & 0xf);                      blue = ImageUtils.Conv4To8((color) & 0xf);                  }                    encoded[i] = Color.FromArgb(alpha' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue' alpha;                  if ((color & 0x8000) != 0) //no alpha                  {                      red = ImageUtils.Conv5To8((color >> 10) & 0x1F);                      green = ImageUtils.Conv5To8((color >> 5) & 0x1F);                      blue = ImageUtils.Conv5To8((color) & 0x1F);                      alpha = 255;                  }                  else // with alpha                  {                      alpha = ImageUtils.Conv3To8((color >> 12) & 0x7);                      red = ImageUtils.Conv4To8((color >> 8) & 0xf);                      green = ImageUtils.Conv4To8((color >> 4) & 0xf);                      blue = ImageUtils.Conv4To8((color) & 0xf);                  }                    encoded[i] = Color.FromArgb(alpha' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue' alpha;                  if ((color & 0x8000) != 0) //no alpha                  {                      red = ImageUtils.Conv5To8((color >> 10) & 0x1F);                      green = ImageUtils.Conv5To8((color >> 5) & 0x1F);                      blue = ImageUtils.Conv5To8((color) & 0x1F);                      alpha = 255;                  }                  else // with alpha                  {                      alpha = ImageUtils.Conv3To8((color >> 12) & 0x7);                      red = ImageUtils.Conv4To8((color >> 8) & 0xf);                      green = ImageUtils.Conv4To8((color >> 4) & 0xf);                      blue = ImageUtils.Conv4To8((color) & 0xf);                  }                    encoded[i] = Color.FromArgb(alpha' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue' alpha;                  if ((color & 0x8000) != 0) //no alpha                  {                      red = ImageUtils.Conv5To8((color >> 10) & 0x1F);                      green = ImageUtils.Conv5To8((color >> 5) & 0x1F);                      blue = ImageUtils.Conv5To8((color) & 0x1F);                      alpha = 255;                  }                  else // with alpha                  {                      alpha = ImageUtils.Conv3To8((color >> 12) & 0x7);                      red = ImageUtils.Conv4To8((color >> 8) & 0xf);                      green = ImageUtils.Conv4To8((color >> 4) & 0xf);                      blue = ImageUtils.Conv4To8((color) & 0xf);                  }                    encoded[i] = Color.FromArgb(alpha' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue' alpha;                  if ((color & 0x8000) != 0) //no alpha                  {                      red = ImageUtils.Conv5To8((color >> 10) & 0x1F);                      green = ImageUtils.Conv5To8((color >> 5) & 0x1F);                      blue = ImageUtils.Conv5To8((color) & 0x1F);                      alpha = 255;                  }                  else // with alpha                  {                      alpha = ImageUtils.Conv3To8((color >> 12) & 0x7);                      red = ImageUtils.Conv4To8((color >> 8) & 0xf);                      green = ImageUtils.Conv4To8((color >> 4) & 0xf);                      blue = ImageUtils.Conv4To8((color) & 0xf);                  }                    encoded[i] = Color.FromArgb(alpha' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: for (int i = 0; i < encoded.Length; i++)              {                  ushort color = 0;                  color = reader.ReadUInt16(ByteOrder);                      int red' green' blue' alpha;                  if ((color & 0x8000) != 0) //no alpha                  {                      red = ImageUtils.Conv5To8((color >> 10) & 0x1F);                      green = ImageUtils.Conv5To8((color >> 5) & 0x1F);                      blue = ImageUtils.Conv5To8((color) & 0x1F);                      alpha = 255;                  }                  else // with alpha                  {                      alpha = ImageUtils.Conv3To8((color >> 12) & 0x7);                      red = ImageUtils.Conv4To8((color >> 8) & 0xf);                      green = ImageUtils.Conv4To8((color >> 4) & 0xf);                      blue = ImageUtils.Conv4To8((color) & 0xf);                  }                    encoded[i] = Color.FromArgb(alpha' red' green' blue);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: for(int i=0;i<length;i++)              {                  ushort color = 0;                  int red' green' blue;                    int alpha = ImageUtils.Conv8To3(colors[start + i].A);                  if (alpha == 7) //we don't need alpha                  {                      red = ImageUtils.Conv8To5(colors[start + i].R);                      green = ImageUtils.Conv8To5(colors[start + i].G);                      blue = ImageUtils.Conv8To5(colors[start + i].B);                      color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);                      color |= 0x8000; //mark as no alpha                  }                  else                  {                      red = ImageUtils.Conv8To4(colors[start + i].R);                      green = ImageUtils.Conv8To4(colors[start + i].G);                      blue = ImageUtils.Conv8To4(colors[start + i].B);                      color = (ushort)( ((alpha & 0x7) << 12) | ((red & 0xF) << 8) | ((green & 0xF) << 4) | blue & 0xF);                  }                    encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);                  encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: byte b = pixelData[pos / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: if (ByteOrder == ByteOrder.LittleEndian)              {                  return pos % 2 == 0 ? b & 0xF : (b >> 4) & 0xF;              }              else              {                  return pos % 2 != 0 ? b & 0xF : (b >> 4) & 0xF;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: if (ByteOrder == ByteOrder.LittleEndian)              {                  return pos % 2 == 0 ? b & 0xF : (b >> 4) & 0xF;              }              else              {                  return pos % 2 != 0 ? b & 0xF : (b >> 4) & 0xF;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: if (ByteOrder == ByteOrder.LittleEndian)              {                  return pos % 2 == 0 ? b & 0xF : (b >> 4) & 0xF;              }              else              {                  return pos % 2 != 0 ? b & 0xF : (b >> 4) & 0xF;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: if (ByteOrder == ByteOrder.LittleEndian)              {                  return pos % 2 == 0 ? b & 0xF : (b >> 4) & 0xF;              }              else              {                  return pos % 2 != 0 ? b & 0xF : (b >> 4) & 0xF;              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: if (length % 2 != 0)                  throw new ArgumentException("Number of indexes must be odd!");
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: byte[] packed = new byte[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: for (int i = start; i < length; i += 2)              {                  if (indexes[i] > 15 || indexes[i + 1] > 15)                  {                      throw new ArgumentException("Too big index!");                    }                    if (ByteOrder == ByteOrder.LittleEndian)                  {                      packed[k++] = (byte)((indexes[i + 1] << 4) | indexes[i]);                  }                  else                  {                      packed[k++] = (byte)((indexes[i] << 4) | indexes[i + 1]);                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: for (int i = start; i < length; i += 2)              {                  if (indexes[i] > 15 || indexes[i + 1] > 15)                  {                      throw new ArgumentException("Too big index!");                    }                    if (ByteOrder == ByteOrder.LittleEndian)                  {                      packed[k++] = (byte)((indexes[i + 1] << 4) | indexes[i]);                  }                  else                  {                      packed[k++] = (byte)((indexes[i] << 4) | indexes[i + 1]);                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: for (int i = start; i < length; i += 2)              {                  if (indexes[i] > 15 || indexes[i + 1] > 15)                  {                      throw new ArgumentException("Too big index!");                    }                    if (ByteOrder == ByteOrder.LittleEndian)                  {                      packed[k++] = (byte)((indexes[i + 1] << 4) | indexes[i]);                  }                  else                  {                      packed[k++] = (byte)((indexes[i] << 4) | indexes[i + 1]);                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: for (int i = start; i < length; i += 2)              {                  if (indexes[i] > 15 || indexes[i + 1] > 15)                  {                      throw new ArgumentException("Too big index!");                    }                    if (ByteOrder == ByteOrder.LittleEndian)                  {                      packed[k++] = (byte)((indexes[i + 1] << 4) | indexes[i]);                  }                  else                  {                      packed[k++] = (byte)((indexes[i] << 4) | indexes[i + 1]);                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: for (int i = start; i < length; i += 2)              {                  if (indexes[i] > 15 || indexes[i + 1] > 15)                  {                      throw new ArgumentException("Too big index!");                    }                    if (ByteOrder == ByteOrder.LittleEndian)                  {                      packed[k++] = (byte)((indexes[i + 1] << 4) | indexes[i]);                  }                  else                  {                      packed[k++] = (byte)((indexes[i] << 4) | indexes[i + 1]);                  }              }
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec8Bpp,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec8Bpp.cs,PackIndexes,The following statement contains a magic number: for (int i = start; i < length; i++)              {                  if (indexes[i] > 255)                  {                      throw new ArgumentException("Too big index!");                  }                  packed[i - start] = (byte)indexes[i];              }
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: int planeSize = 32;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: int totalPlanes=2;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: for (int pos = 0; pos < length ;pos+=tileSize)              {                  reader.Read(ar' 0' ar.Length);                  reader.Read(gb' 0' gb.Length);                    for(int i=0;i<planeSize;i+=2)                  {                      byte a = ar[i];                      byte r = ar[i + 1];                        byte g = gb[i];                      byte b = gb[i + 1];                        decoded[pos + i * 2]        = a;                      decoded[pos + i * 2 + 1]    = r;                      decoded[pos + i * 2 + 2]    = g;                      decoded[pos + i * 2 + 3]    = b;                  }              }
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: for (int pos = 0; pos < length ;pos+=tileSize)              {                  reader.Read(ar' 0' ar.Length);                  reader.Read(gb' 0' gb.Length);                    for(int i=0;i<planeSize;i+=2)                  {                      byte a = ar[i];                      byte r = ar[i + 1];                        byte g = gb[i];                      byte b = gb[i + 1];                        decoded[pos + i * 2]        = a;                      decoded[pos + i * 2 + 1]    = r;                      decoded[pos + i * 2 + 2]    = g;                      decoded[pos + i * 2 + 3]    = b;                  }              }
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: for (int pos = 0; pos < length ;pos+=tileSize)              {                  reader.Read(ar' 0' ar.Length);                  reader.Read(gb' 0' gb.Length);                    for(int i=0;i<planeSize;i+=2)                  {                      byte a = ar[i];                      byte r = ar[i + 1];                        byte g = gb[i];                      byte b = gb[i + 1];                        decoded[pos + i * 2]        = a;                      decoded[pos + i * 2 + 1]    = r;                      decoded[pos + i * 2 + 2]    = g;                      decoded[pos + i * 2 + 3]    = b;                  }              }
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: for (int pos = 0; pos < length ;pos+=tileSize)              {                  reader.Read(ar' 0' ar.Length);                  reader.Read(gb' 0' gb.Length);                    for(int i=0;i<planeSize;i+=2)                  {                      byte a = ar[i];                      byte r = ar[i + 1];                        byte g = gb[i];                      byte b = gb[i + 1];                        decoded[pos + i * 2]        = a;                      decoded[pos + i * 2 + 1]    = r;                      decoded[pos + i * 2 + 2]    = g;                      decoded[pos + i * 2 + 3]    = b;                  }              }
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: for (int pos = 0; pos < length ;pos+=tileSize)              {                  reader.Read(ar' 0' ar.Length);                  reader.Read(gb' 0' gb.Length);                    for(int i=0;i<planeSize;i+=2)                  {                      byte a = ar[i];                      byte r = ar[i + 1];                        byte g = gb[i];                      byte b = gb[i + 1];                        decoded[pos + i * 2]        = a;                      decoded[pos + i * 2 + 1]    = r;                      decoded[pos + i * 2 + 2]    = g;                      decoded[pos + i * 2 + 3]    = b;                  }              }
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: for (int pos = 0; pos < length ;pos+=tileSize)              {                  reader.Read(ar' 0' ar.Length);                  reader.Read(gb' 0' gb.Length);                    for(int i=0;i<planeSize;i+=2)                  {                      byte a = ar[i];                      byte r = ar[i + 1];                        byte g = gb[i];                      byte b = gb[i + 1];                        decoded[pos + i * 2]        = a;                      decoded[pos + i * 2 + 1]    = r;                      decoded[pos + i * 2 + 2]    = g;                      decoded[pos + i * 2 + 3]    = b;                  }              }
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: for (int pos = 0; pos < length ;pos+=tileSize)              {                  reader.Read(ar' 0' ar.Length);                  reader.Read(gb' 0' gb.Length);                    for(int i=0;i<planeSize;i+=2)                  {                      byte a = ar[i];                      byte r = ar[i + 1];                        byte g = gb[i];                      byte b = gb[i + 1];                        decoded[pos + i * 2]        = a;                      decoded[pos + i * 2 + 1]    = r;                      decoded[pos + i * 2 + 2]    = g;                      decoded[pos + i * 2 + 3]    = b;                  }              }
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,ApplyFilter,The following statement contains a magic number: int w = (encodingWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,ApplyFilter,The following statement contains a magic number: int lineSize = TileDimensionsAsBytes? tileWidth : (tileWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,ApplyFilter,The following statement contains a magic number: int origW = (this.width * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,Defilter,The following statement contains a magic number: int w = (this.width * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,Defilter,The following statement contains a magic number: int lineSize = TileDimensionsAsBytes ? tileWidth : (tileWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,GetWidthForEncoding,The following statement contains a magic number: int w = (realWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,GetWidthForEncoding,The following statement contains a magic number: int lineSize = TileDimensionsAsBytes ? tileWidth : (tileWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,GetWidthForEncoding,The following statement contains a magic number: if (w % lineSize != 0)              {                  encodingWidth += ((lineSize - w % lineSize) * 8) / bpp;              }
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: if(bitDepth!=8)              {                  Array.Copy(originalData' index' newColors' 0' length);                  return newColors;              }
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int parts = length / 32;
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int stripes=2;
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int colors = 8;
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int blocks = 2;
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPaletteColorSize,The following statement contains a magic number: return 2;
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (clutFormat)              {                  case 1:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB565;                      break;                  case 2:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                      break;                  case 3:                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  case 0xB: //not sure about this (FIX)                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  default:                      throw new TextureFormatException("Unsupported clut format " + clutFormat);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (clutFormat)              {                  case 1:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB565;                      break;                  case 2:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                      break;                  case 3:                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  case 0xB: //not sure about this (FIX)                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  default:                      throw new TextureFormatException("Unsupported clut format " + clutFormat);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: imgFilter = new TileFilter(bpp' 8' 32 / bpp' width' height);
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: imgFilter = new TileFilter(bpp' 8' 32 / bpp' width' height);
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: reader.BaseStream.Position += 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < texturesCount; i++)              {                  TextureFormat segment = null;                    //image table                  uint imageHeaderOffset = reader.ReadUInt32(order);                  uint offsetPaletteHeader = reader.ReadUInt32(order);                    long oldPos = reader.BaseStream.Position;                    reader.BaseStream.Position = imageHeaderOffset;                    int height = reader.ReadUInt16(order);                  int width = reader.ReadUInt16(order);                  uint format = reader.ReadUInt32(order);                  uint imgDataOffset = reader.ReadUInt32(order);                    ColorCodec colorCodec=null;                  IndexCodec idxCodec=null;                  ImageFilter imgFilter=null;                    ushort entryCount=0;                  ushort unknown=0;//this might be a set of flags denoting whether the palette is internal to the tpl image or external.                  uint paletteFormat=0;                  uint palDataOffset=0;                  bool isIndexed = false;                    int imgDataSize=0;                  int palDataSize=0;                    switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }                    reader.BaseStream.Position = imgDataOffset;                  byte[] imgData = reader.ReadBytes(imgDataSize);                    if (isIndexed)                  {                      reader.BaseStream.Position = palDataOffset;                      byte[] palData = reader.ReadBytes(palDataSize);                        PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                      segment = builder.SetIndexCodec(idxCodec)                                       .SetPaletteCodec(colorCodec)                                       .SetImageFilter(imgFilter)                                       .Build(imgData' palData' width' height);                  }                  else                  {                      GenericTextureFormat.Builder builder = new GenericTextureFormat.Builder();                      segment=  builder .SetColorCodec(colorCodec)                                                      .SetImageFilter(imgFilter)                                                      .Build(imgData' width' height);                  }                    segment.FormatSpecificData.Put<uint>(FORMAT_KEY' format)                                            .Put<uint>(UNKNOWN_KEY'unknown)                                            .Put<uint>(PALETTEFORMAT_KEY'paletteFormat);                    texture.TextureFormats.Add(segment);                    reader.BaseStream.Position = oldPos;                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<bpps.Length;i++)              {                  int count = widths[i] * heights[i];                  if (bpps[i] == 4)                  {                      count /= 2;                  }                    if (bpps[i] != 8 && bpps[i] != 4)                  {                      throw new TextureFormatException("Illegal bpp value: " + bpps[i]);                  }                    byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];                  byte[] imageData = new byte[count];                    reader.Read(paletteData' 0' paletteData.Length);                  palettes.Add(ColorCodec.CODEC_32BIT_RGBA.DecodeColors(paletteData));                    reader.Read(imageData'0'count);                    imagesData.Add(imageData);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<images.Count;i++)              {                  if(bpps[i]!=8 && bpps[i]!=4)                      throw new TextureFormatException("Illegal bpp value: "+bpps[i]);                    Image img=images[i];                  ImageEncoderIndexed encoder = new ImageEncoderIndexed(img' IndexCodec.FromBitPerPixel(bpps[i])'null'null'new SwizzleFilter(widths[i]'heights[i]'bpps[i]));                  imagesData.Add(encoder.Encode());                  palettes.Add(encoder.Palettes[0]);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: for(int i=0;i<images.Count;i++)              {                  if(bpps[i]!=8 && bpps[i]!=4)                      throw new TextureFormatException("Illegal bpp value: "+bpps[i]);                    Image img=images[i];                  ImageEncoderIndexed encoder = new ImageEncoderIndexed(img' IndexCodec.FromBitPerPixel(bpps[i])'null'null'new SwizzleFilter(widths[i]'heights[i]'bpps[i]));                  imagesData.Add(encoder.Encode());                  palettes.Add(encoder.Palettes[0]);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: width = 512;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: height = imageData.Length * 2 / width;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: if (img.Width != 512)              {                  throw new TextureFormatException("Only a width of 512 pixel is allowed!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: ImageEncoderIndexed encoder = new ImageEncoderIndexed(img'                                                                     IndexCodec.FromBitPerPixel(4)' null' null'                                                                     new SwizzleFilter(width' height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: ImageEncoderIndexed encoder = new ImageEncoderIndexed(img'                                                                     IndexCodec.FromBitPerPixel(4)' null' null'                                                                     new SwizzleFilter(width' height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,GetImage,The following statement contains a magic number: ImageDecoderIndexed decoder = new ImageDecoderIndexed(imageData'                                                                     Width' Height'                                                                     IndexCodec.FromBitPerPixel(4)' null'                                                                    new SwizzleFilter(Width' Height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,GetImage,The following statement contains a magic number: ImageDecoderIndexed decoder = new ImageDecoderIndexed(imageData'                                                                     Width' Height'                                                                     IndexCodec.FromBitPerPixel(4)' null'                                                                    new SwizzleFilter(Width' Height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,Open,The following statement contains a magic number: reader.BaseStream.Seek(4' SeekOrigin.Begin);
Magic Number,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,Open,The following statement contains a magic number: int padding = headerSize - 8;
Magic Number,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,ConstructSegment,The following statement contains a magic number: byte[] data=reader.ReadBytes(24);
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,IsValidFormat,The following statement contains a magic number: for (int i = 0; i < count;i++)              {                  reader.BaseStream.Seek(0x0C' SeekOrigin.Current);                  uint format=reader.ReadUInt32();                  if (format != 2 && format != 1)                  {                      inputFormat.Position = oldPos;                      return false;                  }              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < bpps.Length;i++ )              {                  if (formats[i] != 2 && formats[i] != 1)                      throw new TextureFormatException("Not valid format code: " + formats[i]);                  bpps[i] = formats[i] == 2 ? 8 : 4;              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < bpps.Length;i++ )              {                  if (formats[i] != 2 && formats[i] != 1)                      throw new TextureFormatException("Not valid format code: " + formats[i]);                  bpps[i] = formats[i] == 2 ? 8 : 4;              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < bpps.Length;i++ )              {                  if (formats[i] != 2 && formats[i] != 1)                      throw new TextureFormatException("Not valid format code: " + formats[i]);                  bpps[i] = formats[i] == 2 ? 8 : 4;              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: for (int i = 0; i < bpps.Length;i++ )              {                  if (formats[i] != 2 && formats[i] != 1)                      throw new TextureFormatException("Not valid format code: " + formats[i]);                  bpps[i] = formats[i] == 2 ? 8 : 4;              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Save,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  writer.Write((uint)0);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Save,The following statement contains a magic number: for(int i=0;i<dat.FramesCount;i++)              {                  dat.SelectedFrame = i;                  writer.Write(dat.Position1);                  writer.Write((ushort)dat.Width);                  writer.Write((ushort)dat.Height);                  writer.Write(dat.Position2);                  writer.Write(dat.Bpp == 8 ? (uint)2 : (uint)1);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Save,The following statement contains a magic number: for(int i=0;i<dat.FramesCount;i++)              {                  dat.SelectedFrame = i;                  writer.Write(dat.Position1);                  writer.Write((ushort)dat.Width);                  writer.Write((ushort)dat.Height);                  writer.Write(dat.Position2);                  writer.Write(dat.Bpp == 8 ? (uint)2 : (uint)1);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,IsValidFormat,The following statement contains a magic number: char[] magic = reader.ReadChars(4);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,Save,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  writer.Write((byte)0);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,ReadHeader,The following statement contains a magic number: char[] magic = reader.ReadChars(4);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,ReadHeader,The following statement contains a magic number: reader.BaseStream.Position += 8;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: ushort colorEntries = (ushort)(parameters.bpp > 8 ? 0 : 1 << parameters.bpp);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: byte clutFormat = (byte)(parameters.bpp > 8 ? 0 : parameters.colorSize - 1);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.GsTEX0 = reader.ReadBytes(8);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.GsTEX1 = reader.ReadBytes(8);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.colorSize = parameters.bpp > 8 ? parameters.bpp / 8 : (clutFormat & 0x07) + 1;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.colorSize = parameters.bpp > 8 ? parameters.bpp / 8 : (clutFormat & 0x07) + 1;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TX48Serializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TX48Texture.Serializer.cs,Open,The following statement contains a magic number: try              {                    char[] magic = reader.ReadChars(MAGIC.Length);                  if (new string(magic) != MAGIC)                  {                      throw new TextureFormatException("Not a valid TX48 Texture!");                  }                    int bpp = reader.ReadInt32();                  if (bpp != 0 && bpp != 1)                  {                      throw new TextureFormatException("Illegal Bit per pixel value!");                  }                    bpp = (bpp + 1) * 4;                    int width = reader.ReadInt32();                  int height = reader.ReadInt32();                  int paletteOffset = reader.ReadInt32();                  if (paletteOffset != 0x40)                  {                      throw new TextureFormatException("TX48 Header is wrong!");                  }                    int paletteSize = reader.ReadInt32();                  int imageOffset = reader.ReadInt32();                  int imageSize = reader.ReadInt32();                  reader.BaseStream.Position += 0x20;                    byte[] paletteData = reader.ReadBytes(paletteSize);                  byte[] imageData = reader.ReadBytes(imageSize);                    PalettedTextureFormat.Builder builder = new PalettedTextureFormat.Builder();                  builder.SetPaletteCodec(ColorCodec.CODEC_32BIT_RGBA)                         .SetIndexCodec(IndexCodec.FromBitPerPixel(bpp));                    PalettedTextureFormat segment = builder.Build(imageData' paletteData' width' height);                  TX48Texture texture = new TX48Texture();                  texture.TextureFormats.Add(segment);                    return texture;                }              catch (Exception e)              {                  if (e is TextureFormatException)                      throw;                  throw new TextureFormatException(e.Message' e);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TX48Serializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TX48Texture.Serializer.cs,Save,The following statement contains a magic number: writer.Write(bpps / 4 - 1);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TX48Serializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TX48Texture.Serializer.cs,Save,The following statement contains a magic number: for (int j = 0; j < 8; j++)              {                  writer.Write(0);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,TIM2Segment,The following statement contains a magic number: if (parameters.bpp > 8) //true color image              {                  imageData = GetColorCodec(parameters.colorSize).EncodeColors(image.GetColorArray()); //I love extension methods. Hurray!              }              else              {                  ImageEncoderIndexed encoder;                  if (palettes != null)                  {                      encoder = new ImageEncoderIndexed(palettes' image' IndexCodec.FromBitPerPixel(parameters.bpp));                  }                  else                  {                      encoder = new ImageEncoderIndexed(image' IndexCodec.FromBitPerPixel(parameters.bpp)' new ARGBColorComparer());                  }                    imageData = encoder.Encode();                  this.palettes = new List<Color[]>(encoder.Palettes).ToArray();              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,CreateImageDecoder,The following statement contains a magic number: if (Bpp <= 8) //here we have an Indexed TIM2              {                  decoder = new ImageDecoderIndexed(imageData'                                                parameters.width' parameters.height'                                                IndexCodec.FromBitPerPixel(Bpp)'                                                palettes[SelectedPalette]);              }              else //otherwise' we have a true color TIM2              {                  decoder = new ImageDecoderDirectColor(imageData'                                                parameters.width' parameters.height'                                                GetColorCodec(parameters.colorSize));                }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,ConstructPalettes,The following statement contains a magic number: if (parameters.bpp > 8)                  return;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,GetColorCodec,The following statement contains a magic number: switch (pixelSize)              {                  case 2:                      return ColorCodec.CODEC_16BITLE_ABGR;                  case 3:                      return ColorCodec.CODEC_24BIT_RGB;                  case 4:                      return ColorCodec.CODEC_32BIT_RGBA;                  default:                      throw new TextureFormatException("Illegal Pixel size!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,GetColorCodec,The following statement contains a magic number: switch (pixelSize)              {                  case 2:                      return ColorCodec.CODEC_16BITLE_ABGR;                  case 3:                      return ColorCodec.CODEC_24BIT_RGB;                  case 4:                      return ColorCodec.CODEC_32BIT_RGBA;                  default:                      throw new TextureFormatException("Illegal Pixel size!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,GetColorCodec,The following statement contains a magic number: switch (pixelSize)              {                  case 2:                      return ColorCodec.CODEC_16BITLE_ABGR;                  case 3:                      return ColorCodec.CODEC_24BIT_RGB;                  case 4:                      return ColorCodec.CODEC_32BIT_RGBA;                  default:                      throw new TextureFormatException("Illegal Pixel size!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Open,The following statement contains a magic number: reader.ReadBytes(8);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: foreach (TextureFormat segment in efxTexture.TextureFormats)              {                  byte[] entryData = null;                  int fullEntrySize = 0;                  int sizeOfEntryNoHeader1 = 0;                    byte[] imgData = null' palData = null;                  PalettedTextureFormat palSegment = segment as PalettedTextureFormat;                  DummyTexture dummySegment = segment as DummyTexture;                    if (palSegment != null)                  {                      imgData = palSegment.GetImageData();                      IList<byte[]> palettes = palSegment.GetPaletteData();                      if (palettes.Count > 1)                          throw new TextureFormatException("EFX should not support multi palette images!");                        palData = palettes.First();                        fullEntrySize = 0x30 + imgData.Length + palData.Length;                        entryData = imgData.Concat(palData).ToArray();                  }                  else if (dummySegment != null)                  {                      entryData = dummySegment.FormatSpecificData.Get<byte[]>(RAW_DATA_KEY);                        fullEntrySize = 0x10 + entryData.Length;                  }                  else                  {                      throw new TextureFormatException("EFX segments should be Paletted or dummy!");                  }                    writer.Write(fullEntrySize);                    writer.Write(segment.FormatSpecificData.Get<ushort>(UNK1_KEY));                  writer.Write(segment.FormatSpecificData.Get<ushort>(UNK2_KEY));                    sizeOfEntryNoHeader1 = fullEntrySize - 0x10;                    if (palSegment != null)                  {                      writer.Write((uint)sizeOfEntryNoHeader1);                  }                  else                  {                      writer.Write(segment.FormatSpecificData.Get<uint>(ENTRY_NO_HEADER_KEY));                  }                    writer.Write(segment.FormatSpecificData.Get<ushort>(ID_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(ENTRY_TYPE_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(UNK3_KEY));                    if (palSegment != null)                  {                      byte bpp = segment.FormatSpecificData.Get<byte>(BPP_KEY);                      writer.Write(bpp);                      writer.Write(segment.FormatSpecificData.Get<byte>(UNK4_KEY));                      writer.Write(segment.FormatSpecificData.Get<ushort>(UNK5_KEY));                      writer.Write((ushort)(1 << bpp));                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)0);                      writer.Write(segment.FormatSpecificData.Get<uint>(UNK6_KEY));                        int header2AndImgSize = 0x20 + imgData.Length;                        writer.Write((uint)header2AndImgSize);                      writer.Write((uint)sizeOfEntryNoHeader1);                      writer.Write((uint)0);                  }                    writer.Write(entryData);                    fileSize += fullEntrySize;                    if (fullEntrySize % 4 != 0)                  {                      fileSize = fileSize + 4 - fullEntrySize % 4;                      writer.Write(Enumerable.Repeat((byte)0' 4 - fullEntrySize % 4).ToArray());                  }              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: foreach (TextureFormat segment in efxTexture.TextureFormats)              {                  byte[] entryData = null;                  int fullEntrySize = 0;                  int sizeOfEntryNoHeader1 = 0;                    byte[] imgData = null' palData = null;                  PalettedTextureFormat palSegment = segment as PalettedTextureFormat;                  DummyTexture dummySegment = segment as DummyTexture;                    if (palSegment != null)                  {                      imgData = palSegment.GetImageData();                      IList<byte[]> palettes = palSegment.GetPaletteData();                      if (palettes.Count > 1)                          throw new TextureFormatException("EFX should not support multi palette images!");                        palData = palettes.First();                        fullEntrySize = 0x30 + imgData.Length + palData.Length;                        entryData = imgData.Concat(palData).ToArray();                  }                  else if (dummySegment != null)                  {                      entryData = dummySegment.FormatSpecificData.Get<byte[]>(RAW_DATA_KEY);                        fullEntrySize = 0x10 + entryData.Length;                  }                  else                  {                      throw new TextureFormatException("EFX segments should be Paletted or dummy!");                  }                    writer.Write(fullEntrySize);                    writer.Write(segment.FormatSpecificData.Get<ushort>(UNK1_KEY));                  writer.Write(segment.FormatSpecificData.Get<ushort>(UNK2_KEY));                    sizeOfEntryNoHeader1 = fullEntrySize - 0x10;                    if (palSegment != null)                  {                      writer.Write((uint)sizeOfEntryNoHeader1);                  }                  else                  {                      writer.Write(segment.FormatSpecificData.Get<uint>(ENTRY_NO_HEADER_KEY));                  }                    writer.Write(segment.FormatSpecificData.Get<ushort>(ID_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(ENTRY_TYPE_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(UNK3_KEY));                    if (palSegment != null)                  {                      byte bpp = segment.FormatSpecificData.Get<byte>(BPP_KEY);                      writer.Write(bpp);                      writer.Write(segment.FormatSpecificData.Get<byte>(UNK4_KEY));                      writer.Write(segment.FormatSpecificData.Get<ushort>(UNK5_KEY));                      writer.Write((ushort)(1 << bpp));                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)0);                      writer.Write(segment.FormatSpecificData.Get<uint>(UNK6_KEY));                        int header2AndImgSize = 0x20 + imgData.Length;                        writer.Write((uint)header2AndImgSize);                      writer.Write((uint)sizeOfEntryNoHeader1);                      writer.Write((uint)0);                  }                    writer.Write(entryData);                    fileSize += fullEntrySize;                    if (fullEntrySize % 4 != 0)                  {                      fileSize = fileSize + 4 - fullEntrySize % 4;                      writer.Write(Enumerable.Repeat((byte)0' 4 - fullEntrySize % 4).ToArray());                  }              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: foreach (TextureFormat segment in efxTexture.TextureFormats)              {                  byte[] entryData = null;                  int fullEntrySize = 0;                  int sizeOfEntryNoHeader1 = 0;                    byte[] imgData = null' palData = null;                  PalettedTextureFormat palSegment = segment as PalettedTextureFormat;                  DummyTexture dummySegment = segment as DummyTexture;                    if (palSegment != null)                  {                      imgData = palSegment.GetImageData();                      IList<byte[]> palettes = palSegment.GetPaletteData();                      if (palettes.Count > 1)                          throw new TextureFormatException("EFX should not support multi palette images!");                        palData = palettes.First();                        fullEntrySize = 0x30 + imgData.Length + palData.Length;                        entryData = imgData.Concat(palData).ToArray();                  }                  else if (dummySegment != null)                  {                      entryData = dummySegment.FormatSpecificData.Get<byte[]>(RAW_DATA_KEY);                        fullEntrySize = 0x10 + entryData.Length;                  }                  else                  {                      throw new TextureFormatException("EFX segments should be Paletted or dummy!");                  }                    writer.Write(fullEntrySize);                    writer.Write(segment.FormatSpecificData.Get<ushort>(UNK1_KEY));                  writer.Write(segment.FormatSpecificData.Get<ushort>(UNK2_KEY));                    sizeOfEntryNoHeader1 = fullEntrySize - 0x10;                    if (palSegment != null)                  {                      writer.Write((uint)sizeOfEntryNoHeader1);                  }                  else                  {                      writer.Write(segment.FormatSpecificData.Get<uint>(ENTRY_NO_HEADER_KEY));                  }                    writer.Write(segment.FormatSpecificData.Get<ushort>(ID_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(ENTRY_TYPE_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(UNK3_KEY));                    if (palSegment != null)                  {                      byte bpp = segment.FormatSpecificData.Get<byte>(BPP_KEY);                      writer.Write(bpp);                      writer.Write(segment.FormatSpecificData.Get<byte>(UNK4_KEY));                      writer.Write(segment.FormatSpecificData.Get<ushort>(UNK5_KEY));                      writer.Write((ushort)(1 << bpp));                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)0);                      writer.Write(segment.FormatSpecificData.Get<uint>(UNK6_KEY));                        int header2AndImgSize = 0x20 + imgData.Length;                        writer.Write((uint)header2AndImgSize);                      writer.Write((uint)sizeOfEntryNoHeader1);                      writer.Write((uint)0);                  }                    writer.Write(entryData);                    fileSize += fullEntrySize;                    if (fullEntrySize % 4 != 0)                  {                      fileSize = fileSize + 4 - fullEntrySize % 4;                      writer.Write(Enumerable.Repeat((byte)0' 4 - fullEntrySize % 4).ToArray());                  }              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: foreach (TextureFormat segment in efxTexture.TextureFormats)              {                  byte[] entryData = null;                  int fullEntrySize = 0;                  int sizeOfEntryNoHeader1 = 0;                    byte[] imgData = null' palData = null;                  PalettedTextureFormat palSegment = segment as PalettedTextureFormat;                  DummyTexture dummySegment = segment as DummyTexture;                    if (palSegment != null)                  {                      imgData = palSegment.GetImageData();                      IList<byte[]> palettes = palSegment.GetPaletteData();                      if (palettes.Count > 1)                          throw new TextureFormatException("EFX should not support multi palette images!");                        palData = palettes.First();                        fullEntrySize = 0x30 + imgData.Length + palData.Length;                        entryData = imgData.Concat(palData).ToArray();                  }                  else if (dummySegment != null)                  {                      entryData = dummySegment.FormatSpecificData.Get<byte[]>(RAW_DATA_KEY);                        fullEntrySize = 0x10 + entryData.Length;                  }                  else                  {                      throw new TextureFormatException("EFX segments should be Paletted or dummy!");                  }                    writer.Write(fullEntrySize);                    writer.Write(segment.FormatSpecificData.Get<ushort>(UNK1_KEY));                  writer.Write(segment.FormatSpecificData.Get<ushort>(UNK2_KEY));                    sizeOfEntryNoHeader1 = fullEntrySize - 0x10;                    if (palSegment != null)                  {                      writer.Write((uint)sizeOfEntryNoHeader1);                  }                  else                  {                      writer.Write(segment.FormatSpecificData.Get<uint>(ENTRY_NO_HEADER_KEY));                  }                    writer.Write(segment.FormatSpecificData.Get<ushort>(ID_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(ENTRY_TYPE_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(UNK3_KEY));                    if (palSegment != null)                  {                      byte bpp = segment.FormatSpecificData.Get<byte>(BPP_KEY);                      writer.Write(bpp);                      writer.Write(segment.FormatSpecificData.Get<byte>(UNK4_KEY));                      writer.Write(segment.FormatSpecificData.Get<ushort>(UNK5_KEY));                      writer.Write((ushort)(1 << bpp));                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)0);                      writer.Write(segment.FormatSpecificData.Get<uint>(UNK6_KEY));                        int header2AndImgSize = 0x20 + imgData.Length;                        writer.Write((uint)header2AndImgSize);                      writer.Write((uint)sizeOfEntryNoHeader1);                      writer.Write((uint)0);                  }                    writer.Write(entryData);                    fileSize += fullEntrySize;                    if (fullEntrySize % 4 != 0)                  {                      fileSize = fileSize + 4 - fullEntrySize % 4;                      writer.Write(Enumerable.Repeat((byte)0' 4 - fullEntrySize % 4).ToArray());                  }              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: foreach (TextureFormat segment in efxTexture.TextureFormats)              {                  byte[] entryData = null;                  int fullEntrySize = 0;                  int sizeOfEntryNoHeader1 = 0;                    byte[] imgData = null' palData = null;                  PalettedTextureFormat palSegment = segment as PalettedTextureFormat;                  DummyTexture dummySegment = segment as DummyTexture;                    if (palSegment != null)                  {                      imgData = palSegment.GetImageData();                      IList<byte[]> palettes = palSegment.GetPaletteData();                      if (palettes.Count > 1)                          throw new TextureFormatException("EFX should not support multi palette images!");                        palData = palettes.First();                        fullEntrySize = 0x30 + imgData.Length + palData.Length;                        entryData = imgData.Concat(palData).ToArray();                  }                  else if (dummySegment != null)                  {                      entryData = dummySegment.FormatSpecificData.Get<byte[]>(RAW_DATA_KEY);                        fullEntrySize = 0x10 + entryData.Length;                  }                  else                  {                      throw new TextureFormatException("EFX segments should be Paletted or dummy!");                  }                    writer.Write(fullEntrySize);                    writer.Write(segment.FormatSpecificData.Get<ushort>(UNK1_KEY));                  writer.Write(segment.FormatSpecificData.Get<ushort>(UNK2_KEY));                    sizeOfEntryNoHeader1 = fullEntrySize - 0x10;                    if (palSegment != null)                  {                      writer.Write((uint)sizeOfEntryNoHeader1);                  }                  else                  {                      writer.Write(segment.FormatSpecificData.Get<uint>(ENTRY_NO_HEADER_KEY));                  }                    writer.Write(segment.FormatSpecificData.Get<ushort>(ID_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(ENTRY_TYPE_KEY));                  writer.Write(segment.FormatSpecificData.Get<byte>(UNK3_KEY));                    if (palSegment != null)                  {                      byte bpp = segment.FormatSpecificData.Get<byte>(BPP_KEY);                      writer.Write(bpp);                      writer.Write(segment.FormatSpecificData.Get<byte>(UNK4_KEY));                      writer.Write(segment.FormatSpecificData.Get<ushort>(UNK5_KEY));                      writer.Write((ushort)(1 << bpp));                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)segment.Width);                      writer.Write((ushort)segment.Height);                      writer.Write((ushort)0);                      writer.Write(segment.FormatSpecificData.Get<uint>(UNK6_KEY));                        int header2AndImgSize = 0x20 + imgData.Length;                        writer.Write((uint)header2AndImgSize);                      writer.Write((uint)sizeOfEntryNoHeader1);                      writer.Write((uint)0);                  }                    writer.Write(entryData);                    fileSize += fullEntrySize;                    if (fullEntrySize % 4 != 0)                  {                      fileSize = fileSize + 4 - fullEntrySize % 4;                      writer.Write(Enumerable.Repeat((byte)0' 4 - fullEntrySize % 4).ToArray());                  }              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,The following statement contains a magic number: if (entryType != 0x52) // non-image entry              {                  //let's copy the raw data and put it in a dummy texture                  byte[] buf = reader.ReadBytes((int)fullEntrySize - 0x10);                    segment = new DummyTexture(string.Format("Data entry' type=0x{0:X}"' entryType));                    segment.FormatSpecificData.Put<byte[]>(RAW_DATA_KEY' buf);                  segment.FormatSpecificData.Put<uint>(ENTRY_NO_HEADER_KEY' sizeEntryNotHeader);              }              else //image data' let's read header 2 data              {                  if (fullEntrySize - sizeEntryNotHeader != 0x10)                  {                      throw new TextureFormatException("Not a valid EFX file' full size and size without header 1 do not match!");                  }                    byte bpp = reader.ReadByte();                  if (bpp != 4 && bpp != 8)                  {                      throw new TextureFormatException("Not a valid EFX file' unsupported bpp=" + bpp);                  }                    byte unk4 = reader.ReadByte();                  if (unk4 != 0x20)                  {                      throw new TextureFormatException("Not a valid EFX file' unk3 not equal to 0x20!");                  }                    ushort unk5 = reader.ReadUInt16();                  if (unk5 != 0x01)                  {                      throw new TextureFormatException("Not a valid EFX file' unk4 not equal to 0x01!");                  }                    ushort paletteColors = reader.ReadUInt16();                  if (paletteColors != 1 << bpp)                  {                      throw new TextureFormatException("This EFX file contains more colors then requested by bpp. Is this a multi-palette texture?");                  }                    ushort width = reader.ReadUInt16();                  ushort height = reader.ReadUInt16();                    if (reader.ReadUInt16() != width)                  {                      throw new TextureFormatException("Not a valid EFX file' widths not corresponding!");                  }                  if (reader.ReadUInt16() != height)                  {                      throw new TextureFormatException("Not a valid EFX file' widths not corresponding!");                  }                    reader.ReadUInt16(); //pad                    uint unk6 = reader.ReadUInt32();                  if (unk6 != 0x20)                  {                      throw new TextureFormatException("Not a valid EFX file' unk5 not equal to 0x20!");                  }                    uint header2AndImgDataSize = reader.ReadUInt32();                  uint imgSize = header2AndImgDataSize - 0x20;                    int paletteSize = paletteColors * 4;                  if (sizeEntryNotHeader - header2AndImgDataSize != paletteSize)                  {                      throw new TextureFormatException("Not a valid EFX file' size of image data not corresponding!");                  }                    if (reader.ReadUInt32() != sizeEntryNotHeader)                  {                      throw new TextureFormatException("Not a valid EFX file' size of entry without header 1 not corresponding in header 2!");                  }                    reader.ReadUInt32(); //pad                    //retrieve image and palette data and construct texture                    byte[] imgData = reader.ReadBytes((int)imgSize);                  byte[] palData = reader.ReadBytes(paletteSize);                    segment = new PalettedTextureFormat.Builder()                      .SetIndexCodec(IndexCodec.FromBitPerPixel(bpp))                      .SetImageFilter(new SwizzleFilter(width' height' bpp))                      .SetPaletteCodec(ColorCodec.CODEC_32BIT_RGBA)                      .SetColorComparer(new ARGBColorComparer())                      .Build(imgData' palData' width' height);                    segment.FormatSpecificData.Put<byte>(BPP_KEY' bpp);                  segment.FormatSpecificData.Put<byte>(UNK4_KEY' unk4);                  segment.FormatSpecificData.Put<ushort>(UNK5_KEY' unk5);                  segment.FormatSpecificData.Put<uint>(UNK6_KEY' unk6);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,The following statement contains a magic number: if (entryType != 0x52) // non-image entry              {                  //let's copy the raw data and put it in a dummy texture                  byte[] buf = reader.ReadBytes((int)fullEntrySize - 0x10);                    segment = new DummyTexture(string.Format("Data entry' type=0x{0:X}"' entryType));                    segment.FormatSpecificData.Put<byte[]>(RAW_DATA_KEY' buf);                  segment.FormatSpecificData.Put<uint>(ENTRY_NO_HEADER_KEY' sizeEntryNotHeader);              }              else //image data' let's read header 2 data              {                  if (fullEntrySize - sizeEntryNotHeader != 0x10)                  {                      throw new TextureFormatException("Not a valid EFX file' full size and size without header 1 do not match!");                  }                    byte bpp = reader.ReadByte();                  if (bpp != 4 && bpp != 8)                  {                      throw new TextureFormatException("Not a valid EFX file' unsupported bpp=" + bpp);                  }                    byte unk4 = reader.ReadByte();                  if (unk4 != 0x20)                  {                      throw new TextureFormatException("Not a valid EFX file' unk3 not equal to 0x20!");                  }                    ushort unk5 = reader.ReadUInt16();                  if (unk5 != 0x01)                  {                      throw new TextureFormatException("Not a valid EFX file' unk4 not equal to 0x01!");                  }                    ushort paletteColors = reader.ReadUInt16();                  if (paletteColors != 1 << bpp)                  {                      throw new TextureFormatException("This EFX file contains more colors then requested by bpp. Is this a multi-palette texture?");                  }                    ushort width = reader.ReadUInt16();                  ushort height = reader.ReadUInt16();                    if (reader.ReadUInt16() != width)                  {                      throw new TextureFormatException("Not a valid EFX file' widths not corresponding!");                  }                  if (reader.ReadUInt16() != height)                  {                      throw new TextureFormatException("Not a valid EFX file' widths not corresponding!");                  }                    reader.ReadUInt16(); //pad                    uint unk6 = reader.ReadUInt32();                  if (unk6 != 0x20)                  {                      throw new TextureFormatException("Not a valid EFX file' unk5 not equal to 0x20!");                  }                    uint header2AndImgDataSize = reader.ReadUInt32();                  uint imgSize = header2AndImgDataSize - 0x20;                    int paletteSize = paletteColors * 4;                  if (sizeEntryNotHeader - header2AndImgDataSize != paletteSize)                  {                      throw new TextureFormatException("Not a valid EFX file' size of image data not corresponding!");                  }                    if (reader.ReadUInt32() != sizeEntryNotHeader)                  {                      throw new TextureFormatException("Not a valid EFX file' size of entry without header 1 not corresponding in header 2!");                  }                    reader.ReadUInt32(); //pad                    //retrieve image and palette data and construct texture                    byte[] imgData = reader.ReadBytes((int)imgSize);                  byte[] palData = reader.ReadBytes(paletteSize);                    segment = new PalettedTextureFormat.Builder()                      .SetIndexCodec(IndexCodec.FromBitPerPixel(bpp))                      .SetImageFilter(new SwizzleFilter(width' height' bpp))                      .SetPaletteCodec(ColorCodec.CODEC_32BIT_RGBA)                      .SetColorComparer(new ARGBColorComparer())                      .Build(imgData' palData' width' height);                    segment.FormatSpecificData.Put<byte>(BPP_KEY' bpp);                  segment.FormatSpecificData.Put<byte>(UNK4_KEY' unk4);                  segment.FormatSpecificData.Put<ushort>(UNK5_KEY' unk5);                  segment.FormatSpecificData.Put<uint>(UNK6_KEY' unk6);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,C:\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,The following statement contains a magic number: if (entryType != 0x52) // non-image entry              {                  //let's copy the raw data and put it in a dummy texture                  byte[] buf = reader.ReadBytes((int)fullEntrySize - 0x10);                    segment = new DummyTexture(string.Format("Data entry' type=0x{0:X}"' entryType));                    segment.FormatSpecificData.Put<byte[]>(RAW_DATA_KEY' buf);                  segment.FormatSpecificData.Put<uint>(ENTRY_NO_HEADER_KEY' sizeEntryNotHeader);              }              else //image data' let's read header 2 data              {                  if (fullEntrySize - sizeEntryNotHeader != 0x10)                  {                      throw new TextureFormatException("Not a valid EFX file' full size and size without header 1 do not match!");                  }                    byte bpp = reader.ReadByte();                  if (bpp != 4 && bpp != 8)                  {                      throw new TextureFormatException("Not a valid EFX file' unsupported bpp=" + bpp);                  }                    byte unk4 = reader.ReadByte();                  if (unk4 != 0x20)                  {                      throw new TextureFormatException("Not a valid EFX file' unk3 not equal to 0x20!");                  }                    ushort unk5 = reader.ReadUInt16();                  if (unk5 != 0x01)                  {                      throw new TextureFormatException("Not a valid EFX file' unk4 not equal to 0x01!");                  }                    ushort paletteColors = reader.ReadUInt16();                  if (paletteColors != 1 << bpp)                  {                      throw new TextureFormatException("This EFX file contains more colors then requested by bpp. Is this a multi-palette texture?");                  }                    ushort width = reader.ReadUInt16();                  ushort height = reader.ReadUInt16();                    if (reader.ReadUInt16() != width)                  {                      throw new TextureFormatException("Not a valid EFX file' widths not corresponding!");                  }                  if (reader.ReadUInt16() != height)                  {                      throw new TextureFormatException("Not a valid EFX file' widths not corresponding!");                  }                    reader.ReadUInt16(); //pad                    uint unk6 = reader.ReadUInt32();                  if (unk6 != 0x20)                  {                      throw new TextureFormatException("Not a valid EFX file' unk5 not equal to 0x20!");                  }                    uint header2AndImgDataSize = reader.ReadUInt32();                  uint imgSize = header2AndImgDataSize - 0x20;                    int paletteSize = paletteColors * 4;                  if (sizeEntryNotHeader - header2AndImgDataSize != paletteSize)                  {                      throw new TextureFormatException("Not a valid EFX file' size of image data not corresponding!");                  }                    if (reader.ReadUInt32() != sizeEntryNotHeader)                  {                      throw new TextureFormatException("Not a valid EFX file' size of entry without header 1 not corresponding in header 2!");                  }                    reader.ReadUInt32(); //pad                    //retrieve image and palette data and construct texture                    byte[] imgData = reader.ReadBytes((int)imgSize);                  byte[] palData = reader.ReadBytes(paletteSize);                    segment = new PalettedTextureFormat.Builder()                      .SetIndexCodec(IndexCodec.FromBitPerPixel(bpp))                      .SetImageFilter(new SwizzleFilter(width' height' bpp))                      .SetPaletteCodec(ColorCodec.CODEC_32BIT_RGBA)                      .SetColorComparer(new ARGBColorComparer())                      .Build(imgData' palData' width' height);                    segment.FormatSpecificData.Put<byte>(BPP_KEY' bpp);                  segment.FormatSpecificData.Put<byte>(UNK4_KEY' unk4);                  segment.FormatSpecificData.Put<ushort>(UNK5_KEY' unk5);                  segment.FormatSpecificData.Put<uint>(UNK6_KEY' unk6);              }
