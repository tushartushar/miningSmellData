Implementation smell,Namespace,Class,File,Method,Description
Long Method,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The method has 144 lines of code.
Complex Method,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,EncodeFromImages,Cyclomatic complexity of the method is 14
Complex Method,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,Cyclomatic complexity of the method is 8
Complex Method,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,Cyclomatic complexity of the method is 18
Complex Method,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,Cyclomatic complexity of the method is 8
Complex Method,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,Cyclomatic complexity of the method is 12
Complex Method,Rainbow.ImgLib.Formats.Serialization.Metadata,MetadataReaderBase,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\Metadata\MetadataReaderBase.cs,_Get,Cyclomatic complexity of the method is 14
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,ImageEncoderIndexed,The method has 6 parameters. Parameters: palettes' referenceImage' codec' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,ImageEncoderIndexed,The method has 6 parameters. Parameters: image' codec' pixelComparer' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,ImageEncoderIndexed,The method has 6 parameters. Parameters: images' codec' pixelComparer' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,Init,The method has 5 parameters. Parameters: codec' pixelComparer' encoder' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,IndexCodec,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,GetPixelIndex,The method has 5 parameters. Parameters: pixelData' width' height' x' y
Long Parameter List,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The method has 7 parameters. Parameters: pixelData' width' height' codec' palette' imageFilter' paletteFilter
Long Parameter List,Rainbow.ImgLib.Encoding,ImageDecoderDirectColor,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderDirectColor.cs,ImageDecoderDirectColor,The method has 5 parameters. Parameters: pixelData' width' height' decoder' imageFilter
Long Parameter List,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The method has 5 parameters. Parameters: pixelData' width' height' x' y
Long Parameter List,Rainbow.ImgLib.Encoding.Implementation,IndexCodec8Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec8Bpp.cs,GetPixelIndex,The method has 5 parameters. Parameters: pixelData' width' height' x' y
Long Parameter List,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,TileFilter,The method has 5 parameters. Parameters: bpp' tileWidth' tileHeight' width' height
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The method has 12 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' paletteCodec' indexCodec' imgFilter' palFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The method has 10 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' imageCodec' imgFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The method has 6 parameters. Parameters: reader' pos1' pos2' w' h' bpps
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The method has 6 parameters. Parameters: images' pos1' pos2' w' h' bpps
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,GetPalettedTools,The method has 12 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' paletteCodec' indexCodec' imgFilter' palFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,GetUnpalettedTools,The method has 10 parameters. Parameters: version' clutFormat' depth' colorsCount' width' height' data' userData' imageCodec' imgFilter
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The method has 5 parameters. Parameters: formatData' parameters' dataSize' paletteSize' colorEntries
Long Parameter List,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Serialization,SimpleTextureFormatSerializer<T>,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\SimpleTextureFormatSerializer.cs,CreateFrameForGeneralTexture,The method has 6 parameters. Parameters: texture' frame' formatSpecificData' images' referenceImage' mipmapsCount
Long Parameter List,Rainbow.ImgLib.Formats.Serialization,SimpleTextureFormatSerializer<T>,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\SimpleTextureFormatSerializer.cs,OnImportFrameMetadata,The method has 6 parameters. Parameters: texture' frame' metadata' images' referenceImage' mipmapsCount
Long Statement,Rainbow.ImgLib.Common,InteropUtils,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\InteropUtils.cs,WriteTo,The length of the statement  "                metadata.GetType().InvokeMember("Put"' BindingFlags.InvokeMethod' Type.DefaultBinder' metadata' new object[]{ key' value }); " is 124.
Long Statement,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,EncodeFromImages,The length of the statement  "            else //for multi palette images' quantization may break the pixel structure of the images. We must trust the work of the graphics editor. " is 137.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4])); " is 128.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3])); " is 132.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The length of the statement  "                data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F)); " is 145.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4])); " is 132.
Long Statement,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The length of the statement  "                pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2])); " is 132.
Long Statement,Rainbow.ImgLib.Filters,TIM2PaletteFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The length of the statement  "                            newColors[i++] = originalData[ index + part * colors * stripes * blocks + block * colors + stripe * stripes * colors + color ]; " is 127.
Long Statement,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,The length of the statement  "                    throw new TextureFormatException("This EFX file contains more colors then requested by bpp. Is this a multi-palette texture?"); " is 127.
Long Statement,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,ReadEntry,The length of the statement  "                    throw new TextureFormatException("Not a valid EFX file' size of entry without header 1 not corresponding in header 2!"); " is 120.
Long Statement,Rainbow.ImgLib.Formats.Serialization.Metadata,XmlMetadataReader,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\Metadata\XmlMetadataReader.cs,EnterSection,The length of the statement  "                    throw new MetadataException("Expected section named " + name + " but found " + subSections.Current.Attribute("name").Value); " is 124.
Long Statement,Rainbow.ImgLib.Formats.Serialization.Metadata,XmlMetadataReader,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\Metadata\XmlMetadataReader.cs,GetDataStringRepresentation,The length of the statement  "                    throw new MetadataException("Data " + key + " not found or many occurrences found in section " + currentElement.Attribute("name").Value); " is 137.
Long Statement,Rainbow.ImgLib.Formats.Serialization.Metadata,XmlMetadataReader,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\Metadata\XmlMetadataReader.cs,GetAttributeStringRepresentation,The length of the statement  "                    throw new MetadataException("Attribute " + key + " not found or many occurrences found in section " + currentElement.Attribute("name").Value); " is 142.
Long Statement,Rainbow.ImgLib.Formats.Serialization,SimpleTextureFormatSerializer<T>,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Serialization\SimpleTextureFormatSerializer.cs,OnImportFrameMetadata,The length of the statement  "            TextureFormat segment = CreateFrameForGeneralTexture(texture' frame' formatSpecific' images' referenceImage' mipmapsCount); " is 123.
Virtual Method Call from Constructor,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The constructor "PE3DATTexture" calls a virtual method "DecodeColors".
Virtual Method Call from Constructor,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,TIM2Segment,The constructor "TIM2Segment" calls a virtual method "EncodeColors".
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt16,The following statement contains a magic number: reader.Read(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt16,The following statement contains a magic number: Array.Reverse(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt16,The following statement contains a magic number: reader.Read(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt16,The following statement contains a magic number: Array.Reverse(buf' 0' 2);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt32,The following statement contains a magic number: reader.Read(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt32,The following statement contains a magic number: Array.Reverse(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt32,The following statement contains a magic number: reader.Read(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt32,The following statement contains a magic number: Array.Reverse(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt64,The following statement contains a magic number: reader.Read(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadUInt64,The following statement contains a magic number: Array.Reverse(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt64,The following statement contains a magic number: reader.Read(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadInt64,The following statement contains a magic number: Array.Reverse(buf' 0' 8);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadSingle,The following statement contains a magic number: reader.Read(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,BinaryReaderExtensions,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\BinaryReaderExtensions.cs,ReadSingle,The following statement contains a magic number: Array.Reverse(buf' 0' 4);
Magic Number,Rainbow.ImgLib.Common,ImageUtils,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\ImageUtils.cs,ToGrayScale,The following statement contains a magic number: int intensity = (int)(color.R * 0.2126 + color.G * 0.7152 + color.B * 0.0722);
Magic Number,Rainbow.ImgLib.Common,ImageUtils,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\ImageUtils.cs,ToGrayScale,The following statement contains a magic number: int intensity = (int)(color.R * 0.2126 + color.G * 0.7152 + color.B * 0.0722);
Magic Number,Rainbow.ImgLib.Common,ImageUtils,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Common\ImageUtils.cs,ToGrayScale,The following statement contains a magic number: int intensity = (int)(color.R * 0.2126 + color.G * 0.7152 + color.B * 0.0722);
Magic Number,Rainbow.ImgLib.Encoding,ImageEncoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageEncoderIndexed.cs,EncodeFromReference,The following statement contains a magic number: int[] indexes = referenceImage.GetColorArray().Select((c) => (c.R >> (8 - codec.BitDepth))).ToArray();
Magic Number,Rainbow.ImgLib.Encoding,IndexCodec,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,FromNumberOfColors,The following statement contains a magic number: colors <= 16
Magic Number,Rainbow.ImgLib.Encoding,IndexCodec,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int bytes = totalPixel * BitDepth / 8;
Magic Number,Rainbow.ImgLib.Encoding,IndexCodec,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\IndexCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int remainder = (totalPixel * BitDepth) % 8;
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));
Magic Number,Rainbow.ImgLib.Encoding,ImageDecoderIndexed,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ImageDecoderIndexed.cs,ImageDecoderIndexed,The following statement contains a magic number: grayScale[i] = Color.FromArgb(255' i * (256 / grayScale.Length)' i * (256 / grayScale.Length)' i * (256 / grayScale.Length));
Magic Number,Rainbow.ImgLib.Encoding,ColorCodec,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int bytes = totalPixel * BitDepth / 8;
Magic Number,Rainbow.ImgLib.Encoding,ColorCodec,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorCodec.cs,GetBytesNeededForEncode,The following statement contains a magic number: int remainder = (totalPixel * BitDepth) % 8;
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c1 = (uint)(x.A << 24 | x.B << 16 | x.G << 8 | x.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c1 = (uint)(x.A << 24 | x.B << 16 | x.G << 8 | x.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c1 = (uint)(x.A << 24 | x.B << 16 | x.G << 8 | x.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c2 = (uint)(y.A << 24 | y.B << 16 | y.G << 8 | y.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c2 = (uint)(y.A << 24 | y.B << 16 | y.G << 8 | y.R);
Magic Number,Rainbow.ImgLib.Encoding.ColorComparers,ARGBColorComparer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\ColorComparers\ARGBColorComparer.cs,Compare,The following statement contains a magic number: long c2 = (uint)(y.A << 24 | y.B << 16 | y.G << 8 | y.R);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,DecodeColors,The following statement contains a magic number: i < size / 4
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: encoded[i]      = colors[start + i / 4].A;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: encoded[i+1]    = colors[start + i / 4].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: encoded[i+2]    = colors[start + i / 4].G;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: encoded[i+2]    = colors[start + i / 4].G;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: encoded[i+3]    = colors[start + i / 4].R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitABGR.cs,EncodeColors,The following statement contains a magic number: encoded[i+3]    = colors[start + i / 4].R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]' palette[start + i * 4 + 3]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,DecodeColors,The following statement contains a magic number: i < size / 4
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: encoded[i] = colors[start + i / 4].A;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: encoded[i + 1] = colors[start + i / 4].R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: encoded[i + 2] = colors[start + i / 4].G;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: encoded[i + 2] = colors[start + i / 4].G;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: encoded[i + 3] = colors[start + i / 4].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitARGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitARGB.cs,EncodeColors,The following statement contains a magic number: encoded[i + 3] = colors[start + i / 4].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: Color[] tile = new Color[4 * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: Color[] tile = new Color[4 * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: Array.Copy(tile' line * 4' decoded' FullWidth * (y + line) + x' 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: Array.Copy(tile' line * 4' decoded' FullWidth * (y + line) + x' 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeColors,The following statement contains a magic number: line < 4
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetBytesNeededForEncode,The following statement contains a magic number: return GetFullWidth(width) * GetFullHeight(height) * BitDepth / 8;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: table = reader.ReadBytes(4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green1 = ImageUtils.Conv6To8((color1 >> 5) & 0x3F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green2 = ImageUtils.Conv6To8((color2 >> 5) & 0x3F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red1 = ImageUtils.Conv5To8((color1 >> 11) & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red2 = ImageUtils.Conv5To8((color2 >> 11) & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[0] = Color.FromArgb(255'red1' green1' blue1);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[1] = Color.FromArgb(255' red2' green2' blue2);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int blue3 = (2 * blue1 + blue2) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int blue3 = (2 * blue1 + blue2) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green3 = (2 * green1 + green2) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green3 = (2 * green1 + green2) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red3 = (2 * red1 + red2) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red3 = (2 * red1 + red2) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int blue4 = (2 * blue2 + blue1) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int blue4 = (2 * blue2 + blue1) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green4 = (2 * green2 + green1) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int green4 = (2 * green2 + green1) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red4 = (2 * red2 + red1) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: int red4 = (2 * red2 + red1) / 3;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[2] = Color.FromArgb(255' red3'green3'blue3);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[2] = Color.FromArgb(255' red3'green3'blue3);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[3] = Color.FromArgb(255'red4'green4'blue4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: clut[3] = Color.FromArgb(255'red4'green4'blue4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: tile[k++] = clut[(val >> 6) & 3];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: tile[k++] = clut[(val >> 6) & 3];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: val <<= 2;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: x < 4
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,DecodeDXT1Block,The following statement contains a magic number: y < 4
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullWidth,The following statement contains a magic number: return width % 4 != 0 ? (width / 4) * 4 + 4 : width;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1.cs,GetFullHeight,The following statement contains a magic number: return height % 4 != 0 ? (height / 4) * 4 + 4 : height;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: data >>= 5;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: data >>= 5;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: data >>= 5;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: int alpha = data == 0 ? 0 : 255;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,DecodeColors,The following statement contains a magic number: i < size / 2
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: byte[] palette = new byte[colors.Length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: ushort data = (ushort)(colors[i].A > 127 ? 0x8000 : 0);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: data |= (ushort)((ImageUtils.Conv8To5(colors[i].B) << 10) | (ImageUtils.Conv8To5(colors[i].G) << 5) | (ImageUtils.Conv8To5(colors[i].R) & 0x1F));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: palette[(i - start) * 2] = (byte)(data & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: palette[(i - start) * 2 + 1] = (byte)(data >> 8);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec16BitLEABGR,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec16BitLEABGR.cs,EncodeColors,The following statement contains a magic number: palette[(i - start) * 2 + 1] = (byte)(data >> 8);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(255' palette[start + i * 3]' palette[start + i * 3 + 1]' palette[start + i * 3 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,DecodeColors,The following statement contains a magic number: i < size / 3
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: byte[] palette = new byte[colors.Length * 3];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: palette[(i - start) * 3] = colors[i].R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: palette[(i - start) * 3 + 1] = colors[i].G;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: palette[(i - start) * 3 + 2] = colors[i].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec24BitRGB,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec24BitRGB.cs,EncodeColors,The following statement contains a magic number: palette[(i - start) * 3 + 2] = colors[i].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4 + 2]' palette[start + i * 4 + 1]' palette[start + i * 4]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,DecodeColors,The following statement contains a magic number: i < size / 4
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: encoded[i] = colors[start + i / 4].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 1] = colors[start + i / 4].G;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 2] = colors[start + i / 4].R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 2] = colors[start + i / 4].R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 3] = colors[start + i / 4].A;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitBGRA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitBGRA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 3] = colors[start + i / 4].A;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: pal.Add(Color.FromArgb(palette[start + i * 4 + 3]' palette[start + i * 4]' palette[start + i * 4 + 1]' palette[start + i * 4 + 2]));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,DecodeColors,The following statement contains a magic number: i < size / 4
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 4];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: encoded[i]      = colors[start + i / 4].R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 1]  = colors[start + i / 4].G;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 2]  = colors[start + i / 4].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 2]  = colors[start + i / 4].B;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 3]  = colors[start + i / 4].A;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodec32BitRGBA,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodec32BitRGBA.cs,EncodeColors,The following statement contains a magic number: encoded[i + 3]  = colors[start + i / 4].A;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: Color[] decoded = new Color[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: int first   = ByteOrder == ByteOrder.LittleEndian ? value & 0xF : (value >> 4) & 0xF;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: int second = ByteOrder == ByteOrder.LittleEndian ? (value >> 4) & 0xF : value & 0xF;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: decoded[i * 2]  = Color.FromArgb(255' first' first' first);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: decoded[i * 2]  = Color.FromArgb(255' first' first' first);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,DecodeColors,The following statement contains a magic number: decoded[i * 2 + 1] = Color.FromArgb(255' second' second' second);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[(length +1)/ 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: value = (byte)((firstNibble & 0xF) | ((secondNibble & 0xF) << 4));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI4.cs,EncodeColors,The following statement contains a magic number: encoded[i / 2] = value;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecI8,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecI8.cs,DecodeColors,The following statement contains a magic number: decoded[i] = Color.FromArgb(255' intensity' intensity' intensity);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA4.cs,DecodeColors,The following statement contains a magic number: int alpha = ByteOrder == ByteOrder.LittleEndian ? data & 0xF : (data >> 4) & 0xF;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA4.cs,DecodeColors,The following statement contains a magic number: int intensity = ByteOrder == ByteOrder.LittleEndian ? (data>>4) & 0xF : data & 0xF;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA4,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA4.cs,EncodeColors,The following statement contains a magic number: value = (byte)((alphaNibble & 0xF) | ((intensityNibble & 0xF) << 4));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,DecodeColors,The following statement contains a magic number: Color[] decoded = new Color[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,DecodeColors,The following statement contains a magic number: int alpha=(data>>8)&0xFF;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2] = ByteOrder == ByteOrder.LittleEndian ? gray.R : gray.A;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecIA8,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecIA8.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2 + 1] = ByteOrder == ByteOrder.LittleEndian ? gray.A : gray.R;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: Color[] encoded = new Color[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: red = ImageUtils.Conv5To8((color >> 11) & 0x1f);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: green = ImageUtils.Conv6To8((color >> 5) & 0x3f);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,DecodeColors,The following statement contains a magic number: encoded[i] = Color.FromArgb(255' red' green' blue);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: ushort color = (ushort)(((red & 0x1F) << 11) | ((green & 0x3F) << 5) | (blue & 0x1F));
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB565,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB565.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: Color[] encoded = new Color[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: red = ImageUtils.Conv5To8((color >> 10) & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: green = ImageUtils.Conv5To8((color >> 5) & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,DecodeColors,The following statement contains a magic number: alpha = 255;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: byte[] encoded = new byte[length * 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: color = (ushort)(((red & 0x1F) << 10) | ((green & 0x1F) << 5) | blue & 0x1F);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: alpha == 7
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2] = (byte)(ByteOrder == ByteOrder.LittleEndian ? color & 0xFF : (color >> 8) & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecRGB5A3,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecRGB5A3.cs,EncodeColors,The following statement contains a magic number: encoded[i * 2 + 1] = (byte)(ByteOrder == ByteOrder.LittleEndian ? (color >> 8) & 0xFF : color & 0xFF);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,ColorCodecDXT1Gamecube,The following statement contains a magic number: filter = new TileFilter(64' 2' 2' FullWidth / 4' FullHeight / 4);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullWidth,The following statement contains a magic number: return oldWidth % 8 != 0 ? (oldWidth/8)*8 + 8 : oldWidth;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,ColorCodecDXT1Gamecube,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\ColorCodecDXT1Gamecube.cs,GetFullHeight,The following statement contains a magic number: return oldHeight % 8 != 0 ? (oldHeight/8)*8 + 8  : oldHeight;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: byte b = pixelData[pos / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: return pos % 2 == 0 ? b & 0xF : (b >> 4) & 0xF;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,GetPixelIndex,The following statement contains a magic number: return pos % 2 == 0 ? b & 0xF : (b >> 4) & 0xF;
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: length % 2 != 0
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: byte[] packed = new byte[length / 2];
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: indexes[i] > 15 || indexes[i + 1] > 15
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: indexes[i] > 15 || indexes[i + 1] > 15
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec4Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec4Bpp.cs,PackIndexes,The following statement contains a magic number: packed[k++] = (byte)((indexes[i + 1] << 4) | indexes[i]);
Magic Number,Rainbow.ImgLib.Encoding.Implementation,IndexCodec8Bpp,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Encoding\Implementation\IndexCodec8Bpp.cs,PackIndexes,The following statement contains a magic number: indexes[i] > 255
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: int planeSize = 32;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: int totalPlanes=2;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: decoded[pos + i * 2]        = a;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: decoded[pos + i * 2 + 1]    = r;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: decoded[pos + i * 2 + 2]    = g;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: decoded[pos + i * 2 + 2]    = g;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: decoded[pos + i * 2 + 3]    = b;
Magic Number,Rainbow.ImgLib.Filters,GamecubePlanarFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\GamecubePlanarFilter.cs,Defilter,The following statement contains a magic number: decoded[pos + i * 2 + 3]    = b;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,ApplyFilter,The following statement contains a magic number: int w = (encodingWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,ApplyFilter,The following statement contains a magic number: int lineSize = TileDimensionsAsBytes? tileWidth : (tileWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,ApplyFilter,The following statement contains a magic number: int origW = (this.width * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,Defilter,The following statement contains a magic number: int w = (this.width * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,Defilter,The following statement contains a magic number: int lineSize = TileDimensionsAsBytes ? tileWidth : (tileWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,GetWidthForEncoding,The following statement contains a magic number: int w = (realWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,GetWidthForEncoding,The following statement contains a magic number: int lineSize = TileDimensionsAsBytes ? tileWidth : (tileWidth * bpp) / 8;
Magic Number,Rainbow.ImgLib.Filters,TileFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TileFilter.cs,GetWidthForEncoding,The following statement contains a magic number: encodingWidth += ((lineSize - w % lineSize) * 8) / bpp;
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: bitDepth!=8
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int parts = length / 32;
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int stripes=2;
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int colors = 8;
Magic Number,Rainbow.ImgLib.Filters,TIM2PaletteFilter,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Filters\TIM2PaletteFilter.cs,Defilter,The following statement contains a magic number: int blocks = 2;
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPaletteColorSize,The following statement contains a magic number: return 2;
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (depth)              {                  case 5: //C4                      bpp = 4;                      break;                  case 6: //C8                      bpp = 8;                      break;                  default:                      throw new TextureFormatException("Unsupported depth " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (clutFormat)              {                  case 1:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB565;                      break;                  case 2:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                      break;                  case 3:                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  case 0xB: //not sure about this (FIX)                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  default:                      throw new TextureFormatException("Unsupported clut format " + clutFormat);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: switch (clutFormat)              {                  case 1:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB565;                      break;                  case 2:                      paletteCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                      break;                  case 3:                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  case 0xB: //not sure about this (FIX)                      paletteCodec = ColorCodec.CODEC_16BITBE_IA8;                      break;                  default:                      throw new TextureFormatException("Unsupported clut format " + clutFormat);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: imgFilter = new TileFilter(bpp' 8' 32 / bpp' width' height);
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetPalettedTools,The following statement contains a magic number: imgFilter = new TileFilter(bpp' 8' 32 / bpp' width' height);
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,NUTTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NUTTexture.Serializer.cs,GetUnpalettedTools,The following statement contains a magic number: switch (depth)              {                  case 3: //RGBA32bit 2 planes                      imageCodec = ColorCodec.CODEC_32BIT_ARGB;                      imgFilter = new ImageFilterComposer { new GamecubePlanarFilter()' new TileFilter(32' 4' 4' width' height) };                      break;                  case 4: //DXT1                      imageCodec = new ColorCodecDXT1Gamecube(width' height);                      imgFilter = null;                      break;                  case 0xA: // I8                      imageCodec = ColorCodec.CODEC_8BIT_I8;                      imgFilter=new TileFilter(8' 8' 4' width' height);                      break;                  case 0xB: // IA8                      imageCodec = ColorCodec.CODEC_16BITBE_IA8;                      imgFilter=new TileFilter(16' 4' 4' width' height);                      break;                  default:                      throw new TextureFormatException("Usupported unpalletted image format " + depth);              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: reader.BaseStream.Position += 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TPLTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TPLTexture.Serializer.cs,Open,The following statement contains a magic number: switch (format)                  {                      case 0: //I4                          colorCodec = ColorCodec.CODEC_4BITBE_I4;                          imgFilter = new TileFilter(4' 8' 8' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 1: //I8                          colorCodec = ColorCodec.CODEC_8BIT_I8;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 2: //IA4                          colorCodec = ColorCodec.CODEC_8BITBE_IA4;                          imgFilter = new TileFilter(8' 8' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 3: //IA8                          colorCodec = ColorCodec.CODEC_16BITBE_IA8;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 4: //RGB565                          colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 5: //RGB5A3                          colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                          imgFilter = new TileFilter(16' 4' 4' width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height'imgFilter);                          break;                      case 6: //RGBA32 2 planes                          colorCodec = ColorCodec.CODEC_32BIT_ARGB;                          imgFilter = new ImageFilterComposer{ new GamecubePlanarFilter()'                                                             new TileFilter(32'4'4'width'height)};                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 8: //C4                      case 9: //C8                          isIndexed = true;                          reader.BaseStream.Position = offsetPaletteHeader;                            entryCount = reader.ReadUInt16(order);                          unknown = reader.ReadUInt16(order);                            paletteFormat = reader.ReadUInt32(order);                          palDataOffset = reader.ReadUInt32(order);                            switch (paletteFormat)                          {                              case 0:                                  colorCodec = ColorCodec.CODEC_16BITBE_IA8;                                  break;                              case 1:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB565;                                  break;                              case 2:                                  colorCodec = ColorCodec.CODEC_16BITBE_RGB5A3;                                  break;                              default:                                  throw new TextureFormatException("Unsupported palette format " + paletteFormat);                          }                          palDataSize = colorCodec.GetBytesNeededForEncode(entryCount' 1);                            if (format == 8)                          {                              idxCodec = IndexCodec.FromBitPerPixel(4' order);                              imgFilter = new TileFilter(4' 8' 8' width' height);                          }                          else                          {                              idxCodec = IndexCodec.FromBitPerPixel(8' order);                              imgFilter = new TileFilter(8' 8' 4' width' height);                          }                            imgDataSize = idxCodec.GetBytesNeededForEncode(width' height' imgFilter);                          break;                      case 0xA: //C14X2                          throw new TextureFormatException("C14X2 not implemented yet!");                          break;                      case 0xE: //DXT1 (aka CMPR)                          colorCodec = new ColorCodecDXT1Gamecube(width' height);                          imgDataSize = colorCodec.GetBytesNeededForEncode(width' height);                          break;                      default:                          throw new TextureFormatException("Unsupported TPL image format " + format);                  }
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: count /= 2;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: bpps[i] == 4
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: bpps[i] != 8 && bpps[i] != 4
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: bpps[i] != 8 && bpps[i] != 4
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: byte[] paletteData = new byte[bpps[i] == 8? 4 * 256 : 4 * 16];
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: bpps[i]!=8 && bpps[i]!=4
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.cs,PE3DATTexture,The following statement contains a magic number: bpps[i]!=8 && bpps[i]!=4
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: width = 512;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: height = imageData.Length * 2 / width;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: img.Width != 512
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: ImageEncoderIndexed encoder = new ImageEncoderIndexed(img'                                                                     IndexCodec.FromBitPerPixel(4)' null' null'                                                                     new SwizzleFilter(width' height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,PE3SimpleDATTexture,The following statement contains a magic number: ImageEncoderIndexed encoder = new ImageEncoderIndexed(img'                                                                     IndexCodec.FromBitPerPixel(4)' null' null'                                                                     new SwizzleFilter(width' height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,GetImage,The following statement contains a magic number: ImageDecoderIndexed decoder = new ImageDecoderIndexed(imageData'                                                                     Width' Height'                                                                     IndexCodec.FromBitPerPixel(4)' null'                                                                    new SwizzleFilter(Width' Height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3SimpleDATTexture,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3SimpleDATTexture.cs,GetImage,The following statement contains a magic number: ImageDecoderIndexed decoder = new ImageDecoderIndexed(imageData'                                                                     Width' Height'                                                                     IndexCodec.FromBitPerPixel(4)' null'                                                                    new SwizzleFilter(Width' Height' 4));
Magic Number,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,Open,The following statement contains a magic number: reader.BaseStream.Seek(4' SeekOrigin.Begin);
Magic Number,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,Open,The following statement contains a magic number: int padding = headerSize - 8;
Magic Number,Rainbow.ImgLib.Formats.Implementation,NamcoTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\NamcoTexture.Serializer.cs,ConstructSegment,The following statement contains a magic number: byte[] data=reader.ReadBytes(24);
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,IsValidFormat,The following statement contains a magic number: format != 2 && format != 1
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: formats[i] != 2 && formats[i] != 1
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: bpps[i] = formats[i] == 2 ? 8 : 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: bpps[i] = formats[i] == 2 ? 8 : 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Open,The following statement contains a magic number: bpps[i] = formats[i] == 2 ? 8 : 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Save,The following statement contains a magic number: i < 3
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Save,The following statement contains a magic number: writer.Write(dat.Bpp == 8 ? (uint)2 : (uint)1);
Magic Number,Rainbow.ImgLib.Formats.Implementation,PE3DATSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\PE3DATTexture.Serializer.cs,Save,The following statement contains a magic number: writer.Write(dat.Bpp == 8 ? (uint)2 : (uint)1);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,IsValidFormat,The following statement contains a magic number: char[] magic = reader.ReadChars(4);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,Save,The following statement contains a magic number: i < 8
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,ReadHeader,The following statement contains a magic number: char[] magic = reader.ReadChars(4);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2TextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,ReadHeader,The following statement contains a magic number: reader.BaseStream.Position += 8;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: ushort colorEntries = (ushort)(parameters.bpp > 8 ? 0 : 1 << parameters.bpp);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: byte clutFormat = (byte)(parameters.bpp > 8 ? 0 : parameters.colorSize - 1);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,WriteHeader,The following statement contains a magic number: switch (parameters.bpp)              {                  case 4:                      depth = 4;                      break;                  case 8:                      depth = 5;                      break;                  case 16:                      depth = 1;                      break;                  case 24:                      depth = 2;                      break;                  case 32:                      depth = 3;                      break;                  default:                      throw new ArgumentException("Should never happen");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: switch (depth)              {                  case 01:                      parameters.bpp = 16;                      break;                  case 02:                      parameters.bpp = 24;                      break;                  case 03:                      parameters.bpp = 32;                      break;                  case 04:                      parameters.bpp = 4;                      break;                  case 05:                      parameters.bpp = 8;                      break;                  default:                      throw new TextureFormatException("Illegal bit depth!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.GsTEX0 = reader.ReadBytes(8);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.GsTEX1 = reader.ReadBytes(8);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.colorSize = parameters.bpp > 8 ? parameters.bpp / 8 : (clutFormat & 0x07) + 1;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2SegmentSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Serializer.cs,AcquireInfoFromHeader,The following statement contains a magic number: parameters.colorSize = parameters.bpp > 8 ? parameters.bpp / 8 : (clutFormat & 0x07) + 1;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TX48Serializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TX48Texture.Serializer.cs,Open,The following statement contains a magic number: bpp = (bpp + 1) * 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TX48Serializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TX48Texture.Serializer.cs,Save,The following statement contains a magic number: writer.Write(bpps / 4 - 1);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TX48Serializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TX48Texture.Serializer.cs,Save,The following statement contains a magic number: j < 8
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,TIM2Segment,The following statement contains a magic number: parameters.bpp > 8
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,CreateImageDecoder,The following statement contains a magic number: Bpp <= 8
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,ConstructPalettes,The following statement contains a magic number: parameters.bpp > 8
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,GetColorCodec,The following statement contains a magic number: switch (pixelSize)              {                  case 2:                      return ColorCodec.CODEC_16BITLE_ABGR;                  case 3:                      return ColorCodec.CODEC_24BIT_RGB;                  case 4:                      return ColorCodec.CODEC_32BIT_RGBA;                  default:                      throw new TextureFormatException("Illegal Pixel size!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,GetColorCodec,The following statement contains a magic number: switch (pixelSize)              {                  case 2:                      return ColorCodec.CODEC_16BITLE_ABGR;                  case 3:                      return ColorCodec.CODEC_24BIT_RGB;                  case 4:                      return ColorCodec.CODEC_32BIT_RGBA;                  default:                      throw new TextureFormatException("Illegal Pixel size!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TIM2Segment,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TIM2Texture.Segment.cs,GetColorCodec,The following statement contains a magic number: switch (pixelSize)              {                  case 2:                      return ColorCodec.CODEC_16BITLE_ABGR;                  case 3:                      return ColorCodec.CODEC_24BIT_RGB;                  case 4:                      return ColorCodec.CODEC_32BIT_RGBA;                  default:                      throw new TextureFormatException("Illegal Pixel size!");              }
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Open,The following statement contains a magic number: reader.ReadBytes(8);
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: fileSize = fileSize + 4 - fullEntrySize % 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: fileSize = fileSize + 4 - fullEntrySize % 4;
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: writer.Write(Enumerable.Repeat((byte)0' 4 - fullEntrySize % 4).ToArray());
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: writer.Write(Enumerable.Repeat((byte)0' 4 - fullEntrySize % 4).ToArray());
Magic Number,Rainbow.ImgLib.Formats.Implementation,TacticsOgreEFXTextureSerializer,D:\research\architectureSmells\repos\marco-calautti_Rainbow\Rainbow.ImgLib\ImgLib\Formats\Implementation\TacticsOgreEFXTexture.Serializer.cs,Save,The following statement contains a magic number: fullEntrySize % 4 != 0
