Implementation smell,Namespace,Class,File,Method,Description
Complex Method,nQuant,WuQuantizer,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizer.cs,GetQuantizedPalette,Cyclomatic complexity of the method is 9
Long Parameter List,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Maximize,The method has 10 parameters. Parameters: data' cube' direction' first' last' wholeAlpha' wholeRed' wholeGreen' wholeBlue' wholeWeight
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,ProcessImagePixels,The length of the statement  "                targetData = result.LockBits(Rectangle.FromLTRB(0' 0' result.Width' result.Height)' ImageLockMode.WriteOnly' result.PixelFormat); " is 129.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,ProcessImagePixels,The length of the statement  "                        targetValue[0] = (byte)(palette.PixelIndex[pixelIndex] == -1 ? palette.Colors.Count - 1 : palette.PixelIndex[pixelIndex]); " is 122.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The length of the statement  "                    throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length)); " is 229.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,CalculateMoments,The length of the statement  "                            data.Weights[alphaIndex' redIndex' greenIndex' blueIndex] = data.Weights[alphaIndex - 1' redIndex' greenIndex' blueIndex] + xarea[redIndex' greenIndex' blueIndex]; " is 163.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,CalculateMoments,The length of the statement  "                            data.MomentsAlpha[alphaIndex' redIndex' greenIndex' blueIndex] = data.MomentsAlpha[alphaIndex - 1' redIndex' greenIndex' blueIndex] + xareaAlpha[redIndex' greenIndex' blueIndex]; " is 178.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,CalculateMoments,The length of the statement  "                            data.MomentsRed[alphaIndex' redIndex' greenIndex' blueIndex] = data.MomentsRed[alphaIndex - 1' redIndex' greenIndex' blueIndex] + xareaRed[redIndex' greenIndex' blueIndex]; " is 172.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,CalculateMoments,The length of the statement  "                            data.MomentsGreen[alphaIndex' redIndex' greenIndex' blueIndex] = data.MomentsGreen[alphaIndex - 1' redIndex' greenIndex' blueIndex] + xareaGreen[redIndex' greenIndex' blueIndex]; " is 178.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,CalculateMoments,The length of the statement  "                            data.MomentsBlue[alphaIndex' redIndex' greenIndex' blueIndex] = data.MomentsBlue[alphaIndex - 1' redIndex' greenIndex' blueIndex] + xareaBlue[redIndex' greenIndex' blueIndex]; " is 175.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,CalculateMoments,The length of the statement  "                            data.Moments[alphaIndex' redIndex' greenIndex' blueIndex] = data.Moments[alphaIndex - 1' redIndex' greenIndex' blueIndex] + xarea2[redIndex' greenIndex' blueIndex]; " is 164.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Cut,The length of the statement  "            var maxAlpha = Maximize(data' first' Alpha' (byte) (first.AlphaMinimum + 1)' first.AlphaMaximum' wholeAlpha' wholeRed' wholeGreen' wholeBlue' wholeWeight); " is 155.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Cut,The length of the statement  "            var maxRed = Maximize(data' first' Red' (byte) (first.RedMinimum + 1)' first.RedMaximum' wholeAlpha' wholeRed' wholeGreen' wholeBlue' wholeWeight); " is 147.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Cut,The length of the statement  "            var maxGreen = Maximize(data' first' Green' (byte) (first.GreenMinimum + 1)' first.GreenMaximum' wholeAlpha' wholeRed' wholeGreen' wholeBlue' wholeWeight); " is 155.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Cut,The length of the statement  "            var maxBlue = Maximize(data' first' Blue' (byte) (first.BlueMinimum + 1)' first.BlueMaximum' wholeAlpha' wholeRed' wholeGreen' wholeBlue' wholeWeight); " is 151.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Cut,The length of the statement  "            first.Size = (first.AlphaMaximum - first.AlphaMinimum) * (first.RedMaximum - first.RedMinimum) * (first.GreenMaximum - first.GreenMinimum) * (first.BlueMaximum - first.BlueMinimum); " is 181.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Cut,The length of the statement  "            second.Size = (second.AlphaMaximum - second.AlphaMinimum) * (second.RedMaximum - second.RedMinimum) * (second.GreenMaximum - second.GreenMinimum) * (second.BlueMaximum - second.BlueMinimum); " is 190.
Long Statement,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,CalculateVariance,The length of the statement  "            float distance = volumeAlpha * volumeAlpha + volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue; " is 121.
Magic Number,nQuant,Pixel,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\Pixel.cs,Pixel,The following statement contains a magic number: Argb = alpha << 24 | red << 16 | green << 8 | blue;
Magic Number,nQuant,Pixel,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\Pixel.cs,Pixel,The following statement contains a magic number: Argb = alpha << 24 | red << 16 | green << 8 | blue;
Magic Number,nQuant,Pixel,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\Pixel.cs,Pixel,The following statement contains a magic number: Argb = alpha << 24 | red << 16 | green << 8 | blue;
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,ProcessImagePixels,The following statement contains a magic number: try              {                  targetData = result.LockBits(Rectangle.FromLTRB(0' 0' result.Width' result.Height)' ImageLockMode.WriteOnly' result.PixelFormat);                  const byte targetBitDepth = 8;                  var targetByteLength = targetData.Stride < 0 ? -targetData.Stride : targetData.Stride;                  var targetByteCount = Math.Max(1' targetBitDepth >> 3);                  var targetSize = targetByteLength * result.Height;                  var targetOffset = 0;                  var targetBuffer = new byte[targetSize];                  var targetValue = new byte[targetByteCount];                  var pixelIndex = 0;                    for (var y = 0; y < result.Height; y++)                  {                      var targetIndex = 0;                      for (var x = 0; x < result.Width; x++)                      {                          var targetIndexOffset = targetIndex >> 3;                          targetValue[0] = (byte)(palette.PixelIndex[pixelIndex] == -1 ? palette.Colors.Count - 1 : palette.PixelIndex[pixelIndex]);                          pixelIndex++;                            for (var valueIndex = 0; valueIndex < targetByteCount; valueIndex++)                              targetBuffer[targetOffset + valueIndex + targetIndexOffset] = targetValue[valueIndex];                            targetIndex += targetBitDepth;                      }                        targetOffset += targetByteLength;                  }                    Marshal.Copy(targetBuffer' 0' targetData.Scan0' targetSize);              }              finally              {                  if(targetData != null)                      result.UnlockBits(targetData);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,ProcessImagePixels,The following statement contains a magic number: try              {                  targetData = result.LockBits(Rectangle.FromLTRB(0' 0' result.Width' result.Height)' ImageLockMode.WriteOnly' result.PixelFormat);                  const byte targetBitDepth = 8;                  var targetByteLength = targetData.Stride < 0 ? -targetData.Stride : targetData.Stride;                  var targetByteCount = Math.Max(1' targetBitDepth >> 3);                  var targetSize = targetByteLength * result.Height;                  var targetOffset = 0;                  var targetBuffer = new byte[targetSize];                  var targetValue = new byte[targetByteCount];                  var pixelIndex = 0;                    for (var y = 0; y < result.Height; y++)                  {                      var targetIndex = 0;                      for (var x = 0; x < result.Width; x++)                      {                          var targetIndexOffset = targetIndex >> 3;                          targetValue[0] = (byte)(palette.PixelIndex[pixelIndex] == -1 ? palette.Colors.Count - 1 : palette.PixelIndex[pixelIndex]);                          pixelIndex++;                            for (var valueIndex = 0; valueIndex < targetByteCount; valueIndex++)                              targetBuffer[targetOffset + valueIndex + targetIndexOffset] = targetValue[valueIndex];                            targetIndex += targetBitDepth;                      }                        targetOffset += targetByteLength;                  }                    Marshal.Copy(targetBuffer' 0' targetData.Scan0' targetSize);              }              finally              {                  if(targetData != null)                      result.UnlockBits(targetData);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,ProcessImagePixels,The following statement contains a magic number: try              {                  targetData = result.LockBits(Rectangle.FromLTRB(0' 0' result.Width' result.Height)' ImageLockMode.WriteOnly' result.PixelFormat);                  const byte targetBitDepth = 8;                  var targetByteLength = targetData.Stride < 0 ? -targetData.Stride : targetData.Stride;                  var targetByteCount = Math.Max(1' targetBitDepth >> 3);                  var targetSize = targetByteLength * result.Height;                  var targetOffset = 0;                  var targetBuffer = new byte[targetSize];                  var targetValue = new byte[targetByteCount];                  var pixelIndex = 0;                    for (var y = 0; y < result.Height; y++)                  {                      var targetIndex = 0;                      for (var x = 0; x < result.Width; x++)                      {                          var targetIndexOffset = targetIndex >> 3;                          targetValue[0] = (byte)(palette.PixelIndex[pixelIndex] == -1 ? palette.Colors.Count - 1 : palette.PixelIndex[pixelIndex]);                          pixelIndex++;                            for (var valueIndex = 0; valueIndex < targetByteCount; valueIndex++)                              targetBuffer[targetOffset + valueIndex + targetIndexOffset] = targetValue[valueIndex];                            targetIndex += targetBitDepth;                      }                        targetOffset += targetByteLength;                  }                    Marshal.Copy(targetBuffer' 0' targetData.Scan0' targetSize);              }              finally              {                  if(targetData != null)                      result.UnlockBits(targetData);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Magic Number,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,BuildHistogram,The following statement contains a magic number: try              {                  var bitDepth = Image.GetPixelFormatSize(sourceImage.PixelFormat);                  if (bitDepth != 32)                      throw new QuantizationException(string.Format("Thie image you are attempting to quantize does not contain a 32 bit ARGB palette. This image has a bit depth of {0} with {1} colors."' bitDepth' sourceImage.Palette.Entries.Length));                  var byteLength = data.Stride < 0 ? -data.Stride : data.Stride;                  var byteCount = Math.Max(1' bitDepth >> 3);                  var offset = 0;                  var buffer = new Byte[byteLength * sourceImage.Height];                  var value = new Byte[byteCount];                    Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                                   for (int y = 0; y < bitmapHeight; y++)                  {                      var index = 0;                      for (int x = 0; x < bitmapWidth; x++)                      {                          var indexOffset = index >> 3;                            for (var valueIndex = 0; valueIndex < byteCount; valueIndex++)                              value[valueIndex] = buffer[offset + valueIndex + indexOffset];                            var indexAlpha = (byte)((value[Alpha] >> 3) + 1);                          var indexRed = (byte)((value[Red] >> 3) + 1);                          var indexGreen = (byte)((value[Green] >> 3) + 1);                          var indexBlue = (byte)((value[Blue] >> 3) + 1);                            if (value[Alpha] > alphaThreshold)                          {                              if (value[Alpha] < 255)                              {                                  var alpha = value[Alpha] + (value[Alpha] % alphaFader);                                  value[Alpha] = (byte)(alpha > 255 ? 255 : alpha);                                  indexAlpha = (byte)((value[Alpha] >> 3) + 1);                              }                                colorData.Weights[indexAlpha' indexRed' indexGreen' indexBlue]++;                              colorData.MomentsRed[indexAlpha' indexRed' indexGreen' indexBlue] += value[Red];                              colorData.MomentsGreen[indexAlpha' indexRed' indexGreen' indexBlue] += value[Green];                              colorData.MomentsBlue[indexAlpha' indexRed' indexGreen' indexBlue] += value[Blue];                              colorData.MomentsAlpha[indexAlpha' indexRed' indexGreen' indexBlue] += value[Alpha];                              colorData.Moments[indexAlpha' indexRed' indexGreen' indexBlue] += (value[Alpha]*value[Alpha]) +                                                                                                (value[Red]*value[Red]) +                                                                                                (value[Green]*value[Green]) +                                                                                                (value[Blue]*value[Blue]);                          }                            colorData.AddPixel(                              new Pixel(value[Alpha]' value[Red]' value[Green]' value[Blue])'                              BitConverter.ToInt32 (new[] { indexAlpha' indexRed' indexGreen' indexBlue }' 0));                          index += bitDepth;                      }                        offset += byteLength;                  }              }              finally              {                  sourceImage.UnlockBits(data);              }
Missing Default,nQuant,WuQuantizerBase,C:\repos\marco-calautti_Rainbow\nQuant.Core\nQuant\WuQuantizerBase.cs,Cut,The following switch statement is missing a default case: switch (direction)              {                  case Alpha:                      second.AlphaMinimum = first.AlphaMaximum = (byte) maxAlpha.Position;                      second.RedMinimum = first.RedMinimum;                      second.GreenMinimum = first.GreenMinimum;                      second.BlueMinimum = first.BlueMinimum;                      break;                    case Red:                      second.RedMinimum = first.RedMaximum = (byte) maxRed.Position;                      second.AlphaMinimum = first.AlphaMinimum;                      second.GreenMinimum = first.GreenMinimum;                      second.BlueMinimum = first.BlueMinimum;                      break;                    case Green:                      second.GreenMinimum = first.GreenMaximum = (byte) maxGreen.Position;                      second.AlphaMinimum = first.AlphaMinimum;                      second.RedMinimum = first.RedMinimum;                      second.BlueMinimum = first.BlueMinimum;                      break;                    case Blue:                      second.BlueMinimum = first.BlueMaximum = (byte) maxBlue.Position;                      second.AlphaMinimum = first.AlphaMinimum;                      second.RedMinimum = first.RedMinimum;                      second.GreenMinimum = first.GreenMinimum;                      break;              }
