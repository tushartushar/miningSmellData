Implementation smell,Namespace,Class,File,Method,Description
Long Method,NetMQ.WebSockets,Mtrie,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,The method has 106 lines of code.
Long Method,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The method has 101 lines of code.
Complex Method,NetMQ.WebSockets,Mtrie,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.WebSockets,Mtrie,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemovemHelper,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.WebSockets,Mtrie,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,Match,Cyclomatic complexity of the method is 10
Long Parameter List,NetMQ.WebSockets,Mtrie,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,The method has 6 parameters. Parameters: pipe' buff' buffsize' maxbuffsize' func' arg
Long Statement,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,ValidateClientHandshake,The length of the statement  "            if (!lines.Any(l => { var lt = l.Trim(); return lt.StartsWith("Connection: "' StringComparison.OrdinalIgnoreCase) && lt.Split(new char[]{'''' ':'}).Any(p => p.Trim().Equals("Upgrade"' StringComparison.OrdinalIgnoreCase)); })) " is 225.
Complex Conditional,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,NextState,The conditional expression  "(m_state == State.LongSize8 || m_state == State.SecondByte || m_state == State.ShortSize2) && m_isMaksed"  is complex.
Empty Catch Block,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,OnMessage,The method has an empty catch block.
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: int frameSize = 2 + 1 + data.Length;
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: int payloadStartIndex = 2;
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > 0xFFFF) // 2 bytes max value                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > 0xFFFF) // 2 bytes max value                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > 0xFFFF) // 2 bytes max value                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > 0xFFFF) // 2 bytes max value                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > 0xFFFF) // 2 bytes max value                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,BaseShimHandler,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: if (payloadLength <= 125)              {                  outgoingData[1] |= (byte)(payloadLength & 127);              }              else if (payloadLength <= 0xFFFF) // maximum size of short              {                  outgoingData[1] |= 126;                  outgoingData[2] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[3] = (byte)(payloadLength & 0xFF);              }              else              {                  outgoingData[1] |= 127;                  outgoingData[2] = 0;                  outgoingData[3] = 0;                  outgoingData[4] = 0;                  outgoingData[5] = 0;                  outgoingData[6] = (byte)((payloadLength >> 24) & 0xFF);                  outgoingData[7] = (byte)((payloadLength >> 16) & 0xFF);                  outgoingData[8] = (byte)((payloadLength >> 8) & 0xFF);                  outgoingData[9] = (byte)(payloadLength & 0xFF);              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    for (int i = 0; i < alignedLength; i += 4)                  {                      uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (UInt32)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.WebSockets,Mtrie,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,The following statement contains a magic number: if (buffsize >= maxbuffsize)              {                  maxbuffsize = buffsize + 256;                  Array.Resize(ref buff' maxbuffsize);              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: while (i < message.Length)              {                  switch (m_state)                  {                      case State.Payload:                          m_payloadIndex = 0;                          m_payload = new byte[m_payloadLength];                          goto case State.PayloadInProgress;                        case State.PayloadInProgress:                          int bytesToRead = m_payloadLength - m_payloadIndex;                            if (bytesToRead > (message.Length - i))                          {                              bytesToRead = message.Length - i;                          }                            Buffer.BlockCopy(message' i' m_payload' m_payloadIndex' bytesToRead);                            if (m_isMaksed)                          {                              for (int j = m_payloadIndex; j < m_payloadIndex + bytesToRead; j++)                              {                                                                  if (m_opcode == OpcodeEnum.Binary)                                  {                                      // because the first byte is the more bit we always add + 1 to the index                                       // when retrieving the mask byte                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j + 1) % 4]);                                      }                                  else                                  {                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j) % 4]);                                      }                                                              }                          }                            m_payloadIndex += bytesToRead;                          i += bytesToRead;                            if (m_payloadIndex < m_payloadLength)                          {                              m_state = State.PayloadInProgress;                          }                          else                          {                              var temp = Message;                              if (temp != null)                              {                                  temp(this' new MessageEventArgs(m_opcode' m_payload' m_more));                              }                                m_state = State.NewMessage;                          }                            break;                      default:                          Process(message[i]);                          i++;                          break;                  }              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: while (i < message.Length)              {                  switch (m_state)                  {                      case State.Payload:                          m_payloadIndex = 0;                          m_payload = new byte[m_payloadLength];                          goto case State.PayloadInProgress;                        case State.PayloadInProgress:                          int bytesToRead = m_payloadLength - m_payloadIndex;                            if (bytesToRead > (message.Length - i))                          {                              bytesToRead = message.Length - i;                          }                            Buffer.BlockCopy(message' i' m_payload' m_payloadIndex' bytesToRead);                            if (m_isMaksed)                          {                              for (int j = m_payloadIndex; j < m_payloadIndex + bytesToRead; j++)                              {                                                                  if (m_opcode == OpcodeEnum.Binary)                                  {                                      // because the first byte is the more bit we always add + 1 to the index                                       // when retrieving the mask byte                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j + 1) % 4]);                                      }                                  else                                  {                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j) % 4]);                                      }                                                              }                          }                            m_payloadIndex += bytesToRead;                          i += bytesToRead;                            if (m_payloadIndex < m_payloadLength)                          {                              m_state = State.PayloadInProgress;                          }                          else                          {                              var temp = Message;                              if (temp != null)                              {                                  temp(this' new MessageEventArgs(m_opcode' m_payload' m_more));                              }                                m_state = State.NewMessage;                          }                            break;                      default:                          Process(message[i]);                          i++;                          break;                  }              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,OnMessage,The following statement contains a magic number: if (e.Opcode == OpcodeEnum.Close)              {                  // send close command to the socket                  try                  {                      if (m_streamSocket.TrySendFrame(Identity' Identity.Length' true))                          m_streamSocket.TrySendFrame("");                  }                  catch (NetMQException)                  {                  }                    m_state = WebSocketClientState.Closed;              }              else if (e.Opcode == OpcodeEnum.Binary)              {                  if (m_outgoingMessage == null)                  {                      m_outgoingMessage = new NetMQMessage();                  }                    m_outgoingMessage.Append(e.Payload);                    if (!e.More)                  {                      if (IncomingMessage != null)                      {                          IncomingMessage(this' new NetMQMessageEventArgs(Identity' m_outgoingMessage));                      }                      m_outgoingMessage = null;                  }              }              else if (e.Opcode == OpcodeEnum.Ping)              {                  byte[] pong = new byte[2 + e.Payload.Length];                  pong[0] = 0x8A; // Pong and Final                  pong[1] = (byte)(e.Payload.Length & 127);                  Buffer.BlockCopy(e.Payload' 0' pong' 2' e.Payload.Length);                    if (m_streamSocket.TrySendFrame(Identity' Identity.Length' true))                      m_streamSocket.TrySendFrame(pong);              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,OnMessage,The following statement contains a magic number: if (e.Opcode == OpcodeEnum.Close)              {                  // send close command to the socket                  try                  {                      if (m_streamSocket.TrySendFrame(Identity' Identity.Length' true))                          m_streamSocket.TrySendFrame("");                  }                  catch (NetMQException)                  {                  }                    m_state = WebSocketClientState.Closed;              }              else if (e.Opcode == OpcodeEnum.Binary)              {                  if (m_outgoingMessage == null)                  {                      m_outgoingMessage = new NetMQMessage();                  }                    m_outgoingMessage.Append(e.Payload);                    if (!e.More)                  {                      if (IncomingMessage != null)                      {                          IncomingMessage(this' new NetMQMessageEventArgs(Identity' m_outgoingMessage));                      }                      m_outgoingMessage = null;                  }              }              else if (e.Opcode == OpcodeEnum.Ping)              {                  byte[] pong = new byte[2 + e.Payload.Length];                  pong[0] = 0x8A; // Pong and Final                  pong[1] = (byte)(e.Payload.Length & 127);                  Buffer.BlockCopy(e.Payload' 0' pong' 2' e.Payload.Length);                    if (m_streamSocket.TrySendFrame(Identity' Identity.Length' true))                      m_streamSocket.TrySendFrame(pong);              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,OnMessage,The following statement contains a magic number: if (e.Opcode == OpcodeEnum.Close)              {                  // send close command to the socket                  try                  {                      if (m_streamSocket.TrySendFrame(Identity' Identity.Length' true))                          m_streamSocket.TrySendFrame("");                  }                  catch (NetMQException)                  {                  }                    m_state = WebSocketClientState.Closed;              }              else if (e.Opcode == OpcodeEnum.Binary)              {                  if (m_outgoingMessage == null)                  {                      m_outgoingMessage = new NetMQMessage();                  }                    m_outgoingMessage.Append(e.Payload);                    if (!e.More)                  {                      if (IncomingMessage != null)                      {                          IncomingMessage(this' new NetMQMessageEventArgs(Identity' m_outgoingMessage));                      }                      m_outgoingMessage = null;                  }              }              else if (e.Opcode == OpcodeEnum.Ping)              {                  byte[] pong = new byte[2 + e.Payload.Length];                  pong[0] = 0x8A; // Pong and Final                  pong[1] = (byte)(e.Payload.Length & 127);                  Buffer.BlockCopy(e.Payload' 0' pong' 2' e.Payload.Length);                    if (m_streamSocket.TrySendFrame(Identity' Identity.Length' true))                      m_streamSocket.TrySendFrame(pong);              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: int frameSize = 2 + 1 + message.Length;
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: int payloadStartIndex = 2;
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > ushort.MaxValue)                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > ushort.MaxValue)                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > ushort.MaxValue)                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > ushort.MaxValue)                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: if (payloadLength > 125)              {                  frameSize += 2;                  payloadStartIndex += 2;                    if (payloadLength > ushort.MaxValue)                  {                      frameSize += 6;                      payloadStartIndex += 6;                  }              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: if (payloadLength <= 125)              {                  frame[1] |= (byte)(payloadLength & 127);              }              else              {                  // TODO: implement              }
Magic Number,NetMQ.WebSockets,WebSocketClient,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: if (payloadLength <= 125)              {                  frame[1] |= (byte)(payloadLength & 127);              }              else              {                  // TODO: implement              }
Missing Default,NetMQ.WebSockets,ByteArrayEqualityComparer,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following switch statement is missing a default case: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Missing Default,NetMQ.WebSockets,Decoder,C:\repos\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following switch statement is missing a default case: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
