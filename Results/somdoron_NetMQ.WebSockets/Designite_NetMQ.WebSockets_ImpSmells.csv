Implementation smell,Namespace,Class,File,Method,Description
Long Method,NetMQ.WebSockets,Mtrie,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,The method has 106 lines of code.
Long Method,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The method has 101 lines of code.
Complex Method,NetMQ.WebSockets,Mtrie,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,AddHelper,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.WebSockets,Mtrie,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,Cyclomatic complexity of the method is 14
Complex Method,NetMQ.WebSockets,Mtrie,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemovemHelper,Cyclomatic complexity of the method is 17
Complex Method,NetMQ.WebSockets,Mtrie,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,Match,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,Cyclomatic complexity of the method is 20
Complex Method,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,OnMessage,Cyclomatic complexity of the method is 9
Long Parameter List,NetMQ.WebSockets,Mtrie,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,The method has 6 parameters. Parameters: pipe' buff' buffsize' maxbuffsize' func' arg
Long Statement,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,ValidateClientHandshake,The length of the statement  "            if (!lines.Any(l => { var lt = l.Trim(); return lt.StartsWith("Connection: "' StringComparison.OrdinalIgnoreCase) && lt.Split(new char[]{'''' ':'}).Any(p => p.Trim().Equals("Upgrade"' StringComparison.OrdinalIgnoreCase)); })) " is 225.
Complex Conditional,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,NextState,The conditional expression  "(m_state == State.LongSize8 || m_state == State.SecondByte || m_state == State.ShortSize2) && m_isMaksed"  is complex.
Empty Catch Block,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,OnMessage,The method has an empty catch block.
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: int frameSize = 2 + 1 + data.Length;
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: int payloadStartIndex = 2;
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: frameSize += 2;
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: payloadStartIndex += 2;
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: frameSize += 6;
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: payloadStartIndex += 6;
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: payloadLength > 125
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: outgoingData[1] |= (byte)(payloadLength & 127);
Magic Number,NetMQ.WebSockets,BaseShimHandler,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\BaseShimHandler.cs,Encode,The following statement contains a magic number: payloadLength <= 125
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: int remainder = data.Length & 3;
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: uint k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = hash * 5 + 0xe6546b64;
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 16;
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 13;
Magic Number,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 16;
Magic Number,NetMQ.WebSockets,Mtrie,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Mtrie.cs,RemoveHelper,The following statement contains a magic number: maxbuffsize = buffsize + 256;
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)                  {                      case State.Payload:                          m_payloadIndex = 0;                          m_payload = new byte[m_payloadLength];                          goto case State.PayloadInProgress;                        case State.PayloadInProgress:                          int bytesToRead = m_payloadLength - m_payloadIndex;                            if (bytesToRead > (message.Length - i))                          {                              bytesToRead = message.Length - i;                          }                            Buffer.BlockCopy(message' i' m_payload' m_payloadIndex' bytesToRead);                            if (m_isMaksed)                          {                              for (int j = m_payloadIndex; j < m_payloadIndex + bytesToRead; j++)                              {                                                                  if (m_opcode == OpcodeEnum.Binary)                                  {                                      // because the first byte is the more bit we always add + 1 to the index                                       // when retrieving the mask byte                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j + 1) % 4]);                                      }                                  else                                  {                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j) % 4]);                                      }                                                              }                          }                            m_payloadIndex += bytesToRead;                          i += bytesToRead;                            if (m_payloadIndex < m_payloadLength)                          {                              m_state = State.PayloadInProgress;                          }                          else                          {                              var temp = Message;                              if (temp != null)                              {                                  temp(this' new MessageEventArgs(m_opcode' m_payload' m_more));                              }                                m_state = State.NewMessage;                          }                            break;                      default:                          Process(message[i]);                          i++;                          break;                  }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)                  {                      case State.Payload:                          m_payloadIndex = 0;                          m_payload = new byte[m_payloadLength];                          goto case State.PayloadInProgress;                        case State.PayloadInProgress:                          int bytesToRead = m_payloadLength - m_payloadIndex;                            if (bytesToRead > (message.Length - i))                          {                              bytesToRead = message.Length - i;                          }                            Buffer.BlockCopy(message' i' m_payload' m_payloadIndex' bytesToRead);                            if (m_isMaksed)                          {                              for (int j = m_payloadIndex; j < m_payloadIndex + bytesToRead; j++)                              {                                                                  if (m_opcode == OpcodeEnum.Binary)                                  {                                      // because the first byte is the more bit we always add + 1 to the index                                       // when retrieving the mask byte                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j + 1) % 4]);                                      }                                  else                                  {                                      m_payload[j] = (byte)(m_payload[j] ^ m_mask[(j) % 4]);                                      }                                                              }                          }                            m_payloadIndex += bytesToRead;                          i += bytesToRead;                            if (m_payloadIndex < m_payloadLength)                          {                              m_state = State.PayloadInProgress;                          }                          else                          {                              var temp = Message;                              if (temp != null)                              {                                  temp(this' new MessageEventArgs(m_opcode' m_payload' m_more));                              }                                m_state = State.NewMessage;                          }                            break;                      default:                          Process(message[i]);                          i++;                          break;                  }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following statement contains a magic number: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: int frameSize = 2 + 1 + message.Length;
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: int payloadStartIndex = 2;
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: frameSize += 2;
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: payloadStartIndex += 2;
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: frameSize += 6;
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: payloadStartIndex += 6;
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: payloadLength > 125
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: frame[1] |= (byte)(payloadLength & 127);
Magic Number,NetMQ.WebSockets,WebSocketClient,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\WebSocketClient.cs,Send,The following statement contains a magic number: payloadLength <= 125
Missing Default,NetMQ.WebSockets,ByteArrayEqualityComparer,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\ByteArrayEqualityComparer.cs,GetHashCode,The following switch statement is missing a default case: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Missing Default,NetMQ.WebSockets,Decoder,D:\research\architectureSmells\repos1\somdoron_NetMQ.WebSockets\src\NetMQ.WebSockets\Decoder.cs,Process,The following switch statement is missing a default case: switch (m_state)              {                  case State.NewMessage:                      m_final = (b & FinalBit) != 0;                      m_opcode = (OpcodeEnum)(b & 0xF);                      m_state = State.SecondByte;                                         break;                  case State.SecondByte:                      m_isMaksed = (b & MaskedBit) != 0;                      byte length = (byte)(b & 0x7F);                        if (length < 126)                      {                          m_payloadLength = length;                          m_state = NextState();                      }                      else if (length == 126)                      {                          m_state = State.ShortSize;                      }                      else                      {                          m_state = State.LongSize;                      }                      break;                  case State.Mask:                      m_mask[0] = b;                      m_state = State.Mask2;                      break;                  case State.Mask2:                      m_mask[1] = b;                      m_state = State.Mask3;                      break;                  case State.Mask3:                      m_mask[2] = b;                      m_state = State.Mask4;                      break;                  case State.Mask4:                      m_mask[3] = b;                      m_state = NextState();                      break;                  case State.ShortSize:                      m_payloadLength = b << 8;                      m_state = State.ShortSize2;                      break;                  case State.ShortSize2:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.LongSize:                      m_payloadLength = 0;                        // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize2;                      break;                  case State.LongSize2:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize3;                      break;                  case State.LongSize3:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize4;                      break;                  case State.LongSize4:                      // must be zero' max message size is MaxInt                      Debug.Assert(b == 0);                      m_state = State.LongSize5;                      break;                  case State.LongSize5:                      m_payloadLength |= b << 24;                      m_state = State.LongSize6;                      break;                  case State.LongSize6:                      m_payloadLength |= b << 16;                      m_state = State.LongSize7;                      break;                  case State.LongSize7:                      m_payloadLength |= b << 8;                      m_state = State.LongSize8;                      break;                  case State.LongSize8:                      m_payloadLength |= b;                      m_state = NextState();                      break;                  case State.MoreByte:                      // The first byte of the payload is the more bit                                          if (m_isMaksed)                      {                          m_more = (b ^ m_mask[0]) == 1;                      }                      else                      {                          m_more = b == 1;                      }                        m_payloadLength--;                        m_state = State.Payload;                      break;              }
