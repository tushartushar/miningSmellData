Implementation smell,Namespace,Class,File,Method,Description
Long Method,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,SanitizePlugin,The method has 108 lines of code.
Long Method,TESVSnip.Domain.Model,BatchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The method has 115 lines of code.
Long Method,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The method has 191 lines of code.
Long Method,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The method has 252 lines of code.
Long Method,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,The method has 137 lines of code.
Long Method,TESVSnip.Domain.Model,SearchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,The method has 103 lines of code.
Long Method,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The method has 156 lines of code.
Long Method,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The method has 121 lines of code.
Long Method,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The method has 131 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The method has 107 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The method has 128 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpression2,The method has 100 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpressionValue,The method has 102 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The method has 257 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The method has 123 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The method has 146 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The method has 128 lines of code.
Long Method,TESVSnip.Domain.Scripts,TokenStream,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,The method has 183 lines of code.
Complex Method,TESVSnip.Domain.Data.Structure,SubrecordStructure,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\SubrecordStructure.cs,GetElementArray,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,Cyclomatic complexity of the method is 15
Complex Method,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,SanitizePlugin,Cyclomatic complexity of the method is 16
Complex Method,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,Cyclomatic complexity of the method is 10
Complex Method,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,Cyclomatic complexity of the method is 10
Complex Method,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Services,CloneTool,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,Cyclomatic complexity of the method is 14
Complex Method,TESVSnip.Domain.Services,CloneTool,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\CloneTool.cs,CopyRecordsTo,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Model,BatchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,Cyclomatic complexity of the method is 21
Complex Method,TESVSnip.Domain.Model,BatchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BatchElement.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Model,BatchSubrecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BatchSubrecord.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,Cyclomatic complexity of the method is 26
Complex Method,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,Cyclomatic complexity of the method is 77
Complex Method,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,ReloadStrings,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,DetectVersion,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,Cyclomatic complexity of the method is 10
Complex Method,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,Record,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,Cyclomatic complexity of the method is 36
Complex Method,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,InnerLoop,Cyclomatic complexity of the method is 17
Complex Method,TESVSnip.Domain.Model,SearchCriteriaSettings,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchCriteriaSettings.cs,GetFormatString,Cyclomatic complexity of the method is 11
Complex Method,TESVSnip.Domain.Model,SearchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchElement.cs,Match,Cyclomatic complexity of the method is 18
Complex Method,TESVSnip.Domain.Model,SearchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,Cyclomatic complexity of the method is 21
Complex Method,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,EnumerateElements,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,Cyclomatic complexity of the method is 31
Complex Method,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,LoadAllPrototypeFunction,Cyclomatic complexity of the method is 11
Complex Method,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,Cyclomatic complexity of the method is 19
Complex Method,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,Cyclomatic complexity of the method is 24
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,Cyclomatic complexity of the method is 25
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,Cyclomatic complexity of the method is 11
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpression2,Cyclomatic complexity of the method is 16
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpressionValue,Cyclomatic complexity of the method is 19
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,Cyclomatic complexity of the method is 50
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitRefLabel,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,Cyclomatic complexity of the method is 21
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,Cyclomatic complexity of the method is 20
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,Cyclomatic complexity of the method is 18
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,Cyclomatic complexity of the method is 16
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,Cyclomatic complexity of the method is 13
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Scripts,FunctionSig,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,FunctionSig,Cyclomatic complexity of the method is 14
Complex Method,TESVSnip.Domain.Scripts,FunctionSig,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,GetVarType,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Scripts,TokenStream,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,Cyclomatic complexity of the method is 41
Long Parameter List,TESVSnip.Domain.Services,CompressHelper,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Compressor.cs,Decompress,The method has 5 parameters. Parameters: data' offset' length' compSize' level
Long Parameter List,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,Element,The method has 5 parameters. Parameters: es' data' offset' count' indices
Long Parameter List,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The method has 5 parameters. Parameters: es' data' offset' rawData' indices
Long Parameter List,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The method has 5 parameters. Parameters: Size' br' define' recFilter' filterAll
Long Parameter List,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,EnumerateElements,The method has 5 parameters. Parameters: elements' data' offset' rawData' indices
Long Parameter List,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The method has 6 parameters. Parameters: r' mask' id' records' quests' refs
Long Statement,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The length of the statement  "            // uint maxid = plugin.Masters.Max(x=>x.Strings.Count > 0 ? x.Strings.Keys.Max() : 0); // No need to check the masters string since the numbers are unique for every plugin " is 171.
Long Statement,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The length of the statement  "                                    // uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin " is 182.
Long Statement,TESVSnip.Domain.Model,BatchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BatchElement.cs,Evaluate,The length of the statement  "            foreach (bool value in sr.EnumerateElements().Where(x => x.Structure.name == this.Record.name).Select(x => this.Evaluate(r' sr' x))) " is 132.
Long Statement,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,ToString,The length of the statement  "            return string.Format("[Element] {0} '{1}' = {2}"' this.Type' this.Structure != null ? this.Structure.desc : ""' this.Value); " is 124.
Long Statement,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,AddRecord,The length of the statement  "              throw new TESParserException("Record to add was not of the correct type." + Environment.NewLine + "Groups can only hold records or other groups."); " is 147.
Long Statement,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,AddRecords,The length of the statement  "                throw new TESParserException("Record to add was not of the correct type.\nGroups can only hold records or other groups."); " is 122.
Long Statement,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,DeleteRecords,The length of the statement  "                throw new TESParserException("Record to delete was not of the correct type.\nGroups can only hold records or other groups."); " is 125.
Long Statement,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,InsertRecord,The length of the statement  "                throw new TESParserException("Record to add was not of the correct type." + Environment.NewLine + "Groups can only hold records or other groups."); " is 147.
Long Statement,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,InsertRecords,The length of the statement  "                throw new TESParserException("Record to add was not of the correct type.\nGroups can only hold records or other groups."); " is 122.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddRecord,The length of the statement  "                    throw new TESParserException("Record to add was not of the correct type." + Environment.NewLine + "PluginList can only hold Groups or Records."); " is 145.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddRecords,The length of the statement  "                    throw new TESParserException("Record to add was not of the correct type.\nPlugins can only hold records or other groups."); " is 123.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,DeleteRecords,The length of the statement  "                throw new TESParserException("Record to delete was not of the correct type.\nPlugins can only hold records or other groups."); " is 126.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,InsertRecord,The length of the statement  "                throw new TESParserException("Record to add was not of the correct type." + Environment.NewLine + "PluginList can only hold Groups or Records."); " is 145.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,InsertRecords,The length of the statement  "                throw new TESParserException("Record to add was not of the correct type.\nPlugins can only hold records or other groups."); " is 123.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,ReloadStrings,The length of the statement  "            if (string.IsNullOrEmpty(this.StringsFolder) || string.IsNullOrEmpty(this.FileName) || !Directory.Exists(this.StringsFolder)) " is 125.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,Save,The length of the statement  "                    string prefix = Path.Combine(Path.Combine(Path.GetDirectoryName(filePath)' "Strings")' Path.GetFileNameWithoutExtension(filePath)); " is 131.
Long Statement,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The length of the statement  "                    throw new Exception(string.Format("File is not a valid {0} plugin (Missing HEDR subrecord in the {1} record)"'define.Name'define.HEDRType)); " is 140.
Long Statement,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The length of the statement  "                        "COMPRESSED RECORD [NAME={0} AT POSITION={1}] SIZE DIFFERS FROM ORIGINAL: ORIGINAL={2} ACTUAL={3}' RAW RECORD SIZE={4}"' " is 120.
Long Statement,TESVSnip.Domain.Model,SearchCriteriaList,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchCriteriaList.cs,ToXml,The length of the statement  "                criteria.Add(new SearchElementXml { SubRecord = par.Record.name' Element = elem.Record.name' Type = elem.Type' Value = elem.Value != null ? elem.Value.ToString() : null }); " is 172.
Long Statement,TESVSnip.Domain.Model,SearchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchElement.cs,Match,The length of the statement  "            foreach (bool value in sr.EnumerateElements().Where(x => x.Structure.name == this.Record.name).Select(x => this.Match(r' sr' x))) " is 129.
Long Statement,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpressionValue,The length of the statement  "                    // if(fs.requiredArgs!=fs.args.Length) throw new ExpressionParseException("functions with variable argument count cannot be used in expressions"); " is 146.
Long Statement,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpressionValue,The length of the statement  "                    // if(fs.ret==VarType.None) throw new ExpressionParseException("Functions with no return type cannot be used in expressions"); " is 126.
Long Statement,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The length of the statement  "                            Enum[n3.Attributes.GetNamedItem("name").Value.ToLowerInvariant()] = ushort.Parse(n3.Attributes.GetNamedItem("value").Value); " is 124.
Complex Conditional,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The conditional expression  "tes4 != null && tes4.SubRecords.Count > 0 && tes4.SubRecords[0].Name == "HEDR" &&                  tes4.SubRecords[0].Size >= 8"  is complex.
Complex Conditional,TESVSnip.Domain.Scripts,FunctionSig,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,FunctionSig,The conditional expression  "block && (this.args[i] != VarType.Ref && this.args[i] != VarType.Short && this.args[i] != VarType.Int)"  is complex.
Complex Conditional,TESVSnip.Domain.Scripts,TokenStream,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\TokenStream.cs,FromWord,The conditional expression  "char.IsDigit(token[0]) || (token.Length > 1 && (token[0] == '.' || token[0] == '-') && char.IsDigit(token[1]))"  is complex.
Complex Conditional,TESVSnip.Domain.Scripts,TokenStream,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,The conditional expression  "char.IsLetterOrDigit(c) || c == '_' || ((c == '.' || c == '~') && char.IsDigit(this.SafePeek()))"  is complex.
Complex Conditional,TESVSnip.Domain.Scripts,TokenStream,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,The conditional expression  "char.IsLetterOrDigit(c) || c == '_' || (numeric && c == '.')"  is complex.
Virtual Method Call from Constructor,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The constructor "GroupRecord" calls a virtual method "Clone".
Empty Catch Block,TESVSnip.Domain.Services,CompressHelper,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Compressor.cs,CompressHelper,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordStructureToRecord,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,SearchCriteriaList,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchCriteriaList.cs,Deserialize,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,SearchCriteriaList,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchCriteriaList.cs,Serialize,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,SearchCriteriaList,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchCriteriaList.cs,Serialize,The method has an empty catch block.
Magic Number,TESVSnip.Domain.Data,DomainDefinition,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\DomainDefinition.cs,DetectDefinitionFromVersion,The following statement contains a magic number: const float EPSILON = Single.Epsilon * 10;
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: string[] val = src.name.Split(new[] {';'}' 2' StringSplitOptions.None);
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: var c = (char) int.Parse(val[0].Substring(3)' NumberStyles.HexNumber' null);
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: string[] val = node.name.Split(new[] {';'}' 2' StringSplitOptions.None);
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: var c = (char) int.Parse(val[0].Substring(3)' NumberStyles.HexNumber' null);
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: string[] val = node.name.Split(new[] {';'}' 2' StringSplitOptions.None);
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: var c = (char) int.Parse(val[0].Substring(3)' NumberStyles.HexNumber' null);
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: string[] val = src.name.Split(new[] {';'}' 2' StringSplitOptions.None);
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: var c = (char) int.Parse(val[0].Substring(3)' NumberStyles.HexNumber' null);
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: string[] val = node.name.Split(new[] {';'}' 2' StringSplitOptions.None);
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: var c = (char) int.Parse(val[0].Substring(3)' NumberStyles.HexNumber' null);
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: string[] val = node.name.Split(new[] {';'}' 2' StringSplitOptions.None);
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: var c = (char) int.Parse(val[0].Substring(3)' NumberStyles.HexNumber' null);
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: data.Count == 4 && TypeConverter.IsLikelyString(data)
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: data.Count != 4 || TypeConverter.IsLikelyString(data)
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The following statement contains a magic number: var formid = (uint)TypeConverter.GetObject<uint>(data' 8);
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The following statement contains a magic number: TypeConverter.i2h(formid + 1' data' 8);
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The following statement contains a magic number: tes4 != null && tes4.SubRecords.Count > 0 && tes4.SubRecords[0].Name == "HEDR" &&                  tes4.SubRecords[0].Size >= 8
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,The following statement contains a magic number: data.Count == 4
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,The following statement contains a magic number: data.Count == 4
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,The following statement contains a magic number: data.Count == 4
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,The following statement contains a magic number: data.Count == 4
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: var data = new byte[4];
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: data[0] = 40;
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: record.Flags3 = TypeConverter.h2i(new ArraySegment<byte>(data' 0' 4));
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: data[0] > 40
Magic Number,TESVSnip.Domain.Services,Spells,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: record.Flags3 > 40
Magic Number,TESVSnip.Domain.Services,CloneTool,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: var idx = id >> 24;
Magic Number,TESVSnip.Domain.Services,CloneTool,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: info.References[id] = (id & 0x00FFFFFF) | (uint)(newidx << 24);
Magic Number,TESVSnip.Domain.Services,CloneTool,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: var masterId = (uint)(this.masters.Count << 24);
Magic Number,TESVSnip.Domain.Services,CompressHelper,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Services\Compressor.cs,Decompress,The following statement contains a magic number: level = (int)args[4];
Magic Number,TESVSnip.Domain.Model,BaseRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BaseRecord.cs,ReadRecName,The following statement contains a magic number: return Encoding.Default.GetString(br.ReadBytes(4));
Magic Number,TESVSnip.Domain.Model,BaseRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BaseRecord.cs,ReadRecName,The following statement contains a magic number: return Encoding.Default.GetString(rec'0'4);
Magic Number,TESVSnip.Domain.Model,BatchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The following statement contains a magic number: numText = strvalue.Substring(2);
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type)                  {                      case ElementValueType.Int:                          len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;                          elem = new Element(es' ElementValueType.Int' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UInt:                      case ElementValueType.FormID:                          len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;                          elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Float:                          len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;                          elem = new Element(es' ElementValueType.Float' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Short:                          len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;                          elem = new Element(es' ElementValueType.Short' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.UShort:                          len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;                          elem = new Element(es' ElementValueType.UShort' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.SByte:                          len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;                          elem = new Element(es' ElementValueType.SByte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.Byte:                          len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;                          elem = new Element(es' ElementValueType.Byte' new ArraySegment<byte>(data' offset' len)' indices);                          offset += len;                          break;                      case ElementValueType.String:                          len = 0;                          for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                          {                              ;                          }                            if (rawData)                          {                              // raw form includes the zero termination byte                              len = len == 0 ? 0 : len + 1;                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len;                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                              offset += len == 0 ? 0 : len + 1;                          }                            break;                      case ElementValueType.BString:                          if (maxlen >= sizeof(ushort))                          {                              len = TypeConverter.h2s(data[offset]' data[offset + 1]);                              len = (len < maxlen - 2) ? len : maxlen - 2;                              if (rawData)                              {                                  // raw data includes short prefix                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(data' offset' len + 2)' indices);                                  offset += len + 2;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 2' len)' indices);                                  offset += len + 2;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.BString' new ArraySegment<byte>(new byte[2] { 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.IString:                          if (maxlen >= sizeof(int))                          {                              len = TypeConverter.h2si(data[offset]' data[offset + 1]' data[offset + 2]' data[offset + 3]);                              len = (len < maxlen - 4) ? len : maxlen - 4;                              if (rawData)                              {                                  // raw data includes int prefix                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(data' offset' len + 4)' indices);                                  offset += len + 4;                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset + 4' len)' indices);                                  offset += len + 4;                              }                          }                          else                          {                              if (rawData)                              {                                  elem = new Element(es' ElementValueType.IString' new ArraySegment<byte>(new byte[4] { 0' 0' 0' 0 })' indices);                              }                              else                              {                                  elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(new byte[0])' indices);                              }                                offset += maxlen;                          }                            break;                      case ElementValueType.Str4:                          len = maxlen >= 4 ? 4 : maxlen;                          if (rawData)                          {                              elem = new Element(es' ElementValueType.Str4' new ArraySegment<byte>(data' offset' len)' indices);                          }                          else                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                          }                            offset += len;                          break;                        case ElementValueType.LString:                          if (maxlen < sizeof(int))                          {                              elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' maxlen)' indices);                              offset += maxlen;                          }                          else                          {                              len = maxlen;                              var blob = new ArraySegment<byte>(data' offset' len);                              bool isString = TypeConverter.IsLikelyString(blob);                              if (!isString)                              {                                  elem = new Element(es' ElementValueType.UInt' new ArraySegment<byte>(data' offset' len)' indices);                                  offset += 4;                              }                              else                              {                                  len = 0;                                  for (int i = offset; i < data.Length && data[i] != 0; ++i' ++len)                                  {                                      ;                                  }                                    if (rawData)                                  {                                      // lstring as raw string includes the terminating null                                      len = len == 0 ? 0 : len + 1;                                      elem = new Element(es' ElementValueType.LString' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len;                                  }                                  else                                  {                                      elem = new Element(es' ElementValueType.String' new ArraySegment<byte>(data' offset' len)' indices);                                      offset += len == 0 ? 0 : len + 1;                                  }                              }                          }                            break;                        default:                          elem = new Element(es' ElementValueType.Blob' new ArraySegment<byte>(data' offset' maxlen)' indices);                          offset += maxlen;                          break;                  }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following statement contains a magic number: switch (this.Structure.type)              {                  case ElementValueType.String:                      {                          var str1 = Extensions.CastValue<string>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(str1 + Extensions.CastValue<string>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }                      }                        break;                    case ElementValueType.FormID:                      {                          if (this.Value is uint && val is uint)                          {                              var u1 = (uint)this.Value;                              var u2 = (uint)val;                              switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<uint>(u2);                                  case ElementAssignmentType.Add:                                      return this.AssignValue<uint>(u1 + u2);                                  case ElementAssignmentType.Subtract:                                      return this.AssignValue<uint>(u1 - u2);                                  case ElementAssignmentType.Multiply:                                      return this.AssignValue<uint>(u1 * u2);                                  case ElementAssignmentType.Divide:                                      return this.AssignValue<uint>(u1 / u2);                                  case ElementAssignmentType.BitAnd:                                      return this.AssignValue<uint>(u1 & u2);                                  case ElementAssignmentType.BitOr:                                      return this.AssignValue<uint>(u1 | u2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<uint>(default(uint));                              }                          }                      }                        break;                    case ElementValueType.Blob:                      break;                    case ElementValueType.LString:                      if (this.Value is string && val is string)                      {                          var s1 = (string)this.Value;                          var s2 = (string)val;                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(s2);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(s1 + s2);                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }                      }                        break;                    case ElementValueType.BString:                  case ElementValueType.IString:                      break;                    case ElementValueType.Str4:                      {                          var str2 = Extensions.CastValue<string>(val);                          if (this.Data.Count == 4 && str2.Length == 4)                          {                              switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<string>(str2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<string>("    ");                              }                          }                      }                        break;                  case ElementValueType.Float:                      {                          var val1 = Extensions.CastValue<float>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<float>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<float>(val1 + Extensions.CastValue<float>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<float>(val1 - Extensions.CastValue<float>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<float>(val1 * Extensions.CastValue<float>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<float>(val1 / Extensions.CastValue<float>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<float>(default(float));                          }                      }                        break;                  case ElementValueType.Int:                      {                          var val1 = Extensions.CastValue<int>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<int>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<int>(val1 + Extensions.CastValue<int>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<int>(val1 - Extensions.CastValue<int>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<int>(val1 * Extensions.CastValue<int>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<int>(val1 / Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<int>(val1 & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<int>(val1 | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<int>(default(int));                          }                      }                        break;                  case ElementValueType.Short:                      {                          var val1 = Extensions.CastValue<short>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<short>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<short>(val1 + Extensions.CastValue<short>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<short>(val1 - Extensions.CastValue<short>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<short>(val1 * Extensions.CastValue<short>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<short>(val1 / Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<short>(val1 & Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<short>(val1 | Extensions.CastValue<short>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<short>(default(short));                          }                      }                        break;                  case ElementValueType.Byte:                      {                          var val1 = Extensions.CastValue<byte>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<byte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<byte>(val1 + Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<byte>(val1 - Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<byte>(val1 * Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<byte>(val1 / Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<byte>(val1 & Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<byte>(val1 | Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<byte>(default(byte));                          }                      }                        break;                  case ElementValueType.UShort:                      {                          var val1 = Extensions.CastValue<ushort>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<ushort>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<ushort>(val1 + Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<ushort>(val1 - Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<ushort>(val1 * Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<ushort>(val1 / Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<ushort>(val1 & Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<ushort>(val1 | Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<ushort>(default(ushort));                          }                      }                        break;                  case ElementValueType.UInt:                      {                          var val1 = Extensions.CastValue<uint>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<uint>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<uint>(val1 + Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<uint>(val1 - Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<uint>(val1 * Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<uint>(val1 / Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<uint>(val1 & Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<uint>(val1 | Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<uint>(default(uint));                          }                      }                        break;                  case ElementValueType.SByte:                      {                          var val1 = Extensions.CastValue<sbyte>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<sbyte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<sbyte>(val1 + Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<sbyte>(val1 - Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<sbyte>(val1 * Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<sbyte>(val1 / Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<sbyte>(val1 & Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<sbyte>(val1 | Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<sbyte>(default(sbyte));                          }                      }                        break;              }
Magic Number,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following statement contains a magic number: switch (this.Structure.type)              {                  case ElementValueType.String:                      {                          var str1 = Extensions.CastValue<string>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(str1 + Extensions.CastValue<string>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }                      }                        break;                    case ElementValueType.FormID:                      {                          if (this.Value is uint && val is uint)                          {                              var u1 = (uint)this.Value;                              var u2 = (uint)val;                              switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<uint>(u2);                                  case ElementAssignmentType.Add:                                      return this.AssignValue<uint>(u1 + u2);                                  case ElementAssignmentType.Subtract:                                      return this.AssignValue<uint>(u1 - u2);                                  case ElementAssignmentType.Multiply:                                      return this.AssignValue<uint>(u1 * u2);                                  case ElementAssignmentType.Divide:                                      return this.AssignValue<uint>(u1 / u2);                                  case ElementAssignmentType.BitAnd:                                      return this.AssignValue<uint>(u1 & u2);                                  case ElementAssignmentType.BitOr:                                      return this.AssignValue<uint>(u1 | u2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<uint>(default(uint));                              }                          }                      }                        break;                    case ElementValueType.Blob:                      break;                    case ElementValueType.LString:                      if (this.Value is string && val is string)                      {                          var s1 = (string)this.Value;                          var s2 = (string)val;                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(s2);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(s1 + s2);                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }                      }                        break;                    case ElementValueType.BString:                  case ElementValueType.IString:                      break;                    case ElementValueType.Str4:                      {                          var str2 = Extensions.CastValue<string>(val);                          if (this.Data.Count == 4 && str2.Length == 4)                          {                              switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<string>(str2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<string>("    ");                              }                          }                      }                        break;                  case ElementValueType.Float:                      {                          var val1 = Extensions.CastValue<float>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<float>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<float>(val1 + Extensions.CastValue<float>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<float>(val1 - Extensions.CastValue<float>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<float>(val1 * Extensions.CastValue<float>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<float>(val1 / Extensions.CastValue<float>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<float>(default(float));                          }                      }                        break;                  case ElementValueType.Int:                      {                          var val1 = Extensions.CastValue<int>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<int>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<int>(val1 + Extensions.CastValue<int>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<int>(val1 - Extensions.CastValue<int>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<int>(val1 * Extensions.CastValue<int>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<int>(val1 / Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<int>(val1 & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<int>(val1 | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<int>(default(int));                          }                      }                        break;                  case ElementValueType.Short:                      {                          var val1 = Extensions.CastValue<short>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<short>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<short>(val1 + Extensions.CastValue<short>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<short>(val1 - Extensions.CastValue<short>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<short>(val1 * Extensions.CastValue<short>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<short>(val1 / Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<short>(val1 & Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<short>(val1 | Extensions.CastValue<short>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<short>(default(short));                          }                      }                        break;                  case ElementValueType.Byte:                      {                          var val1 = Extensions.CastValue<byte>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<byte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<byte>(val1 + Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<byte>(val1 - Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<byte>(val1 * Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<byte>(val1 / Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<byte>(val1 & Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<byte>(val1 | Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<byte>(default(byte));                          }                      }                        break;                  case ElementValueType.UShort:                      {                          var val1 = Extensions.CastValue<ushort>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<ushort>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<ushort>(val1 + Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<ushort>(val1 - Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<ushort>(val1 * Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<ushort>(val1 / Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<ushort>(val1 & Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<ushort>(val1 | Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<ushort>(default(ushort));                          }                      }                        break;                  case ElementValueType.UInt:                      {                          var val1 = Extensions.CastValue<uint>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<uint>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<uint>(val1 + Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<uint>(val1 - Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<uint>(val1 * Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<uint>(val1 / Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<uint>(val1 & Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<uint>(val1 | Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<uint>(default(uint));                          }                      }                        break;                  case ElementValueType.SByte:                      {                          var val1 = Extensions.CastValue<sbyte>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<sbyte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<sbyte>(val1 + Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<sbyte>(val1 - Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<sbyte>(val1 * Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<sbyte>(val1 / Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<sbyte>(val1 & Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<sbyte>(val1 | Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<sbyte>(default(sbyte));                          }                      }                        break;              }
Magic Number,TESVSnip.Domain.Model,FlagDefs,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\FlagDefs.cs,GetRecFlags1Desc,The following statement contains a magic number: i < 32
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: this.data = new byte[4];
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: i < 4
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: this.data = br.ReadBytes(4);
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: define.RecSize >= 16
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: amountRead < Size - (define.RecSize+8)
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: throw new TESParserException(                      string.Format("Record block did not match the size specified in the group header! Header Size={0:D} Group Size={1:D}"' Size - (define.RecSize+8)' amountRead));
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: amountRead != (Size - (define.RecSize+8))
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,SetData,The following statement contains a magic number: data.Length != 4
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,SetData,The following statement contains a magic number: i < 4
Magic Number,TESVSnip.Domain.Model,GroupRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\GroupRecord.cs,SaveData,The following statement contains a magic number: writer.BaseStream.Position = startpos + 4;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: (rec.FormID >> 24) >= masterIdx
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: elem.AssignValue<uint>((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: elem.AssignValue<uint>((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: (value >> 24) >= masterIdx
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,ReloadStrings,The following statement contains a magic number: fontInfo.CodePage != 1252
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,EnumerateRecords,The following statement contains a magic number: match <<= 24;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,EnumerateRecords,The following statement contains a magic number: uint mask = (uint)i << 24;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: hedr.TrySetValue(8' (formID & 0x00FFFFFF) + 1);
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: hedr.TryGetValue(8' out formID) && increment
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: hedr.Name == "HEDR" && hedr.Size >= 12
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: return (formID & 0x00FFFFFF) | ((uint)(masterCount << 24));
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateNextFormID,The following statement contains a magic number: hedr.TrySetValue(8' newid);
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateNextFormID,The following statement contains a magic number: hedr.Name == "HEDR" && hedr.Size >= 12
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,GetRecordByID,The following statement contains a magic number: uint pluginid = (id & 0xff000000) >> 24;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,GetRecordByID,The following statement contains a magic number: id += this.Fixups[pluginid] << 24;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,GetRecordMaster,The following statement contains a magic number: uint pluginid = (id & 0xff000000) >> 24;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LookupFormID,The following statement contains a magic number: uint pluginid = (id & 0xff000000) >> 24;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LookupFormID,The following statement contains a magic number: id |= this.Fixups[pluginid] << 24;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,SaveStrings,The following statement contains a magic number: fontInfo.CodePage != 1252
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: hedr.TrySetValue(4' reccount);
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: var maxID = this.Records.OfType<BaseRecord>().SelectMany(x => x.Enumerate()).OfType<Record>()                              .Where(x => (x.FormID >> 24) == masterCount).Select(x => x.FormID & 0x00FFFFFF)                              .Union(minId).Max();
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: hedr.TrySetValue(8' maxID + 1);
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: hedr.TryGetValue(8' out curid) && maxID >= curid
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: hedr.Name == "HEDR" && hedr.Size >= 12
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,DetectVersion,The following statement contains a magic number: br.BaseStream.Position = 20;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: br.BaseStream.Position = 4;
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,The following statement contains a magic number: var buffer = new byte[65536];
Magic Number,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,The following statement contains a magic number: var buffer = new byte[65536];
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: int estimatedCount = Math.Max( Math.Min(16' (int)dataSize/10)' 0 );
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: int estimatedCount = Math.Max( Math.Min(16' (int)dataSize/10)' 0 );
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: define.RecSize >= 12
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: define.RecSize >= 16
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: dataSize -= 4;
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: left < 4
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: desc = string.Format(" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float>(0) / 4096.0f)'                                               (int)(data.GetValue<float>(4) / 4096.0f));
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: desc = string.Format(" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float>(0) / 4096.0f)'                                               (int)(data.GetValue<float>(4) / 4096.0f));
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: desc = string.Format(" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float>(0) / 4096.0f)'                                               (int)(data.GetValue<float>(4) / 4096.0f));
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The following statement contains a magic number: data = Compressor.Compress(data' (compressLevel == 0) ? 9 : compressLevel);
Magic Number,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The following statement contains a magic number: dataSize += 4;
Magic Number,TESVSnip.Domain.Model,SearchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,The following statement contains a magic number: numText = strvalue.Substring(2);
Magic Number,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetHexData,The following statement contains a magic number: s += b.ToString("X").PadLeft(2' '0') + " ";
Magic Number,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetLString,The following statement contains a magic number: bool isString = (data.Count != 4) || TypeConverter.IsLikelyString(data);
Magic Number,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type)              {                  case ElementValueType.FormID:                      {                          var id = (uint) value;                          strValue = id.ToString("X8");                          if (id != 0)                          {                              rec = p.GetRecordByID(id);                              if (rec != null)                              {                                  strValue = string.Format("{0}: {1}"' strValue' rec.DescriptiveName);                              }                          }                            value = strValue;                      }                        break;                  case ElementValueType.LString:                      if (value is uint)                      {                          if (p != null)                          {                              value = p.LookupFormStrings((uint) value) ?? value;                          }                      }                        break;                  case ElementValueType.Blob:                      value = TypeConverter.GetHexData(elem.Data);                      break;                  case ElementValueType.SByte:                  case ElementValueType.Int:                  case ElementValueType.Short:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              int intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == int.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              int intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.UInt:                  case ElementValueType.Byte:                  case ElementValueType.UShort:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              uint intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToUInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == uint.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              uint intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.Str4:                      strValue = TypeConverter.GetString(elem.Data);                      break;                  case ElementValueType.BString:                      strValue = TypeConverter.GetBString(elem.Data);                      break;                  case ElementValueType.IString:                      strValue = TypeConverter.GetIString(elem.Data);                      break;                  default:                      strValue = value == null ? string.Empty : value.ToString();                      break;              }
Magic Number,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type)              {                  case ElementValueType.FormID:                      {                          var id = (uint) value;                          strValue = id.ToString("X8");                          if (id != 0)                          {                              rec = p.GetRecordByID(id);                              if (rec != null)                              {                                  strValue = string.Format("{0}: {1}"' strValue' rec.DescriptiveName);                              }                          }                            value = strValue;                      }                        break;                  case ElementValueType.LString:                      if (value is uint)                      {                          if (p != null)                          {                              value = p.LookupFormStrings((uint) value) ?? value;                          }                      }                        break;                  case ElementValueType.Blob:                      value = TypeConverter.GetHexData(elem.Data);                      break;                  case ElementValueType.SByte:                  case ElementValueType.Int:                  case ElementValueType.Short:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              int intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == int.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              int intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.UInt:                  case ElementValueType.Byte:                  case ElementValueType.UShort:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              uint intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToUInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == uint.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              uint intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.Str4:                      strValue = TypeConverter.GetString(elem.Data);                      break;                  case ElementValueType.BString:                      strValue = TypeConverter.GetBString(elem.Data);                      break;                  case ElementValueType.IString:                      strValue = TypeConverter.GetIString(elem.Data);                      break;                  default:                      strValue = value == null ? string.Empty : value.ToString();                      break;              }
Magic Number,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type)              {                  case ElementValueType.FormID:                      {                          var id = (uint) value;                          strValue = id.ToString("X8");                          if (id != 0)                          {                              rec = p.GetRecordByID(id);                              if (rec != null)                              {                                  strValue = string.Format("{0}: {1}"' strValue' rec.DescriptiveName);                              }                          }                            value = strValue;                      }                        break;                  case ElementValueType.LString:                      if (value is uint)                      {                          if (p != null)                          {                              value = p.LookupFormStrings((uint) value) ?? value;                          }                      }                        break;                  case ElementValueType.Blob:                      value = TypeConverter.GetHexData(elem.Data);                      break;                  case ElementValueType.SByte:                  case ElementValueType.Int:                  case ElementValueType.Short:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              int intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == int.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              int intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.UInt:                  case ElementValueType.Byte:                  case ElementValueType.UShort:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              uint intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToUInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == uint.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              uint intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.Str4:                      strValue = TypeConverter.GetString(elem.Data);                      break;                  case ElementValueType.BString:                      strValue = TypeConverter.GetBString(elem.Data);                      break;                  case ElementValueType.IString:                      strValue = TypeConverter.GetIString(elem.Data);                      break;                  default:                      strValue = value == null ? string.Empty : value.ToString();                      break;              }
Magic Number,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type)              {                  case ElementValueType.FormID:                      {                          var id = (uint) value;                          strValue = id.ToString("X8");                          if (id != 0)                          {                              rec = p.GetRecordByID(id);                              if (rec != null)                              {                                  strValue = string.Format("{0}: {1}"' strValue' rec.DescriptiveName);                              }                          }                            value = strValue;                      }                        break;                  case ElementValueType.LString:                      if (value is uint)                      {                          if (p != null)                          {                              value = p.LookupFormStrings((uint) value) ?? value;                          }                      }                        break;                  case ElementValueType.Blob:                      value = TypeConverter.GetHexData(elem.Data);                      break;                  case ElementValueType.SByte:                  case ElementValueType.Int:                  case ElementValueType.Short:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              int intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == int.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              int intVal = int.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.UInt:                  case ElementValueType.Byte:                  case ElementValueType.UShort:                      {                          if (sselem.hexview || hasFlags)                          {                              value = string.Format(string.Format("{{0:X{0}}}"' elem.Data.Count*2)' value);                          }                          else                          {                              value = value ?? string.Empty;                          }                            if (hasOptions)                          {                              uint intVal;                              if (sselem.hexview || hasFlags)                              {                                  intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              }                              else                              {                                  intVal = Convert.ToUInt32(value);                              }                                for (int k = 0; k < sselem.options.Length; k += 2)                              {                                  if (intVal == uint.Parse(sselem.options[k + 1]))                                  {                                      value = sselem.options[k];                                  }                              }                          }                          else if (hasFlags)                          {                              uint intVal = uint.Parse(value.ToString()' NumberStyles.HexNumber);                              var tmp2 = new StringBuilder();                              for (int k = 0; k < sselem.flags.Length; k++)                              {                                  if ((intVal & (1 << k)) != 0)                                  {                                      if (tmp2.Length > 0)                                      {                                          tmp2.Append("' ");                                      }                                        tmp2.Append(sselem.flags[k]);                                  }                              }                                tmp2.Insert(0' ": ");                              tmp2.Insert(0' value.ToString());                              value = tmp2.ToString();                          }                      }                        break;                  case ElementValueType.Str4:                      strValue = TypeConverter.GetString(elem.Data);                      break;                  case ElementValueType.BString:                      strValue = TypeConverter.GetBString(elem.Data);                      break;                  case ElementValueType.IString:                      strValue = TypeConverter.GetIString(elem.Data);                      break;                  default:                      strValue = value == null ? string.Empty : value.ToString();                      break;              }
Magic Number,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,SaveData,The following statement contains a magic number: writer.Write((ushort) 4);
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: switch (pyFunc.Parameters[i + 3]) //+2 jump self' element and value parameter                          {                              case "float":                                  param[i] = float.Parse(parameters[i]' _ni);                                  break;                              case "int":                                  param[i] = int.Parse(parameters[i]' _ni);                                  break;                              case "short":                                  param[i] = short.Parse(parameters[i]' _ni);                                  break;                              case "uint":                                  param[i] = uint.Parse(parameters[i]' _ni);                                  break;                              case "ushort":                                  param[i] = ushort.Parse(parameters[i]' _ni);                                  break;                          }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si(tmp[16]' tmp[17]' tmp[18]' tmp[19]);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si(tmp[16]' tmp[17]' tmp[18]' tmp[19]);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si(tmp[16]' tmp[17]' tmp[18]' tmp[19]);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si(tmp[16]' tmp[17]' tmp[18]' tmp[19]);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: smt.Length != 2 || !smt[0].IsKeyword(Keywords.ScriptName) || smt[1].token == null
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: var header = new byte[20];
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.si2h(refcount' header' 4);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.i2h((uint)bw.BaseStream.Length' header' 8);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.si2h(localList.Count' header' 12);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.si2h(scptype' header' 16);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: var header = new byte[20];
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.si2h(refcount' header' 4);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.i2h((uint)bw.BaseStream.Length' header' 8);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.si2h(localList.Count' header' 12);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.si2h(0x10000' header' 16);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: mask <<= 24;
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: uint id = i << 24;
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: smt.Length > fs.args.Length + 2
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: Emit((ushort)(smt.Length - 2));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: switch (fs.args[i - 2])                      {                          case VarType.Short:                              if (smt[i].type != TokenType.Integer)                              {                                  AddError("Block argument: Expected short");                              }                              else                              {                                  Emit(ushort.Parse(smt[i].token));                              }                                break;                          case VarType.Int:                              if (smt[i].type != TokenType.Integer)                              {                                  AddError("Block argument: Expected integer");                              }                              else                              {                                  EmitByte(0x73);                                  EmitLong(uint.Parse(smt[i].token));                              }                                break;                          case VarType.Ref:                              if (smt[i].type != TokenType.edid)                              {                                  AddError("Block argument: Expected edid");                              }                              else                              {                                  EmitRefLabel(smt[i]' RefType.Expression);                              }                                break;                          default:                              AddError("Sanity check failed. VarType of block argument was invalid");                              break;                      }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: Emit((ushort)(bw.BaseStream.Length - (pos + 2)));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpression,The following statement contains a magic number: Emit((ushort)(bw.BaseStream.Length - (pos + 2)));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: Emit(2);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: Dictionary<string' ushort> vars = farVars[smt[i - 2].token];
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: AddError("Reference '" + smt[i - 2].utoken + "' has no variable called '" + smt[i].utoken + "'");
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: Emit((ushort)(bw.BaseStream.Length - (pos + 2)));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: smt.Length == 2
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: Emit((ushort)(bw.BaseStream.Length - (pos + 2)));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: long pos = bw.BaseStream.Length + 6;
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: smt.Length < 2 || !smt[0].IsKeyword(Keywords.Begin)
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: smt.Length != 2 || smt[1].type != TokenType.Unknown
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: var data = new byte[24];
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: data[16] = 1;
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("*"' new Operator(null' 4' false' "*"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("/"' new Operator(null' 4' false' "/"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("+"' new Operator(null' 5' false' "+"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("-"' new Operator(null' 5' false' "-"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("<"' new Operator(null' 7' false' "<"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("<="' new Operator(null' 7' false' "<="));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add(">="' new Operator(null' 7' false' ">="));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add(">"' new Operator(null' 7' false' ">"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("=="' new Operator(null' 8' false' "=="));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("!="' new Operator(null' 8' false' "!="));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("&&"' new Operator(null' 12' false' "&&"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add("||"' new Operator(null' 13' false' "||"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: uniOps.Add("-"' new Operator(null' 3' false' "~"));
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: uint formid = TypeConverter.h2i(bytes[0]' bytes[1]' bytes[2]' bytes[3]);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: uint formid = TypeConverter.h2i(bytes[0]' bytes[1]' bytes[2]' bytes[3]);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: uint formid = TypeConverter.h2i(bytes[0]' bytes[1]' bytes[2]' bytes[3]);
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: uint formid = TypeConverter.h2i(bytes[0]' bytes[1]' bytes[2]' bytes[3]);
Magic Number,TESVSnip.Domain.Scripts,TokenStream,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\TokenStream.cs,SafePeek,The following statement contains a magic number: c < 32 && c != '\n'
Magic Number,TESVSnip.Domain.Scripts,TokenStream,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\TokenStream.cs,SafePop,The following statement contains a magic number: c < 32 && c != '\n'
Duplicate Code,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,The method contains a code clone-set at the following line numbers (starting from the method definition): ((42' 65)' (119' 142))
Duplicate Code,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,The method contains a code clone-set at the following line numbers (starting from the method definition): ((43' 65)' (70' 92))
Duplicate Code,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,The method contains a code clone-set at the following line numbers (starting from the method definition): ((43' 62)' (70' 89)' (120' 139))
Duplicate Code,TESVSnip.Domain.Model,Record,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,The method contains a code clone-set at the following line numbers (starting from the method definition): ((70' 92)' (120' 142))
Duplicate Code,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The method contains a code clone-set at the following line numbers (starting from the method definition): ((79' 99)' (136' 156))
Missing Default,TESVSnip.Domain.Data.Structure,ElementStructure,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Data\Structure\ElementStructure.cs,ElementStructure,The following switch statement is missing a default case: switch (this.type)              {                  case ElementValueType.FormID:                      this.FormIDType = node.reftype;                      break;                  case ElementValueType.Blob:                      if (this.repeat > 0 || this.optional > 0)                      {                          throw new RecordXmlException("blob type elements can't be marked with repeat or optional");                      }                        break;              }
Missing Default,TESVSnip.Domain.Model,BatchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The following switch statement is missing a default case: switch (this.Record.type)              {                  case ElementValueType.String:                  case ElementValueType.BString:                  case ElementValueType.IString:                  case ElementValueType.Str4:                      this.value = strvalue;                      return true;                  case ElementValueType.Float:                      {                          float v;                          if (float.TryParse(strvalue' NumberStyles.Any' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;                  case ElementValueType.Int:                      {                          int v;                          if (int.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;                  case ElementValueType.Short:                      {                          short v;                          if (short.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;                  case ElementValueType.Byte:                      {                          byte v;                          if (byte.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;                  case ElementValueType.FormID:                      {                          uint v;                          if (uint.TryParse(strvalue' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;                  case ElementValueType.Blob:                      {                          return false; // no support yet                      }                    case ElementValueType.LString:                      {                          uint v;                          this.value = uint.TryParse(strvalue' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out v) ? (object)v : strvalue;                          return true;                      }                    case ElementValueType.UShort:                      {                          ushort v;                          if (ushort.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;                  case ElementValueType.UInt:                      {                          uint v;                          if (uint.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;                  case ElementValueType.SByte:                      {                          uint v;                          if (uint.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              this.value = v;                              return true;                          }                      }                        break;              }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (this.Structure.type)              {                  case ElementValueType.String:                      {                          var str1 = Extensions.CastValue<string>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(str1 + Extensions.CastValue<string>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }                      }                        break;                    case ElementValueType.FormID:                      {                          if (this.Value is uint && val is uint)                          {                              var u1 = (uint)this.Value;                              var u2 = (uint)val;                              switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<uint>(u2);                                  case ElementAssignmentType.Add:                                      return this.AssignValue<uint>(u1 + u2);                                  case ElementAssignmentType.Subtract:                                      return this.AssignValue<uint>(u1 - u2);                                  case ElementAssignmentType.Multiply:                                      return this.AssignValue<uint>(u1 * u2);                                  case ElementAssignmentType.Divide:                                      return this.AssignValue<uint>(u1 / u2);                                  case ElementAssignmentType.BitAnd:                                      return this.AssignValue<uint>(u1 & u2);                                  case ElementAssignmentType.BitOr:                                      return this.AssignValue<uint>(u1 | u2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<uint>(default(uint));                              }                          }                      }                        break;                    case ElementValueType.Blob:                      break;                    case ElementValueType.LString:                      if (this.Value is string && val is string)                      {                          var s1 = (string)this.Value;                          var s2 = (string)val;                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(s2);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(s1 + s2);                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }                      }                        break;                    case ElementValueType.BString:                  case ElementValueType.IString:                      break;                    case ElementValueType.Str4:                      {                          var str2 = Extensions.CastValue<string>(val);                          if (this.Data.Count == 4 && str2.Length == 4)                          {                              switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<string>(str2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<string>("    ");                              }                          }                      }                        break;                  case ElementValueType.Float:                      {                          var val1 = Extensions.CastValue<float>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<float>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<float>(val1 + Extensions.CastValue<float>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<float>(val1 - Extensions.CastValue<float>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<float>(val1 * Extensions.CastValue<float>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<float>(val1 / Extensions.CastValue<float>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<float>(default(float));                          }                      }                        break;                  case ElementValueType.Int:                      {                          var val1 = Extensions.CastValue<int>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<int>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<int>(val1 + Extensions.CastValue<int>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<int>(val1 - Extensions.CastValue<int>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<int>(val1 * Extensions.CastValue<int>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<int>(val1 / Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<int>(val1 & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<int>(val1 | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<int>(default(int));                          }                      }                        break;                  case ElementValueType.Short:                      {                          var val1 = Extensions.CastValue<short>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<short>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<short>(val1 + Extensions.CastValue<short>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<short>(val1 - Extensions.CastValue<short>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<short>(val1 * Extensions.CastValue<short>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<short>(val1 / Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<short>(val1 & Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<short>(val1 | Extensions.CastValue<short>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<short>(default(short));                          }                      }                        break;                  case ElementValueType.Byte:                      {                          var val1 = Extensions.CastValue<byte>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<byte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<byte>(val1 + Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<byte>(val1 - Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<byte>(val1 * Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<byte>(val1 / Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<byte>(val1 & Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<byte>(val1 | Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<byte>(default(byte));                          }                      }                        break;                  case ElementValueType.UShort:                      {                          var val1 = Extensions.CastValue<ushort>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<ushort>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<ushort>(val1 + Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<ushort>(val1 - Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<ushort>(val1 * Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<ushort>(val1 / Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<ushort>(val1 & Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<ushort>(val1 | Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<ushort>(default(ushort));                          }                      }                        break;                  case ElementValueType.UInt:                      {                          var val1 = Extensions.CastValue<uint>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<uint>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<uint>(val1 + Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<uint>(val1 - Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<uint>(val1 * Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<uint>(val1 / Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<uint>(val1 & Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<uint>(val1 | Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<uint>(default(uint));                          }                      }                        break;                  case ElementValueType.SByte:                      {                          var val1 = Extensions.CastValue<sbyte>(this.Value);                          switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<sbyte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<sbyte>(val1 + Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<sbyte>(val1 - Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<sbyte>(val1 * Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<sbyte>(val1 / Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<sbyte>(val1 & Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<sbyte>(val1 | Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<sbyte>(default(sbyte));                          }                      }                        break;              }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(str1 + Extensions.CastValue<string>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<uint>(u2);                                  case ElementAssignmentType.Add:                                      return this.AssignValue<uint>(u1 + u2);                                  case ElementAssignmentType.Subtract:                                      return this.AssignValue<uint>(u1 - u2);                                  case ElementAssignmentType.Multiply:                                      return this.AssignValue<uint>(u1 * u2);                                  case ElementAssignmentType.Divide:                                      return this.AssignValue<uint>(u1 / u2);                                  case ElementAssignmentType.BitAnd:                                      return this.AssignValue<uint>(u1 & u2);                                  case ElementAssignmentType.BitOr:                                      return this.AssignValue<uint>(u1 | u2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<uint>(default(uint));                              }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<string>(s2);                              case ElementAssignmentType.Add:                                  return this.AssignValue<string>(s1 + s2);                              case ElementAssignmentType.Clear:                                  return this.AssignValue<string>(default(string));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                              {                                  case ElementAssignmentType.Set:                                      return this.AssignValue<string>(str2);                                  case ElementAssignmentType.Clear:                                      return this.AssignValue<string>("    ");                              }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<float>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<float>(val1 + Extensions.CastValue<float>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<float>(val1 - Extensions.CastValue<float>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<float>(val1 * Extensions.CastValue<float>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<float>(val1 / Extensions.CastValue<float>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<float>(Extensions.CastValue<int>(val1) | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<float>(default(float));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<int>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<int>(val1 + Extensions.CastValue<int>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<int>(val1 - Extensions.CastValue<int>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<int>(val1 * Extensions.CastValue<int>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<int>(val1 / Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<int>(val1 & Extensions.CastValue<int>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<int>(val1 | Extensions.CastValue<int>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<int>(default(int));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<short>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<short>(val1 + Extensions.CastValue<short>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<short>(val1 - Extensions.CastValue<short>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<short>(val1 * Extensions.CastValue<short>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<short>(val1 / Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<short>(val1 & Extensions.CastValue<short>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<short>(val1 | Extensions.CastValue<short>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<short>(default(short));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<byte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<byte>(val1 + Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<byte>(val1 - Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<byte>(val1 * Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<byte>(val1 / Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<byte>(val1 & Extensions.CastValue<byte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<byte>(val1 | Extensions.CastValue<byte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<byte>(default(byte));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<ushort>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<ushort>(val1 + Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<ushort>(val1 - Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<ushort>(val1 * Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<ushort>(val1 / Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<ushort>(val1 & Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<ushort>(val1 | Extensions.CastValue<ushort>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<ushort>(default(ushort));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<uint>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<uint>(val1 + Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<uint>(val1 - Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<uint>(val1 * Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<uint>(val1 / Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<uint>(val1 & Extensions.CastValue<uint>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<uint>(val1 | Extensions.CastValue<uint>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<uint>(default(uint));                          }
Missing Default,TESVSnip.Domain.Model,Element,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType)                          {                              case ElementAssignmentType.Set:                                  return this.AssignValue<sbyte>(val);                              case ElementAssignmentType.Add:                                  return this.AssignValue<sbyte>(val1 + Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Subtract:                                  return this.AssignValue<sbyte>(val1 - Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Multiply:                                  return this.AssignValue<sbyte>(val1 * Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Divide:                                  return this.AssignValue<sbyte>(val1 / Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitAnd:                                  return this.AssignValue<sbyte>(val1 & Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.BitOr:                                  return this.AssignValue<sbyte>(val1 | Extensions.CastValue<sbyte>(val));                              case ElementAssignmentType.Clear:                                  return this.AssignValue<sbyte>(default(sbyte));                          }
Missing Default,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,The following switch statement is missing a default case: switch (format)                  {                      case LocalizedStringFormat.Base:                          while (data[start + len] != 0)                          {                              ++len;                          }                            break;                        case LocalizedStringFormat.DL:                      case LocalizedStringFormat.IL:                          len = BitConverter.ToInt32(data' start) - 1;                          start = start + sizeof(int);                          if (start + len > data.Length)                          {                              len = data.Length - start;                          }                            if (len < 0)                          {                              len = 0;                          }                            break;                  }
Missing Default,TESVSnip.Domain.Model,Plugin,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,The following switch statement is missing a default case: switch (format)                      {                          case LocalizedStringFormat.Base:                              memWriter.Write(data' 0' data.Length);                              memWriter.Write((byte)0);                              break;                            case LocalizedStringFormat.DL:                          case LocalizedStringFormat.IL:                              memWriter.Write(data.Length + 1);                              memWriter.Write(data' 0' data.Length);                              memWriter.Write((byte)0);                              break;                      }
Missing Default,TESVSnip.Domain.Model,SearchCriteriaSettings,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchCriteriaSettings.cs,GetDisplayString,The following switch statement is missing a default case: switch (type)              {                  case SearchCondRecordType.Exists:                      return "Exists";                  case SearchCondRecordType.Missing:                      return "Missing";              }
Missing Default,TESVSnip.Domain.Model,SearchCriteriaSettings,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchCriteriaSettings.cs,GetFormatString,The following switch statement is missing a default case: switch (type)              {                  case SearchCondElementType.Equal:                      return "{0} = {1}";                  case SearchCondElementType.Not:                      return "Not {0}";                  case SearchCondElementType.Greater:                      return "{0} > {1}";                  case SearchCondElementType.Less:                      return "{0} < {1}";                  case SearchCondElementType.GreaterEqual:                      return "{0} >= {1}";                  case SearchCondElementType.LessEqual:                      return "{0} <= {1}";                  case SearchCondElementType.StartsWith:                      return "{0} like '{1}%'";                  case SearchCondElementType.EndsWith:                      return "{0} like '%{1}'";                  case SearchCondElementType.Contains:                      return "{0} like '%{1}%'";                  case SearchCondElementType.Exists:                      return "{0} Exists";                  case SearchCondElementType.Missing:                      return "{0} Missing";              }
Missing Default,TESVSnip.Domain.Model,SearchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchElement.cs,Match,The following switch statement is missing a default case: switch (this.Type)              {                  case SearchCondElementType.Equal:                      return diff == 0;                  case SearchCondElementType.Not:                      return diff != 0;                  case SearchCondElementType.Greater:                      return diff > 0;                  case SearchCondElementType.Less:                      return diff < 0;                  case SearchCondElementType.GreaterEqual:                      return diff >= 0;                  case SearchCondElementType.LessEqual:                      return diff <= 0;                  case SearchCondElementType.StartsWith:                      if (diff == 0)                      {                          return true;                      }                        if (value != null && this.Value != null)                      {                          return value.ToString().StartsWith(this.Value.ToString()' StringComparison.CurrentCultureIgnoreCase);                      }                        break;                  case SearchCondElementType.EndsWith:                      if (diff == 0)                      {                          return true;                      }                        if (value != null && this.Value != null)                      {                          return value.ToString().EndsWith(this.Value.ToString()' StringComparison.CurrentCultureIgnoreCase);                      }                        break;                  case SearchCondElementType.Contains:                      if (diff == 0)                      {                          return true;                      }                        if (value != null && this.Value != null)                      {                          return value.ToString().IndexOf(this.Value.ToString()' StringComparison.CurrentCultureIgnoreCase) >= 0;                      }                        break;              }
Missing Default,TESVSnip.Domain.Model,SearchElement,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,The following switch statement is missing a default case: switch (this.Record.type)              {                  case ElementValueType.String:                  case ElementValueType.BString:                  case ElementValueType.IString:                  case ElementValueType.Str4:                      return true;                  case ElementValueType.Float:                      {                          float v;                          if (float.TryParse(strvalue' NumberStyles.Any' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;                  case ElementValueType.Int:                      {                          int v;                          if (int.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;                  case ElementValueType.Short:                      {                          short v;                          if (short.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;                  case ElementValueType.Byte:                      {                          byte v;                          if (byte.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;                  case ElementValueType.FormID:                      {                          uint v;                          if (uint.TryParse(strvalue' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;                  case ElementValueType.Blob:                      {                          return false; // no support yet                      }                    case ElementValueType.LString:                      {                          return true;                      }                    case ElementValueType.UShort:                      {                          ushort v;                          if (ushort.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;                  case ElementValueType.UInt:                      {                          uint v;                          if (uint.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;                  case ElementValueType.SByte:                      {                          uint v;                          if (uint.TryParse(numText' numStyle' CultureInfo.CurrentCulture' out v))                          {                              return true;                          }                      }                        break;              }
Missing Default,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following switch statement is missing a default case: switch (elem.type)                              {                                  case ElementValueType.FormID:                                  case ElementValueType.LString:                                  case ElementValueType.Int:                                  case ElementValueType.UInt:                                  case ElementValueType.Float:                                  case ElementValueType.Str4:                                  case ElementValueType.IString:                                      size += 4;                                      break;                                  case ElementValueType.BString:                                  case ElementValueType.Short:                                  case ElementValueType.UShort:                                      size += 2;                                      break;                                  case ElementValueType.String:                                  case ElementValueType.Byte:                                  case ElementValueType.SByte:                                      size += 1;                                      break;                              }
Missing Default,TESVSnip.Domain.Model,SubRecord,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Model\SubRecord.cs,GetCompareValue,The following switch statement is missing a default case: switch (se.Structure.type)              {                  case ElementValueType.LString:                      if (value is uint)                      {                          var p = this.GetPlugin();                          if (p != null)                          {                              value = p.LookupFormStrings((uint) value) ?? value;                          }                      }                        break;              }
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (pyFunc.Parameters[i + 3]) //+2 jump self' element and value parameter                          {                              case "float":                                  param[i] = float.Parse(parameters[i]' _ni);                                  break;                              case "int":                                  param[i] = int.Parse(parameters[i]' _ni);                                  break;                              case "short":                                  param[i] = short.Parse(parameters[i]' _ni);                                  break;                              case "uint":                                  param[i] = uint.Parse(parameters[i]' _ni);                                  break;                              case "ushort":                                  param[i] = ushort.Parse(parameters[i]' _ni);                                  break;                          }
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (elemt.Type)                  {                      case ElementValueType.Float:                          result = _objOps.Invoke(function' el' (float) elemt.Value' param);                          break;                      case ElementValueType.Int:                          result = _objOps.Invoke(function' el' (int)elemt.Value' param);                          break;                      case ElementValueType.Short:                          result = _objOps.Invoke(function' el' (short)elemt.Value' param);                          break;                      case ElementValueType.UInt:                          result = _objOps.Invoke(function' el' (uint)elemt.Value' param);                          break;                      case ElementValueType.UShort:                          result = _objOps.Invoke(function' el' (ushort)elemt.Value' param);                          break;                  }
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (pyFunc.Parameters[i + 3]) //+2 jump self' element and value parameter                              {                                  case "float":                                      param[i] = float.Parse(parameters[i]' _ni);                                      break;                                  case "int":                                      param[i] = int.Parse(parameters[i]' _ni);                                      break;                                  case "short":                                      param[i] = short.Parse(parameters[i]' _ni);                                      break;                                  case "uint":                                      param[i] = uint.Parse(parameters[i]' _ni);                                      break;                                  case "ushort":                                      param[i] = ushort.Parse(parameters[i]' _ni);                                      break;                              }
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (elemt.type)                  {                      case ElementValueType.Float:                          result = _objOps.Invoke(function' el' (float)value' param);                          break;                      case ElementValueType.Int:                          result = _objOps.Invoke(function' el' (int)value' param);                          break;                      case ElementValueType.Short:                          result = _objOps.Invoke(function' el' (short)value' param);                          break;                      case ElementValueType.UInt:                          result = _objOps.Invoke(function' el' (uint)value' param);                          break;                      case ElementValueType.UShort:                          result = _objOps.Invoke(function' el' (ushort)value' param);                          break;                  }
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following switch statement is missing a default case: switch (vt.type)                          {                              case VarType.Int:                                  if (fs.args[argcount - 1] != VarType.Float && fs.args[argcount - 1] != VarType.Int)                                  {                                      AddError("Invalid argument " + i + " to function. Expected " + fs.args[argcount - 1].ToString());                                  }                                    EmitByte(0x73);                                  Emit((ushort)locals[smt[i].token].index);                                  break;                              case VarType.Float:                                  if (fs.args[argcount - 1] != VarType.Float && fs.args[argcount - 1] != VarType.Int)                                  {                                      AddError("Invalid argument " + i + " to function. Expected " + fs.args[argcount - 1].ToString());                                  }                                    EmitByte(0x66);                                  Emit((ushort)locals[smt[i].token].index);                                  break;                              case VarType.Ref:                                  if (fs.args[argcount - 1] != VarType.Ref)                                  {                                      AddError("Invalid argument " + i + " to function. Expected " + fs.args[argcount - 1].ToString());                                  }                                    EmitRefLabel(smt[i]' RefType.Expression);                                  break;                          }
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitRefLabel,The following switch statement is missing a default case: switch (type)                  {                      case RefType.Standard:                          Emit(0x1c);                          break;                      case RefType.Expression:                          EmitByte(0x72);                          break;                      case RefType.Standalone:                          EmitByte(0x5a);                          break;                  }
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following switch statement is missing a default case: switch (vt.type)                              {                                  case VarType.Int:                                      EmitByte(0x73);                                      Emit((ushort)locals[smt[i].token].index);                                      break;                                  case VarType.Float:                                      EmitByte(0x66);                                      Emit((ushort)locals[smt[i].token].index);                                      break;                                  case VarType.Ref:                                      EmitRefLabel(smt[i]' RefType.Expression);                                      break;                              }
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following switch statement is missing a default case: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,D:\research\architectureSmells\repos\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following switch statement is missing a default case: switch (smt[0].keyword)                      {                          case Keywords.If:                              {                                  for (int i = 0; i < opcodecount.Count; i++)                                  {                                      opcodecount[i] += 1;                                  }                                    Emit(0x16);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                                  break;                              }                            case Keywords.ElseIf:                              if (flowControl.Count == 0)                              {                                  AddError("elseif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                              {                                  Emit(0x18);                                  long pos2 = bw.BaseStream.Length;                                  Emit(0);                                  flowControl.Push(bw.BaseStream.Length);                                  Emit(0);                                  EmitExpression(TrimStatement(smt' 1)' ExpressionType.If);                                  bw.BaseStream.Position = pos2;                                  Emit((ushort)(bw.BaseStream.Length - (pos2 + 2)));                                  bw.BaseStream.Position = bw.BaseStream.Length;                                  opcodecount.Add(0);                              }                                break;                          case Keywords.Else:                              if (flowControl.Count == 0)                              {                                  AddError("else without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                Emit(0x17);                              Emit(2);                              flowControl.Push(bw.BaseStream.Length);                              Emit(0);                              opcodecount.Add(0);                              break;                          case Keywords.EndIf:                              Emit(0x19);                              Emit(0);                              if (flowControl.Count == 0)                              {                                  AddError("endif without matching if");                              }                              else                              {                                  bw.BaseStream.Position = flowControl.Pop();                                  Emit(opcodecount[opcodecount.Count - 1]);                                  opcodecount.RemoveAt(opcodecount.Count - 1);                                  bw.BaseStream.Position = bw.BaseStream.Length;                              }                                for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                          case Keywords.Return:                              Emit(0x1e);                              Emit(0);                              for (int i = 0; i < opcodecount.Count; i++)                              {                                  opcodecount[i] += 1;                              }                                break;                      }
