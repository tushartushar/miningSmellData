Implementation smell,Namespace,Class,File,Method,Description
Long Method,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The method has 103 lines of code.
Long Method,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The method has 157 lines of code.
Long Method,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The method has 237 lines of code.
Long Method,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,The method has 115 lines of code.
Long Method,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The method has 124 lines of code.
Long Method,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The method has 110 lines of code.
Long Method,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The method has 122 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The method has 100 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The method has 206 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The method has 102 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The method has 118 lines of code.
Long Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The method has 105 lines of code.
Long Method,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,The method has 147 lines of code.
Complex Method,TESVSnip.Domain.Data.Structure,ElementStructure,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementStructure.cs,ElementStructure,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Data.Structure,SubrecordStructure,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\SubrecordStructure.cs,GetElementArray,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,Cyclomatic complexity of the method is 17
Complex Method,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,SanitizePlugin,Cyclomatic complexity of the method is 16
Complex Method,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,Cyclomatic complexity of the method is 10
Complex Method,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,Cyclomatic complexity of the method is 10
Complex Method,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,Cyclomatic complexity of the method is 14
Complex Method,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,Cyclomatic complexity of the method is 15
Complex Method,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,CopyRecordsTo,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,Cyclomatic complexity of the method is 43
Complex Method,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,Evaluate,Cyclomatic complexity of the method is 15
Complex Method,TESVSnip.Domain.Model,BatchSubrecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchSubrecord.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,Cyclomatic complexity of the method is 73
Complex Method,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,Cyclomatic complexity of the method is 102
Complex Method,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,ReloadStrings,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,Save,Cyclomatic complexity of the method is 10
Complex Method,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,Cyclomatic complexity of the method is 13
Complex Method,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,Cyclomatic complexity of the method is 19
Complex Method,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,Cyclomatic complexity of the method is 18
Complex Method,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,Cyclomatic complexity of the method is 49
Complex Method,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,InnerLoop,Cyclomatic complexity of the method is 17
Complex Method,TESVSnip.Domain.Model,SearchCriteriaSettings,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchCriteriaSettings.cs,GetFormatString,Cyclomatic complexity of the method is 11
Complex Method,TESVSnip.Domain.Model,SearchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchElement.cs,Match,Cyclomatic complexity of the method is 27
Complex Method,TESVSnip.Domain.Model,SearchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,Cyclomatic complexity of the method is 42
Complex Method,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,Cyclomatic complexity of the method is 23
Complex Method,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,EnumerateElements,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,Cyclomatic complexity of the method is 53
Complex Method,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,LoadAllPrototypeFunction,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,Cyclomatic complexity of the method is 44
Complex Method,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,Cyclomatic complexity of the method is 36
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,Cyclomatic complexity of the method is 14
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,Cyclomatic complexity of the method is 25
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,Cyclomatic complexity of the method is 19
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpression2,Cyclomatic complexity of the method is 18
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpressionValue,Cyclomatic complexity of the method is 43
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,Cyclomatic complexity of the method is 70
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitRefLabel,Cyclomatic complexity of the method is 15
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,Cyclomatic complexity of the method is 41
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,Cyclomatic complexity of the method is 42
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,Cyclomatic complexity of the method is 40
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,Cyclomatic complexity of the method is 16
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,Cyclomatic complexity of the method is 14
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,Cyclomatic complexity of the method is 12
Complex Method,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,Cyclomatic complexity of the method is 9
Complex Method,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,Cyclomatic complexity of the method is 52
Long Parameter List,TESVSnip.Domain.Services,CompressHelper,F:\newReposMay17\figment_tesvsnip\Domain\Services\Compressor.cs,Decompress,The method has 5 parameters.
Long Parameter List,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,Element,The method has 5 parameters.
Long Parameter List,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The method has 5 parameters.
Long Parameter List,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The method has 5 parameters.
Long Parameter List,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,EnumerateElements,The method has 5 parameters.
Long Parameter List,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The method has 6 parameters.
Long Statement,TESVSnip.Domain.Data,DomainDefinition,F:\newReposMay17\figment_tesvsnip\Domain\Data\DomainDefinition.cs,DetectDefinitionFromVersion,The length of the statement  "	foreach (var domain in Domains.Values.Where (domain => type == domain.HEDRType && Math.Abs (version - domain.HEDRVersion) < EPSILON)) { " is 135.
Long Statement,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The length of the statement  "	// uint maxid = plugin.Masters.Max(x=>x.Strings.Count > 0 ? x.Strings.Keys.Max() : 0); // No need to check the masters string since the numbers are unique for every plugin " is 171.
Long Statement,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The length of the statement  "							// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin " is 182.
Long Statement,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The length of the statement  "		var ids = rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID).Select (elem => TypeConverter.h2i (elem.Data)).Distinct ().ToList (); " is 226.
Long Statement,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,Clone,The length of the statement  "		foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) { " is 170.
Long Statement,TESVSnip.Domain.Services,Compressor,F:\newReposMay17\figment_tesvsnip\Domain\Services\Compressor.cs,Init,The length of the statement  "	autoCompRecList = new HashSet<string> (Properties.Settings.Default.AutoCompressRecords != null ? Properties.Settings.Default.AutoCompressRecords.Trim ().Split (new[] { " is 167.
Long Statement,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The length of the statement  "		this.value = uint.TryParse (strvalue' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out v) ? (object)v : strvalue; " is 120.
Long Statement,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,Evaluate,The length of the statement  "	foreach (bool value in r.SubRecords.Where (x => x.Name == this.Parent.Record.name).Select (x => this.Evaluate (r' x))) { " is 120.
Long Statement,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,Evaluate,The length of the statement  "	foreach (bool value in sr.EnumerateElements ().Where (x => x.Structure.name == this.Record.name).Select (x => this.Evaluate (r' sr' x))) { " is 138.
Long Statement,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,ToString,The length of the statement  "	return string.Format ("[Element] {0} '{1}' = {2}"' this.Type' this.Structure != null ? this.Structure.desc : ""' this.Value); " is 125.
Long Statement,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,AddRecord,The length of the statement  "			throw new TESParserException ("Record to add was not of the correct type." + Environment.NewLine + "Groups can only hold records or other groups."); " is 148.
Long Statement,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,AddRecords,The length of the statement  "		throw new TESParserException ("Record to add was not of the correct type.\nGroups can only hold records or other groups."); " is 123.
Long Statement,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,DeleteRecords,The length of the statement  "		throw new TESParserException ("Record to delete was not of the correct type.\nGroups can only hold records or other groups."); " is 126.
Long Statement,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,InsertRecord,The length of the statement  "		throw new TESParserException ("Record to add was not of the correct type." + Environment.NewLine + "Groups can only hold records or other groups."); " is 148.
Long Statement,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,InsertRecords,The length of the statement  "		throw new TESParserException ("Record to add was not of the correct type.\nGroups can only hold records or other groups."); " is 123.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The length of the statement  "	foreach (var rec in EnumerateRecords (null).Select (x => x.Value).SkipWhile (x => RecordLayout.NoNewCopyTypes.Contains (x.Name))) { " is 131.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The length of the statement  "		foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) { " is 170.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddRecord,The length of the statement  "			throw new TESParserException ("Record to add was not of the correct type." + Environment.NewLine + "PluginList can only hold Groups or Records."); " is 146.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddRecords,The length of the statement  "			throw new TESParserException ("Record to add was not of the correct type.\nPlugins can only hold records or other groups."); " is 124.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,DeleteRecords,The length of the statement  "		throw new TESParserException ("Record to delete was not of the correct type.\nPlugins can only hold records or other groups."); " is 127.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,InsertRecord,The length of the statement  "		throw new TESParserException ("Record to add was not of the correct type." + Environment.NewLine + "PluginList can only hold Groups or Records."); " is 146.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,InsertRecords,The length of the statement  "		throw new TESParserException ("Record to add was not of the correct type.\nPlugins can only hold records or other groups."); " is 124.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,ReloadStrings,The length of the statement  "	if (string.IsNullOrEmpty (this.StringsFolder) || string.IsNullOrEmpty (this.FileName) || !Directory.Exists (this.StringsFolder)) { " is 130.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetRecordList,The length of the statement  "	Predicate<BaseRecord> itr = rec => (rec is Plugin) || (rec is GroupRecord && (((GroupRecord)rec).groupType != 0 || vtypes.Contains (((GroupRecord)rec).ContentsType))) || (rec is Record && vtypes.Contains (rec.Name)); " is 216.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,Save,The length of the statement  "			string prefix = Path.Combine (Path.Combine (Path.GetDirectoryName (filePath)' "Strings")' Path.GetFileNameWithoutExtension (filePath)); " is 135.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The length of the statement  "				var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max (); " is 200.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,DetectVersion,The length of the statement  "		foreach (var domain in DomainDefinition.AllDomains ().Where (domain => string.Compare (domain.Master' Path.GetFileName (fileName)' StringComparison.InvariantCultureIgnoreCase) == 0)) { " is 184.
Long Statement,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The length of the statement  "			throw new Exception (string.Format ("File is not a valid {0} plugin (Missing HEDR subrecord in the {1} record)"' define.Name' define.HEDRType)); " is 144.
Long Statement,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,AddRecord,The length of the statement  "		throw new TESParserException ("Record to add was not of the correct type." + Environment.NewLine + "Records can only hold Subrecords."); " is 136.
Long Statement,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,InsertRecord,The length of the statement  "		throw new TESParserException ("Record to add was not of the correct type." + Environment.NewLine + "Records can only hold Subrecords."); " is 136.
Long Statement,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The length of the statement  "				desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f)); " is 133.
Long Statement,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The length of the statement  "				desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f)); " is 133.
Long Statement,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The length of the statement  "			compressed = ((this.Flags1 & 0x00040000) != 0) || (Properties.Settings.Default.EnableAutoCompress && Compressor.CompressRecord (Name)) || (Properties.Settings.Default.EnableCompressionLimit && (realSize >= Properties.Settings.Default.CompressionLimit)); " is 253.
Long Statement,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The length of the statement  "		Debug.WriteLineIf (this.dataSize != dataSize' string.Format ("COMPRESSED RECORD [NAME={0} AT POSITION={1}] SIZE DIFFERS FROM ORIGINAL: ORIGINAL={2} ACTUAL={3}' RAW RECORD SIZE={4}"' Name' position' this.dataSize' dataSize' realSize)); " is 234.
Long Statement,TESVSnip.Domain.Model,SearchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchElement.cs,Match,The length of the statement  "	foreach (bool value in sr.EnumerateElements ().Where (x => x.Structure.name == this.Record.name).Select (x => this.Match (r' sr' x))) { " is 135.
Long Statement,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,ToString,The length of the statement  "	return string.Format ("[SubRecord] {0} [{1}]: {2} "' this.Name' this.Size' this.Structure != null ? this.Structure.desc : ""); " is 126.
Long Statement,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpressionValue,The length of the statement  "		// if(fs.requiredArgs!=fs.args.Length) throw new ExpressionParseException("functions with variable argument count cannot be used in expressions"); " is 146.
Long Statement,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpressionValue,The length of the statement  "		// if(fs.ret==VarType.None) throw new ExpressionParseException("Functions with no return type cannot be used in expressions"); " is 126.
Long Statement,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The length of the statement  "					Enum [n3.Attributes.GetNamedItem ("name").Value.ToLowerInvariant ()] = ushort.Parse (n3.Attributes.GetNamedItem ("value").Value); " is 129.
Long Statement,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,FromWord,The length of the statement  "	if (char.IsDigit (token [0]) || (token.Length > 1 && (token [0] == '.' || token [0] == '-') && char.IsDigit (token [1]))) { " is 123.
Complex Conditional,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The conditional expression  "tes4 != null && tes4.SubRecords.Count > 0 && tes4.SubRecords [0].Name == "HEDR" && tes4.SubRecords [0].Size >= 8"  is complex.
Complex Conditional,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,FromWord,The conditional expression  "char.IsDigit (token [0]) || (token.Length > 1 && (token [0] == '.' || token [0] == '-') && char.IsDigit (token [1]))"  is complex.
Complex Conditional,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,The conditional expression  "char.IsLetterOrDigit (c) || c == '_' || ((c == '.' || c == '~') && char.IsDigit (this.SafePeek ()))"  is complex.
Complex Conditional,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,PopTokenInternal2,The conditional expression  "char.IsLetterOrDigit (c) || c == '_' || (numeric && c == '.')"  is complex.
Empty Catch Block,TESVSnip.Domain.Services,CompressHelper,F:\newReposMay17\figment_tesvsnip\Domain\Services\Compressor.cs,CompressHelper,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordStructureToRecord,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,SearchCriteriaList,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchCriteriaList.cs,Deserialize,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,SearchCriteriaList,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchCriteriaList.cs,Serialize,The method has an empty catch block.
Empty Catch Block,TESVSnip.Domain.Model,SearchCriteriaList,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchCriteriaList.cs,Serialize,The method has an empty catch block.
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: if (src.name.StartsWith ("&#x")) {  	string[] val = src.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = src.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: if (src.name.StartsWith ("&#x")) {  	string[] val = src.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = src.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,ElementBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementBase.cs,ElementBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: if (src.name.StartsWith ("&#x")) {  	string[] val = src.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = src.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: if (src.name.StartsWith ("&#x")) {  	string[] val = src.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = src.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Data.Structure,SubrecordBase,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\SubrecordBase.cs,SubrecordBase,The following statement contains a magic number: if (node.name.StartsWith ("&#x")) {  	string[] val = node.name.Split (new[] {  		';'  	}' 2' StringSplitOptions.None);  	var c = (char)int.Parse (val [0].Substring (3)' NumberStyles.HexNumber' null);  	this.name = c + val [1];  } else {  	this.name = node.name;  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	foreach (var sr in record.SubRecords) {  		var elements = record.EnumerateElements (sr' rawData: true).ToList ();  		foreach (var elem in elements) {  			if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  				var data = elem.Data;  				uint id = TypeConverter.h2i (data);  				if (id == 0) {  					continue;  				}  				if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  					string str;  					if (plugin.Strings.TryGetValue (id' out str)) {  						continue;  					}  				}  				if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  					string value = TypeConverter.GetString (data);  					if (!string.IsNullOrEmpty (value)) {  						// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  						uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  						int idx = plugin.Strings.FindValue (value);  						if (idx >= 0) {  							nextid = plugin.Strings.ElementAt (idx).Key;  						} else {  							plugin.Strings [nextid] = value;  						}  						elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  						++count;  					}  				}  			}  		}  		if (elements.Any (x => x.Changed)) {  			// need to repack the structure  			using (var ms = new MemoryStream (sr.GetReadonlyData ().Length)) {  				foreach (var seg in elements.Select (elem => elem.Data)) {  					ms.Write (seg.Array' seg.Offset' seg.Count);  				}  				sr.SetData (ms.ToArray ());  			}  			anyModified = true;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	foreach (var sr in record.SubRecords) {  		var elements = record.EnumerateElements (sr' rawData: true).ToList ();  		foreach (var elem in elements) {  			if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  				var data = elem.Data;  				uint id = TypeConverter.h2i (data);  				if (id == 0) {  					continue;  				}  				if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  					string str;  					if (plugin.Strings.TryGetValue (id' out str)) {  						continue;  					}  				}  				if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  					string value = TypeConverter.GetString (data);  					if (!string.IsNullOrEmpty (value)) {  						// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  						uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  						int idx = plugin.Strings.FindValue (value);  						if (idx >= 0) {  							nextid = plugin.Strings.ElementAt (idx).Key;  						} else {  							plugin.Strings [nextid] = value;  						}  						elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  						++count;  					}  				}  			}  		}  		if (elements.Any (x => x.Changed)) {  			// need to repack the structure  			using (var ms = new MemoryStream (sr.GetReadonlyData ().Length)) {  				foreach (var seg in elements.Select (elem => elem.Data)) {  					ms.Write (seg.Array' seg.Offset' seg.Count);  				}  				sr.SetData (ms.ToArray ());  			}  			anyModified = true;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: foreach (var sr in record.SubRecords) {  	var elements = record.EnumerateElements (sr' rawData: true).ToList ();  	foreach (var elem in elements) {  		if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  			var data = elem.Data;  			uint id = TypeConverter.h2i (data);  			if (id == 0) {  				continue;  			}  			if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  				string str;  				if (plugin.Strings.TryGetValue (id' out str)) {  					continue;  				}  			}  			if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  				string value = TypeConverter.GetString (data);  				if (!string.IsNullOrEmpty (value)) {  					// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  					uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  					int idx = plugin.Strings.FindValue (value);  					if (idx >= 0) {  						nextid = plugin.Strings.ElementAt (idx).Key;  					} else {  						plugin.Strings [nextid] = value;  					}  					elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  					++count;  				}  			}  		}  	}  	if (elements.Any (x => x.Changed)) {  		// need to repack the structure  		using (var ms = new MemoryStream (sr.GetReadonlyData ().Length)) {  			foreach (var seg in elements.Select (elem => elem.Data)) {  				ms.Write (seg.Array' seg.Offset' seg.Count);  			}  			sr.SetData (ms.ToArray ());  		}  		anyModified = true;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: foreach (var sr in record.SubRecords) {  	var elements = record.EnumerateElements (sr' rawData: true).ToList ();  	foreach (var elem in elements) {  		if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  			var data = elem.Data;  			uint id = TypeConverter.h2i (data);  			if (id == 0) {  				continue;  			}  			if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  				string str;  				if (plugin.Strings.TryGetValue (id' out str)) {  					continue;  				}  			}  			if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  				string value = TypeConverter.GetString (data);  				if (!string.IsNullOrEmpty (value)) {  					// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  					uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  					int idx = plugin.Strings.FindValue (value);  					if (idx >= 0) {  						nextid = plugin.Strings.ElementAt (idx).Key;  					} else {  						plugin.Strings [nextid] = value;  					}  					elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  					++count;  				}  			}  		}  	}  	if (elements.Any (x => x.Changed)) {  		// need to repack the structure  		using (var ms = new MemoryStream (sr.GetReadonlyData ().Length)) {  			foreach (var seg in elements.Select (elem => elem.Data)) {  				ms.Write (seg.Array' seg.Offset' seg.Count);  			}  			sr.SetData (ms.ToArray ());  		}  		anyModified = true;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: foreach (var elem in elements) {  	if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  		var data = elem.Data;  		uint id = TypeConverter.h2i (data);  		if (id == 0) {  			continue;  		}  		if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  			string str;  			if (plugin.Strings.TryGetValue (id' out str)) {  				continue;  			}  		}  		if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  			string value = TypeConverter.GetString (data);  			if (!string.IsNullOrEmpty (value)) {  				// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  				uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  				int idx = plugin.Strings.FindValue (value);  				if (idx >= 0) {  					nextid = plugin.Strings.ElementAt (idx).Key;  				} else {  					plugin.Strings [nextid] = value;  				}  				elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  				++count;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: foreach (var elem in elements) {  	if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  		var data = elem.Data;  		uint id = TypeConverter.h2i (data);  		if (id == 0) {  			continue;  		}  		if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  			string str;  			if (plugin.Strings.TryGetValue (id' out str)) {  				continue;  			}  		}  		if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  			string value = TypeConverter.GetString (data);  			if (!string.IsNullOrEmpty (value)) {  				// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  				uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  				int idx = plugin.Strings.FindValue (value);  				if (idx >= 0) {  					nextid = plugin.Strings.ElementAt (idx).Key;  				} else {  					plugin.Strings [nextid] = value;  				}  				elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  				++count;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  	var data = elem.Data;  	uint id = TypeConverter.h2i (data);  	if (id == 0) {  		continue;  	}  	if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  		string str;  		if (plugin.Strings.TryGetValue (id' out str)) {  			continue;  		}  	}  	if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  		string value = TypeConverter.GetString (data);  		if (!string.IsNullOrEmpty (value)) {  			// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  			uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  			int idx = plugin.Strings.FindValue (value);  			if (idx >= 0) {  				nextid = plugin.Strings.ElementAt (idx).Key;  			} else {  				plugin.Strings [nextid] = value;  			}  			elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  			++count;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  	var data = elem.Data;  	uint id = TypeConverter.h2i (data);  	if (id == 0) {  		continue;  	}  	if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  		string str;  		if (plugin.Strings.TryGetValue (id' out str)) {  			continue;  		}  	}  	if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  		string value = TypeConverter.GetString (data);  		if (!string.IsNullOrEmpty (value)) {  			// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  			uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  			int idx = plugin.Strings.FindValue (value);  			if (idx >= 0) {  				nextid = plugin.Strings.ElementAt (idx).Key;  			} else {  				plugin.Strings [nextid] = value;  			}  			elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  			++count;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: if (data.Count == 4 && TypeConverter.IsLikelyString (data)) {  	string str;  	if (plugin.Strings.TryGetValue (id' out str)) {  		continue;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ExtractInternalStrings,The following statement contains a magic number: if (data.Count != 4 || TypeConverter.IsLikelyString (data)) {  	string value = TypeConverter.GetString (data);  	if (!string.IsNullOrEmpty (value)) {  		// uint nextid = Math.Max(maxid' plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max()) + 1; // No need to check the masters strings since the numbers are unique for every plugin  		uint nextid = (plugin.Strings.Count == 0 ? 0 : plugin.Strings.Keys.Max ()) + 1;  		int idx = plugin.Strings.FindValue (value);  		if (idx >= 0) {  			nextid = plugin.Strings.ElementAt (idx).Key;  		} else {  			plugin.Strings [nextid] = value;  		}  		elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> ((byte[])TypeConverter.i2h (nextid).Clone ()));  		++count;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0 && tes4.SubRecords [0].Name == "HEDR" && tes4.SubRecords [0].Size >= 8) {  	byte[] data = tes4.SubRecords [0].GetData ();  	var formid = (uint)TypeConverter.GetObject<uint> (data' 8);  	TypeConverter.i2h (formid + 1' data' 8);  	tes4.SubRecords [0].SetData (data);  	return formid;  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0 && tes4.SubRecords [0].Name == "HEDR" && tes4.SubRecords [0].Size >= 8) {  	byte[] data = tes4.SubRecords [0].GetData ();  	var formid = (uint)TypeConverter.GetObject<uint> (data' 8);  	TypeConverter.i2h (formid + 1' data' 8);  	tes4.SubRecords [0].SetData (data);  	return formid;  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0 && tes4.SubRecords [0].Name == "HEDR" && tes4.SubRecords [0].Size >= 8) {  	byte[] data = tes4.SubRecords [0].GetData ();  	var formid = (uint)TypeConverter.GetObject<uint> (data' 8);  	TypeConverter.i2h (formid + 1' data' 8);  	tes4.SubRecords [0].SetData (data);  	return formid;  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,getNextFormID,The following statement contains a magic number: TypeConverter.i2h (formid + 1' data' 8);  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	foreach (var sr in record.SubRecords) {  		var elements = record.EnumerateElements (sr' rawData: true).ToList ();  		foreach (var elem in elements) {  			if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  				var data = elem.Data;  				if (data.Count == 4) {  					string value;  					uint id = TypeConverter.h2i (data);  					if (id == 0) {  						continue;  					}  					if (oldStrings.TryGetValue (id' out value)) {  						oldStrings.Remove (id);  						plugin.Strings [id] = value;  					}  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,The following statement contains a magic number: foreach (var sr in record.SubRecords) {  	var elements = record.EnumerateElements (sr' rawData: true).ToList ();  	foreach (var elem in elements) {  		if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  			var data = elem.Data;  			if (data.Count == 4) {  				string value;  				uint id = TypeConverter.h2i (data);  				if (id == 0) {  					continue;  				}  				if (oldStrings.TryGetValue (id' out value)) {  					oldStrings.Remove (id);  					plugin.Strings [id] = value;  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,The following statement contains a magic number: foreach (var elem in elements) {  	if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  		var data = elem.Data;  		if (data.Count == 4) {  			string value;  			uint id = TypeConverter.h2i (data);  			if (id == 0) {  				continue;  			}  			if (oldStrings.TryGetValue (id' out value)) {  				oldStrings.Remove (id);  				plugin.Strings [id] = value;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,The following statement contains a magic number: if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  	var data = elem.Data;  	if (data.Count == 4) {  		string value;  		uint id = TypeConverter.h2i (data);  		if (id == 0) {  			continue;  		}  		if (oldStrings.TryGetValue (id' out value)) {  			oldStrings.Remove (id);  			plugin.Strings [id] = value;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CleanUnusedStrings,The following statement contains a magic number: if (data.Count == 4) {  	string value;  	uint id = TypeConverter.h2i (data);  	if (id == 0) {  		continue;  	}  	if (oldStrings.TryGetValue (id' out value)) {  		oldStrings.Remove (id);  		plugin.Strings [id] = value;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	foreach (var sr in record.SubRecords) {  		var elements = record.EnumerateElements (sr' rawData: true).ToList ();  		foreach (var elem in elements) {  			if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  				var data = elem.Data;  				if (data.Count == 4) {  					string value;  					uint id = TypeConverter.h2i (data);  					if (id == 0) {  						continue;  					}  					if (!plugin.Strings.TryGetValue (id' out value)) {  						foreach (var master in masters.Reverse ()) {  							if (master.Strings.TryGetValue (id' out value)) {  								++count;  								plugin.Strings [id] = value;  								break;  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,The following statement contains a magic number: foreach (var sr in record.SubRecords) {  	var elements = record.EnumerateElements (sr' rawData: true).ToList ();  	foreach (var elem in elements) {  		if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  			var data = elem.Data;  			if (data.Count == 4) {  				string value;  				uint id = TypeConverter.h2i (data);  				if (id == 0) {  					continue;  				}  				if (!plugin.Strings.TryGetValue (id' out value)) {  					foreach (var master in masters.Reverse ()) {  						if (master.Strings.TryGetValue (id' out value)) {  							++count;  							plugin.Strings [id] = value;  							break;  						}  					}  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,The following statement contains a magic number: foreach (var elem in elements) {  	if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  		var data = elem.Data;  		if (data.Count == 4) {  			string value;  			uint id = TypeConverter.h2i (data);  			if (id == 0) {  				continue;  			}  			if (!plugin.Strings.TryGetValue (id' out value)) {  				foreach (var master in masters.Reverse ()) {  					if (master.Strings.TryGetValue (id' out value)) {  						++count;  						plugin.Strings [id] = value;  						break;  					}  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,The following statement contains a magic number: if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  	var data = elem.Data;  	if (data.Count == 4) {  		string value;  		uint id = TypeConverter.h2i (data);  		if (id == 0) {  			continue;  		}  		if (!plugin.Strings.TryGetValue (id' out value)) {  			foreach (var master in masters.Reverse ()) {  				if (master.Strings.TryGetValue (id' out value)) {  					++count;  					plugin.Strings [id] = value;  					break;  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CopyMasterStringReferences,The following statement contains a magic number: if (data.Count == 4) {  	string value;  	uint id = TypeConverter.h2i (data);  	if (id == 0) {  		continue;  	}  	if (!plugin.Strings.TryGetValue (id' out value)) {  		foreach (var master in masters.Reverse ()) {  			if (master.Strings.TryGetValue (id' out value)) {  				++count;  				plugin.Strings [id] = value;  				break;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	foreach (var sr in record.SubRecords) {  		var elements = record.EnumerateElements (sr' rawData: true).ToList ();  		foreach (var elem in elements) {  			if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  				var data = elem.Data;  				if (data.Count == 4) {  					string value;  					uint id = TypeConverter.h2i (data);  					if (id == 0) {  						continue;  					}  					if (!plugin.Strings.TryGetValue (id' out value)) {  						value = string.Format ("STUB: {0} {1}"' record.DescriptiveName' sr.DescriptiveName);  						plugin.Strings [id] = value;  						++count;  					}  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,The following statement contains a magic number: foreach (var sr in record.SubRecords) {  	var elements = record.EnumerateElements (sr' rawData: true).ToList ();  	foreach (var elem in elements) {  		if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  			var data = elem.Data;  			if (data.Count == 4) {  				string value;  				uint id = TypeConverter.h2i (data);  				if (id == 0) {  					continue;  				}  				if (!plugin.Strings.TryGetValue (id' out value)) {  					value = string.Format ("STUB: {0} {1}"' record.DescriptiveName' sr.DescriptiveName);  					plugin.Strings [id] = value;  					++count;  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,The following statement contains a magic number: foreach (var elem in elements) {  	if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  		var data = elem.Data;  		if (data.Count == 4) {  			string value;  			uint id = TypeConverter.h2i (data);  			if (id == 0) {  				continue;  			}  			if (!plugin.Strings.TryGetValue (id' out value)) {  				value = string.Format ("STUB: {0} {1}"' record.DescriptiveName' sr.DescriptiveName);  				plugin.Strings [id] = value;  				++count;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,The following statement contains a magic number: if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  	var data = elem.Data;  	if (data.Count == 4) {  		string value;  		uint id = TypeConverter.h2i (data);  		if (id == 0) {  			continue;  		}  		if (!plugin.Strings.TryGetValue (id' out value)) {  			value = string.Format ("STUB: {0} {1}"' record.DescriptiveName' sr.DescriptiveName);  			plugin.Strings [id] = value;  			++count;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,CreateStringStubs,The following statement contains a magic number: if (data.Count == 4) {  	string value;  	uint id = TypeConverter.h2i (data);  	if (id == 0) {  		continue;  	}  	if (!plugin.Strings.TryGetValue (id' out value)) {  		value = string.Format ("STUB: {0} {1}"' record.DescriptiveName' sr.DescriptiveName);  		plugin.Strings [id] = value;  		++count;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	foreach (var sr in record.SubRecords) {  		var elements = record.EnumerateElements (sr' rawData: true).ToList ();  		foreach (var elem in elements) {  			if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  				var data = elem.Data;  				uint id = TypeConverter.h2i (data);  				if (id == 0) {  					continue;  				}  				if (data.Count == 4) {  					var str = plugin.LookupFormStrings (id);  					if (!string.IsNullOrEmpty (str)) {  						elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> (TypeConverter.str2h (str)));  						++count;  					}  				}  			}  		}  		if (elements.Any (x => x.Changed)) {  			// need to repack the structure  			using (var ms = new MemoryStream (sr.GetReadonlyData ().Length)) {  				foreach (var seg in elements.Select (elem => elem.Data)) {  					ms.Write (seg.Array' seg.Offset' seg.Count);  				}  				sr.SetData (ms.ToArray ());  			}  			anyModified = true;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,The following statement contains a magic number: foreach (var sr in record.SubRecords) {  	var elements = record.EnumerateElements (sr' rawData: true).ToList ();  	foreach (var elem in elements) {  		if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  			var data = elem.Data;  			uint id = TypeConverter.h2i (data);  			if (id == 0) {  				continue;  			}  			if (data.Count == 4) {  				var str = plugin.LookupFormStrings (id);  				if (!string.IsNullOrEmpty (str)) {  					elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> (TypeConverter.str2h (str)));  					++count;  				}  			}  		}  	}  	if (elements.Any (x => x.Changed)) {  		// need to repack the structure  		using (var ms = new MemoryStream (sr.GetReadonlyData ().Length)) {  			foreach (var seg in elements.Select (elem => elem.Data)) {  				ms.Write (seg.Array' seg.Offset' seg.Count);  			}  			sr.SetData (ms.ToArray ());  		}  		anyModified = true;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,The following statement contains a magic number: foreach (var elem in elements) {  	if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  		var data = elem.Data;  		uint id = TypeConverter.h2i (data);  		if (id == 0) {  			continue;  		}  		if (data.Count == 4) {  			var str = plugin.LookupFormStrings (id);  			if (!string.IsNullOrEmpty (str)) {  				elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> (TypeConverter.str2h (str)));  				++count;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,The following statement contains a magic number: if (elem.Structure != null && elem.Structure.type == ElementValueType.LString) {  	var data = elem.Data;  	uint id = TypeConverter.h2i (data);  	if (id == 0) {  		continue;  	}  	if (data.Count == 4) {  		var str = plugin.LookupFormStrings (id);  		if (!string.IsNullOrEmpty (str)) {  			elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> (TypeConverter.str2h (str)));  			++count;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,InternalizeStrings,The following statement contains a magic number: if (data.Count == 4) {  	var str = plugin.LookupFormStrings (id);  	if (!string.IsNullOrEmpty (str)) {  		elem.AssignValue<ArraySegment<byte>> (new ArraySegment<byte> (TypeConverter.str2h (str)));  		++count;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	if (record.Flags3 > 40) {  		var data = new byte[4];  		TypeConverter.i2h (record.Flags3' data' 0);  		if (data [0] > 40) {  			data [0] = 40;  			record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  			countGreate40++;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	if (record.Flags3 > 40) {  		var data = new byte[4];  		TypeConverter.i2h (record.Flags3' data' 0);  		if (data [0] > 40) {  			data [0] = 40;  			record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  			countGreate40++;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	if (record.Flags3 > 40) {  		var data = new byte[4];  		TypeConverter.i2h (record.Flags3' data' 0);  		if (data [0] > 40) {  			data [0] = 40;  			record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  			countGreate40++;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	if (record.Flags3 > 40) {  		var data = new byte[4];  		TypeConverter.i2h (record.Flags3' data' 0);  		if (data [0] > 40) {  			data [0] = 40;  			record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  			countGreate40++;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: foreach (var record in plugin.Enumerate ().OfType<Record> ()) {  	record.MatchRecordStructureToRecord ();  	if (record.Flags3 > 40) {  		var data = new byte[4];  		TypeConverter.i2h (record.Flags3' data' 0);  		if (data [0] > 40) {  			data [0] = 40;  			record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  			countGreate40++;  		}  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (record.Flags3 > 40) {  	var data = new byte[4];  	TypeConverter.i2h (record.Flags3' data' 0);  	if (data [0] > 40) {  		data [0] = 40;  		record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  		countGreate40++;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (record.Flags3 > 40) {  	var data = new byte[4];  	TypeConverter.i2h (record.Flags3' data' 0);  	if (data [0] > 40) {  		data [0] = 40;  		record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  		countGreate40++;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (record.Flags3 > 40) {  	var data = new byte[4];  	TypeConverter.i2h (record.Flags3' data' 0);  	if (data [0] > 40) {  		data [0] = 40;  		record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  		countGreate40++;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (record.Flags3 > 40) {  	var data = new byte[4];  	TypeConverter.i2h (record.Flags3' data' 0);  	if (data [0] > 40) {  		data [0] = 40;  		record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  		countGreate40++;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (record.Flags3 > 40) {  	var data = new byte[4];  	TypeConverter.i2h (record.Flags3' data' 0);  	if (data [0] > 40) {  		data [0] = 40;  		record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  		countGreate40++;  	}  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (data [0] > 40) {  	data [0] = 40;  	record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  	countGreate40++;  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (data [0] > 40) {  	data [0] = 40;  	record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  	countGreate40++;  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: if (data [0] > 40) {  	data [0] = 40;  	record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  	countGreate40++;  }  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: data [0] = 40;  
Magic Number,TESVSnip.Domain.Services,Spells,F:\newReposMay17\figment_tesvsnip\Domain\Services\Spells.cs,ChangeFormIdGreater40To40,The following statement contains a magic number: record.Flags3 = TypeConverter.h2i (new ArraySegment<byte> (data' 0' 4));  
Magic Number,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: foreach (var rec in recordList) {  	var p = rec.GetPlugin ();  	PluginInfo info;  	if (!pluginMap.TryGetValue (p' out info))  		pluginMap.Add (p' info = new PluginInfo () {  			Masters = p.GetMasters ()  		});  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	var ids = rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID).Select (elem => TypeConverter.h2i (elem.Data)).Distinct ().ToList ();  	ids.Add (rec.FormID);  	ids.Sort ();  	// processing in sort order should keep master orders slightly more sane  	foreach (var id in ids) {  		if (info.References.ContainsKey (id))  			continue;  		var idx = id >> 24;  		var masterName = idx >= info.Masters.Length ? p.Name : info.Masters [idx];  		if (!masters.ContainsKey (masterName)) {  			plugin.AddMaster (masterName);  			this.masters.Add (masterName' masterName);  			changed = true;  		}  		var newidx = this.masters.FindIndex (masterName);  		if (newidx < 0)  			newidx = 0xFF;  		info.References [id] = (id & 0x00FFFFFF) | (uint)(newidx << 24);  	}  }  
Magic Number,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: foreach (var rec in recordList) {  	var p = rec.GetPlugin ();  	PluginInfo info;  	if (!pluginMap.TryGetValue (p' out info))  		pluginMap.Add (p' info = new PluginInfo () {  			Masters = p.GetMasters ()  		});  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	var ids = rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID).Select (elem => TypeConverter.h2i (elem.Data)).Distinct ().ToList ();  	ids.Add (rec.FormID);  	ids.Sort ();  	// processing in sort order should keep master orders slightly more sane  	foreach (var id in ids) {  		if (info.References.ContainsKey (id))  			continue;  		var idx = id >> 24;  		var masterName = idx >= info.Masters.Length ? p.Name : info.Masters [idx];  		if (!masters.ContainsKey (masterName)) {  			plugin.AddMaster (masterName);  			this.masters.Add (masterName' masterName);  			changed = true;  		}  		var newidx = this.masters.FindIndex (masterName);  		if (newidx < 0)  			newidx = 0xFF;  		info.References [id] = (id & 0x00FFFFFF) | (uint)(newidx << 24);  	}  }  
Magic Number,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: foreach (var id in ids) {  	if (info.References.ContainsKey (id))  		continue;  	var idx = id >> 24;  	var masterName = idx >= info.Masters.Length ? p.Name : info.Masters [idx];  	if (!masters.ContainsKey (masterName)) {  		plugin.AddMaster (masterName);  		this.masters.Add (masterName' masterName);  		changed = true;  	}  	var newidx = this.masters.FindIndex (masterName);  	if (newidx < 0)  		newidx = 0xFF;  	info.References [id] = (id & 0x00FFFFFF) | (uint)(newidx << 24);  }  
Magic Number,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: foreach (var id in ids) {  	if (info.References.ContainsKey (id))  		continue;  	var idx = id >> 24;  	var masterName = idx >= info.Masters.Length ? p.Name : info.Masters [idx];  	if (!masters.ContainsKey (masterName)) {  		plugin.AddMaster (masterName);  		this.masters.Add (masterName' masterName);  		changed = true;  	}  	var newidx = this.masters.FindIndex (masterName);  	if (newidx < 0)  		newidx = 0xFF;  	info.References [id] = (id & 0x00FFFFFF) | (uint)(newidx << 24);  }  
Magic Number,TESVSnip.Domain.Services,CloneTool,F:\newReposMay17\figment_tesvsnip\Domain\Services\CloneTool.cs,PrepMasters,The following statement contains a magic number: info.References [id] = (id & 0x00FFFFFF) | (uint)(newidx << 24);  
Magic Number,TESVSnip.Domain.Services,CompressHelper,F:\newReposMay17\figment_tesvsnip\Domain\Services\Compressor.cs,Decompress,The following statement contains a magic number: level = (int)args [4];  
Magic Number,TESVSnip.Domain.Model,BaseRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\BaseRecord.cs,ReadRecName,The following statement contains a magic number: try {  	return Encoding.Default.GetString (br.ReadBytes (4));  } catch (Exception ex) {  	throw new TESParserException ("BaseRecord.ReadRecName: " + Environment.NewLine + ex.Message);  }  
Magic Number,TESVSnip.Domain.Model,BaseRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\BaseRecord.cs,ReadRecName,The following statement contains a magic number: return Encoding.Default.GetString (br.ReadBytes (4));  
Magic Number,TESVSnip.Domain.Model,BaseRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\BaseRecord.cs,ReadRecName,The following statement contains a magic number: try {  	return Encoding.Default.GetString (rec' 0' 4);  } catch (Exception ex) {  	throw new TESParserException ("BaseRecord.ReadRecName: " + Environment.NewLine + ex.Message);  }  
Magic Number,TESVSnip.Domain.Model,BaseRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\BaseRecord.cs,ReadRecName,The following statement contains a magic number: return Encoding.Default.GetString (rec' 0' 4);  
Magic Number,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The following statement contains a magic number: if (numText.StartsWith ("0x")) {  	numStyle = NumberStyles.HexNumber;  	numText = strvalue.Substring (2);  }  
Magic Number,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The following statement contains a magic number: numText = strvalue.Substring (2);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: try {  	int len;  	switch (es.type) {  	case ElementValueType.Int:  		len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  		elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UInt:  	case ElementValueType.FormID:  		len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Float:  		len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  		elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Short:  		len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  		elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.UShort:  		len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  		elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.SByte:  		len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  		elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.Byte:  		len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  		elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  		break;  	case ElementValueType.String:  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// raw form includes the zero termination byte  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  		break;  	case ElementValueType.BString:  		if (maxlen >= sizeof(ushort)) {  			len = TypeConverter.h2s (data [offset]' data [offset + 1]);  			len = (len < maxlen - 2) ? len : maxlen - 2;  			if (rawData) {  				// raw data includes short prefix  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  				offset += len + 2;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  				offset += len + 2;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.IString:  		if (maxlen >= sizeof(int)) {  			len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  			len = (len < maxlen - 4) ? len : maxlen - 4;  			if (rawData) {  				// raw data includes int prefix  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  				offset += len + 4;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  				offset += len + 4;  			}  		} else {  			if (rawData) {  				elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  					0'  					0'  					0'  					0  				})' indices);  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  			}  			offset += maxlen;  		}  		break;  	case ElementValueType.Str4:  		len = maxlen >= 4 ? 4 : maxlen;  		if (rawData) {  			elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		}  		offset += len;  		break;  	case ElementValueType.LString:  		if (maxlen < sizeof(int)) {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  			offset += maxlen;  		} else {  			len = maxlen;  			var blob = new ArraySegment<byte> (data' offset' len);  			bool isString = TypeConverter.IsLikelyString (blob);  			if (!isString) {  				elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  				offset += 4;  			} else {  				len = 0;  				for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  					;  				}  				if (rawData) {  					// lstring as raw string includes the terminating null  					len = len == 0 ? 0 : len + 1;  					elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len;  				} else {  					elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  					offset += len == 0 ? 0 : len + 1;  				}  			}  		}  		break;  	default:  		elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  		break;  	}  } catch {  } finally {  	if (offset > data.Length) {  		offset = data.Length;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: switch (es.type) {  case ElementValueType.Int:  	len = maxlen >= sizeof(int) ? sizeof(int) : maxlen;  	elem = new Element (es' ElementValueType.Int' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UInt:  case ElementValueType.FormID:  	len = maxlen >= sizeof(uint) ? sizeof(uint) : maxlen;  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Float:  	len = maxlen >= sizeof(float) ? sizeof(float) : maxlen;  	elem = new Element (es' ElementValueType.Float' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Short:  	len = maxlen >= sizeof(short) ? sizeof(short) : maxlen;  	elem = new Element (es' ElementValueType.Short' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.UShort:  	len = maxlen >= sizeof(ushort) ? sizeof(ushort) : maxlen;  	elem = new Element (es' ElementValueType.UShort' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.SByte:  	len = maxlen >= sizeof(sbyte) ? sizeof(sbyte) : maxlen;  	elem = new Element (es' ElementValueType.SByte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.Byte:  	len = maxlen >= sizeof(byte) ? sizeof(byte) : maxlen;  	elem = new Element (es' ElementValueType.Byte' new ArraySegment<byte> (data' offset' len)' indices);  	offset += len;  	break;  case ElementValueType.String:  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// raw form includes the zero termination byte  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  	break;  case ElementValueType.BString:  	if (maxlen >= sizeof(ushort)) {  		len = TypeConverter.h2s (data [offset]' data [offset + 1]);  		len = (len < maxlen - 2) ? len : maxlen - 2;  		if (rawData) {  			// raw data includes short prefix  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  			offset += len + 2;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  			offset += len + 2;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.IString:  	if (maxlen >= sizeof(int)) {  		len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  		len = (len < maxlen - 4) ? len : maxlen - 4;  		if (rawData) {  			// raw data includes int prefix  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  			offset += len + 4;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  			offset += len + 4;  		}  	} else {  		if (rawData) {  			elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  				0'  				0'  				0'  				0  			})' indices);  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  		}  		offset += maxlen;  	}  	break;  case ElementValueType.Str4:  	len = maxlen >= 4 ? 4 : maxlen;  	if (rawData) {  		elem = new Element (es' ElementValueType.Str4' new ArraySegment<byte> (data' offset' len)' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  	}  	offset += len;  	break;  case ElementValueType.LString:  	if (maxlen < sizeof(int)) {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  		offset += maxlen;  	} else {  		len = maxlen;  		var blob = new ArraySegment<byte> (data' offset' len);  		bool isString = TypeConverter.IsLikelyString (blob);  		if (!isString) {  			elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  			offset += 4;  		} else {  			len = 0;  			for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  				;  			}  			if (rawData) {  				// lstring as raw string includes the terminating null  				len = len == 0 ? 0 : len + 1;  				elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len;  			} else {  				elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  				offset += len == 0 ? 0 : len + 1;  			}  		}  	}  	break;  default:  	elem = new Element (es' ElementValueType.Blob' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(ushort)) {  	len = TypeConverter.h2s (data [offset]' data [offset + 1]);  	len = (len < maxlen - 2) ? len : maxlen - 2;  	if (rawData) {  		// raw data includes short prefix  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  		offset += len + 2;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  		offset += len + 2;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(ushort)) {  	len = TypeConverter.h2s (data [offset]' data [offset + 1]);  	len = (len < maxlen - 2) ? len : maxlen - 2;  	if (rawData) {  		// raw data includes short prefix  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  		offset += len + 2;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  		offset += len + 2;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(ushort)) {  	len = TypeConverter.h2s (data [offset]' data [offset + 1]);  	len = (len < maxlen - 2) ? len : maxlen - 2;  	if (rawData) {  		// raw data includes short prefix  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  		offset += len + 2;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  		offset += len + 2;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(ushort)) {  	len = TypeConverter.h2s (data [offset]' data [offset + 1]);  	len = (len < maxlen - 2) ? len : maxlen - 2;  	if (rawData) {  		// raw data includes short prefix  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  		offset += len + 2;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  		offset += len + 2;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(ushort)) {  	len = TypeConverter.h2s (data [offset]' data [offset + 1]);  	len = (len < maxlen - 2) ? len : maxlen - 2;  	if (rawData) {  		// raw data includes short prefix  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  		offset += len + 2;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  		offset += len + 2;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(ushort)) {  	len = TypeConverter.h2s (data [offset]' data [offset + 1]);  	len = (len < maxlen - 2) ? len : maxlen - 2;  	if (rawData) {  		// raw data includes short prefix  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  		offset += len + 2;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  		offset += len + 2;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(ushort)) {  	len = TypeConverter.h2s (data [offset]' data [offset + 1]);  	len = (len < maxlen - 2) ? len : maxlen - 2;  	if (rawData) {  		// raw data includes short prefix  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  		offset += len + 2;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  		offset += len + 2;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = (len < maxlen - 2) ? len : maxlen - 2;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = (len < maxlen - 2) ? len : maxlen - 2;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes short prefix  	elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  	offset += len + 2;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  	offset += len + 2;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes short prefix  	elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  	offset += len + 2;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  	offset += len + 2;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes short prefix  	elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  	offset += len + 2;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  	offset += len + 2;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes short prefix  	elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  	offset += len + 2;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  	offset += len + 2;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (data' offset' len + 2)' indices);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: offset += len + 2;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 2' len)' indices);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: offset += len + 2;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  		0'  		0  	})' indices);  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: elem = new Element (es' ElementValueType.BString' new ArraySegment<byte> (new byte[2] {  	0'  	0  })' indices);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen >= sizeof(int)) {  	len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  	len = (len < maxlen - 4) ? len : maxlen - 4;  	if (rawData) {  		// raw data includes int prefix  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  		offset += len + 4;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  		offset += len + 4;  	}  } else {  	if (rawData) {  		elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  			0'  			0'  			0'  			0  		})' indices);  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  	}  	offset += maxlen;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = TypeConverter.h2si (data [offset]' data [offset + 1]' data [offset + 2]' data [offset + 3]);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = (len < maxlen - 4) ? len : maxlen - 4;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = (len < maxlen - 4) ? len : maxlen - 4;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes int prefix  	elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  	offset += len + 4;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  	offset += len + 4;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes int prefix  	elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  	offset += len + 4;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  	offset += len + 4;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes int prefix  	elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  	offset += len + 4;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  	offset += len + 4;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	// raw data includes int prefix  	elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  	offset += len + 4;  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  	offset += len + 4;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (data' offset' len + 4)' indices);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: offset += len + 4;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset + 4' len)' indices);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: offset += len + 4;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (rawData) {  	elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  		0'  		0'  		0'  		0  	})' indices);  } else {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (new byte[0])' indices);  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: elem = new Element (es' ElementValueType.IString' new ArraySegment<byte> (new byte[4] {  	0'  	0'  	0'  	0  })' indices);  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = maxlen >= 4 ? 4 : maxlen;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: len = maxlen >= 4 ? 4 : maxlen;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (maxlen < sizeof(int)) {  	elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' maxlen)' indices);  	offset += maxlen;  } else {  	len = maxlen;  	var blob = new ArraySegment<byte> (data' offset' len);  	bool isString = TypeConverter.IsLikelyString (blob);  	if (!isString) {  		elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  		offset += 4;  	} else {  		len = 0;  		for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  			;  		}  		if (rawData) {  			// lstring as raw string includes the terminating null  			len = len == 0 ? 0 : len + 1;  			elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len;  		} else {  			elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  			offset += len == 0 ? 0 : len + 1;  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: if (!isString) {  	elem = new Element (es' ElementValueType.UInt' new ArraySegment<byte> (data' offset' len)' indices);  	offset += 4;  } else {  	len = 0;  	for (int i = offset; i < data.Length && data [i] != 0; ++i' ++len) {  		;  	}  	if (rawData) {  		// lstring as raw string includes the terminating null  		len = len == 0 ? 0 : len + 1;  		elem = new Element (es' ElementValueType.LString' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len;  	} else {  		elem = new Element (es' ElementValueType.String' new ArraySegment<byte> (data' offset' len)' indices);  		offset += len == 0 ? 0 : len + 1;  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,CreateElement,The following statement contains a magic number: offset += 4;  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following statement contains a magic number: switch (this.Structure.type) {  case ElementValueType.String:  	{  		var str1 = Extensions.CastValue<string> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<string> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<string> (str1 + Extensions.CastValue<string> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<string> (default(string));  		}  	}  	break;  case ElementValueType.FormID:  	{  		if (this.Value is uint && val is uint) {  			var u1 = (uint)this.Value;  			var u2 = (uint)val;  			switch (elemType) {  			case ElementAssignmentType.Set:  				return this.AssignValue<uint> (u2);  			case ElementAssignmentType.Add:  				return this.AssignValue<uint> (u1 + u2);  			case ElementAssignmentType.Subtract:  				return this.AssignValue<uint> (u1 - u2);  			case ElementAssignmentType.Multiply:  				return this.AssignValue<uint> (u1 * u2);  			case ElementAssignmentType.Divide:  				return this.AssignValue<uint> (u1 / u2);  			case ElementAssignmentType.BitAnd:  				return this.AssignValue<uint> (u1 & u2);  			case ElementAssignmentType.BitOr:  				return this.AssignValue<uint> (u1 | u2);  			case ElementAssignmentType.Clear:  				return this.AssignValue<uint> (default(uint));  			}  		}  	}  	break;  case ElementValueType.Blob:  	break;  case ElementValueType.LString:  	if (this.Value is string && val is string) {  		var s1 = (string)this.Value;  		var s2 = (string)val;  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<string> (s2);  		case ElementAssignmentType.Add:  			return this.AssignValue<string> (s1 + s2);  		case ElementAssignmentType.Clear:  			return this.AssignValue<string> (default(string));  		}  	}  	break;  case ElementValueType.BString:  case ElementValueType.IString:  	break;  case ElementValueType.Str4:  	{  		var str2 = Extensions.CastValue<string> (val);  		if (this.Data.Count == 4 && str2.Length == 4) {  			switch (elemType) {  			case ElementAssignmentType.Set:  				return this.AssignValue<string> (str2);  			case ElementAssignmentType.Clear:  				return this.AssignValue<string> ("    ");  			}  		}  	}  	break;  case ElementValueType.Float:  	{  		var val1 = Extensions.CastValue<float> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<float> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<float> (val1 + Extensions.CastValue<float> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<float> (val1 - Extensions.CastValue<float> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<float> (val1 * Extensions.CastValue<float> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<float> (val1 / Extensions.CastValue<float> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<float> (Extensions.CastValue<int> (val1) & Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<float> (Extensions.CastValue<int> (val1) | Extensions.CastValue<int> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<float> (default(float));  		}  	}  	break;  case ElementValueType.Int:  	{  		var val1 = Extensions.CastValue<int> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<int> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<int> (val1 + Extensions.CastValue<int> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<int> (val1 - Extensions.CastValue<int> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<int> (val1 * Extensions.CastValue<int> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<int> (val1 / Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<int> (val1 & Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<int> (val1 | Extensions.CastValue<int> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<int> (default(int));  		}  	}  	break;  case ElementValueType.Short:  	{  		var val1 = Extensions.CastValue<short> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<short> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<short> (val1 + Extensions.CastValue<short> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<short> (val1 - Extensions.CastValue<short> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<short> (val1 * Extensions.CastValue<short> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<short> (val1 / Extensions.CastValue<short> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<short> (val1 & Extensions.CastValue<short> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<short> (val1 | Extensions.CastValue<short> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<short> (default(short));  		}  	}  	break;  case ElementValueType.Byte:  	{  		var val1 = Extensions.CastValue<byte> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<byte> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<byte> (val1 + Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<byte> (val1 - Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<byte> (val1 * Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<byte> (val1 / Extensions.CastValue<byte> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<byte> (val1 & Extensions.CastValue<byte> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<byte> (val1 | Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<byte> (default(byte));  		}  	}  	break;  case ElementValueType.UShort:  	{  		var val1 = Extensions.CastValue<ushort> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<ushort> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<ushort> (val1 + Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<ushort> (val1 - Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<ushort> (val1 * Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<ushort> (val1 / Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<ushort> (val1 & Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<ushort> (val1 | Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<ushort> (default(ushort));  		}  	}  	break;  case ElementValueType.UInt:  	{  		var val1 = Extensions.CastValue<uint> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<uint> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<uint> (val1 + Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<uint> (val1 - Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<uint> (val1 * Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<uint> (val1 / Extensions.CastValue<uint> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<uint> (val1 & Extensions.CastValue<uint> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<uint> (val1 | Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<uint> (default(uint));  		}  	}  	break;  case ElementValueType.SByte:  	{  		var val1 = Extensions.CastValue<sbyte> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<sbyte> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<sbyte> (val1 + Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<sbyte> (val1 - Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<sbyte> (val1 * Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<sbyte> (val1 / Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<sbyte> (val1 & Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<sbyte> (val1 | Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<sbyte> (default(sbyte));  		}  	}  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following statement contains a magic number: switch (this.Structure.type) {  case ElementValueType.String:  	{  		var str1 = Extensions.CastValue<string> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<string> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<string> (str1 + Extensions.CastValue<string> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<string> (default(string));  		}  	}  	break;  case ElementValueType.FormID:  	{  		if (this.Value is uint && val is uint) {  			var u1 = (uint)this.Value;  			var u2 = (uint)val;  			switch (elemType) {  			case ElementAssignmentType.Set:  				return this.AssignValue<uint> (u2);  			case ElementAssignmentType.Add:  				return this.AssignValue<uint> (u1 + u2);  			case ElementAssignmentType.Subtract:  				return this.AssignValue<uint> (u1 - u2);  			case ElementAssignmentType.Multiply:  				return this.AssignValue<uint> (u1 * u2);  			case ElementAssignmentType.Divide:  				return this.AssignValue<uint> (u1 / u2);  			case ElementAssignmentType.BitAnd:  				return this.AssignValue<uint> (u1 & u2);  			case ElementAssignmentType.BitOr:  				return this.AssignValue<uint> (u1 | u2);  			case ElementAssignmentType.Clear:  				return this.AssignValue<uint> (default(uint));  			}  		}  	}  	break;  case ElementValueType.Blob:  	break;  case ElementValueType.LString:  	if (this.Value is string && val is string) {  		var s1 = (string)this.Value;  		var s2 = (string)val;  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<string> (s2);  		case ElementAssignmentType.Add:  			return this.AssignValue<string> (s1 + s2);  		case ElementAssignmentType.Clear:  			return this.AssignValue<string> (default(string));  		}  	}  	break;  case ElementValueType.BString:  case ElementValueType.IString:  	break;  case ElementValueType.Str4:  	{  		var str2 = Extensions.CastValue<string> (val);  		if (this.Data.Count == 4 && str2.Length == 4) {  			switch (elemType) {  			case ElementAssignmentType.Set:  				return this.AssignValue<string> (str2);  			case ElementAssignmentType.Clear:  				return this.AssignValue<string> ("    ");  			}  		}  	}  	break;  case ElementValueType.Float:  	{  		var val1 = Extensions.CastValue<float> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<float> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<float> (val1 + Extensions.CastValue<float> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<float> (val1 - Extensions.CastValue<float> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<float> (val1 * Extensions.CastValue<float> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<float> (val1 / Extensions.CastValue<float> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<float> (Extensions.CastValue<int> (val1) & Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<float> (Extensions.CastValue<int> (val1) | Extensions.CastValue<int> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<float> (default(float));  		}  	}  	break;  case ElementValueType.Int:  	{  		var val1 = Extensions.CastValue<int> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<int> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<int> (val1 + Extensions.CastValue<int> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<int> (val1 - Extensions.CastValue<int> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<int> (val1 * Extensions.CastValue<int> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<int> (val1 / Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<int> (val1 & Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<int> (val1 | Extensions.CastValue<int> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<int> (default(int));  		}  	}  	break;  case ElementValueType.Short:  	{  		var val1 = Extensions.CastValue<short> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<short> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<short> (val1 + Extensions.CastValue<short> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<short> (val1 - Extensions.CastValue<short> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<short> (val1 * Extensions.CastValue<short> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<short> (val1 / Extensions.CastValue<short> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<short> (val1 & Extensions.CastValue<short> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<short> (val1 | Extensions.CastValue<short> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<short> (default(short));  		}  	}  	break;  case ElementValueType.Byte:  	{  		var val1 = Extensions.CastValue<byte> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<byte> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<byte> (val1 + Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<byte> (val1 - Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<byte> (val1 * Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<byte> (val1 / Extensions.CastValue<byte> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<byte> (val1 & Extensions.CastValue<byte> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<byte> (val1 | Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<byte> (default(byte));  		}  	}  	break;  case ElementValueType.UShort:  	{  		var val1 = Extensions.CastValue<ushort> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<ushort> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<ushort> (val1 + Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<ushort> (val1 - Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<ushort> (val1 * Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<ushort> (val1 / Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<ushort> (val1 & Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<ushort> (val1 | Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<ushort> (default(ushort));  		}  	}  	break;  case ElementValueType.UInt:  	{  		var val1 = Extensions.CastValue<uint> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<uint> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<uint> (val1 + Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<uint> (val1 - Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<uint> (val1 * Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<uint> (val1 / Extensions.CastValue<uint> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<uint> (val1 & Extensions.CastValue<uint> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<uint> (val1 | Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<uint> (default(uint));  		}  	}  	break;  case ElementValueType.SByte:  	{  		var val1 = Extensions.CastValue<sbyte> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<sbyte> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<sbyte> (val1 + Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<sbyte> (val1 - Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<sbyte> (val1 * Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<sbyte> (val1 / Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<sbyte> (val1 & Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<sbyte> (val1 | Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<sbyte> (default(sbyte));  		}  	}  	break;  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following statement contains a magic number: if (this.Data.Count == 4 && str2.Length == 4) {  	switch (elemType) {  	case ElementAssignmentType.Set:  		return this.AssignValue<string> (str2);  	case ElementAssignmentType.Clear:  		return this.AssignValue<string> ("    ");  	}  }  
Magic Number,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following statement contains a magic number: if (this.Data.Count == 4 && str2.Length == 4) {  	switch (elemType) {  	case ElementAssignmentType.Set:  		return this.AssignValue<string> (str2);  	case ElementAssignmentType.Clear:  		return this.AssignValue<string> ("    ");  	}  }  
Magic Number,TESVSnip.Domain.Model,FlagDefs,F:\newReposMay17\figment_tesvsnip\Domain\Model\FlagDefs.cs,GetRecFlags1Desc,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  	brr = (int)(1 << i);  	if (brr < 0)  		//brr < 0 when 1 << 31 = overflow   		brr = Convert.ToInt64 (0x80000000);  	//Header Flags : (REFR) MultiBound 0x80000000;   	if ((flags & brr) > 0) {  		if (b)  			desc += "' ";  		b = true;  		desc += RecFlags1 [i] == null ? "Unknown (" + brr.ToString ("x") + ")" : RecFlags1 [i];  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: this.data = new byte[4];  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.data [i] = (byte)data [i];  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: this.data = br.ReadBytes (4);  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: if (define.RecSize >= 16) {  	this.flags = br.ReadUInt32 ();  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: while (amountRead < Size - (define.RecSize + 8)) {  	string s = ReadRecName (br);  	uint recsize = br.ReadUInt32 ();  	if (s == "GRUP") {  		try {  			bool skip = filterAll || (recFilter != null && !recFilter (contentType));  			var gr = new GroupRecord (recsize' br' define' recFilter' skip);  			if (!filterAll) {  				this.AddRecord (gr);  			}  		} catch (Exception e) {  			Alerts.Show (e.Message);  		} finally {  			amountRead += recsize;  		}  	} else {  		bool skip = filterAll || (recFilter != null && !recFilter (contentType));  		if (skip) {  			long size = recsize + define.RecSize;  			// if ((br.ReadUInt32() & 0x00040000) > 0) size += 4;  			br.BaseStream.Position += size;  			// just read past the data  			amountRead += (uint)(recsize + (define.RecSize + 8));  		} else {  			try {  				var r = new Record (s' recsize' br' define);  				this.AddRecord (r);  			} catch (Exception e) {  				Alerts.Show (e.Message);  			} finally {  				amountRead += (uint)(recsize + (define.RecSize + 8));  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: while (amountRead < Size - (define.RecSize + 8)) {  	string s = ReadRecName (br);  	uint recsize = br.ReadUInt32 ();  	if (s == "GRUP") {  		try {  			bool skip = filterAll || (recFilter != null && !recFilter (contentType));  			var gr = new GroupRecord (recsize' br' define' recFilter' skip);  			if (!filterAll) {  				this.AddRecord (gr);  			}  		} catch (Exception e) {  			Alerts.Show (e.Message);  		} finally {  			amountRead += recsize;  		}  	} else {  		bool skip = filterAll || (recFilter != null && !recFilter (contentType));  		if (skip) {  			long size = recsize + define.RecSize;  			// if ((br.ReadUInt32() & 0x00040000) > 0) size += 4;  			br.BaseStream.Position += size;  			// just read past the data  			amountRead += (uint)(recsize + (define.RecSize + 8));  		} else {  			try {  				var r = new Record (s' recsize' br' define);  				this.AddRecord (r);  			} catch (Exception e) {  				Alerts.Show (e.Message);  			} finally {  				amountRead += (uint)(recsize + (define.RecSize + 8));  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: while (amountRead < Size - (define.RecSize + 8)) {  	string s = ReadRecName (br);  	uint recsize = br.ReadUInt32 ();  	if (s == "GRUP") {  		try {  			bool skip = filterAll || (recFilter != null && !recFilter (contentType));  			var gr = new GroupRecord (recsize' br' define' recFilter' skip);  			if (!filterAll) {  				this.AddRecord (gr);  			}  		} catch (Exception e) {  			Alerts.Show (e.Message);  		} finally {  			amountRead += recsize;  		}  	} else {  		bool skip = filterAll || (recFilter != null && !recFilter (contentType));  		if (skip) {  			long size = recsize + define.RecSize;  			// if ((br.ReadUInt32() & 0x00040000) > 0) size += 4;  			br.BaseStream.Position += size;  			// just read past the data  			amountRead += (uint)(recsize + (define.RecSize + 8));  		} else {  			try {  				var r = new Record (s' recsize' br' define);  				this.AddRecord (r);  			} catch (Exception e) {  				Alerts.Show (e.Message);  			} finally {  				amountRead += (uint)(recsize + (define.RecSize + 8));  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: if (s == "GRUP") {  	try {  		bool skip = filterAll || (recFilter != null && !recFilter (contentType));  		var gr = new GroupRecord (recsize' br' define' recFilter' skip);  		if (!filterAll) {  			this.AddRecord (gr);  		}  	} catch (Exception e) {  		Alerts.Show (e.Message);  	} finally {  		amountRead += recsize;  	}  } else {  	bool skip = filterAll || (recFilter != null && !recFilter (contentType));  	if (skip) {  		long size = recsize + define.RecSize;  		// if ((br.ReadUInt32() & 0x00040000) > 0) size += 4;  		br.BaseStream.Position += size;  		// just read past the data  		amountRead += (uint)(recsize + (define.RecSize + 8));  	} else {  		try {  			var r = new Record (s' recsize' br' define);  			this.AddRecord (r);  		} catch (Exception e) {  			Alerts.Show (e.Message);  		} finally {  			amountRead += (uint)(recsize + (define.RecSize + 8));  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: if (s == "GRUP") {  	try {  		bool skip = filterAll || (recFilter != null && !recFilter (contentType));  		var gr = new GroupRecord (recsize' br' define' recFilter' skip);  		if (!filterAll) {  			this.AddRecord (gr);  		}  	} catch (Exception e) {  		Alerts.Show (e.Message);  	} finally {  		amountRead += recsize;  	}  } else {  	bool skip = filterAll || (recFilter != null && !recFilter (contentType));  	if (skip) {  		long size = recsize + define.RecSize;  		// if ((br.ReadUInt32() & 0x00040000) > 0) size += 4;  		br.BaseStream.Position += size;  		// just read past the data  		amountRead += (uint)(recsize + (define.RecSize + 8));  	} else {  		try {  			var r = new Record (s' recsize' br' define);  			this.AddRecord (r);  		} catch (Exception e) {  			Alerts.Show (e.Message);  		} finally {  			amountRead += (uint)(recsize + (define.RecSize + 8));  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: if (skip) {  	long size = recsize + define.RecSize;  	// if ((br.ReadUInt32() & 0x00040000) > 0) size += 4;  	br.BaseStream.Position += size;  	// just read past the data  	amountRead += (uint)(recsize + (define.RecSize + 8));  } else {  	try {  		var r = new Record (s' recsize' br' define);  		this.AddRecord (r);  	} catch (Exception e) {  		Alerts.Show (e.Message);  	} finally {  		amountRead += (uint)(recsize + (define.RecSize + 8));  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: if (skip) {  	long size = recsize + define.RecSize;  	// if ((br.ReadUInt32() & 0x00040000) > 0) size += 4;  	br.BaseStream.Position += size;  	// just read past the data  	amountRead += (uint)(recsize + (define.RecSize + 8));  } else {  	try {  		var r = new Record (s' recsize' br' define);  		this.AddRecord (r);  	} catch (Exception e) {  		Alerts.Show (e.Message);  	} finally {  		amountRead += (uint)(recsize + (define.RecSize + 8));  	}  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: amountRead += (uint)(recsize + (define.RecSize + 8));  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: try {  	var r = new Record (s' recsize' br' define);  	this.AddRecord (r);  } catch (Exception e) {  	Alerts.Show (e.Message);  } finally {  	amountRead += (uint)(recsize + (define.RecSize + 8));  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: amountRead += (uint)(recsize + (define.RecSize + 8));  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: if (amountRead != (Size - (define.RecSize + 8))) {  	throw new TESParserException (string.Format ("Record block did not match the size specified in the group header! Header Size={0:D} Group Size={1:D}"' Size - (define.RecSize + 8)' amountRead));  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: if (amountRead != (Size - (define.RecSize + 8))) {  	throw new TESParserException (string.Format ("Record block did not match the size specified in the group header! Header Size={0:D} Group Size={1:D}"' Size - (define.RecSize + 8)' amountRead));  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,GroupRecord,The following statement contains a magic number: throw new TESParserException (string.Format ("Record block did not match the size specified in the group header! Header Size={0:D} Group Size={1:D}"' Size - (define.RecSize + 8)' amountRead));  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,SetData,The following statement contains a magic number: if (data.Length != 4) {  	throw new ArgumentException ("data length must be 4");  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,SetData,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.data [i] = data [i];  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,SaveData,The following statement contains a magic number: if (wrSize != svSize2) {  	// fix size due to compression  	writer.BaseStream.Position = startpos + 4;  	writer.Write (wrSize);  	// Write the actuall compressed group size  	writer.BaseStream.Position = curpos;  }  
Magic Number,TESVSnip.Domain.Model,GroupRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\GroupRecord.cs,SaveData,The following statement contains a magic number: writer.BaseStream.Position = startpos + 4;  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var rec in EnumerateRecords (null).Select (x => x.Value).SkipWhile (x => RecordLayout.NoNewCopyTypes.Contains (x.Name))) {  	if ((rec.FormID >> 24) >= masterIdx)  		rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  		var value = elem.GetValue<uint> ();  		if ((value >> 24) >= masterIdx)  			elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var rec in EnumerateRecords (null).Select (x => x.Value).SkipWhile (x => RecordLayout.NoNewCopyTypes.Contains (x.Name))) {  	if ((rec.FormID >> 24) >= masterIdx)  		rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  		var value = elem.GetValue<uint> ();  		if ((value >> 24) >= masterIdx)  			elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var rec in EnumerateRecords (null).Select (x => x.Value).SkipWhile (x => RecordLayout.NoNewCopyTypes.Contains (x.Name))) {  	if ((rec.FormID >> 24) >= masterIdx)  		rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  		var value = elem.GetValue<uint> ();  		if ((value >> 24) >= masterIdx)  			elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var rec in EnumerateRecords (null).Select (x => x.Value).SkipWhile (x => RecordLayout.NoNewCopyTypes.Contains (x.Name))) {  	if ((rec.FormID >> 24) >= masterIdx)  		rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  		var value = elem.GetValue<uint> ();  		if ((value >> 24) >= masterIdx)  			elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var rec in EnumerateRecords (null).Select (x => x.Value).SkipWhile (x => RecordLayout.NoNewCopyTypes.Contains (x.Name))) {  	if ((rec.FormID >> 24) >= masterIdx)  		rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  		var value = elem.GetValue<uint> ();  		if ((value >> 24) >= masterIdx)  			elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var rec in EnumerateRecords (null).Select (x => x.Value).SkipWhile (x => RecordLayout.NoNewCopyTypes.Contains (x.Name))) {  	if ((rec.FormID >> 24) >= masterIdx)  		rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  	// now handle child references  	rec.MatchRecordStructureToRecord ();  	foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  		var value = elem.GetValue<uint> ();  		if ((value >> 24) >= masterIdx)  			elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: if ((rec.FormID >> 24) >= masterIdx)  	rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: if ((rec.FormID >> 24) >= masterIdx)  	rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: if ((rec.FormID >> 24) >= masterIdx)  	rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: rec.FormID = (rec.FormID & 0x00FFFFFF) | (((rec.FormID >> 24) + 1) << 24);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  	var value = elem.GetValue<uint> ();  	if ((value >> 24) >= masterIdx)  		elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  	var value = elem.GetValue<uint> ();  	if ((value >> 24) >= masterIdx)  		elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: foreach (var elem in rec.SubRecords.SelectMany (sr => sr.EnumerateElements ()).Where (elem => elem.Structure != null && elem.Structure.type == ElementValueType.FormID)) {  	var value = elem.GetValue<uint> ();  	if ((value >> 24) >= masterIdx)  		elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: if ((value >> 24) >= masterIdx)  	elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: if ((value >> 24) >= masterIdx)  	elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: if ((value >> 24) >= masterIdx)  	elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,AddMaster,The following statement contains a magic number: elem.AssignValue<uint> ((value & 0x00FFFFFF) | (((value >> 24) + 1) << 24));  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,ReloadStrings,The following statement contains a magic number: if (Encoding.TryGetFontInfo (locName' out fontInfo)) {  	if (fontInfo.CodePage != 1252) {  		enc = System.Text.Encoding.GetEncoding (fontInfo.CodePage);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,ReloadStrings,The following statement contains a magic number: if (fontInfo.CodePage != 1252) {  	enc = System.Text.Encoding.GetEncoding (fontInfo.CodePage);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,EnumerateRecords,The following statement contains a magic number: for (int i = 0; i < this.Masters.Length - 1; i++) {  	if (this.Masters [i] == null) {  		continue;  		// missing master  	}  	uint match = this.Fixups [i];  	match <<= 24;  	uint mask = (uint)i << 24;  	// This enumerate misses any records that are children of masters  	foreach (var r in this.Masters [i].Enumerate (r => {  		if (r is Record) {  			if ((type == null || r.Name == type) && (((Record)r).FormID & 0xFF000000) == match) {  				return true;  			}  		} else if (r is GroupRecord) {  			var gr = (GroupRecord)r;  			if (gr.groupType != 0 || gr.ContentsType == type) {  				return true;  			}  		} else if (r is Plugin) {  			return true;  		}  		return false;  	})) {  		if (r is Record) {  			var r2 = r as Record;  			yield return new KeyValuePair<uint' Record> ((r2.FormID & 0xffffff) | mask' r2);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,EnumerateRecords,The following statement contains a magic number: for (int i = 0; i < this.Masters.Length - 1; i++) {  	if (this.Masters [i] == null) {  		continue;  		// missing master  	}  	uint match = this.Fixups [i];  	match <<= 24;  	uint mask = (uint)i << 24;  	// This enumerate misses any records that are children of masters  	foreach (var r in this.Masters [i].Enumerate (r => {  		if (r is Record) {  			if ((type == null || r.Name == type) && (((Record)r).FormID & 0xFF000000) == match) {  				return true;  			}  		} else if (r is GroupRecord) {  			var gr = (GroupRecord)r;  			if (gr.groupType != 0 || gr.ContentsType == type) {  				return true;  			}  		} else if (r is Plugin) {  			return true;  		}  		return false;  	})) {  		if (r is Record) {  			var r2 = r as Record;  			yield return new KeyValuePair<uint' Record> ((r2.FormID & 0xffffff) | mask' r2);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,EnumerateRecords,The following statement contains a magic number: match <<= 24;  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0) {  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		if (hedr.TryGetValue (8' out formID) && increment) {  			hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  		}  	}  	return (formID & 0x00FFFFFF) | ((uint)(masterCount << 24));  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0) {  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		if (hedr.TryGetValue (8' out formID) && increment) {  			hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  		}  	}  	return (formID & 0x00FFFFFF) | ((uint)(masterCount << 24));  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0) {  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		if (hedr.TryGetValue (8' out formID) && increment) {  			hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  		}  	}  	return (formID & 0x00FFFFFF) | ((uint)(masterCount << 24));  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0) {  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		if (hedr.TryGetValue (8' out formID) && increment) {  			hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  		}  	}  	return (formID & 0x00FFFFFF) | ((uint)(masterCount << 24));  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	if (hedr.TryGetValue (8' out formID) && increment) {  		hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	if (hedr.TryGetValue (8' out formID) && increment) {  		hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	if (hedr.TryGetValue (8' out formID) && increment) {  		hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (hedr.TryGetValue (8' out formID) && increment) {  	hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: if (hedr.TryGetValue (8' out formID) && increment) {  	hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: hedr.TrySetValue (8' (formID & 0x00FFFFFF) + 1);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetNewFormID,The following statement contains a magic number: return (formID & 0x00FFFFFF) | ((uint)(masterCount << 24));  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateNextFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0) {  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		hedr.TrySetValue (8' newid);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateNextFormID,The following statement contains a magic number: if (tes4 != null && tes4.SubRecords.Count > 0) {  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		hedr.TrySetValue (8' newid);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateNextFormID,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	hedr.TrySetValue (8' newid);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateNextFormID,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	hedr.TrySetValue (8' newid);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateNextFormID,The following statement contains a magic number: hedr.TrySetValue (8' newid);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,GetRecordByID,The following statement contains a magic number: id += this.Fixups [pluginid] << 24;  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LookupFormID,The following statement contains a magic number: if (pluginid < this.Masters.Length && this.Masters [pluginid] != null) {  	// find the reference master and search it for reference  	// TODO: in theory another master could override the first master  	var p = this.Masters [pluginid];  	id |= this.Fixups [pluginid] << 24;  	if (p.TryGetRecordByID (id' out r)) {  		return r.DescriptiveName;  	}  	return "No match";  } else {  	return "Master not loaded";  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LookupFormID,The following statement contains a magic number: id |= this.Fixups [pluginid] << 24;  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,SaveStrings,The following statement contains a magic number: if (Encoding.TryGetFontInfo (TESVSnip.Domain.Properties.Settings.Default.LocalizationName' out fontInfo)) {  	if (fontInfo.CodePage != 1252) {  		enc = System.Text.Encoding.GetEncoding (fontInfo.CodePage);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,SaveStrings,The following statement contains a magic number: if (fontInfo.CodePage != 1252) {  	enc = System.Text.Encoding.GetEncoding (fontInfo.CodePage);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (tes4 != null) {  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		hedr.TrySetValue (4' reccount);  		if (Properties.Settings.Default.AutoUpdateNextFormID) {  			var minId = new uint[] {  				0x0801  			};  			var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  			var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  			uint curid;  			if (hedr.TryGetValue (8' out curid) && maxID >= curid)  				hedr.TrySetValue (8' maxID + 1);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (tes4 != null) {  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		hedr.TrySetValue (4' reccount);  		if (Properties.Settings.Default.AutoUpdateNextFormID) {  			var minId = new uint[] {  				0x0801  			};  			var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  			var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  			uint curid;  			if (hedr.TryGetValue (8' out curid) && maxID >= curid)  				hedr.TrySetValue (8' maxID + 1);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (tes4 != null) {  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		hedr.TrySetValue (4' reccount);  		if (Properties.Settings.Default.AutoUpdateNextFormID) {  			var minId = new uint[] {  				0x0801  			};  			var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  			var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  			uint curid;  			if (hedr.TryGetValue (8' out curid) && maxID >= curid)  				hedr.TrySetValue (8' maxID + 1);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (tes4 != null) {  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		hedr.TrySetValue (4' reccount);  		if (Properties.Settings.Default.AutoUpdateNextFormID) {  			var minId = new uint[] {  				0x0801  			};  			var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  			var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  			uint curid;  			if (hedr.TryGetValue (8' out curid) && maxID >= curid)  				hedr.TrySetValue (8' maxID + 1);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (tes4 != null) {  	var hedr = tes4.SubRecords [0];  	if (hedr.Name == "HEDR" && hedr.Size >= 12) {  		hedr.TrySetValue (4' reccount);  		if (Properties.Settings.Default.AutoUpdateNextFormID) {  			var minId = new uint[] {  				0x0801  			};  			var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  			var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  			uint curid;  			if (hedr.TryGetValue (8' out curid) && maxID >= curid)  				hedr.TrySetValue (8' maxID + 1);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	hedr.TrySetValue (4' reccount);  	if (Properties.Settings.Default.AutoUpdateNextFormID) {  		var minId = new uint[] {  			0x0801  		};  		var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  		var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  		uint curid;  		if (hedr.TryGetValue (8' out curid) && maxID >= curid)  			hedr.TrySetValue (8' maxID + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	hedr.TrySetValue (4' reccount);  	if (Properties.Settings.Default.AutoUpdateNextFormID) {  		var minId = new uint[] {  			0x0801  		};  		var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  		var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  		uint curid;  		if (hedr.TryGetValue (8' out curid) && maxID >= curid)  			hedr.TrySetValue (8' maxID + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	hedr.TrySetValue (4' reccount);  	if (Properties.Settings.Default.AutoUpdateNextFormID) {  		var minId = new uint[] {  			0x0801  		};  		var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  		var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  		uint curid;  		if (hedr.TryGetValue (8' out curid) && maxID >= curid)  			hedr.TrySetValue (8' maxID + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	hedr.TrySetValue (4' reccount);  	if (Properties.Settings.Default.AutoUpdateNextFormID) {  		var minId = new uint[] {  			0x0801  		};  		var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  		var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  		uint curid;  		if (hedr.TryGetValue (8' out curid) && maxID >= curid)  			hedr.TrySetValue (8' maxID + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (hedr.Name == "HEDR" && hedr.Size >= 12) {  	hedr.TrySetValue (4' reccount);  	if (Properties.Settings.Default.AutoUpdateNextFormID) {  		var minId = new uint[] {  			0x0801  		};  		var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  		var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  		uint curid;  		if (hedr.TryGetValue (8' out curid) && maxID >= curid)  			hedr.TrySetValue (8' maxID + 1);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: hedr.TrySetValue (4' reccount);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (Properties.Settings.Default.AutoUpdateNextFormID) {  	var minId = new uint[] {  		0x0801  	};  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  	uint curid;  	if (hedr.TryGetValue (8' out curid) && maxID >= curid)  		hedr.TrySetValue (8' maxID + 1);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (Properties.Settings.Default.AutoUpdateNextFormID) {  	var minId = new uint[] {  		0x0801  	};  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  	uint curid;  	if (hedr.TryGetValue (8' out curid) && maxID >= curid)  		hedr.TrySetValue (8' maxID + 1);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (Properties.Settings.Default.AutoUpdateNextFormID) {  	var minId = new uint[] {  		0x0801  	};  	var masterCount = tes4.SubRecords.Count (x => x.Name == "MAST");  	var maxID = this.Records.OfType<BaseRecord> ().SelectMany (x => x.Enumerate ()).OfType<Record> ().Where (x => (x.FormID >> 24) == masterCount).Select (x => x.FormID & 0x00FFFFFF).Union (minId).Max ();  	uint curid;  	if (hedr.TryGetValue (8' out curid) && maxID >= curid)  		hedr.TrySetValue (8' maxID + 1);  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (hedr.TryGetValue (8' out curid) && maxID >= curid)  	hedr.TrySetValue (8' maxID + 1);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: if (hedr.TryGetValue (8' out curid) && maxID >= curid)  	hedr.TrySetValue (8' maxID + 1);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,UpdateRecordCount,The following statement contains a magic number: hedr.TrySetValue (8' maxID + 1);  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,DetectVersion,The following statement contains a magic number: br.BaseStream.Position = 20;  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: try {  	string s;  	uint recsize;  	this.Filtered = includeFilter != null;  	HoldUpdates = true;  	Decompressor.Init ();  	s = ReadRecName (br);  	if (s != this.define.HEDRType) {  		throw new Exception ("File is not a valid TES4 plugin (Missing TES4 record)");  	}  	// Check for file version by checking the position of the HEDR field in the file. (ie. how big are the record header.)  	br.BaseStream.Position = define.HEDROffset;  	s = ReadRecName (br);  	if (s != "HEDR")  		throw new Exception (string.Format ("File is not a valid {0} plugin (Missing HEDR subrecord in the {1} record)"' define.Name' define.HEDRType));  	br.BaseStream.Position = 4;  	recsize = br.ReadUInt32 ();  	try {  		this.AddRecord (new Record (this.define.HEDRType' recsize' br' this.define));  	} catch (Exception e) {  		Alerts.Show (e.Message);  	}  	//bool hasExtraFlags = Math.Abs(version - 1.0f) > float.Epsilon * 10.0f;  	if (!headerOnly) {  		while (br.PeekChar () != -1) {  			s = ReadRecName (br);  			recsize = br.ReadUInt32 ();  			if (s == "GRUP") {  				try {  					this.AddRecord (new GroupRecord (recsize' br' this.define' includeFilter' false));  				} catch (Exception e) {  					Alerts.Show (e.Message);  				}  			} else {  				bool skip = includeFilter != null && !includeFilter (s);  				if (skip) {  					long size = recsize + define.RecSize;  					if ((br.ReadUInt32 () & 0x00040000) > 0) {  						size += 4;  						// Add 4 bytes for compressed record since the decompressed size is not included in the record size.  					}  					br.BaseStream.Position += size;  					// just position past the data  				} else {  					try {  						this.AddRecord (new Record (s' recsize' br' define));  					} catch (Exception e) {  						Alerts.Show (e.Message);  					}  				}  			}  		}  	}  	foreach (var rec in Enumerate (x => x is IGroupRecord || x is Record))  		rec.UpdateShortDescription ();  	this.UpdateRecordCount ();  } finally {  	HoldUpdates = oldHoldUpdates;  	FireRecordListUpdate (this' this);  	Decompressor.Close ();  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: try {  	string s;  	uint recsize;  	this.Filtered = includeFilter != null;  	HoldUpdates = true;  	Decompressor.Init ();  	s = ReadRecName (br);  	if (s != this.define.HEDRType) {  		throw new Exception ("File is not a valid TES4 plugin (Missing TES4 record)");  	}  	// Check for file version by checking the position of the HEDR field in the file. (ie. how big are the record header.)  	br.BaseStream.Position = define.HEDROffset;  	s = ReadRecName (br);  	if (s != "HEDR")  		throw new Exception (string.Format ("File is not a valid {0} plugin (Missing HEDR subrecord in the {1} record)"' define.Name' define.HEDRType));  	br.BaseStream.Position = 4;  	recsize = br.ReadUInt32 ();  	try {  		this.AddRecord (new Record (this.define.HEDRType' recsize' br' this.define));  	} catch (Exception e) {  		Alerts.Show (e.Message);  	}  	//bool hasExtraFlags = Math.Abs(version - 1.0f) > float.Epsilon * 10.0f;  	if (!headerOnly) {  		while (br.PeekChar () != -1) {  			s = ReadRecName (br);  			recsize = br.ReadUInt32 ();  			if (s == "GRUP") {  				try {  					this.AddRecord (new GroupRecord (recsize' br' this.define' includeFilter' false));  				} catch (Exception e) {  					Alerts.Show (e.Message);  				}  			} else {  				bool skip = includeFilter != null && !includeFilter (s);  				if (skip) {  					long size = recsize + define.RecSize;  					if ((br.ReadUInt32 () & 0x00040000) > 0) {  						size += 4;  						// Add 4 bytes for compressed record since the decompressed size is not included in the record size.  					}  					br.BaseStream.Position += size;  					// just position past the data  				} else {  					try {  						this.AddRecord (new Record (s' recsize' br' define));  					} catch (Exception e) {  						Alerts.Show (e.Message);  					}  				}  			}  		}  	}  	foreach (var rec in Enumerate (x => x is IGroupRecord || x is Record))  		rec.UpdateShortDescription ();  	this.UpdateRecordCount ();  } finally {  	HoldUpdates = oldHoldUpdates;  	FireRecordListUpdate (this' this);  	Decompressor.Close ();  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: br.BaseStream.Position = 4;  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: if (!headerOnly) {  	while (br.PeekChar () != -1) {  		s = ReadRecName (br);  		recsize = br.ReadUInt32 ();  		if (s == "GRUP") {  			try {  				this.AddRecord (new GroupRecord (recsize' br' this.define' includeFilter' false));  			} catch (Exception e) {  				Alerts.Show (e.Message);  			}  		} else {  			bool skip = includeFilter != null && !includeFilter (s);  			if (skip) {  				long size = recsize + define.RecSize;  				if ((br.ReadUInt32 () & 0x00040000) > 0) {  					size += 4;  					// Add 4 bytes for compressed record since the decompressed size is not included in the record size.  				}  				br.BaseStream.Position += size;  				// just position past the data  			} else {  				try {  					this.AddRecord (new Record (s' recsize' br' define));  				} catch (Exception e) {  					Alerts.Show (e.Message);  				}  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: while (br.PeekChar () != -1) {  	s = ReadRecName (br);  	recsize = br.ReadUInt32 ();  	if (s == "GRUP") {  		try {  			this.AddRecord (new GroupRecord (recsize' br' this.define' includeFilter' false));  		} catch (Exception e) {  			Alerts.Show (e.Message);  		}  	} else {  		bool skip = includeFilter != null && !includeFilter (s);  		if (skip) {  			long size = recsize + define.RecSize;  			if ((br.ReadUInt32 () & 0x00040000) > 0) {  				size += 4;  				// Add 4 bytes for compressed record since the decompressed size is not included in the record size.  			}  			br.BaseStream.Position += size;  			// just position past the data  		} else {  			try {  				this.AddRecord (new Record (s' recsize' br' define));  			} catch (Exception e) {  				Alerts.Show (e.Message);  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: if (s == "GRUP") {  	try {  		this.AddRecord (new GroupRecord (recsize' br' this.define' includeFilter' false));  	} catch (Exception e) {  		Alerts.Show (e.Message);  	}  } else {  	bool skip = includeFilter != null && !includeFilter (s);  	if (skip) {  		long size = recsize + define.RecSize;  		if ((br.ReadUInt32 () & 0x00040000) > 0) {  			size += 4;  			// Add 4 bytes for compressed record since the decompressed size is not included in the record size.  		}  		br.BaseStream.Position += size;  		// just position past the data  	} else {  		try {  			this.AddRecord (new Record (s' recsize' br' define));  		} catch (Exception e) {  			Alerts.Show (e.Message);  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: if (skip) {  	long size = recsize + define.RecSize;  	if ((br.ReadUInt32 () & 0x00040000) > 0) {  		size += 4;  		// Add 4 bytes for compressed record since the decompressed size is not included in the record size.  	}  	br.BaseStream.Position += size;  	// just position past the data  } else {  	try {  		this.AddRecord (new Record (s' recsize' br' define));  	} catch (Exception e) {  		Alerts.Show (e.Message);  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: if ((br.ReadUInt32 () & 0x00040000) > 0) {  	size += 4;  	// Add 4 bytes for compressed record since the decompressed size is not included in the record size.  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginData,The following statement contains a magic number: size += 4;  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,The following statement contains a magic number: using (var stream = new MemoryStream (data' 0' size' true' false)) {  	var buffer = new byte[65536];  	int left = size;  	while (left > 0) {  		int read = Math.Min (left' buffer.Length);  		int nread = reader.BaseStream.Read (buffer' 0' read);  		if (nread == 0) {  			break;  		}  		stream.Write (buffer' 0' nread);  		left -= nread;  	}  }  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,The following statement contains a magic number: using (var stream = new MemoryStream ())  	using (var memWriter = new BinaryWriter (stream)) {  		foreach (var kvp in strings) {  			list.Add (new Pair<uint' uint> (kvp.Key' (uint)stream.Position));  			byte[] data = enc.GetBytes (kvp.Value);  			switch (format) {  			case LocalizedStringFormat.Base:  				memWriter.Write (data' 0' data.Length);  				memWriter.Write ((byte)0);  				break;  			case LocalizedStringFormat.DL:  			case LocalizedStringFormat.IL:  				memWriter.Write (data.Length + 1);  				memWriter.Write (data' 0' data.Length);  				memWriter.Write ((byte)0);  				break;  			}  		}  		writer.Write (strings.Count);  		writer.Write ((int)stream.Length);  		foreach (var item in list) {  			writer.Write (item.Key);  			writer.Write (item.Value);  		}  		stream.Position = 0;  		var buffer = new byte[65536];  		var left = (int)stream.Length;  		while (left > 0) {  			int read = Math.Min (left' buffer.Length);  			int nread = stream.Read (buffer' 0' read);  			if (nread == 0) {  				break;  			}  			writer.Write (buffer' 0' nread);  			left -= nread;  		}  	}  
Magic Number,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,The following statement contains a magic number: using (var memWriter = new BinaryWriter (stream)) {  	foreach (var kvp in strings) {  		list.Add (new Pair<uint' uint> (kvp.Key' (uint)stream.Position));  		byte[] data = enc.GetBytes (kvp.Value);  		switch (format) {  		case LocalizedStringFormat.Base:  			memWriter.Write (data' 0' data.Length);  			memWriter.Write ((byte)0);  			break;  		case LocalizedStringFormat.DL:  		case LocalizedStringFormat.IL:  			memWriter.Write (data.Length + 1);  			memWriter.Write (data' 0' data.Length);  			memWriter.Write ((byte)0);  			break;  		}  	}  	writer.Write (strings.Count);  	writer.Write ((int)stream.Length);  	foreach (var item in list) {  		writer.Write (item.Key);  		writer.Write (item.Value);  	}  	stream.Position = 0;  	var buffer = new byte[65536];  	var left = (int)stream.Length;  	while (left > 0) {  		int read = Math.Min (left' buffer.Length);  		int nread = stream.Read (buffer' 0' read);  		if (nread == 0) {  			break;  		}  		writer.Write (buffer' 0' nread);  		left -= nread;  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: if (define.RecSize >= 12)  	Flags2 = recordReader.ReadUInt32 ();  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: if (define.RecSize >= 16)  	Flags3 = recordReader.ReadUInt32 ();  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: if (compressed) {  	realSize = recordReader.ReadUInt32 ();  	dataSize -= 4;  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: dataSize -= 4;  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: using (var stream = new MemoryStream (recordReader.ReadBytes ((int)dataSize)' false))  	using (var br = new BinaryReader (stream)) {  		var dataReader = compressed ? Decompressor.Decompress (br' (int)dataSize' (int)realSize' out compressLevel) : br;  		{  			while (true) {  				long left = dataReader.BaseStream.Length - dataReader.BaseStream.Position;  				if (left < 4) {  					break;  				}  				string type = ReadRecName (dataReader);  				uint size;  				if (type == "XXXX") {  					dataReader.ReadUInt16 ();  					size = dataReader.ReadUInt32 ();  					type = ReadRecName (dataReader);  					dataReader.ReadUInt16 ();  				} else {  					size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  				}  				var record = new SubRecord (this' type' dataReader' size);  				SubRecords.Add (record);  				amountRead += (uint)record.Size2;  			}  		}  	}  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: using (var stream = new MemoryStream (recordReader.ReadBytes ((int)dataSize)' false))  	using (var br = new BinaryReader (stream)) {  		var dataReader = compressed ? Decompressor.Decompress (br' (int)dataSize' (int)realSize' out compressLevel) : br;  		{  			while (true) {  				long left = dataReader.BaseStream.Length - dataReader.BaseStream.Position;  				if (left < 4) {  					break;  				}  				string type = ReadRecName (dataReader);  				uint size;  				if (type == "XXXX") {  					dataReader.ReadUInt16 ();  					size = dataReader.ReadUInt32 ();  					type = ReadRecName (dataReader);  					dataReader.ReadUInt16 ();  				} else {  					size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  				}  				var record = new SubRecord (this' type' dataReader' size);  				SubRecords.Add (record);  				amountRead += (uint)record.Size2;  			}  		}  	}  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var dataReader = compressed ? Decompressor.Decompress (br' (int)dataSize' (int)realSize' out compressLevel) : br;  	{  		while (true) {  			long left = dataReader.BaseStream.Length - dataReader.BaseStream.Position;  			if (left < 4) {  				break;  			}  			string type = ReadRecName (dataReader);  			uint size;  			if (type == "XXXX") {  				dataReader.ReadUInt16 ();  				size = dataReader.ReadUInt32 ();  				type = ReadRecName (dataReader);  				dataReader.ReadUInt16 ();  			} else {  				size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  			}  			var record = new SubRecord (this' type' dataReader' size);  			SubRecords.Add (record);  			amountRead += (uint)record.Size2;  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var dataReader = compressed ? Decompressor.Decompress (br' (int)dataSize' (int)realSize' out compressLevel) : br;  	{  		while (true) {  			long left = dataReader.BaseStream.Length - dataReader.BaseStream.Position;  			if (left < 4) {  				break;  			}  			string type = ReadRecName (dataReader);  			uint size;  			if (type == "XXXX") {  				dataReader.ReadUInt16 ();  				size = dataReader.ReadUInt32 ();  				type = ReadRecName (dataReader);  				dataReader.ReadUInt16 ();  			} else {  				size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  			}  			var record = new SubRecord (this' type' dataReader' size);  			SubRecords.Add (record);  			amountRead += (uint)record.Size2;  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: while (true) {  	long left = dataReader.BaseStream.Length - dataReader.BaseStream.Position;  	if (left < 4) {  		break;  	}  	string type = ReadRecName (dataReader);  	uint size;  	if (type == "XXXX") {  		dataReader.ReadUInt16 ();  		size = dataReader.ReadUInt32 ();  		type = ReadRecName (dataReader);  		dataReader.ReadUInt16 ();  	} else {  		size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  	}  	var record = new SubRecord (this' type' dataReader' size);  	SubRecords.Add (record);  	amountRead += (uint)record.Size2;  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: while (true) {  	long left = dataReader.BaseStream.Length - dataReader.BaseStream.Position;  	if (left < 4) {  		break;  	}  	string type = ReadRecName (dataReader);  	uint size;  	if (type == "XXXX") {  		dataReader.ReadUInt16 ();  		size = dataReader.ReadUInt32 ();  		type = ReadRecName (dataReader);  		dataReader.ReadUInt16 ();  	} else {  		size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  	}  	var record = new SubRecord (this' type' dataReader' size);  	SubRecords.Add (record);  	amountRead += (uint)record.Size2;  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: if (left < 4) {  	break;  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: if (type == "XXXX") {  	dataReader.ReadUInt16 ();  	size = dataReader.ReadUInt32 ();  	type = ReadRecName (dataReader);  	dataReader.ReadUInt16 ();  } else {  	size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,Record,The following statement contains a magic number: size = define.HEDRRecSize == 2 ? dataReader.ReadUInt16 () : dataReader.ReadUInt32 ();  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: try {  	if (Name == "REFR") {  		// temporary hack for references  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  		// var name = SubRecords.FirstOrDefault( x => x.Name == "NAME" );  		var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  		if (data != null) {  			desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  		}  		descriptiveName = desc;  	} else if (Name == "ACHR") {  		// temporary hack for references  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  		var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  		if (data != null) {  			desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  		}  		descriptiveName = desc;  	} else if (Name == "CELL") {  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  		var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  		if (xclc != null) {  			desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  		} else {  			desc = string.Format (" [Intr]\t{0}"' desc);  		}  		descriptiveName = desc;  	} else {  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		if (edid != null) {  			descriptiveName = " (" + edid.GetStrData () + ")";  		} else {  			descriptiveName = string.Empty;  		}  	}  } catch (Exception ex) {  	string msg = ex.Message;  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: try {  	if (Name == "REFR") {  		// temporary hack for references  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  		// var name = SubRecords.FirstOrDefault( x => x.Name == "NAME" );  		var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  		if (data != null) {  			desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  		}  		descriptiveName = desc;  	} else if (Name == "ACHR") {  		// temporary hack for references  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  		var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  		if (data != null) {  			desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  		}  		descriptiveName = desc;  	} else if (Name == "CELL") {  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  		var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  		if (xclc != null) {  			desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  		} else {  			desc = string.Format (" [Intr]\t{0}"' desc);  		}  		descriptiveName = desc;  	} else {  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		if (edid != null) {  			descriptiveName = " (" + edid.GetStrData () + ")";  		} else {  			descriptiveName = string.Empty;  		}  	}  } catch (Exception ex) {  	string msg = ex.Message;  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: try {  	if (Name == "REFR") {  		// temporary hack for references  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  		// var name = SubRecords.FirstOrDefault( x => x.Name == "NAME" );  		var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  		if (data != null) {  			desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  		}  		descriptiveName = desc;  	} else if (Name == "ACHR") {  		// temporary hack for references  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  		var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  		if (data != null) {  			desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  		}  		descriptiveName = desc;  	} else if (Name == "CELL") {  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  		var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  		if (xclc != null) {  			desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  		} else {  			desc = string.Format (" [Intr]\t{0}"' desc);  		}  		descriptiveName = desc;  	} else {  		var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  		if (edid != null) {  			descriptiveName = " (" + edid.GetStrData () + ")";  		} else {  			descriptiveName = string.Empty;  		}  	}  } catch (Exception ex) {  	string msg = ex.Message;  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (Name == "REFR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	// var name = SubRecords.FirstOrDefault( x => x.Name == "NAME" );  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "ACHR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "CELL") {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  	var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  	if (xclc != null) {  		desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  	} else {  		desc = string.Format (" [Intr]\t{0}"' desc);  	}  	descriptiveName = desc;  } else {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	if (edid != null) {  		descriptiveName = " (" + edid.GetStrData () + ")";  	} else {  		descriptiveName = string.Empty;  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (Name == "REFR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	// var name = SubRecords.FirstOrDefault( x => x.Name == "NAME" );  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "ACHR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "CELL") {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  	var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  	if (xclc != null) {  		desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  	} else {  		desc = string.Format (" [Intr]\t{0}"' desc);  	}  	descriptiveName = desc;  } else {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	if (edid != null) {  		descriptiveName = " (" + edid.GetStrData () + ")";  	} else {  		descriptiveName = string.Empty;  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (Name == "REFR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	// var name = SubRecords.FirstOrDefault( x => x.Name == "NAME" );  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "ACHR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "CELL") {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  	var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  	if (xclc != null) {  		desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  	} else {  		desc = string.Format (" [Intr]\t{0}"' desc);  	}  	descriptiveName = desc;  } else {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	if (edid != null) {  		descriptiveName = " (" + edid.GetStrData () + ")";  	} else {  		descriptiveName = string.Empty;  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (data != null) {  	desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (Name == "ACHR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "CELL") {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  	var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  	if (xclc != null) {  		desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  	} else {  		desc = string.Format (" [Intr]\t{0}"' desc);  	}  	descriptiveName = desc;  } else {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	if (edid != null) {  		descriptiveName = " (" + edid.GetStrData () + ")";  	} else {  		descriptiveName = string.Empty;  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (Name == "ACHR") {  	// temporary hack for references  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? string.Format (" ({0})"' edid.GetStrData ()) : string.Empty;  	var data = this.SubRecords.FirstOrDefault (x => x.Name == "DATA");  	if (data != null) {  		desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  	}  	descriptiveName = desc;  } else if (Name == "CELL") {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  	var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  	if (xclc != null) {  		desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  	} else {  		desc = string.Format (" [Intr]\t{0}"' desc);  	}  	descriptiveName = desc;  } else {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	if (edid != null) {  		descriptiveName = " (" + edid.GetStrData () + ")";  	} else {  		descriptiveName = string.Empty;  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (data != null) {  	desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: desc = string.Format (" [{1}'{2}]\t{0}"' desc' (int)(data.GetValue<float> (0) / 4096.0f)' (int)(data.GetValue<float> (4) / 4096.0f));  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (Name == "CELL") {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	string desc = (edid != null) ? desc = " (" + edid.GetStrData () + ")" : string.Empty;  	var xclc = this.SubRecords.FirstOrDefault (x => x.Name == "XCLC");  	if (xclc != null) {  		desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  	} else {  		desc = string.Format (" [Intr]\t{0}"' desc);  	}  	descriptiveName = desc;  } else {  	var edid = this.SubRecords.FirstOrDefault (x => x.Name == "EDID");  	if (edid != null) {  		descriptiveName = " (" + edid.GetStrData () + ")";  	} else {  		descriptiveName = string.Empty;  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: if (xclc != null) {  	desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  } else {  	desc = string.Format (" [Intr]\t{0}"' desc);  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,UpdateShortDescription,The following statement contains a magic number: desc = string.Format (" [{1:F0}'{2:F0}]\t{0}"' desc' xclc.GetValue<int> (0)' xclc.GetValue<int> (4));  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The following statement contains a magic number: using (var stream = new MemoryStream ()) {  	var dataWriter = new BinaryWriter (stream);  	foreach (var subRecord in this.SubRecords) {  		subRecord.SaveData (dataWriter);  	}  	realSize = (uint)stream.Length;  	if (Properties.Settings.Default.UseDefaultRecordCompression) {  		compressed = ((this.Flags1 & 0x00040000) != 0) || (Properties.Settings.Default.EnableAutoCompress && Compressor.CompressRecord (Name)) || (Properties.Settings.Default.EnableCompressionLimit && (realSize >= Properties.Settings.Default.CompressionLimit));  	}  	if (Properties.Settings.Default.UsePluginRecordCompression) {  		compressed = (this.Flags1 & 0x00040000) != 0;  	}  	data = stream.ToArray ();  	if (compressed)// compressed  	 {  		data = Compressor.Compress (data' (compressLevel == 0) ? 9 : compressLevel);  	}  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The following statement contains a magic number: if (compressed)// compressed   {  	data = Compressor.Compress (data' (compressLevel == 0) ? 9 : compressLevel);  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The following statement contains a magic number: data = Compressor.Compress (data' (compressLevel == 0) ? 9 : compressLevel);  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The following statement contains a magic number: if (compressed) {  	dataSize += 4;  	flags |= 0x00040000;  	Debug.WriteLineIf (this.dataSize != dataSize' string.Format ("COMPRESSED RECORD [NAME={0} AT POSITION={1}] SIZE DIFFERS FROM ORIGINAL: ORIGINAL={2} ACTUAL={3}' RAW RECORD SIZE={4}"' Name' position' this.dataSize' dataSize' realSize));  }  
Magic Number,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,SaveData,The following statement contains a magic number: dataSize += 4;  
Magic Number,TESVSnip.Domain.Model,SearchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,The following statement contains a magic number: if (numText.StartsWith ("0x")) {  	numStyle = NumberStyles.HexNumber;  	numText = strvalue.Substring (2);  }  
Magic Number,TESVSnip.Domain.Model,SearchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,The following statement contains a magic number: numText = strvalue.Substring (2);  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: if (srs != null) {  	Name = srs.name;  	int size = 0;  	if (srs.size > 0) {  		size = srs.size;  	} else {  		foreach (var elem in srs.elements) {  			if (elem.optional == 0 || elem.repeat == 0) {  				switch (elem.type) {  				case ElementValueType.FormID:  				case ElementValueType.LString:  				case ElementValueType.Int:  				case ElementValueType.UInt:  				case ElementValueType.Float:  				case ElementValueType.Str4:  				case ElementValueType.IString:  					size += 4;  					break;  				case ElementValueType.BString:  				case ElementValueType.Short:  				case ElementValueType.UShort:  					size += 2;  					break;  				case ElementValueType.String:  				case ElementValueType.Byte:  				case ElementValueType.SByte:  					size += 1;  					break;  				}  			}  		}  	}  	this.Data = new byte[size];  	// TODO: populate with defaults if provided...  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: if (srs != null) {  	Name = srs.name;  	int size = 0;  	if (srs.size > 0) {  		size = srs.size;  	} else {  		foreach (var elem in srs.elements) {  			if (elem.optional == 0 || elem.repeat == 0) {  				switch (elem.type) {  				case ElementValueType.FormID:  				case ElementValueType.LString:  				case ElementValueType.Int:  				case ElementValueType.UInt:  				case ElementValueType.Float:  				case ElementValueType.Str4:  				case ElementValueType.IString:  					size += 4;  					break;  				case ElementValueType.BString:  				case ElementValueType.Short:  				case ElementValueType.UShort:  					size += 2;  					break;  				case ElementValueType.String:  				case ElementValueType.Byte:  				case ElementValueType.SByte:  					size += 1;  					break;  				}  			}  		}  	}  	this.Data = new byte[size];  	// TODO: populate with defaults if provided...  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: if (srs.size > 0) {  	size = srs.size;  } else {  	foreach (var elem in srs.elements) {  		if (elem.optional == 0 || elem.repeat == 0) {  			switch (elem.type) {  			case ElementValueType.FormID:  			case ElementValueType.LString:  			case ElementValueType.Int:  			case ElementValueType.UInt:  			case ElementValueType.Float:  			case ElementValueType.Str4:  			case ElementValueType.IString:  				size += 4;  				break;  			case ElementValueType.BString:  			case ElementValueType.Short:  			case ElementValueType.UShort:  				size += 2;  				break;  			case ElementValueType.String:  			case ElementValueType.Byte:  			case ElementValueType.SByte:  				size += 1;  				break;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: if (srs.size > 0) {  	size = srs.size;  } else {  	foreach (var elem in srs.elements) {  		if (elem.optional == 0 || elem.repeat == 0) {  			switch (elem.type) {  			case ElementValueType.FormID:  			case ElementValueType.LString:  			case ElementValueType.Int:  			case ElementValueType.UInt:  			case ElementValueType.Float:  			case ElementValueType.Str4:  			case ElementValueType.IString:  				size += 4;  				break;  			case ElementValueType.BString:  			case ElementValueType.Short:  			case ElementValueType.UShort:  				size += 2;  				break;  			case ElementValueType.String:  			case ElementValueType.Byte:  			case ElementValueType.SByte:  				size += 1;  				break;  			}  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: foreach (var elem in srs.elements) {  	if (elem.optional == 0 || elem.repeat == 0) {  		switch (elem.type) {  		case ElementValueType.FormID:  		case ElementValueType.LString:  		case ElementValueType.Int:  		case ElementValueType.UInt:  		case ElementValueType.Float:  		case ElementValueType.Str4:  		case ElementValueType.IString:  			size += 4;  			break;  		case ElementValueType.BString:  		case ElementValueType.Short:  		case ElementValueType.UShort:  			size += 2;  			break;  		case ElementValueType.String:  		case ElementValueType.Byte:  		case ElementValueType.SByte:  			size += 1;  			break;  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: foreach (var elem in srs.elements) {  	if (elem.optional == 0 || elem.repeat == 0) {  		switch (elem.type) {  		case ElementValueType.FormID:  		case ElementValueType.LString:  		case ElementValueType.Int:  		case ElementValueType.UInt:  		case ElementValueType.Float:  		case ElementValueType.Str4:  		case ElementValueType.IString:  			size += 4;  			break;  		case ElementValueType.BString:  		case ElementValueType.Short:  		case ElementValueType.UShort:  			size += 2;  			break;  		case ElementValueType.String:  		case ElementValueType.Byte:  		case ElementValueType.SByte:  			size += 1;  			break;  		}  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: if (elem.optional == 0 || elem.repeat == 0) {  	switch (elem.type) {  	case ElementValueType.FormID:  	case ElementValueType.LString:  	case ElementValueType.Int:  	case ElementValueType.UInt:  	case ElementValueType.Float:  	case ElementValueType.Str4:  	case ElementValueType.IString:  		size += 4;  		break;  	case ElementValueType.BString:  	case ElementValueType.Short:  	case ElementValueType.UShort:  		size += 2;  		break;  	case ElementValueType.String:  	case ElementValueType.Byte:  	case ElementValueType.SByte:  		size += 1;  		break;  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: if (elem.optional == 0 || elem.repeat == 0) {  	switch (elem.type) {  	case ElementValueType.FormID:  	case ElementValueType.LString:  	case ElementValueType.Int:  	case ElementValueType.UInt:  	case ElementValueType.Float:  	case ElementValueType.Str4:  	case ElementValueType.IString:  		size += 4;  		break;  	case ElementValueType.BString:  	case ElementValueType.Short:  	case ElementValueType.UShort:  		size += 2;  		break;  	case ElementValueType.String:  	case ElementValueType.Byte:  	case ElementValueType.SByte:  		size += 1;  		break;  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: switch (elem.type) {  case ElementValueType.FormID:  case ElementValueType.LString:  case ElementValueType.Int:  case ElementValueType.UInt:  case ElementValueType.Float:  case ElementValueType.Str4:  case ElementValueType.IString:  	size += 4;  	break;  case ElementValueType.BString:  case ElementValueType.Short:  case ElementValueType.UShort:  	size += 2;  	break;  case ElementValueType.String:  case ElementValueType.Byte:  case ElementValueType.SByte:  	size += 1;  	break;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: switch (elem.type) {  case ElementValueType.FormID:  case ElementValueType.LString:  case ElementValueType.Int:  case ElementValueType.UInt:  case ElementValueType.Float:  case ElementValueType.Str4:  case ElementValueType.IString:  	size += 4;  	break;  case ElementValueType.BString:  case ElementValueType.Short:  case ElementValueType.UShort:  	size += 2;  	break;  case ElementValueType.String:  case ElementValueType.Byte:  case ElementValueType.SByte:  	size += 1;  	break;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: size += 4;  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following statement contains a magic number: size += 2;  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetHexData,The following statement contains a magic number: foreach (byte b in this.Data) {  	s += b.ToString ("X").PadLeft (2' '0') + " ";  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetHexData,The following statement contains a magic number: s += b.ToString ("X").PadLeft (2' '0') + " ";  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type) {  case ElementValueType.FormID:  	{  		var id = (uint)value;  		strValue = id.ToString ("X8");  		if (id != 0) {  			rec = p.GetRecordByID (id);  			if (rec != null) {  				strValue = string.Format ("{0}: {1}"' strValue' rec.DescriptiveName);  			}  		}  		value = strValue;  	}  	break;  case ElementValueType.LString:  	if (value is uint) {  		if (p != null) {  			value = p.LookupFormStrings ((uint)value) ?? value;  		}  	}  	break;  case ElementValueType.Blob:  	value = TypeConverter.GetHexData (elem.Data);  	break;  case ElementValueType.SByte:  case ElementValueType.Int:  case ElementValueType.Short:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			int intVal;  			if (sselem.hexview || hasFlags) {  				intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == int.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			int intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.UInt:  case ElementValueType.Byte:  case ElementValueType.UShort:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			uint intVal;  			if (sselem.hexview || hasFlags) {  				intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToUInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == uint.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			uint intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.Str4:  	strValue = TypeConverter.GetString (elem.Data);  	break;  case ElementValueType.BString:  	strValue = TypeConverter.GetBString (elem.Data);  	break;  case ElementValueType.IString:  	strValue = TypeConverter.GetIString (elem.Data);  	break;  default:  	strValue = value == null ? string.Empty : value.ToString ();  	break;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type) {  case ElementValueType.FormID:  	{  		var id = (uint)value;  		strValue = id.ToString ("X8");  		if (id != 0) {  			rec = p.GetRecordByID (id);  			if (rec != null) {  				strValue = string.Format ("{0}: {1}"' strValue' rec.DescriptiveName);  			}  		}  		value = strValue;  	}  	break;  case ElementValueType.LString:  	if (value is uint) {  		if (p != null) {  			value = p.LookupFormStrings ((uint)value) ?? value;  		}  	}  	break;  case ElementValueType.Blob:  	value = TypeConverter.GetHexData (elem.Data);  	break;  case ElementValueType.SByte:  case ElementValueType.Int:  case ElementValueType.Short:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			int intVal;  			if (sselem.hexview || hasFlags) {  				intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == int.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			int intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.UInt:  case ElementValueType.Byte:  case ElementValueType.UShort:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			uint intVal;  			if (sselem.hexview || hasFlags) {  				intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToUInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == uint.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			uint intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.Str4:  	strValue = TypeConverter.GetString (elem.Data);  	break;  case ElementValueType.BString:  	strValue = TypeConverter.GetBString (elem.Data);  	break;  case ElementValueType.IString:  	strValue = TypeConverter.GetIString (elem.Data);  	break;  default:  	strValue = value == null ? string.Empty : value.ToString ();  	break;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type) {  case ElementValueType.FormID:  	{  		var id = (uint)value;  		strValue = id.ToString ("X8");  		if (id != 0) {  			rec = p.GetRecordByID (id);  			if (rec != null) {  				strValue = string.Format ("{0}: {1}"' strValue' rec.DescriptiveName);  			}  		}  		value = strValue;  	}  	break;  case ElementValueType.LString:  	if (value is uint) {  		if (p != null) {  			value = p.LookupFormStrings ((uint)value) ?? value;  		}  	}  	break;  case ElementValueType.Blob:  	value = TypeConverter.GetHexData (elem.Data);  	break;  case ElementValueType.SByte:  case ElementValueType.Int:  case ElementValueType.Short:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			int intVal;  			if (sselem.hexview || hasFlags) {  				intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == int.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			int intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.UInt:  case ElementValueType.Byte:  case ElementValueType.UShort:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			uint intVal;  			if (sselem.hexview || hasFlags) {  				intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToUInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == uint.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			uint intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.Str4:  	strValue = TypeConverter.GetString (elem.Data);  	break;  case ElementValueType.BString:  	strValue = TypeConverter.GetBString (elem.Data);  	break;  case ElementValueType.IString:  	strValue = TypeConverter.GetIString (elem.Data);  	break;  default:  	strValue = value == null ? string.Empty : value.ToString ();  	break;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: switch (elem.Structure.type) {  case ElementValueType.FormID:  	{  		var id = (uint)value;  		strValue = id.ToString ("X8");  		if (id != 0) {  			rec = p.GetRecordByID (id);  			if (rec != null) {  				strValue = string.Format ("{0}: {1}"' strValue' rec.DescriptiveName);  			}  		}  		value = strValue;  	}  	break;  case ElementValueType.LString:  	if (value is uint) {  		if (p != null) {  			value = p.LookupFormStrings ((uint)value) ?? value;  		}  	}  	break;  case ElementValueType.Blob:  	value = TypeConverter.GetHexData (elem.Data);  	break;  case ElementValueType.SByte:  case ElementValueType.Int:  case ElementValueType.Short:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			int intVal;  			if (sselem.hexview || hasFlags) {  				intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == int.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			int intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.UInt:  case ElementValueType.Byte:  case ElementValueType.UShort:  	{  		if (sselem.hexview || hasFlags) {  			value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  		} else {  			value = value ?? string.Empty;  		}  		if (hasOptions) {  			uint intVal;  			if (sselem.hexview || hasFlags) {  				intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			} else {  				intVal = Convert.ToUInt32 (value);  			}  			for (int k = 0; k < sselem.options.Length; k += 2) {  				if (intVal == uint.Parse (sselem.options [k + 1])) {  					value = sselem.options [k];  				}  			}  		} else if (hasFlags) {  			uint intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  			var tmp2 = new StringBuilder ();  			for (int k = 0; k < sselem.flags.Length; k++) {  				if ((intVal & (1 << k)) != 0) {  					if (tmp2.Length > 0) {  						tmp2.Append ("' ");  					}  					tmp2.Append (sselem.flags [k]);  				}  			}  			tmp2.Insert (0' ": ");  			tmp2.Insert (0' value.ToString ());  			value = tmp2.ToString ();  		}  	}  	break;  case ElementValueType.Str4:  	strValue = TypeConverter.GetString (elem.Data);  	break;  case ElementValueType.BString:  	strValue = TypeConverter.GetBString (elem.Data);  	break;  case ElementValueType.IString:  	strValue = TypeConverter.GetIString (elem.Data);  	break;  default:  	strValue = value == null ? string.Empty : value.ToString ();  	break;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: if (sselem.hexview || hasFlags) {  	value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  } else {  	value = value ?? string.Empty;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: if (hasOptions) {  	int intVal;  	if (sselem.hexview || hasFlags) {  		intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  	} else {  		intVal = Convert.ToInt32 (value);  	}  	for (int k = 0; k < sselem.options.Length; k += 2) {  		if (intVal == int.Parse (sselem.options [k + 1])) {  			value = sselem.options [k];  		}  	}  } else if (hasFlags) {  	int intVal = int.Parse (value.ToString ()' NumberStyles.HexNumber);  	var tmp2 = new StringBuilder ();  	for (int k = 0; k < sselem.flags.Length; k++) {  		if ((intVal & (1 << k)) != 0) {  			if (tmp2.Length > 0) {  				tmp2.Append ("' ");  			}  			tmp2.Append (sselem.flags [k]);  		}  	}  	tmp2.Insert (0' ": ");  	tmp2.Insert (0' value.ToString ());  	value = tmp2.ToString ();  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: for (int k = 0; k < sselem.options.Length; k += 2) {  	if (intVal == int.Parse (sselem.options [k + 1])) {  		value = sselem.options [k];  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: k += 2
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: if (sselem.hexview || hasFlags) {  	value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  } else {  	value = value ?? string.Empty;  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: value = string.Format (string.Format ("{{0:X{0}}}"' elem.Data.Count * 2)' value);  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: if (hasOptions) {  	uint intVal;  	if (sselem.hexview || hasFlags) {  		intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  	} else {  		intVal = Convert.ToUInt32 (value);  	}  	for (int k = 0; k < sselem.options.Length; k += 2) {  		if (intVal == uint.Parse (sselem.options [k + 1])) {  			value = sselem.options [k];  		}  	}  } else if (hasFlags) {  	uint intVal = uint.Parse (value.ToString ()' NumberStyles.HexNumber);  	var tmp2 = new StringBuilder ();  	for (int k = 0; k < sselem.flags.Length; k++) {  		if ((intVal & (1 << k)) != 0) {  			if (tmp2.Length > 0) {  				tmp2.Append ("' ");  			}  			tmp2.Append (sselem.flags [k]);  		}  	}  	tmp2.Insert (0' ": ");  	tmp2.Insert (0' value.ToString ());  	value = tmp2.ToString ();  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: for (int k = 0; k < sselem.options.Length; k += 2) {  	if (intVal == uint.Parse (sselem.options [k + 1])) {  		value = sselem.options [k];  	}  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetDisplayValue,The following statement contains a magic number: k += 2
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SaveData,The following statement contains a magic number: if (this.Data.Length > ushort.MaxValue) {  	WriteString (writer' "XXXX");  	writer.Write ((ushort)4);  	writer.Write (this.Data.Length);  	WriteString (writer' Name);  	writer.Write ((ushort)0);  	writer.Write (this.Data' 0' this.Data.Length);  } else {  	WriteString (writer' Name);  	writer.Write ((ushort)this.Data.Length);  	writer.Write (this.Data' 0' this.Data.Length);  }  
Magic Number,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SaveData,The following statement contains a magic number: writer.Write ((ushort)4);  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: if (!string.IsNullOrWhiteSpace (p)) {  	string[] parameters = p.Split (''');  	param = new object[parameters.Length];  	for (int i = 0; i < parameters.Length; i++) {  		// management of the decimal separator  		parameters [i] = parameters [i].Trim ();  		parameters [i] = parameters [i].Replace ("."' _ni.CurrencyDecimalSeparator);  		parameters [i] = parameters [i].Replace ("'"' _ni.CurrencyDecimalSeparator);  	}  	try {  		for (int i = 0; i < parameters.Length; i++) {  			switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  			{  			case "float":  				param [i] = float.Parse (parameters [i]' _ni);  				break;  			case "int":  				param [i] = int.Parse (parameters [i]' _ni);  				break;  			case "short":  				param [i] = short.Parse (parameters [i]' _ni);  				break;  			case "uint":  				param [i] = uint.Parse (parameters [i]' _ni);  				break;  			case "ushort":  				param [i] = ushort.Parse (parameters [i]' _ni);  				break;  			}  		}  	} catch (Exception ex) {  		Alerts.Show (string.Format (@"ExecuteReadingFunction: {0}"' ex.Message)' @"TESSnip Error");  		throw;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: try {  	for (int i = 0; i < parameters.Length; i++) {  		switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  		{  		case "float":  			param [i] = float.Parse (parameters [i]' _ni);  			break;  		case "int":  			param [i] = int.Parse (parameters [i]' _ni);  			break;  		case "short":  			param [i] = short.Parse (parameters [i]' _ni);  			break;  		case "uint":  			param [i] = uint.Parse (parameters [i]' _ni);  			break;  		case "ushort":  			param [i] = ushort.Parse (parameters [i]' _ni);  			break;  		}  	}  } catch (Exception ex) {  	Alerts.Show (string.Format (@"ExecuteReadingFunction: {0}"' ex.Message)' @"TESSnip Error");  	throw;  }  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: for (int i = 0; i < parameters.Length; i++) {  	switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  	{  	case "float":  		param [i] = float.Parse (parameters [i]' _ni);  		break;  	case "int":  		param [i] = int.Parse (parameters [i]' _ni);  		break;  	case "short":  		param [i] = short.Parse (parameters [i]' _ni);  		break;  	case "uint":  		param [i] = uint.Parse (parameters [i]' _ni);  		break;  	case "ushort":  		param [i] = ushort.Parse (parameters [i]' _ni);  		break;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  {  case "float":  	param [i] = float.Parse (parameters [i]' _ni);  	break;  case "int":  	param [i] = int.Parse (parameters [i]' _ni);  	break;  case "short":  	param [i] = short.Parse (parameters [i]' _ni);  	break;  case "uint":  	param [i] = uint.Parse (parameters [i]' _ni);  	break;  case "ushort":  	param [i] = ushort.Parse (parameters [i]' _ni);  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: if (!string.IsNullOrWhiteSpace (p)) {  	string[] parameters = p.Split (''');  	param = new object[parameters.Length];  	for (int i = 0; i < parameters.Length; i++) {  		// management of the decimal separator  		parameters [i] = parameters [i].Trim ();  		parameters [i] = parameters [i].Replace ("."' _ni.CurrencyDecimalSeparator);  		parameters [i] = parameters [i].Replace ("'"' _ni.CurrencyDecimalSeparator);  	}  	try {  		for (int i = 0; i < parameters.Length; i++) {  			if (pyFunc != null)  				switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  				{  				case "float":  					param [i] = float.Parse (parameters [i]' _ni);  					break;  				case "int":  					param [i] = int.Parse (parameters [i]' _ni);  					break;  				case "short":  					param [i] = short.Parse (parameters [i]' _ni);  					break;  				case "uint":  					param [i] = uint.Parse (parameters [i]' _ni);  					break;  				case "ushort":  					param [i] = ushort.Parse (parameters [i]' _ni);  					break;  				}  		}  	} catch (Exception ex) {  		Alerts.Show (string.Format (@"ExecuteWritingFunction: {0}"' ex.Message)' @"TESSnip Error");  		throw;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: try {  	for (int i = 0; i < parameters.Length; i++) {  		if (pyFunc != null)  			switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  			{  			case "float":  				param [i] = float.Parse (parameters [i]' _ni);  				break;  			case "int":  				param [i] = int.Parse (parameters [i]' _ni);  				break;  			case "short":  				param [i] = short.Parse (parameters [i]' _ni);  				break;  			case "uint":  				param [i] = uint.Parse (parameters [i]' _ni);  				break;  			case "ushort":  				param [i] = ushort.Parse (parameters [i]' _ni);  				break;  			}  	}  } catch (Exception ex) {  	Alerts.Show (string.Format (@"ExecuteWritingFunction: {0}"' ex.Message)' @"TESSnip Error");  	throw;  }  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: for (int i = 0; i < parameters.Length; i++) {  	if (pyFunc != null)  		switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  		{  		case "float":  			param [i] = float.Parse (parameters [i]' _ni);  			break;  		case "int":  			param [i] = int.Parse (parameters [i]' _ni);  			break;  		case "short":  			param [i] = short.Parse (parameters [i]' _ni);  			break;  		case "uint":  			param [i] = uint.Parse (parameters [i]' _ni);  			break;  		case "ushort":  			param [i] = ushort.Parse (parameters [i]' _ni);  			break;  		}  }  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: if (pyFunc != null)  	switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  	{  	case "float":  		param [i] = float.Parse (parameters [i]' _ni);  		break;  	case "int":  		param [i] = int.Parse (parameters [i]' _ni);  		break;  	case "short":  		param [i] = short.Parse (parameters [i]' _ni);  		break;  	case "uint":  		param [i] = uint.Parse (parameters [i]' _ni);  		break;  	case "ushort":  		param [i] = ushort.Parse (parameters [i]' _ni);  		break;  	}  
Magic Number,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following statement contains a magic number: switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  {  case "float":  	param [i] = float.Parse (parameters [i]' _ni);  	break;  case "int":  	param [i] = int.Parse (parameters [i]' _ni);  	break;  case "short":  	param [i] = short.Parse (parameters [i]' _ni);  	break;  case "uint":  	param [i] = uint.Parse (parameters [i]' _ni);  	break;  case "ushort":  	param [i] = ushort.Parse (parameters [i]' _ni);  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: foreach (SubRecord sr2 in r2.SubRecords) {  	if (sr2.Name == "SCTX") {  		script = sr2.GetStrData ();  	}  	if (sr2.Name == "SCHR") {  		byte[] tmp = sr2.GetReadonlyData ();  		scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: foreach (SubRecord sr2 in r2.SubRecords) {  	if (sr2.Name == "SCTX") {  		script = sr2.GetStrData ();  	}  	if (sr2.Name == "SCHR") {  		byte[] tmp = sr2.GetReadonlyData ();  		scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: foreach (SubRecord sr2 in r2.SubRecords) {  	if (sr2.Name == "SCTX") {  		script = sr2.GetStrData ();  	}  	if (sr2.Name == "SCHR") {  		byte[] tmp = sr2.GetReadonlyData ();  		scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: foreach (SubRecord sr2 in r2.SubRecords) {  	if (sr2.Name == "SCTX") {  		script = sr2.GetStrData ();  	}  	if (sr2.Name == "SCHR") {  		byte[] tmp = sr2.GetReadonlyData ();  		scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: if (sr2.Name == "SCHR") {  	byte[] tmp = sr2.GetReadonlyData ();  	scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: if (sr2.Name == "SCHR") {  	byte[] tmp = sr2.GetReadonlyData ();  	scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: if (sr2.Name == "SCHR") {  	byte[] tmp = sr2.GetReadonlyData ();  	scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: if (sr2.Name == "SCHR") {  	byte[] tmp = sr2.GetReadonlyData ();  	scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: scptype = TypeConverter.h2si (tmp [16]' tmp [17]' tmp [18]' tmp [19]);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: if (smt.Length != 2 || !smt [0].IsKeyword (Keywords.ScriptName) || smt [1].token == null) {  	return ReturnError ("Expected 'ScriptName <edid>'"' out msg);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.si2h (refcount' header' 4);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.i2h ((uint)bw.BaseStream.Length' header' 8);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.si2h (localList.Count' header' 12);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Compile,The following statement contains a magic number: TypeConverter.si2h (scptype' header' 16);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.si2h (refcount' header' 4);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.i2h ((uint)bw.BaseStream.Length' header' 8);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.si2h (localList.Count' header' 12);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,CompileResultScript,The following statement contains a magic number: TypeConverter.si2h (0x10000' header' 16);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: for (uint i = 0; i < plugins.Length - 1; i++) {  	var plugin = plugins [i];  	if (plugin == null) {  		continue;  	}  	if (plugin.Records.OfType<BaseRecord> ().FirstOrDefault (x => x.Name.StartsWith ("TES")) == null) {  		continue;  	}  	mask = (uint)plugin.Masters.Count ();  	mask <<= 24;  	uint id = i << 24;  	foreach (Rec r in plugin.Records) {  		RecursePlugin (r' mask' id' records' quests' refs);  	}  	foreach (var recs in refs) {  		if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  			quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  		} else if (records.ContainsKey (recs.Key)) {  			Record r = records [recs.Key];  			uint formID = 0;  			foreach (SubRecord sr in r.SubRecords) {  				if (sr.Name == "SCRI") {  					byte[] bytes = sr.GetReadonlyData ();  					uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  					if ((formid & 0xff000000) == mask) {  						formID = (formid & 0xffffff) + id;  						break;  					}  				}  			}  			quests.Add (new Pair<uint' Record> (formID' recs.Value));  		}  	}  	RefLookupTable.Clear ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: for (uint i = 0; i < plugins.Length - 1; i++) {  	var plugin = plugins [i];  	if (plugin == null) {  		continue;  	}  	if (plugin.Records.OfType<BaseRecord> ().FirstOrDefault (x => x.Name.StartsWith ("TES")) == null) {  		continue;  	}  	mask = (uint)plugin.Masters.Count ();  	mask <<= 24;  	uint id = i << 24;  	foreach (Rec r in plugin.Records) {  		RecursePlugin (r' mask' id' records' quests' refs);  	}  	foreach (var recs in refs) {  		if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  			quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  		} else if (records.ContainsKey (recs.Key)) {  			Record r = records [recs.Key];  			uint formID = 0;  			foreach (SubRecord sr in r.SubRecords) {  				if (sr.Name == "SCRI") {  					byte[] bytes = sr.GetReadonlyData ();  					uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  					if ((formid & 0xff000000) == mask) {  						formID = (formid & 0xffffff) + id;  						break;  					}  				}  			}  			quests.Add (new Pair<uint' Record> (formID' recs.Value));  		}  	}  	RefLookupTable.Clear ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: for (uint i = 0; i < plugins.Length - 1; i++) {  	var plugin = plugins [i];  	if (plugin == null) {  		continue;  	}  	if (plugin.Records.OfType<BaseRecord> ().FirstOrDefault (x => x.Name.StartsWith ("TES")) == null) {  		continue;  	}  	mask = (uint)plugin.Masters.Count ();  	mask <<= 24;  	uint id = i << 24;  	foreach (Rec r in plugin.Records) {  		RecursePlugin (r' mask' id' records' quests' refs);  	}  	foreach (var recs in refs) {  		if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  			quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  		} else if (records.ContainsKey (recs.Key)) {  			Record r = records [recs.Key];  			uint formID = 0;  			foreach (SubRecord sr in r.SubRecords) {  				if (sr.Name == "SCRI") {  					byte[] bytes = sr.GetReadonlyData ();  					uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  					if ((formid & 0xff000000) == mask) {  						formID = (formid & 0xffffff) + id;  						break;  					}  				}  			}  			quests.Add (new Pair<uint' Record> (formID' recs.Value));  		}  	}  	RefLookupTable.Clear ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: for (uint i = 0; i < plugins.Length - 1; i++) {  	var plugin = plugins [i];  	if (plugin == null) {  		continue;  	}  	if (plugin.Records.OfType<BaseRecord> ().FirstOrDefault (x => x.Name.StartsWith ("TES")) == null) {  		continue;  	}  	mask = (uint)plugin.Masters.Count ();  	mask <<= 24;  	uint id = i << 24;  	foreach (Rec r in plugin.Records) {  		RecursePlugin (r' mask' id' records' quests' refs);  	}  	foreach (var recs in refs) {  		if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  			quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  		} else if (records.ContainsKey (recs.Key)) {  			Record r = records [recs.Key];  			uint formID = 0;  			foreach (SubRecord sr in r.SubRecords) {  				if (sr.Name == "SCRI") {  					byte[] bytes = sr.GetReadonlyData ();  					uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  					if ((formid & 0xff000000) == mask) {  						formID = (formid & 0xffffff) + id;  						break;  					}  				}  			}  			quests.Add (new Pair<uint' Record> (formID' recs.Value));  		}  	}  	RefLookupTable.Clear ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: mask <<= 24;  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (var recs in refs) {  	if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  		quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  	} else if (records.ContainsKey (recs.Key)) {  		Record r = records [recs.Key];  		uint formID = 0;  		foreach (SubRecord sr in r.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				if ((formid & 0xff000000) == mask) {  					formID = (formid & 0xffffff) + id;  					break;  				}  			}  		}  		quests.Add (new Pair<uint' Record> (formID' recs.Value));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (var recs in refs) {  	if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  		quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  	} else if (records.ContainsKey (recs.Key)) {  		Record r = records [recs.Key];  		uint formID = 0;  		foreach (SubRecord sr in r.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				if ((formid & 0xff000000) == mask) {  					formID = (formid & 0xffffff) + id;  					break;  				}  			}  		}  		quests.Add (new Pair<uint' Record> (formID' recs.Value));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  	quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  } else if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) == mask) {  				formID = (formid & 0xffffff) + id;  				break;  			}  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  	quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  } else if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) == mask) {  				formID = (formid & 0xffffff) + id;  				break;  			}  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) == mask) {  				formID = (formid & 0xffffff) + id;  				break;  			}  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) == mask) {  				formID = (formid & 0xffffff) + id;  				break;  			}  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (SubRecord sr in r.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) == mask) {  			formID = (formid & 0xffffff) + id;  			break;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (SubRecord sr in r.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) == mask) {  			formID = (formid & 0xffffff) + id;  			break;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	if ((formid & 0xff000000) == mask) {  		formID = (formid & 0xffffff) + id;  		break;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	if ((formid & 0xff000000) == mask) {  		formID = (formid & 0xffffff) + id;  		break;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (var recs in refs) {  	if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  		quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  	} else if (records.ContainsKey (recs.Key)) {  		Record r = records [recs.Key];  		uint formID = 0;  		foreach (SubRecord sr in r.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				break;  			}  		}  		quests.Add (new Pair<uint' Record> (formID' recs.Value));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (var recs in refs) {  	if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  		quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  	} else if (records.ContainsKey (recs.Key)) {  		Record r = records [recs.Key];  		uint formID = 0;  		foreach (SubRecord sr in r.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				break;  			}  		}  		quests.Add (new Pair<uint' Record> (formID' recs.Value));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  	quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  } else if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			break;  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (RefLookupTable.ContainsKey (recs.Key) && RefLookupTable [recs.Key] != 0) {  	quests.Add (new Pair<uint' Record> (RefLookupTable [recs.Key]' recs.Value));  } else if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			break;  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			break;  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (records.ContainsKey (recs.Key)) {  	Record r = records [recs.Key];  	uint formID = 0;  	foreach (SubRecord sr in r.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			break;  		}  	}  	quests.Add (new Pair<uint' Record> (formID' recs.Value));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (SubRecord sr in r.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		break;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: foreach (SubRecord sr in r.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		break;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Setup,The following statement contains a magic number: formID = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: if (smt.Length > fs.args.Length + 2) {  	AddError ("Too many arguments to 'begin' block");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: if (fs.args.Length > 0) {  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		switch (fs.args [i - 2]) {  		case VarType.Short:  			if (smt [i].type != TokenType.Integer) {  				AddError ("Block argument: Expected short");  			} else {  				Emit (ushort.Parse (smt [i].token));  			}  			break;  		case VarType.Int:  			if (smt [i].type != TokenType.Integer) {  				AddError ("Block argument: Expected integer");  			} else {  				EmitByte (0x73);  				EmitLong (uint.Parse (smt [i].token));  			}  			break;  		case VarType.Ref:  			if (smt [i].type != TokenType.edid) {  				AddError ("Block argument: Expected edid");  			} else {  				EmitRefLabel (smt [i]' RefType.Expression);  			}  			break;  		default:  			AddError ("Sanity check failed. VarType of block argument was invalid");  			break;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: if (fs.args.Length > 0) {  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		switch (fs.args [i - 2]) {  		case VarType.Short:  			if (smt [i].type != TokenType.Integer) {  				AddError ("Block argument: Expected short");  			} else {  				Emit (ushort.Parse (smt [i].token));  			}  			break;  		case VarType.Int:  			if (smt [i].type != TokenType.Integer) {  				AddError ("Block argument: Expected integer");  			} else {  				EmitByte (0x73);  				EmitLong (uint.Parse (smt [i].token));  			}  			break;  		case VarType.Ref:  			if (smt [i].type != TokenType.edid) {  				AddError ("Block argument: Expected edid");  			} else {  				EmitRefLabel (smt [i]' RefType.Expression);  			}  			break;  		default:  			AddError ("Sanity check failed. VarType of block argument was invalid");  			break;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: if (fs.args.Length > 0) {  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		switch (fs.args [i - 2]) {  		case VarType.Short:  			if (smt [i].type != TokenType.Integer) {  				AddError ("Block argument: Expected short");  			} else {  				Emit (ushort.Parse (smt [i].token));  			}  			break;  		case VarType.Int:  			if (smt [i].type != TokenType.Integer) {  				AddError ("Block argument: Expected integer");  			} else {  				EmitByte (0x73);  				EmitLong (uint.Parse (smt [i].token));  			}  			break;  		case VarType.Ref:  			if (smt [i].type != TokenType.edid) {  				AddError ("Block argument: Expected edid");  			} else {  				EmitRefLabel (smt [i]' RefType.Expression);  			}  			break;  		default:  			AddError ("Sanity check failed. VarType of block argument was invalid");  			break;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: Emit ((ushort)(smt.Length - 2));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: for (int i = 2; i < smt.Length; i++) {  	switch (fs.args [i - 2]) {  	case VarType.Short:  		if (smt [i].type != TokenType.Integer) {  			AddError ("Block argument: Expected short");  		} else {  			Emit (ushort.Parse (smt [i].token));  		}  		break;  	case VarType.Int:  		if (smt [i].type != TokenType.Integer) {  			AddError ("Block argument: Expected integer");  		} else {  			EmitByte (0x73);  			EmitLong (uint.Parse (smt [i].token));  		}  		break;  	case VarType.Ref:  		if (smt [i].type != TokenType.edid) {  			AddError ("Block argument: Expected edid");  		} else {  			EmitRefLabel (smt [i]' RefType.Expression);  		}  		break;  	default:  		AddError ("Sanity check failed. VarType of block argument was invalid");  		break;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: for (int i = 2; i < smt.Length; i++) {  	switch (fs.args [i - 2]) {  	case VarType.Short:  		if (smt [i].type != TokenType.Integer) {  			AddError ("Block argument: Expected short");  		} else {  			Emit (ushort.Parse (smt [i].token));  		}  		break;  	case VarType.Int:  		if (smt [i].type != TokenType.Integer) {  			AddError ("Block argument: Expected integer");  		} else {  			EmitByte (0x73);  			EmitLong (uint.Parse (smt [i].token));  		}  		break;  	case VarType.Ref:  		if (smt [i].type != TokenType.edid) {  			AddError ("Block argument: Expected edid");  		} else {  			EmitRefLabel (smt [i]' RefType.Expression);  		}  		break;  	default:  		AddError ("Sanity check failed. VarType of block argument was invalid");  		break;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: switch (fs.args [i - 2]) {  case VarType.Short:  	if (smt [i].type != TokenType.Integer) {  		AddError ("Block argument: Expected short");  	} else {  		Emit (ushort.Parse (smt [i].token));  	}  	break;  case VarType.Int:  	if (smt [i].type != TokenType.Integer) {  		AddError ("Block argument: Expected integer");  	} else {  		EmitByte (0x73);  		EmitLong (uint.Parse (smt [i].token));  	}  	break;  case VarType.Ref:  	if (smt [i].type != TokenType.edid) {  		AddError ("Block argument: Expected edid");  	} else {  		EmitRefLabel (smt [i]' RefType.Expression);  	}  	break;  default:  	AddError ("Sanity check failed. VarType of block argument was invalid");  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitBegin,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitExpression,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (smt.Length == 1) {  	if (fs.requiredArgs > 0) {  		AddError ("Not enough arguments to function");  	}  	if (fs.args.Length > 0) {  		Emit (2);  	}  	Emit (0);  	smt = new Token[0];  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (fs.args.Length > 0) {  	Emit (2);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: Emit (2);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: while (true) {  	i++;  	if (i == smt.Length) {  		if (argcount < fs.requiredArgs) {  			AddError ("Not enough arguments to function. Expected " + fs.requiredArgs);  		}  		smt = new Token[0];  		break;  	}  	if (smt [i].type == TokenType.Symbol) {  		if (smt [i].IsSymbol (".") && lastwasref) {  			if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  				i++;  				EmitByte (0x73);  				Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  				if (!vars.ContainsKey (smt [i].token)) {  					AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  				} else {  					Emit (vars [smt [i].token]);  				}  				continue;  			}  		} else if (smt [i].IsSymbol ("-") && (!expression || (argcount < fs.requiredArgs))) {  			if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  				smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  				continue;  			}  		}  		if (expression) {  			if (argcount < fs.requiredArgs) {  				AddError ("Not enough arguments to function. Expected " + fs.requiredArgs);  			}  			for (int j = i; j < smt.Length; j++) {  				smt [j - i] = smt [j];  			}  			Array.Resize (ref smt' smt.Length - i);  			break;  		} else {  			AddError ("Unexpected symbol '" + smt [i].token + "' in function arguments");  		}  	}  	if (argcount == fs.args.Length) {  		AddError ("Too many arguments given to function. Expected " + fs.args.Length);  	}  	argcount++;  	lastwasref = false;  	switch (fs.args [argcount - 1]) {  	case VarType.Axis:  		switch (smt [i].token) {  		case "x":  			EmitByte ((byte)'X');  			continue;  		case "y":  			EmitByte ((byte)'Y');  			continue;  		case "z":  			EmitByte ((byte)'Z');  			continue;  		default:  			AddError ("Expected 'x'' 'y' or 'z'");  			continue;  		}  	case VarType.Enum:  		if (smt [i].type == TokenType.Integer) {  			Emit (ushort.Parse (smt [i].token));  		} else {  			Dictionary<string' ushort> Enum = enumList [fs.reftypes [argcount - 1]];  			if (!Enum.ContainsKey (smt [i].token)) {  				AddError ("'" + smt [i].token + "' is not a valid entry of the enum '" + fs.reftypes [argcount - 1] + "'");  			} else {  				Emit (Enum [smt [i].token]);  			}  		}  		continue;  	case VarType.Short:  		if (smt [i].type != TokenType.Integer) {  			AddError ("Expected integer argument");  		} else {  			Emit (ushort.Parse (smt [i].token));  		}  		continue;  	case VarType.String:  		Emit ((ushort)smt [i].token.Length);  		bw.Write (System.Text.Encoding.Default.GetBytes (smt [i].token));  		continue;  	}  	switch (smt [i].type) {  	case TokenType.edid:  		if (i == smt.Length - 1 || !smt [i + 1].IsSymbol (".")) {  			if (fs.args [argcount - 1] != VarType.Ref) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			if (fs.reftypes [argcount - 1] != null && fs.reftypes [argcount - 1] != edidList [smt [i].token].Value) {  				AddError ("Invalid record type at argument " + i + " of function. Expected " + fs.reftypes [argcount - 1]);  			}  		}  		EmitRefLabel (smt [i]' RefType.Expression);  		lastwasref = true;  		break;  	case TokenType.Local:  		LocalVar vt = locals [smt [i].token];  		switch (vt.type) {  		case VarType.Int:  			if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			EmitByte (0x73);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Float:  			if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			EmitByte (0x66);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Ref:  			if (fs.args [argcount - 1] != VarType.Ref) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		}  		break;  	case TokenType.Global:  		if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  			AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  		}  		EmitRefLabel (smt [i]' RefType.Expression);  		break;  	case TokenType.Integer:  		if (fs.args [argcount - 1] == VarType.Float) {  			goto case TokenType.Float;  		}  		if (fs.args [argcount - 1] != VarType.Int) {  			AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  		}  		EmitByte (0x6e);  		bw.Write (int.Parse (smt [i].token));  		break;  	case TokenType.Float:  		if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  			AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  		}  		EmitByte (0x7a);  		bw.Write (double.Parse (smt [i].token));  		break;  	default:  		AddError ("Expected <global>|<local>|<constant>");  		return;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: while (true) {  	i++;  	if (i == smt.Length) {  		if (argcount < fs.requiredArgs) {  			AddError ("Not enough arguments to function. Expected " + fs.requiredArgs);  		}  		smt = new Token[0];  		break;  	}  	if (smt [i].type == TokenType.Symbol) {  		if (smt [i].IsSymbol (".") && lastwasref) {  			if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  				i++;  				EmitByte (0x73);  				Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  				if (!vars.ContainsKey (smt [i].token)) {  					AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  				} else {  					Emit (vars [smt [i].token]);  				}  				continue;  			}  		} else if (smt [i].IsSymbol ("-") && (!expression || (argcount < fs.requiredArgs))) {  			if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  				smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  				continue;  			}  		}  		if (expression) {  			if (argcount < fs.requiredArgs) {  				AddError ("Not enough arguments to function. Expected " + fs.requiredArgs);  			}  			for (int j = i; j < smt.Length; j++) {  				smt [j - i] = smt [j];  			}  			Array.Resize (ref smt' smt.Length - i);  			break;  		} else {  			AddError ("Unexpected symbol '" + smt [i].token + "' in function arguments");  		}  	}  	if (argcount == fs.args.Length) {  		AddError ("Too many arguments given to function. Expected " + fs.args.Length);  	}  	argcount++;  	lastwasref = false;  	switch (fs.args [argcount - 1]) {  	case VarType.Axis:  		switch (smt [i].token) {  		case "x":  			EmitByte ((byte)'X');  			continue;  		case "y":  			EmitByte ((byte)'Y');  			continue;  		case "z":  			EmitByte ((byte)'Z');  			continue;  		default:  			AddError ("Expected 'x'' 'y' or 'z'");  			continue;  		}  	case VarType.Enum:  		if (smt [i].type == TokenType.Integer) {  			Emit (ushort.Parse (smt [i].token));  		} else {  			Dictionary<string' ushort> Enum = enumList [fs.reftypes [argcount - 1]];  			if (!Enum.ContainsKey (smt [i].token)) {  				AddError ("'" + smt [i].token + "' is not a valid entry of the enum '" + fs.reftypes [argcount - 1] + "'");  			} else {  				Emit (Enum [smt [i].token]);  			}  		}  		continue;  	case VarType.Short:  		if (smt [i].type != TokenType.Integer) {  			AddError ("Expected integer argument");  		} else {  			Emit (ushort.Parse (smt [i].token));  		}  		continue;  	case VarType.String:  		Emit ((ushort)smt [i].token.Length);  		bw.Write (System.Text.Encoding.Default.GetBytes (smt [i].token));  		continue;  	}  	switch (smt [i].type) {  	case TokenType.edid:  		if (i == smt.Length - 1 || !smt [i + 1].IsSymbol (".")) {  			if (fs.args [argcount - 1] != VarType.Ref) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			if (fs.reftypes [argcount - 1] != null && fs.reftypes [argcount - 1] != edidList [smt [i].token].Value) {  				AddError ("Invalid record type at argument " + i + " of function. Expected " + fs.reftypes [argcount - 1]);  			}  		}  		EmitRefLabel (smt [i]' RefType.Expression);  		lastwasref = true;  		break;  	case TokenType.Local:  		LocalVar vt = locals [smt [i].token];  		switch (vt.type) {  		case VarType.Int:  			if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			EmitByte (0x73);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Float:  			if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			EmitByte (0x66);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Ref:  			if (fs.args [argcount - 1] != VarType.Ref) {  				AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  			}  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		}  		break;  	case TokenType.Global:  		if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  			AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  		}  		EmitRefLabel (smt [i]' RefType.Expression);  		break;  	case TokenType.Integer:  		if (fs.args [argcount - 1] == VarType.Float) {  			goto case TokenType.Float;  		}  		if (fs.args [argcount - 1] != VarType.Int) {  			AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  		}  		EmitByte (0x6e);  		bw.Write (int.Parse (smt [i].token));  		break;  	case TokenType.Float:  		if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  			AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  		}  		EmitByte (0x7a);  		bw.Write (double.Parse (smt [i].token));  		break;  	default:  		AddError ("Expected <global>|<local>|<constant>");  		return;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (smt [i].type == TokenType.Symbol) {  	if (smt [i].IsSymbol (".") && lastwasref) {  		if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  			i++;  			EmitByte (0x73);  			Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  			if (!vars.ContainsKey (smt [i].token)) {  				AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  			} else {  				Emit (vars [smt [i].token]);  			}  			continue;  		}  	} else if (smt [i].IsSymbol ("-") && (!expression || (argcount < fs.requiredArgs))) {  		if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  			smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  			continue;  		}  	}  	if (expression) {  		if (argcount < fs.requiredArgs) {  			AddError ("Not enough arguments to function. Expected " + fs.requiredArgs);  		}  		for (int j = i; j < smt.Length; j++) {  			smt [j - i] = smt [j];  		}  		Array.Resize (ref smt' smt.Length - i);  		break;  	} else {  		AddError ("Unexpected symbol '" + smt [i].token + "' in function arguments");  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (smt [i].type == TokenType.Symbol) {  	if (smt [i].IsSymbol (".") && lastwasref) {  		if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  			i++;  			EmitByte (0x73);  			Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  			if (!vars.ContainsKey (smt [i].token)) {  				AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  			} else {  				Emit (vars [smt [i].token]);  			}  			continue;  		}  	} else if (smt [i].IsSymbol ("-") && (!expression || (argcount < fs.requiredArgs))) {  		if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  			smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  			continue;  		}  	}  	if (expression) {  		if (argcount < fs.requiredArgs) {  			AddError ("Not enough arguments to function. Expected " + fs.requiredArgs);  		}  		for (int j = i; j < smt.Length; j++) {  			smt [j - i] = smt [j];  		}  		Array.Resize (ref smt' smt.Length - i);  		break;  	} else {  		AddError ("Unexpected symbol '" + smt [i].token + "' in function arguments");  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (smt [i].IsSymbol (".") && lastwasref) {  	if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  		i++;  		EmitByte (0x73);  		Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  		if (!vars.ContainsKey (smt [i].token)) {  			AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  		} else {  			Emit (vars [smt [i].token]);  		}  		continue;  	}  } else if (smt [i].IsSymbol ("-") && (!expression || (argcount < fs.requiredArgs))) {  	if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  		smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  		continue;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (smt [i].IsSymbol (".") && lastwasref) {  	if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  		i++;  		EmitByte (0x73);  		Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  		if (!vars.ContainsKey (smt [i].token)) {  			AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  		} else {  			Emit (vars [smt [i].token]);  		}  		continue;  	}  } else if (smt [i].IsSymbol ("-") && (!expression || (argcount < fs.requiredArgs))) {  	if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  		smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  		continue;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  	i++;  	EmitByte (0x73);  	Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  	if (!vars.ContainsKey (smt [i].token)) {  		AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  	} else {  		Emit (vars [smt [i].token]);  	}  	continue;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  	i++;  	EmitByte (0x73);  	Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  	if (!vars.ContainsKey (smt [i].token)) {  		AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  	} else {  		Emit (vars [smt [i].token]);  	}  	continue;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: if (!vars.ContainsKey (smt [i].token)) {  	AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  } else {  	Emit (vars [smt [i].token]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt.Length == 2) {  	Emit (0);  } else {  	bool lastwasref = false;  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		if (smt [i].type == TokenType.Symbol) {  			if (smt [i].IsSymbol (".") && lastwasref) {  				if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  					i++;  					EmitByte (0x73);  					Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  					if (!vars.ContainsKey (smt [i].token)) {  						AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  					} else {  						Emit (vars [smt [i].token]);  					}  					continue;  				}  			} else if (smt [i].IsSymbol ("-")) {  				if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  					smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  					continue;  				}  			}  			AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  		}  		lastwasref = false;  		switch (smt [i].type) {  		case TokenType.edid:  			EmitRefLabel (smt [i]' RefType.Expression);  			lastwasref = true;  			break;  		case TokenType.Local:  			LocalVar vt = locals [smt [i].token];  			switch (vt.type) {  			case VarType.Int:  				EmitByte (0x73);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Float:  				EmitByte (0x66);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Ref:  				EmitRefLabel (smt [i]' RefType.Expression);  				break;  			}  			break;  		case TokenType.Global:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		case TokenType.Integer:  			EmitByte (0x6e);  			bw.Write (int.Parse (smt [i].token));  			break;  		case TokenType.Float:  			EmitByte (0x7a);  			bw.Write (double.Parse (smt [i].token));  			break;  		default:  			AddError ("Expected <global>|<local>|<constant>");  			return;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt.Length == 2) {  	Emit (0);  } else {  	bool lastwasref = false;  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		if (smt [i].type == TokenType.Symbol) {  			if (smt [i].IsSymbol (".") && lastwasref) {  				if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  					i++;  					EmitByte (0x73);  					Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  					if (!vars.ContainsKey (smt [i].token)) {  						AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  					} else {  						Emit (vars [smt [i].token]);  					}  					continue;  				}  			} else if (smt [i].IsSymbol ("-")) {  				if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  					smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  					continue;  				}  			}  			AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  		}  		lastwasref = false;  		switch (smt [i].type) {  		case TokenType.edid:  			EmitRefLabel (smt [i]' RefType.Expression);  			lastwasref = true;  			break;  		case TokenType.Local:  			LocalVar vt = locals [smt [i].token];  			switch (vt.type) {  			case VarType.Int:  				EmitByte (0x73);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Float:  				EmitByte (0x66);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Ref:  				EmitRefLabel (smt [i]' RefType.Expression);  				break;  			}  			break;  		case TokenType.Global:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		case TokenType.Integer:  			EmitByte (0x6e);  			bw.Write (int.Parse (smt [i].token));  			break;  		case TokenType.Float:  			EmitByte (0x7a);  			bw.Write (double.Parse (smt [i].token));  			break;  		default:  			AddError ("Expected <global>|<local>|<constant>");  			return;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt.Length == 2) {  	Emit (0);  } else {  	bool lastwasref = false;  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		if (smt [i].type == TokenType.Symbol) {  			if (smt [i].IsSymbol (".") && lastwasref) {  				if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  					i++;  					EmitByte (0x73);  					Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  					if (!vars.ContainsKey (smt [i].token)) {  						AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  					} else {  						Emit (vars [smt [i].token]);  					}  					continue;  				}  			} else if (smt [i].IsSymbol ("-")) {  				if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  					smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  					continue;  				}  			}  			AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  		}  		lastwasref = false;  		switch (smt [i].type) {  		case TokenType.edid:  			EmitRefLabel (smt [i]' RefType.Expression);  			lastwasref = true;  			break;  		case TokenType.Local:  			LocalVar vt = locals [smt [i].token];  			switch (vt.type) {  			case VarType.Int:  				EmitByte (0x73);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Float:  				EmitByte (0x66);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Ref:  				EmitRefLabel (smt [i]' RefType.Expression);  				break;  			}  			break;  		case TokenType.Global:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		case TokenType.Integer:  			EmitByte (0x6e);  			bw.Write (int.Parse (smt [i].token));  			break;  		case TokenType.Float:  			EmitByte (0x7a);  			bw.Write (double.Parse (smt [i].token));  			break;  		default:  			AddError ("Expected <global>|<local>|<constant>");  			return;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt.Length == 2) {  	Emit (0);  } else {  	bool lastwasref = false;  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		if (smt [i].type == TokenType.Symbol) {  			if (smt [i].IsSymbol (".") && lastwasref) {  				if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  					i++;  					EmitByte (0x73);  					Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  					if (!vars.ContainsKey (smt [i].token)) {  						AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  					} else {  						Emit (vars [smt [i].token]);  					}  					continue;  				}  			} else if (smt [i].IsSymbol ("-")) {  				if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  					smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  					continue;  				}  			}  			AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  		}  		lastwasref = false;  		switch (smt [i].type) {  		case TokenType.edid:  			EmitRefLabel (smt [i]' RefType.Expression);  			lastwasref = true;  			break;  		case TokenType.Local:  			LocalVar vt = locals [smt [i].token];  			switch (vt.type) {  			case VarType.Int:  				EmitByte (0x73);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Float:  				EmitByte (0x66);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Ref:  				EmitRefLabel (smt [i]' RefType.Expression);  				break;  			}  			break;  		case TokenType.Global:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		case TokenType.Integer:  			EmitByte (0x6e);  			bw.Write (int.Parse (smt [i].token));  			break;  		case TokenType.Float:  			EmitByte (0x7a);  			bw.Write (double.Parse (smt [i].token));  			break;  		default:  			AddError ("Expected <global>|<local>|<constant>");  			return;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt.Length == 2) {  	Emit (0);  } else {  	bool lastwasref = false;  	Emit ((ushort)(smt.Length - 2));  	for (int i = 2; i < smt.Length; i++) {  		if (smt [i].type == TokenType.Symbol) {  			if (smt [i].IsSymbol (".") && lastwasref) {  				if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  					i++;  					EmitByte (0x73);  					Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  					if (!vars.ContainsKey (smt [i].token)) {  						AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  					} else {  						Emit (vars [smt [i].token]);  					}  					continue;  				}  			} else if (smt [i].IsSymbol ("-")) {  				if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  					smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  					continue;  				}  			}  			AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  		}  		lastwasref = false;  		switch (smt [i].type) {  		case TokenType.edid:  			EmitRefLabel (smt [i]' RefType.Expression);  			lastwasref = true;  			break;  		case TokenType.Local:  			LocalVar vt = locals [smt [i].token];  			switch (vt.type) {  			case VarType.Int:  				EmitByte (0x73);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Float:  				EmitByte (0x66);  				Emit ((ushort)locals [smt [i].token].index);  				break;  			case VarType.Ref:  				EmitRefLabel (smt [i]' RefType.Expression);  				break;  			}  			break;  		case TokenType.Global:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		case TokenType.Integer:  			EmitByte (0x6e);  			bw.Write (int.Parse (smt [i].token));  			break;  		case TokenType.Float:  			EmitByte (0x7a);  			bw.Write (double.Parse (smt [i].token));  			break;  		default:  			AddError ("Expected <global>|<local>|<constant>");  			return;  		}  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: Emit ((ushort)(smt.Length - 2));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: for (int i = 2; i < smt.Length; i++) {  	if (smt [i].type == TokenType.Symbol) {  		if (smt [i].IsSymbol (".") && lastwasref) {  			if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  				i++;  				EmitByte (0x73);  				Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  				if (!vars.ContainsKey (smt [i].token)) {  					AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  				} else {  					Emit (vars [smt [i].token]);  				}  				continue;  			}  		} else if (smt [i].IsSymbol ("-")) {  			if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  				smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  				continue;  			}  		}  		AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  	}  	lastwasref = false;  	switch (smt [i].type) {  	case TokenType.edid:  		EmitRefLabel (smt [i]' RefType.Expression);  		lastwasref = true;  		break;  	case TokenType.Local:  		LocalVar vt = locals [smt [i].token];  		switch (vt.type) {  		case VarType.Int:  			EmitByte (0x73);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Float:  			EmitByte (0x66);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Ref:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		}  		break;  	case TokenType.Global:  		EmitRefLabel (smt [i]' RefType.Expression);  		break;  	case TokenType.Integer:  		EmitByte (0x6e);  		bw.Write (int.Parse (smt [i].token));  		break;  	case TokenType.Float:  		EmitByte (0x7a);  		bw.Write (double.Parse (smt [i].token));  		break;  	default:  		AddError ("Expected <global>|<local>|<constant>");  		return;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: for (int i = 2; i < smt.Length; i++) {  	if (smt [i].type == TokenType.Symbol) {  		if (smt [i].IsSymbol (".") && lastwasref) {  			if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  				i++;  				EmitByte (0x73);  				Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  				if (!vars.ContainsKey (smt [i].token)) {  					AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  				} else {  					Emit (vars [smt [i].token]);  				}  				continue;  			}  		} else if (smt [i].IsSymbol ("-")) {  			if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  				smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  				continue;  			}  		}  		AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  	}  	lastwasref = false;  	switch (smt [i].type) {  	case TokenType.edid:  		EmitRefLabel (smt [i]' RefType.Expression);  		lastwasref = true;  		break;  	case TokenType.Local:  		LocalVar vt = locals [smt [i].token];  		switch (vt.type) {  		case VarType.Int:  			EmitByte (0x73);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Float:  			EmitByte (0x66);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Ref:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		}  		break;  	case TokenType.Global:  		EmitRefLabel (smt [i]' RefType.Expression);  		break;  	case TokenType.Integer:  		EmitByte (0x6e);  		bw.Write (int.Parse (smt [i].token));  		break;  	case TokenType.Float:  		EmitByte (0x7a);  		bw.Write (double.Parse (smt [i].token));  		break;  	default:  		AddError ("Expected <global>|<local>|<constant>");  		return;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: for (int i = 2; i < smt.Length; i++) {  	if (smt [i].type == TokenType.Symbol) {  		if (smt [i].IsSymbol (".") && lastwasref) {  			if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  				i++;  				EmitByte (0x73);  				Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  				if (!vars.ContainsKey (smt [i].token)) {  					AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  				} else {  					Emit (vars [smt [i].token]);  				}  				continue;  			}  		} else if (smt [i].IsSymbol ("-")) {  			if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  				smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  				continue;  			}  		}  		AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  	}  	lastwasref = false;  	switch (smt [i].type) {  	case TokenType.edid:  		EmitRefLabel (smt [i]' RefType.Expression);  		lastwasref = true;  		break;  	case TokenType.Local:  		LocalVar vt = locals [smt [i].token];  		switch (vt.type) {  		case VarType.Int:  			EmitByte (0x73);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Float:  			EmitByte (0x66);  			Emit ((ushort)locals [smt [i].token].index);  			break;  		case VarType.Ref:  			EmitRefLabel (smt [i]' RefType.Expression);  			break;  		}  		break;  	case TokenType.Global:  		EmitRefLabel (smt [i]' RefType.Expression);  		break;  	case TokenType.Integer:  		EmitByte (0x6e);  		bw.Write (int.Parse (smt [i].token));  		break;  	case TokenType.Float:  		EmitByte (0x7a);  		bw.Write (double.Parse (smt [i].token));  		break;  	default:  		AddError ("Expected <global>|<local>|<constant>");  		return;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt [i].type == TokenType.Symbol) {  	if (smt [i].IsSymbol (".") && lastwasref) {  		if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  			i++;  			EmitByte (0x73);  			Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  			if (!vars.ContainsKey (smt [i].token)) {  				AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  			} else {  				Emit (vars [smt [i].token]);  			}  			continue;  		}  	} else if (smt [i].IsSymbol ("-")) {  		if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  			smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  			continue;  		}  	}  	AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt [i].type == TokenType.Symbol) {  	if (smt [i].IsSymbol (".") && lastwasref) {  		if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  			i++;  			EmitByte (0x73);  			Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  			if (!vars.ContainsKey (smt [i].token)) {  				AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  			} else {  				Emit (vars [smt [i].token]);  			}  			continue;  		}  	} else if (smt [i].IsSymbol ("-")) {  		if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  			smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  			continue;  		}  	}  	AddError ("Unexpected symbol '" + smt [i].token + "' in ShowMessage arguments");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt [i].IsSymbol (".") && lastwasref) {  	if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  		i++;  		EmitByte (0x73);  		Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  		if (!vars.ContainsKey (smt [i].token)) {  			AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  		} else {  			Emit (vars [smt [i].token]);  		}  		continue;  	}  } else if (smt [i].IsSymbol ("-")) {  	if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  		smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  		continue;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (smt [i].IsSymbol (".") && lastwasref) {  	if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  		i++;  		EmitByte (0x73);  		Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  		if (!vars.ContainsKey (smt [i].token)) {  			AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  		} else {  			Emit (vars [smt [i].token]);  		}  		continue;  	}  } else if (smt [i].IsSymbol ("-")) {  	if (i < smt.Length - 1 && (smt [i + 1].type == TokenType.Integer || smt [i + 1].type == TokenType.Float)) {  		smt [i + 1] = new Token (smt [i + 1].type' "-" + smt [i + 1].token);  		continue;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  	i++;  	EmitByte (0x73);  	Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  	if (!vars.ContainsKey (smt [i].token)) {  		AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  	} else {  		Emit (vars [smt [i].token]);  	}  	continue;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (i < smt.Length - 1 && farVars.ContainsKey (smt [i - 1].token)) {  	i++;  	EmitByte (0x73);  	Dictionary<string' ushort> vars = farVars [smt [i - 2].token];  	if (!vars.ContainsKey (smt [i].token)) {  		AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  	} else {  		Emit (vars [smt [i].token]);  	}  	continue;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: if (!vars.ContainsKey (smt [i].token)) {  	AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  } else {  	Emit (vars [smt [i].token]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: AddError ("Reference '" + smt [i - 2].utoken + "' has no variable called '" + smt [i].utoken + "'");  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: if (smt.Length < 2 || !smt [0].IsKeyword (Keywords.Begin)) {  	AddError ("Expected 'begin <args>'");  } else {  	EmitBegin (smt);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: while (smt.Length > 0 && !smt [0].IsKeyword (Keywords.End)) {  	if (smt [0].IsFlowControl ()) {  		switch (smt [0].keyword) {  		case Keywords.If: {  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x16);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  			break;  		}  		case Keywords.ElseIf:  			if (flowControl.Count == 0) {  				AddError ("elseif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			{  				Emit (0x18);  				long pos2 = bw.BaseStream.Length;  				Emit (0);  				flowControl.Push (bw.BaseStream.Length);  				Emit (0);  				EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  				bw.BaseStream.Position = pos2;  				Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  				bw.BaseStream.Position = bw.BaseStream.Length;  				opcodecount.Add (0);  			}  			break;  		case Keywords.Else:  			if (flowControl.Count == 0) {  				AddError ("else without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x17);  			Emit (2);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			opcodecount.Add (0);  			break;  		case Keywords.EndIf:  			Emit (0x19);  			Emit (0);  			if (flowControl.Count == 0) {  				AddError ("endif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		case Keywords.Return:  			Emit (0x1e);  			Emit (0);  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		}  	} else {  		HandleStatement (smt);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  	}  	smt = ts.PopNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: while (smt.Length > 0 && !smt [0].IsKeyword (Keywords.End)) {  	if (smt [0].IsFlowControl ()) {  		switch (smt [0].keyword) {  		case Keywords.If: {  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x16);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  			break;  		}  		case Keywords.ElseIf:  			if (flowControl.Count == 0) {  				AddError ("elseif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			{  				Emit (0x18);  				long pos2 = bw.BaseStream.Length;  				Emit (0);  				flowControl.Push (bw.BaseStream.Length);  				Emit (0);  				EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  				bw.BaseStream.Position = pos2;  				Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  				bw.BaseStream.Position = bw.BaseStream.Length;  				opcodecount.Add (0);  			}  			break;  		case Keywords.Else:  			if (flowControl.Count == 0) {  				AddError ("else without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x17);  			Emit (2);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			opcodecount.Add (0);  			break;  		case Keywords.EndIf:  			Emit (0x19);  			Emit (0);  			if (flowControl.Count == 0) {  				AddError ("endif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		case Keywords.Return:  			Emit (0x1e);  			Emit (0);  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		}  	} else {  		HandleStatement (smt);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  	}  	smt = ts.PopNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: while (smt.Length > 0 && !smt [0].IsKeyword (Keywords.End)) {  	if (smt [0].IsFlowControl ()) {  		switch (smt [0].keyword) {  		case Keywords.If: {  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x16);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  			break;  		}  		case Keywords.ElseIf:  			if (flowControl.Count == 0) {  				AddError ("elseif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			{  				Emit (0x18);  				long pos2 = bw.BaseStream.Length;  				Emit (0);  				flowControl.Push (bw.BaseStream.Length);  				Emit (0);  				EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  				bw.BaseStream.Position = pos2;  				Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  				bw.BaseStream.Position = bw.BaseStream.Length;  				opcodecount.Add (0);  			}  			break;  		case Keywords.Else:  			if (flowControl.Count == 0) {  				AddError ("else without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x17);  			Emit (2);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			opcodecount.Add (0);  			break;  		case Keywords.EndIf:  			Emit (0x19);  			Emit (0);  			if (flowControl.Count == 0) {  				AddError ("endif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		case Keywords.Return:  			Emit (0x1e);  			Emit (0);  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		}  	} else {  		HandleStatement (smt);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  	}  	smt = ts.PopNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: if (smt [0].IsFlowControl ()) {  	switch (smt [0].keyword) {  	case Keywords.If: {  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x16);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  		break;  	}  	case Keywords.ElseIf:  		if (flowControl.Count == 0) {  			AddError ("elseif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		{  			Emit (0x18);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  		}  		break;  	case Keywords.Else:  		if (flowControl.Count == 0) {  			AddError ("else without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x17);  		Emit (2);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		opcodecount.Add (0);  		break;  	case Keywords.EndIf:  		Emit (0x19);  		Emit (0);  		if (flowControl.Count == 0) {  			AddError ("endif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	case Keywords.Return:  		Emit (0x1e);  		Emit (0);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	}  } else {  	HandleStatement (smt);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: if (smt [0].IsFlowControl ()) {  	switch (smt [0].keyword) {  	case Keywords.If: {  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x16);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  		break;  	}  	case Keywords.ElseIf:  		if (flowControl.Count == 0) {  			AddError ("elseif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		{  			Emit (0x18);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  		}  		break;  	case Keywords.Else:  		if (flowControl.Count == 0) {  			AddError ("else without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x17);  		Emit (2);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		opcodecount.Add (0);  		break;  	case Keywords.EndIf:  		Emit (0x19);  		Emit (0);  		if (flowControl.Count == 0) {  			AddError ("endif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	case Keywords.Return:  		Emit (0x1e);  		Emit (0);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	}  } else {  	HandleStatement (smt);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: if (smt [0].IsFlowControl ()) {  	switch (smt [0].keyword) {  	case Keywords.If: {  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x16);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  		break;  	}  	case Keywords.ElseIf:  		if (flowControl.Count == 0) {  			AddError ("elseif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		{  			Emit (0x18);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  		}  		break;  	case Keywords.Else:  		if (flowControl.Count == 0) {  			AddError ("else without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x17);  		Emit (2);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		opcodecount.Add (0);  		break;  	case Keywords.EndIf:  		Emit (0x19);  		Emit (0);  		if (flowControl.Count == 0) {  			AddError ("endif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	case Keywords.Return:  		Emit (0x1e);  		Emit (0);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	}  } else {  	HandleStatement (smt);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following statement contains a magic number: Emit (2);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: while (smt.Length > 0) {  	if (smt [0].IsKeyword (Keywords.End)) {  		AddError ("Keyword 'end' not valid in a results script");  		return;  	}  	if (smt [0].IsFlowControl ()) {  		switch (smt [0].keyword) {  		case Keywords.If: {  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x16);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  			break;  		}  		case Keywords.ElseIf:  			if (flowControl.Count == 0) {  				AddError ("elseif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			{  				Emit (0x18);  				long pos2 = bw.BaseStream.Length;  				Emit (0);  				flowControl.Push (bw.BaseStream.Length);  				Emit (0);  				EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  				bw.BaseStream.Position = pos2;  				Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  				bw.BaseStream.Position = bw.BaseStream.Length;  				opcodecount.Add (0);  			}  			break;  		case Keywords.Else:  			if (flowControl.Count == 0) {  				AddError ("else without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x17);  			Emit (2);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			opcodecount.Add (0);  			break;  		case Keywords.EndIf:  			Emit (0x19);  			Emit (0);  			if (flowControl.Count == 0) {  				AddError ("endif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		case Keywords.Return:  			Emit (0x1e);  			Emit (0);  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		}  	} else {  		HandleStatement (smt);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  	}  	smt = ts.PopNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: while (smt.Length > 0) {  	if (smt [0].IsKeyword (Keywords.End)) {  		AddError ("Keyword 'end' not valid in a results script");  		return;  	}  	if (smt [0].IsFlowControl ()) {  		switch (smt [0].keyword) {  		case Keywords.If: {  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x16);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  			break;  		}  		case Keywords.ElseIf:  			if (flowControl.Count == 0) {  				AddError ("elseif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			{  				Emit (0x18);  				long pos2 = bw.BaseStream.Length;  				Emit (0);  				flowControl.Push (bw.BaseStream.Length);  				Emit (0);  				EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  				bw.BaseStream.Position = pos2;  				Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  				bw.BaseStream.Position = bw.BaseStream.Length;  				opcodecount.Add (0);  			}  			break;  		case Keywords.Else:  			if (flowControl.Count == 0) {  				AddError ("else without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x17);  			Emit (2);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			opcodecount.Add (0);  			break;  		case Keywords.EndIf:  			Emit (0x19);  			Emit (0);  			if (flowControl.Count == 0) {  				AddError ("endif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		case Keywords.Return:  			Emit (0x1e);  			Emit (0);  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		}  	} else {  		HandleStatement (smt);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  	}  	smt = ts.PopNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: while (smt.Length > 0) {  	if (smt [0].IsKeyword (Keywords.End)) {  		AddError ("Keyword 'end' not valid in a results script");  		return;  	}  	if (smt [0].IsFlowControl ()) {  		switch (smt [0].keyword) {  		case Keywords.If: {  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x16);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  			break;  		}  		case Keywords.ElseIf:  			if (flowControl.Count == 0) {  				AddError ("elseif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			{  				Emit (0x18);  				long pos2 = bw.BaseStream.Length;  				Emit (0);  				flowControl.Push (bw.BaseStream.Length);  				Emit (0);  				EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  				bw.BaseStream.Position = pos2;  				Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  				bw.BaseStream.Position = bw.BaseStream.Length;  				opcodecount.Add (0);  			}  			break;  		case Keywords.Else:  			if (flowControl.Count == 0) {  				AddError ("else without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			Emit (0x17);  			Emit (2);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			opcodecount.Add (0);  			break;  		case Keywords.EndIf:  			Emit (0x19);  			Emit (0);  			if (flowControl.Count == 0) {  				AddError ("endif without matching if");  			} else {  				bw.BaseStream.Position = flowControl.Pop ();  				Emit (opcodecount [opcodecount.Count - 1]);  				opcodecount.RemoveAt (opcodecount.Count - 1);  				bw.BaseStream.Position = bw.BaseStream.Length;  			}  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		case Keywords.Return:  			Emit (0x1e);  			Emit (0);  			for (int i = 0; i < opcodecount.Count; i++) {  				opcodecount [i] += 1;  			}  			break;  		}  	} else {  		HandleStatement (smt);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  	}  	smt = ts.PopNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: if (smt [0].IsFlowControl ()) {  	switch (smt [0].keyword) {  	case Keywords.If: {  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x16);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  		break;  	}  	case Keywords.ElseIf:  		if (flowControl.Count == 0) {  			AddError ("elseif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		{  			Emit (0x18);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  		}  		break;  	case Keywords.Else:  		if (flowControl.Count == 0) {  			AddError ("else without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x17);  		Emit (2);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		opcodecount.Add (0);  		break;  	case Keywords.EndIf:  		Emit (0x19);  		Emit (0);  		if (flowControl.Count == 0) {  			AddError ("endif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	case Keywords.Return:  		Emit (0x1e);  		Emit (0);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	}  } else {  	HandleStatement (smt);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: if (smt [0].IsFlowControl ()) {  	switch (smt [0].keyword) {  	case Keywords.If: {  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x16);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  		break;  	}  	case Keywords.ElseIf:  		if (flowControl.Count == 0) {  			AddError ("elseif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		{  			Emit (0x18);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  		}  		break;  	case Keywords.Else:  		if (flowControl.Count == 0) {  			AddError ("else without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x17);  		Emit (2);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		opcodecount.Add (0);  		break;  	case Keywords.EndIf:  		Emit (0x19);  		Emit (0);  		if (flowControl.Count == 0) {  			AddError ("endif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	case Keywords.Return:  		Emit (0x1e);  		Emit (0);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	}  } else {  	HandleStatement (smt);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: if (smt [0].IsFlowControl ()) {  	switch (smt [0].keyword) {  	case Keywords.If: {  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x16);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  		break;  	}  	case Keywords.ElseIf:  		if (flowControl.Count == 0) {  			AddError ("elseif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		{  			Emit (0x18);  			long pos2 = bw.BaseStream.Length;  			Emit (0);  			flowControl.Push (bw.BaseStream.Length);  			Emit (0);  			EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  			bw.BaseStream.Position = pos2;  			Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  			bw.BaseStream.Position = bw.BaseStream.Length;  			opcodecount.Add (0);  		}  		break;  	case Keywords.Else:  		if (flowControl.Count == 0) {  			AddError ("else without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		Emit (0x17);  		Emit (2);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		opcodecount.Add (0);  		break;  	case Keywords.EndIf:  		Emit (0x19);  		Emit (0);  		if (flowControl.Count == 0) {  			AddError ("endif without matching if");  		} else {  			bw.BaseStream.Position = flowControl.Pop ();  			Emit (opcodecount [opcodecount.Count - 1]);  			opcodecount.RemoveAt (opcodecount.Count - 1);  			bw.BaseStream.Position = bw.BaseStream.Length;  		}  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	case Keywords.Return:  		Emit (0x1e);  		Emit (0);  		for (int i = 0; i < opcodecount.Count; i++) {  			opcodecount [i] += 1;  		}  		break;  	}  } else {  	HandleStatement (smt);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following statement contains a magic number: Emit (2);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Function) {  	EmitFunctionCall (ref smt' false' false' false);  } else if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.ShowMessage)) {  	EmitShowMessage (smt);  } else if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Set)) {  	if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	Emit (0x15);  	long pos = bw.BaseStream.Length;  	Emit (0);  	if (smt [1].type == TokenType.Local) {  		LocalVar lv = locals [smt [1].token];  		if (lv.type == VarType.Int) {  			EmitByte (0x73);  		} else {  			EmitByte (0x66);  		}  		Emit ((ushort)lv.index);  		EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.Global) {  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  	} else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  		if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  			AddError ("Expected 'set <var> to <expression>'");  			return;  		}  		EmitRefLabel (smt [1]' RefType.Expression);  		EmitByte (0x73);  		if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  			AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  		} else {  			Emit (farVars [smt [1].token] [smt [3].token]);  		}  		EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  	} else {  		AddError ("Expected set <local>|<global> to <expression>");  	}  	bw.BaseStream.Position = pos;  	Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  } else if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  	AddError ("Expected 'set <var> to <expression>'");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  	AddError ("Expected 'set <var> to <expression>'");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 4 || !(smt [2].IsKeyword (Keywords.To) || smt [2].IsSymbol ("."))) {  	AddError ("Expected 'set <var> to <expression>'");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Local) {  	LocalVar lv = locals [smt [1].token];  	if (lv.type == VarType.Int) {  		EmitByte (0x73);  	} else {  		EmitByte (0x66);  	}  	Emit ((ushort)lv.index);  	EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  } else if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: EmitExpression (TrimStatement (smt' 3)' (lv.type == VarType.Ref) ? ExpressionType.Ref : ExpressionType.Numeric);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.Global) {  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  } else if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: EmitExpression (TrimStatement (smt' 3)' ExpressionType.Numeric);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [1].type == TokenType.edid && farVars.ContainsKey (smt [1].token) && smt [2].IsSymbol (".")) {  	if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  		AddError ("Expected 'set <var> to <expression>'");  		return;  	}  	EmitRefLabel (smt [1]' RefType.Expression);  	EmitByte (0x73);  	if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  		AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  	} else {  		Emit (farVars [smt [1].token] [smt [3].token]);  	}  	EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  } else {  	AddError ("Expected set <local>|<global> to <expression>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  	AddError ("Expected 'set <var> to <expression>'");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 6 || !smt [4].IsKeyword (Keywords.To)) {  	AddError ("Expected 'set <var> to <expression>'");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  	AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  } else {  	Emit (farVars [smt [1].token] [smt [3].token]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  	AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  } else {  	Emit (farVars [smt [1].token] [smt [3].token]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (!farVars [smt [1].token].ContainsKey (smt [3].token)) {  	AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  } else {  	Emit (farVars [smt [1].token] [smt [3].token]);  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: AddError ("Local variable '" + smt [3].token + " does not exist in quest " + smt [1].token);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: Emit (farVars [smt [1].token] [smt [3].token]);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: EmitExpression (TrimStatement (smt' 5)' ExpressionType.If);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: Emit ((ushort)(bw.BaseStream.Length - (pos + 2)));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.edid) {  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  	AddError ("Expected ref.function");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  	AddError ("Expected ref.function");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: smt = TrimStatement (smt' 2);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt [0].type == TokenType.Local) {  	LocalVar lv = locals [smt [0].token];  	if (lv.type != VarType.Ref) {  		AddError ("Expected 'Set'' <function> or <ref>.<function>");  		return;  	}  	if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  		AddError ("Expected ref.function");  		return;  	}  	EmitRefLabel (smt [0]' RefType.Standard);  	smt = TrimStatement (smt' 2);  	EmitFunctionCall (ref smt' false' true' false);  } else {  	AddError ("Expected 'Set'' <function> or <ref>.<function>");  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  	AddError ("Expected ref.function");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: if (smt.Length < 3 || !smt [1].IsSymbol (".") || smt [2].type != TokenType.Function) {  	AddError ("Expected ref.function");  	return;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleStatement,The following statement contains a magic number: smt = TrimStatement (smt' 2);  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: while (smt.Length > 0 && smt [0].IsType ()) {  	ts.PopNextStatement ();  	if (smt.Length != 2 || smt [1].type != TokenType.Unknown) {  		AddError ("Expected <type> <variable name>");  		smt = ts.PeekNextStatement ();  		continue;  	}  	slsd = new SubRecord ();  	slsd.Name = "SLSD";  	var data = new byte[24];  	TypeConverter.si2h (locals.Count + 1' data' 0);  	if (smt [0].IsKeyword (Keywords.Int)) {  		data [16] = 1;  	}  	slsd.SetData (data);  	r.AddRecord (slsd);  	scvr = new SubRecord ();  	scvr.Name = "SCVR";  	scvr.SetStrData (smt [1].utoken' true);  	r.AddRecord (scvr);  	var lv = new LocalVar (locals.Count + 1' smt [0]);  	locals.Add (smt [1].token' lv);  	localList.Add (lv);  	ts.AddLocal (smt [1].token);  	smt = ts.PeekNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: while (smt.Length > 0 && smt [0].IsType ()) {  	ts.PopNextStatement ();  	if (smt.Length != 2 || smt [1].type != TokenType.Unknown) {  		AddError ("Expected <type> <variable name>");  		smt = ts.PeekNextStatement ();  		continue;  	}  	slsd = new SubRecord ();  	slsd.Name = "SLSD";  	var data = new byte[24];  	TypeConverter.si2h (locals.Count + 1' data' 0);  	if (smt [0].IsKeyword (Keywords.Int)) {  		data [16] = 1;  	}  	slsd.SetData (data);  	r.AddRecord (slsd);  	scvr = new SubRecord ();  	scvr.Name = "SCVR";  	scvr.SetStrData (smt [1].utoken' true);  	r.AddRecord (scvr);  	var lv = new LocalVar (locals.Count + 1' smt [0]);  	locals.Add (smt [1].token' lv);  	localList.Add (lv);  	ts.AddLocal (smt [1].token);  	smt = ts.PeekNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: while (smt.Length > 0 && smt [0].IsType ()) {  	ts.PopNextStatement ();  	if (smt.Length != 2 || smt [1].type != TokenType.Unknown) {  		AddError ("Expected <type> <variable name>");  		smt = ts.PeekNextStatement ();  		continue;  	}  	slsd = new SubRecord ();  	slsd.Name = "SLSD";  	var data = new byte[24];  	TypeConverter.si2h (locals.Count + 1' data' 0);  	if (smt [0].IsKeyword (Keywords.Int)) {  		data [16] = 1;  	}  	slsd.SetData (data);  	r.AddRecord (slsd);  	scvr = new SubRecord ();  	scvr.Name = "SCVR";  	scvr.SetStrData (smt [1].utoken' true);  	r.AddRecord (scvr);  	var lv = new LocalVar (locals.Count + 1' smt [0]);  	locals.Add (smt [1].token' lv);  	localList.Add (lv);  	ts.AddLocal (smt [1].token);  	smt = ts.PeekNextStatement ();  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: if (smt.Length != 2 || smt [1].type != TokenType.Unknown) {  	AddError ("Expected <type> <variable name>");  	smt = ts.PeekNextStatement ();  	continue;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: if (smt [0].IsKeyword (Keywords.Int)) {  	data [16] = 1;  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleVariables,The following statement contains a magic number: data [16] = 1;  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("*"' new Operator (null' 4' false' "*"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("/"' new Operator (null' 4' false' "/"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("+"' new Operator (null' 5' false' "+"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("-"' new Operator (null' 5' false' "-"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("<"' new Operator (null' 7' false' "<"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("<="' new Operator (null' 7' false' "<="));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add (">="' new Operator (null' 7' false' ">="));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add (">"' new Operator (null' 7' false' ">"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("=="' new Operator (null' 8' false' "=="));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("!="' new Operator (null' 8' false' "!="));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("&&"' new Operator (null' 12' false' "&&"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: biOps.Add ("||"' new Operator (null' 13' false' "||"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,Init,The following statement contains a magic number: uniOps.Add ("-"' new Operator (null' 3' false' "~"));  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	if ((r2.FormID & 0xff000000) != mask || r2.DescriptiveName == null) {  		return;  	}  	records [(r2.FormID & 0xffffff) + id] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				if ((formid & 0xff000000) != mask) {  					return;  				}  				quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' mask' id' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	if ((r2.FormID & 0xff000000) != mask || r2.DescriptiveName == null) {  		return;  	}  	records [(r2.FormID & 0xffffff) + id] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				if ((formid & 0xff000000) != mask) {  					return;  				}  				quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' mask' id' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	if ((r2.FormID & 0xff000000) != mask || r2.DescriptiveName == null) {  		return;  	}  	records [(r2.FormID & 0xffffff) + id] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				if ((formid & 0xff000000) != mask) {  					return;  				}  				quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' mask' id' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	if ((r2.FormID & 0xff000000) != mask || r2.DescriptiveName == null) {  		return;  	}  	records [(r2.FormID & 0xffffff) + id] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				if ((formid & 0xff000000) != mask) {  					return;  				}  				quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' mask' id' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	if ((r2.FormID & 0xff000000) != mask || r2.DescriptiveName == null) {  		return;  	}  	records [(r2.FormID & 0xffffff) + id] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				if ((formid & 0xff000000) != mask) {  					return;  				}  				quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' mask' id' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			if ((formid & 0xff000000) != mask) {  				return;  			}  			quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: foreach (SubRecord sr in r2.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: foreach (SubRecord sr in r2.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	if ((formid & 0xff000000) != mask) {  		return;  	}  	quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	if ((formid & 0xff000000) != mask) {  		return;  	}  	quests.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		if ((formid & 0xff000000) != mask) {  			return;  		}  		refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  	byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	if ((formid & 0xff000000) != mask) {  		return;  	}  	refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  	byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	if ((formid & 0xff000000) != mask) {  		return;  	}  	refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.SubRecords.Count > 2 && r2.SubRecords [0].Name == "EDID" && r2.SubRecords [1].Name == "NAME") {  	byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	if ((formid & 0xff000000) != mask) {  		return;  	}  	refs.Add (new Pair<uint' Record> ((formid & 0xffffff) + id' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	records [r2.FormID] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				quests.Add (new Pair<uint' Record> (formid' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			refs.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	records [r2.FormID] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				quests.Add (new Pair<uint' Record> (formid' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			refs.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	records [r2.FormID] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				quests.Add (new Pair<uint' Record> (formid' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			refs.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r is Record) {  	var r2 = (Record)r;  	if (r2.DescriptiveName == null) {  		return;  	}  	records [r2.FormID] = r2;  	if (r2.Name == "QUST") {  		foreach (SubRecord sr in r2.SubRecords) {  			if (sr.Name == "SCRI") {  				byte[] bytes = sr.GetReadonlyData ();  				uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  				quests.Add (new Pair<uint' Record> (formid' r2));  			}  		}  	} else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  		if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  			byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			refs.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else {  	foreach (Rec r2 in r.Records) {  		RecursePlugin (r2' records' quests' refs);  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			quests.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		refs.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			quests.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		refs.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			quests.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		refs.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "QUST") {  	foreach (SubRecord sr in r2.SubRecords) {  		if (sr.Name == "SCRI") {  			byte[] bytes = sr.GetReadonlyData ();  			uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  			quests.Add (new Pair<uint' Record> (formid' r2));  		}  	}  } else if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		refs.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: foreach (SubRecord sr in r2.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		quests.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: foreach (SubRecord sr in r2.SubRecords) {  	if (sr.Name == "SCRI") {  		byte[] bytes = sr.GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		quests.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	quests.Add (new Pair<uint' Record> (formid' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (sr.Name == "SCRI") {  	byte[] bytes = sr.GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	quests.Add (new Pair<uint' Record> (formid' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		refs.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.Name == "REFR" || r2.Name == "ACHR" || r2.Name == "ACRE") {  	if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  		byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  		uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  		refs.Add (new Pair<uint' Record> (formid' r2));  	}  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  	byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	refs.Add (new Pair<uint' Record> (formid' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,RecursePlugin,The following statement contains a magic number: if (r2.SubRecords.Count > 0 && r2.SubRecords [1].Name == "NAME") {  	byte[] bytes = r2.SubRecords [1].GetReadonlyData ();  	uint formid = TypeConverter.h2i (bytes [0]' bytes [1]' bytes [2]' bytes [3]);  	refs.Add (new Pair<uint' Record> (formid' r2));  }  
Magic Number,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,SafePeek,The following statement contains a magic number: if (c < 32 && c != '\n') {  	this.AddError ("There is an invalid character in the file");  }  
Magic Number,TESVSnip.Domain.Scripts,TokenStream,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\TokenStream.cs,SafePop,The following statement contains a magic number: if (c < 32 && c != '\n') {  	this.AddError ("There is an invalid character in the file");  }  
Duplicate Code,TESVSnip.Domain.Model,Record,F:\newReposMay17\figment_tesvsnip\Domain\Model\Record.cs,MatchRecordCheckCondition,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 47)' (92' 111))
Missing Default,TESVSnip.Domain.Data.Structure,ElementStructure,F:\newReposMay17\figment_tesvsnip\Domain\Data\Structure\ElementStructure.cs,ElementStructure,The following switch statement is missing a default case: switch (this.type) {  case ElementValueType.FormID:  	this.FormIDType = node.reftype;  	break;  case ElementValueType.Blob:  	if (this.repeat > 0 || this.optional > 0) {  		throw new RecordXmlException ("blob type elements can't be marked with repeat or optional");  	}  	break;  }  
Missing Default,TESVSnip.Domain.Model,BatchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\BatchElement.cs,AssignValue,The following switch statement is missing a default case: switch (this.Record.type) {  case ElementValueType.String:  case ElementValueType.BString:  case ElementValueType.IString:  case ElementValueType.Str4:  	this.value = strvalue;  	return true;  case ElementValueType.Float:  	{  		float v;  		if (float.TryParse (strvalue' NumberStyles.Any' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  case ElementValueType.Int:  	{  		int v;  		if (int.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  case ElementValueType.Short:  	{  		short v;  		if (short.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  case ElementValueType.Byte:  	{  		byte v;  		if (byte.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  case ElementValueType.FormID:  	{  		uint v;  		if (uint.TryParse (strvalue' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  case ElementValueType.Blob: {  	return false;  	// no support yet  }  case ElementValueType.LString: {  	uint v;  	this.value = uint.TryParse (strvalue' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out v) ? (object)v : strvalue;  	return true;  }  case ElementValueType.UShort:  	{  		ushort v;  		if (ushort.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  case ElementValueType.UInt:  	{  		uint v;  		if (uint.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  case ElementValueType.SByte:  	{  		uint v;  		if (uint.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			this.value = v;  			return true;  		}  	}  	break;  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (this.Structure.type) {  case ElementValueType.String:  	{  		var str1 = Extensions.CastValue<string> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<string> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<string> (str1 + Extensions.CastValue<string> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<string> (default(string));  		}  	}  	break;  case ElementValueType.FormID:  	{  		if (this.Value is uint && val is uint) {  			var u1 = (uint)this.Value;  			var u2 = (uint)val;  			switch (elemType) {  			case ElementAssignmentType.Set:  				return this.AssignValue<uint> (u2);  			case ElementAssignmentType.Add:  				return this.AssignValue<uint> (u1 + u2);  			case ElementAssignmentType.Subtract:  				return this.AssignValue<uint> (u1 - u2);  			case ElementAssignmentType.Multiply:  				return this.AssignValue<uint> (u1 * u2);  			case ElementAssignmentType.Divide:  				return this.AssignValue<uint> (u1 / u2);  			case ElementAssignmentType.BitAnd:  				return this.AssignValue<uint> (u1 & u2);  			case ElementAssignmentType.BitOr:  				return this.AssignValue<uint> (u1 | u2);  			case ElementAssignmentType.Clear:  				return this.AssignValue<uint> (default(uint));  			}  		}  	}  	break;  case ElementValueType.Blob:  	break;  case ElementValueType.LString:  	if (this.Value is string && val is string) {  		var s1 = (string)this.Value;  		var s2 = (string)val;  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<string> (s2);  		case ElementAssignmentType.Add:  			return this.AssignValue<string> (s1 + s2);  		case ElementAssignmentType.Clear:  			return this.AssignValue<string> (default(string));  		}  	}  	break;  case ElementValueType.BString:  case ElementValueType.IString:  	break;  case ElementValueType.Str4:  	{  		var str2 = Extensions.CastValue<string> (val);  		if (this.Data.Count == 4 && str2.Length == 4) {  			switch (elemType) {  			case ElementAssignmentType.Set:  				return this.AssignValue<string> (str2);  			case ElementAssignmentType.Clear:  				return this.AssignValue<string> ("    ");  			}  		}  	}  	break;  case ElementValueType.Float:  	{  		var val1 = Extensions.CastValue<float> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<float> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<float> (val1 + Extensions.CastValue<float> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<float> (val1 - Extensions.CastValue<float> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<float> (val1 * Extensions.CastValue<float> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<float> (val1 / Extensions.CastValue<float> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<float> (Extensions.CastValue<int> (val1) & Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<float> (Extensions.CastValue<int> (val1) | Extensions.CastValue<int> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<float> (default(float));  		}  	}  	break;  case ElementValueType.Int:  	{  		var val1 = Extensions.CastValue<int> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<int> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<int> (val1 + Extensions.CastValue<int> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<int> (val1 - Extensions.CastValue<int> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<int> (val1 * Extensions.CastValue<int> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<int> (val1 / Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<int> (val1 & Extensions.CastValue<int> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<int> (val1 | Extensions.CastValue<int> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<int> (default(int));  		}  	}  	break;  case ElementValueType.Short:  	{  		var val1 = Extensions.CastValue<short> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<short> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<short> (val1 + Extensions.CastValue<short> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<short> (val1 - Extensions.CastValue<short> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<short> (val1 * Extensions.CastValue<short> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<short> (val1 / Extensions.CastValue<short> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<short> (val1 & Extensions.CastValue<short> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<short> (val1 | Extensions.CastValue<short> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<short> (default(short));  		}  	}  	break;  case ElementValueType.Byte:  	{  		var val1 = Extensions.CastValue<byte> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<byte> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<byte> (val1 + Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<byte> (val1 - Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<byte> (val1 * Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<byte> (val1 / Extensions.CastValue<byte> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<byte> (val1 & Extensions.CastValue<byte> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<byte> (val1 | Extensions.CastValue<byte> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<byte> (default(byte));  		}  	}  	break;  case ElementValueType.UShort:  	{  		var val1 = Extensions.CastValue<ushort> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<ushort> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<ushort> (val1 + Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<ushort> (val1 - Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<ushort> (val1 * Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<ushort> (val1 / Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<ushort> (val1 & Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<ushort> (val1 | Extensions.CastValue<ushort> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<ushort> (default(ushort));  		}  	}  	break;  case ElementValueType.UInt:  	{  		var val1 = Extensions.CastValue<uint> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<uint> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<uint> (val1 + Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<uint> (val1 - Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<uint> (val1 * Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<uint> (val1 / Extensions.CastValue<uint> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<uint> (val1 & Extensions.CastValue<uint> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<uint> (val1 | Extensions.CastValue<uint> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<uint> (default(uint));  		}  	}  	break;  case ElementValueType.SByte:  	{  		var val1 = Extensions.CastValue<sbyte> (this.Value);  		switch (elemType) {  		case ElementAssignmentType.Set:  			return this.AssignValue<sbyte> (val);  		case ElementAssignmentType.Add:  			return this.AssignValue<sbyte> (val1 + Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Subtract:  			return this.AssignValue<sbyte> (val1 - Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Multiply:  			return this.AssignValue<sbyte> (val1 * Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Divide:  			return this.AssignValue<sbyte> (val1 / Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.BitAnd:  			return this.AssignValue<sbyte> (val1 & Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.BitOr:  			return this.AssignValue<sbyte> (val1 | Extensions.CastValue<sbyte> (val));  		case ElementAssignmentType.Clear:  			return this.AssignValue<sbyte> (default(sbyte));  		}  	}  	break;  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<string> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<string> (str1 + Extensions.CastValue<string> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<string> (default(string));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<uint> (u2);  case ElementAssignmentType.Add:  	return this.AssignValue<uint> (u1 + u2);  case ElementAssignmentType.Subtract:  	return this.AssignValue<uint> (u1 - u2);  case ElementAssignmentType.Multiply:  	return this.AssignValue<uint> (u1 * u2);  case ElementAssignmentType.Divide:  	return this.AssignValue<uint> (u1 / u2);  case ElementAssignmentType.BitAnd:  	return this.AssignValue<uint> (u1 & u2);  case ElementAssignmentType.BitOr:  	return this.AssignValue<uint> (u1 | u2);  case ElementAssignmentType.Clear:  	return this.AssignValue<uint> (default(uint));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<string> (s2);  case ElementAssignmentType.Add:  	return this.AssignValue<string> (s1 + s2);  case ElementAssignmentType.Clear:  	return this.AssignValue<string> (default(string));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<string> (str2);  case ElementAssignmentType.Clear:  	return this.AssignValue<string> ("    ");  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<float> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<float> (val1 + Extensions.CastValue<float> (val));  case ElementAssignmentType.Subtract:  	return this.AssignValue<float> (val1 - Extensions.CastValue<float> (val));  case ElementAssignmentType.Multiply:  	return this.AssignValue<float> (val1 * Extensions.CastValue<float> (val));  case ElementAssignmentType.Divide:  	return this.AssignValue<float> (val1 / Extensions.CastValue<float> (val));  case ElementAssignmentType.BitAnd:  	return this.AssignValue<float> (Extensions.CastValue<int> (val1) & Extensions.CastValue<int> (val));  case ElementAssignmentType.BitOr:  	return this.AssignValue<float> (Extensions.CastValue<int> (val1) | Extensions.CastValue<int> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<float> (default(float));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<int> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<int> (val1 + Extensions.CastValue<int> (val));  case ElementAssignmentType.Subtract:  	return this.AssignValue<int> (val1 - Extensions.CastValue<int> (val));  case ElementAssignmentType.Multiply:  	return this.AssignValue<int> (val1 * Extensions.CastValue<int> (val));  case ElementAssignmentType.Divide:  	return this.AssignValue<int> (val1 / Extensions.CastValue<int> (val));  case ElementAssignmentType.BitAnd:  	return this.AssignValue<int> (val1 & Extensions.CastValue<int> (val));  case ElementAssignmentType.BitOr:  	return this.AssignValue<int> (val1 | Extensions.CastValue<int> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<int> (default(int));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<short> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<short> (val1 + Extensions.CastValue<short> (val));  case ElementAssignmentType.Subtract:  	return this.AssignValue<short> (val1 - Extensions.CastValue<short> (val));  case ElementAssignmentType.Multiply:  	return this.AssignValue<short> (val1 * Extensions.CastValue<short> (val));  case ElementAssignmentType.Divide:  	return this.AssignValue<short> (val1 / Extensions.CastValue<short> (val));  case ElementAssignmentType.BitAnd:  	return this.AssignValue<short> (val1 & Extensions.CastValue<short> (val));  case ElementAssignmentType.BitOr:  	return this.AssignValue<short> (val1 | Extensions.CastValue<short> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<short> (default(short));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<byte> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<byte> (val1 + Extensions.CastValue<byte> (val));  case ElementAssignmentType.Subtract:  	return this.AssignValue<byte> (val1 - Extensions.CastValue<byte> (val));  case ElementAssignmentType.Multiply:  	return this.AssignValue<byte> (val1 * Extensions.CastValue<byte> (val));  case ElementAssignmentType.Divide:  	return this.AssignValue<byte> (val1 / Extensions.CastValue<byte> (val));  case ElementAssignmentType.BitAnd:  	return this.AssignValue<byte> (val1 & Extensions.CastValue<byte> (val));  case ElementAssignmentType.BitOr:  	return this.AssignValue<byte> (val1 | Extensions.CastValue<byte> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<byte> (default(byte));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<ushort> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<ushort> (val1 + Extensions.CastValue<ushort> (val));  case ElementAssignmentType.Subtract:  	return this.AssignValue<ushort> (val1 - Extensions.CastValue<ushort> (val));  case ElementAssignmentType.Multiply:  	return this.AssignValue<ushort> (val1 * Extensions.CastValue<ushort> (val));  case ElementAssignmentType.Divide:  	return this.AssignValue<ushort> (val1 / Extensions.CastValue<ushort> (val));  case ElementAssignmentType.BitAnd:  	return this.AssignValue<ushort> (val1 & Extensions.CastValue<ushort> (val));  case ElementAssignmentType.BitOr:  	return this.AssignValue<ushort> (val1 | Extensions.CastValue<ushort> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<ushort> (default(ushort));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<uint> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<uint> (val1 + Extensions.CastValue<uint> (val));  case ElementAssignmentType.Subtract:  	return this.AssignValue<uint> (val1 - Extensions.CastValue<uint> (val));  case ElementAssignmentType.Multiply:  	return this.AssignValue<uint> (val1 * Extensions.CastValue<uint> (val));  case ElementAssignmentType.Divide:  	return this.AssignValue<uint> (val1 / Extensions.CastValue<uint> (val));  case ElementAssignmentType.BitAnd:  	return this.AssignValue<uint> (val1 & Extensions.CastValue<uint> (val));  case ElementAssignmentType.BitOr:  	return this.AssignValue<uint> (val1 | Extensions.CastValue<uint> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<uint> (default(uint));  }  
Missing Default,TESVSnip.Domain.Model,Element,F:\newReposMay17\figment_tesvsnip\Domain\Model\Element.cs,AssignValue,The following switch statement is missing a default case: switch (elemType) {  case ElementAssignmentType.Set:  	return this.AssignValue<sbyte> (val);  case ElementAssignmentType.Add:  	return this.AssignValue<sbyte> (val1 + Extensions.CastValue<sbyte> (val));  case ElementAssignmentType.Subtract:  	return this.AssignValue<sbyte> (val1 - Extensions.CastValue<sbyte> (val));  case ElementAssignmentType.Multiply:  	return this.AssignValue<sbyte> (val1 * Extensions.CastValue<sbyte> (val));  case ElementAssignmentType.Divide:  	return this.AssignValue<sbyte> (val1 / Extensions.CastValue<sbyte> (val));  case ElementAssignmentType.BitAnd:  	return this.AssignValue<sbyte> (val1 & Extensions.CastValue<sbyte> (val));  case ElementAssignmentType.BitOr:  	return this.AssignValue<sbyte> (val1 | Extensions.CastValue<sbyte> (val));  case ElementAssignmentType.Clear:  	return this.AssignValue<sbyte> (default(sbyte));  }  
Missing Default,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,LoadPluginStrings,The following switch statement is missing a default case: switch (format) {  case LocalizedStringFormat.Base:  	while (data [start + len] != 0) {  		++len;  	}  	break;  case LocalizedStringFormat.DL:  case LocalizedStringFormat.IL:  	len = BitConverter.ToInt32 (data' start) - 1;  	start = start + sizeof(int);  	if (start + len > data.Length) {  		len = data.Length - start;  	}  	if (len < 0) {  		len = 0;  	}  	break;  }  
Missing Default,TESVSnip.Domain.Model,Plugin,F:\newReposMay17\figment_tesvsnip\Domain\Model\Plugin.cs,SavePluginStrings,The following switch statement is missing a default case: switch (format) {  case LocalizedStringFormat.Base:  	memWriter.Write (data' 0' data.Length);  	memWriter.Write ((byte)0);  	break;  case LocalizedStringFormat.DL:  case LocalizedStringFormat.IL:  	memWriter.Write (data.Length + 1);  	memWriter.Write (data' 0' data.Length);  	memWriter.Write ((byte)0);  	break;  }  
Missing Default,TESVSnip.Domain.Model,SearchCriteriaSettings,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchCriteriaSettings.cs,GetDisplayString,The following switch statement is missing a default case: switch (type) {  case SearchCondRecordType.Exists:  	return "Exists";  case SearchCondRecordType.Missing:  	return "Missing";  }  
Missing Default,TESVSnip.Domain.Model,SearchCriteriaSettings,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchCriteriaSettings.cs,GetFormatString,The following switch statement is missing a default case: switch (type) {  case SearchCondElementType.Equal:  	return "{0} = {1}";  case SearchCondElementType.Not:  	return "Not {0}";  case SearchCondElementType.Greater:  	return "{0} > {1}";  case SearchCondElementType.Less:  	return "{0} < {1}";  case SearchCondElementType.GreaterEqual:  	return "{0} >= {1}";  case SearchCondElementType.LessEqual:  	return "{0} <= {1}";  case SearchCondElementType.StartsWith:  	return "{0} like '{1}%'";  case SearchCondElementType.EndsWith:  	return "{0} like '%{1}'";  case SearchCondElementType.Contains:  	return "{0} like '%{1}%'";  case SearchCondElementType.Exists:  	return "{0} Exists";  case SearchCondElementType.Missing:  	return "{0} Missing";  }  
Missing Default,TESVSnip.Domain.Model,SearchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchElement.cs,Match,The following switch statement is missing a default case: switch (this.Type) {  case SearchCondElementType.Equal:  	return diff == 0;  case SearchCondElementType.Not:  	return diff != 0;  case SearchCondElementType.Greater:  	return diff > 0;  case SearchCondElementType.Less:  	return diff < 0;  case SearchCondElementType.GreaterEqual:  	return diff >= 0;  case SearchCondElementType.LessEqual:  	return diff <= 0;  case SearchCondElementType.StartsWith:  	if (diff == 0) {  		return true;  	}  	if (value != null && this.Value != null) {  		return value.ToString ().StartsWith (this.Value.ToString ()' StringComparison.CurrentCultureIgnoreCase);  	}  	break;  case SearchCondElementType.EndsWith:  	if (diff == 0) {  		return true;  	}  	if (value != null && this.Value != null) {  		return value.ToString ().EndsWith (this.Value.ToString ()' StringComparison.CurrentCultureIgnoreCase);  	}  	break;  case SearchCondElementType.Contains:  	if (diff == 0) {  		return true;  	}  	if (value != null && this.Value != null) {  		return value.ToString ().IndexOf (this.Value.ToString ()' StringComparison.CurrentCultureIgnoreCase) >= 0;  	}  	break;  }  
Missing Default,TESVSnip.Domain.Model,SearchElement,F:\newReposMay17\figment_tesvsnip\Domain\Model\SearchElement.cs,ValidateValue,The following switch statement is missing a default case: switch (this.Record.type) {  case ElementValueType.String:  case ElementValueType.BString:  case ElementValueType.IString:  case ElementValueType.Str4:  	return true;  case ElementValueType.Float:  	{  		float v;  		if (float.TryParse (strvalue' NumberStyles.Any' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  case ElementValueType.Int:  	{  		int v;  		if (int.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  case ElementValueType.Short:  	{  		short v;  		if (short.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  case ElementValueType.Byte:  	{  		byte v;  		if (byte.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  case ElementValueType.FormID:  	{  		uint v;  		if (uint.TryParse (strvalue' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  case ElementValueType.Blob: {  	return false;  	// no support yet  }  case ElementValueType.LString: {  	return true;  }  case ElementValueType.UShort:  	{  		ushort v;  		if (ushort.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  case ElementValueType.UInt:  	{  		uint v;  		if (uint.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  case ElementValueType.SByte:  	{  		uint v;  		if (uint.TryParse (numText' numStyle' CultureInfo.CurrentCulture' out v)) {  			return true;  		}  	}  	break;  }  
Missing Default,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,SubRecord,The following switch statement is missing a default case: switch (elem.type) {  case ElementValueType.FormID:  case ElementValueType.LString:  case ElementValueType.Int:  case ElementValueType.UInt:  case ElementValueType.Float:  case ElementValueType.Str4:  case ElementValueType.IString:  	size += 4;  	break;  case ElementValueType.BString:  case ElementValueType.Short:  case ElementValueType.UShort:  	size += 2;  	break;  case ElementValueType.String:  case ElementValueType.Byte:  case ElementValueType.SByte:  	size += 1;  	break;  }  
Missing Default,TESVSnip.Domain.Model,SubRecord,F:\newReposMay17\figment_tesvsnip\Domain\Model\SubRecord.cs,GetCompareValue,The following switch statement is missing a default case: switch (se.Structure.type) {  case ElementValueType.LString:  	if (value is uint) {  		var p = this.GetPlugin ();  		if (p != null) {  			value = p.LookupFormStrings ((uint)value) ?? value;  		}  	}  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  {  case "float":  	param [i] = float.Parse (parameters [i]' _ni);  	break;  case "int":  	param [i] = int.Parse (parameters [i]' _ni);  	break;  case "short":  	param [i] = short.Parse (parameters [i]' _ni);  	break;  case "uint":  	param [i] = uint.Parse (parameters [i]' _ni);  	break;  case "ushort":  	param [i] = ushort.Parse (parameters [i]' _ni);  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (elemt.Type) {  case ElementValueType.Float:  	result = _objOps.Invoke (function' el' (float)elemt.Value' param);  	break;  case ElementValueType.Int:  	result = _objOps.Invoke (function' el' (int)elemt.Value' param);  	break;  case ElementValueType.Short:  	result = _objOps.Invoke (function' el' (short)elemt.Value' param);  	break;  case ElementValueType.UInt:  	result = _objOps.Invoke (function' el' (uint)elemt.Value' param);  	break;  case ElementValueType.UShort:  	result = _objOps.Invoke (function' el' (ushort)elemt.Value' param);  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (pyFunc.Parameters [i + 3]) //+2 jump self' element and value parameter  {  case "float":  	param [i] = float.Parse (parameters [i]' _ni);  	break;  case "int":  	param [i] = int.Parse (parameters [i]' _ni);  	break;  case "short":  	param [i] = short.Parse (parameters [i]' _ni);  	break;  case "uint":  	param [i] = uint.Parse (parameters [i]' _ni);  	break;  case "ushort":  	param [i] = ushort.Parse (parameters [i]' _ni);  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,PyInterpreter,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\PyInterpreter.cs,ExecuteFunction,The following switch statement is missing a default case: switch (elemt.type) {  case ElementValueType.Float:  	result = _objOps.Invoke (function' el' (float)value' param);  	break;  case ElementValueType.Int:  	result = _objOps.Invoke (function' el' (int)value' param);  	break;  case ElementValueType.Short:  	result = _objOps.Invoke (function' el' (short)value' param);  	break;  case ElementValueType.UInt:  	result = _objOps.Invoke (function' el' (uint)value' param);  	break;  case ElementValueType.UShort:  	result = _objOps.Invoke (function' el' (ushort)value' param);  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitFunctionCall,The following switch statement is missing a default case: switch (vt.type) {  case VarType.Int:  	if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  		AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  	}  	EmitByte (0x73);  	Emit ((ushort)locals [smt [i].token].index);  	break;  case VarType.Float:  	if (fs.args [argcount - 1] != VarType.Float && fs.args [argcount - 1] != VarType.Int) {  		AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  	}  	EmitByte (0x66);  	Emit ((ushort)locals [smt [i].token].index);  	break;  case VarType.Ref:  	if (fs.args [argcount - 1] != VarType.Ref) {  		AddError ("Invalid argument " + i + " to function. Expected " + fs.args [argcount - 1].ToString ());  	}  	EmitRefLabel (smt [i]' RefType.Expression);  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitRefLabel,The following switch statement is missing a default case: switch (type) {  case RefType.Standard:  	Emit (0x1c);  	break;  case RefType.Expression:  	EmitByte (0x72);  	break;  case RefType.Standalone:  	EmitByte (0x5a);  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,EmitShowMessage,The following switch statement is missing a default case: switch (vt.type) {  case VarType.Int:  	EmitByte (0x73);  	Emit ((ushort)locals [smt [i].token].index);  	break;  case VarType.Float:  	EmitByte (0x66);  	Emit ((ushort)locals [smt [i].token].index);  	break;  case VarType.Ref:  	EmitRefLabel (smt [i]' RefType.Expression);  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleBlock,The following switch statement is missing a default case: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
Missing Default,TESVSnip.Domain.Scripts,ScriptCompiler,F:\newReposMay17\figment_tesvsnip\Domain\Scripts\ScriptCompiler.cs,HandleResultsBlock,The following switch statement is missing a default case: switch (smt [0].keyword) {  case Keywords.If: {  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x16);  	long pos2 = bw.BaseStream.Length;  	Emit (0);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  	bw.BaseStream.Position = pos2;  	Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  	bw.BaseStream.Position = bw.BaseStream.Length;  	opcodecount.Add (0);  	break;  }  case Keywords.ElseIf:  	if (flowControl.Count == 0) {  		AddError ("elseif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	{  		Emit (0x18);  		long pos2 = bw.BaseStream.Length;  		Emit (0);  		flowControl.Push (bw.BaseStream.Length);  		Emit (0);  		EmitExpression (TrimStatement (smt' 1)' ExpressionType.If);  		bw.BaseStream.Position = pos2;  		Emit ((ushort)(bw.BaseStream.Length - (pos2 + 2)));  		bw.BaseStream.Position = bw.BaseStream.Length;  		opcodecount.Add (0);  	}  	break;  case Keywords.Else:  	if (flowControl.Count == 0) {  		AddError ("else without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	Emit (0x17);  	Emit (2);  	flowControl.Push (bw.BaseStream.Length);  	Emit (0);  	opcodecount.Add (0);  	break;  case Keywords.EndIf:  	Emit (0x19);  	Emit (0);  	if (flowControl.Count == 0) {  		AddError ("endif without matching if");  	} else {  		bw.BaseStream.Position = flowControl.Pop ();  		Emit (opcodecount [opcodecount.Count - 1]);  		opcodecount.RemoveAt (opcodecount.Count - 1);  		bw.BaseStream.Position = bw.BaseStream.Length;  	}  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  case Keywords.Return:  	Emit (0x1e);  	Emit (0);  	for (int i = 0; i < opcodecount.Count; i++) {  		opcodecount [i] += 1;  	}  	break;  }  
