Implementation smell,Namespace,Class,File,Method,Description
Long Method,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The method has 357 lines of code.
Long Method,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The method has 142 lines of code.
Long Method,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The method has 148 lines of code.
Complex Method,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,Cyclomatic complexity of the method is 42
Complex Method,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,Cyclomatic complexity of the method is 10
Complex Method,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,GeodesicLine,Cyclomatic complexity of the method is 8
Complex Method,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,Cyclomatic complexity of the method is 16
Complex Method,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,Cyclomatic complexity of the method is 8
Complex Method,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,Cyclomatic complexity of the method is 10
Complex Method,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,Cyclomatic complexity of the method is 9
Long Parameter List,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Direct,The method has 5 parameters.
Long Parameter List,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,ArcDirect,The method has 5 parameters.
Long Parameter List,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Direct,The method has 6 parameters.
Long Parameter List,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The method has 5 parameters.
Long Parameter List,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lengths,The method has 13 parameters.
Long Parameter List,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The method has 9 parameters.
Long Parameter List,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lambda12,The method has 12 parameters.
Long Parameter List,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,GeodesicLine,The method has 5 parameters.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,ArcDirect,The length of the statement  "	return Direct (lat1' lon1' azi1' true' a12' GeodesicMask.LATITUDE | GeodesicMask.LONGITUDE | GeodesicMask.AZIMUTH | GeodesicMask.DISTANCE); " is 139.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The length of the statement  "	double lam12 = lon12 * GeoMath.Degree' slam12 = Math.Abs (lon12) == 180 ? 0 : Math.Sin (lam12)' clam12 = Math.Cos (lam12); " is 122.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The length of the statement  "			LengthsV v = Lengths (_n' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a); " is 140.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The length of the statement  "				LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a); " is 141.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The length of the statement  "			ssig1 = sbet1' csig1 = calp1 * cbet1' ssig2 = sbet2' csig2 = calp2 * cbet2' k2 = GeoMath.Sq (calp0) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2)' // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0). " is 210.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lengths,The length of the statement  "	double A1m1 = A1m1f (eps)' AB1 = (1 + A1m1) * (SinCosSeries (true' ssig2' csig2' C1a) - SinCosSeries (true' ssig1' csig1' C1a))' A2m1 = A2m1f (eps)' AB2 = (1 + A2m1) * (SinCosSeries (true' ssig2' csig2' C2a) - SinCosSeries (true' ssig1' csig1' C2a)); " is 250.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The length of the statement  "	w.calp1 = comg12 >= 0 ? sbet12 + cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 + comg12) : sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12); " is 147.
Long Statement,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lambda12,The length of the statement  "	w.calp2 = cbet2 != cbet1 || Math.Abs (sbet2) != -sbet1 ? Math.Sqrt (GeoMath.Sq (calp1 * cbet1) + (cbet1 < -sbet1 ? (cbet2 - cbet1) * (cbet1 + cbet2) : (sbet1 - sbet2) * (sbet1 + sbet2))) / cbet2 : Math.Abs (calp1); " is 214.
Long Statement,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,ArcPosition,The length of the statement  "	return Position (true' a12' GeodesicMask.LATITUDE | GeodesicMask.LONGITUDE | GeodesicMask.AZIMUTH | GeodesicMask.DISTANCE); " is 123.
Long Statement,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The length of the statement  "		double B22 = Geodesic.SinCosSeries (true' ssig3' csig3' _C2a)' AB2 = (1 + _A2m1) * (B22 - _B21)' J12 = (_A1m1 - _A2m1) * sig12 + (AB1 - AB2); " is 141.
Long Statement,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The length of the statement  "			salp12 = _calp0 * _salp0 * (csig12 <= 0 ? _csig1 * (1 - csig12) + ssig12 * _ssig1 : ssig12 * (_csig1 * ssig12 / (1 + csig12) + _ssig1)); " is 136.
Long Statement,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The length of the statement  "		GeodesicData g = _earth.Inverse (i == 0 ? _lat1 : lat' i == 0 ? _lon1 : lon' i != 0 ? _lat0 : lat' i != 0 ? _lon0 : lon' _mask); " is 128.
Complex Conditional,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The conditional expression  "!meridian && sbet1 == 0 && // and sbet3 == 0  // Mimic the way Lambda12 works with calp1 = 0  (_f <= 0 || lam12 <= Math.PI - _f * Math.PI)"  is complex.
Empty Catch Block,GeographicLib.Util,Inverse,C:\repos\suryapratap_GeographicLib\GeographicLib\Util\Inverse.cs,main,The method has an empty catch block.
Empty Catch Block,GeographicLib.Util,Planimeter,C:\repos\suryapratap_GeographicLib\GeographicLib\Util\Planimeter.cs,main,The method has an empty catch block.
Empty Catch Block,GeographicLib.Util,Direct,C:\repos\suryapratap_GeographicLib\GeographicLib\Util\Direct.cs,main,The method has an empty catch block.
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Geodesic,The following statement contains a magic number: _e2 = _f * (2 - _f);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Geodesic,The following statement contains a magic number: _n = _f / (2 - _f);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Geodesic,The following statement contains a magic number: _c2 = (GeoMath.Sq (_a) + GeoMath.Sq (_b) * (_e2 == 0 ? 1 : (_e2 > 0 ? GeoMath.Atanh (Math.Sqrt (_e2)) : Math.Atan (Math.Sqrt (-_e2))) / Math.Sqrt (Math.Abs (_e2)))) / 2;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Geodesic,The following statement contains a magic number: _etol2 = 0.1 * tol2_ / Math.Sqrt (Math.Max (0.001' Math.Abs (_f)) * Math.Min (1.0' 1 - _f / 2) / 2);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Geodesic,The following statement contains a magic number: _etol2 = 0.1 * tol2_ / Math.Sqrt (Math.Max (0.001' Math.Abs (_f)) * Math.Min (1.0' 1 - _f / 2) / 2);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Geodesic,The following statement contains a magic number: _etol2 = 0.1 * tol2_ / Math.Sqrt (Math.Max (0.001' Math.Abs (_f)) * Math.Min (1.0' 1 - _f / 2) / 2);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Geodesic,The following statement contains a magic number: _etol2 = 0.1 * tol2_ / Math.Sqrt (Math.Max (0.001' Math.Abs (_f)) * Math.Min (1.0' 1 - _f / 2) / 2);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: cbet1 = lat1 == -90 ? tiny_ : Math.Cos (phi);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: cbet2 = Math.Abs (lat2) == 90 ? tiny_ : Math.Cos (phi);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && sbet1 == 0 && // and sbet3 == 0  // Mimic the way Lambda12 works with calp1 = 0  (_f <= 0 || lam12 <= Math.PI - _f * Math.PI)) {  	// Geodesic runs along equator  	calp1 = calp2 = 0;  	salp1 = salp2 = 1;  	s12x = _a * lam12;  	sig12 = omg12 = lam12 / _f1;  	m12x = _b * Math.Sin (sig12);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12);  	a12 = lon12 / _f1;  }  else if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && sbet1 == 0 && // and sbet3 == 0  // Mimic the way Lambda12 works with calp1 = 0  (_f <= 0 || lam12 <= Math.PI - _f * Math.PI)) {  	// Geodesic runs along equator  	calp1 = calp2 = 0;  	salp1 = salp2 = 1;  	s12x = _a * lam12;  	sig12 = omg12 = lam12 / _f1;  	m12x = _b * Math.Sin (sig12);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12);  	a12 = lon12 / _f1;  }  else if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && sbet1 == 0 && // and sbet3 == 0  // Mimic the way Lambda12 works with calp1 = 0  (_f <= 0 || lam12 <= Math.PI - _f * Math.PI)) {  	// Geodesic runs along equator  	calp1 = calp2 = 0;  	salp1 = salp2 = 1;  	s12x = _a * lam12;  	sig12 = omg12 = lam12 / _f1;  	m12x = _b * Math.Sin (sig12);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12);  	a12 = lon12 / _f1;  }  else if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && sbet1 == 0 && // and sbet3 == 0  // Mimic the way Lambda12 works with calp1 = 0  (_f <= 0 || lam12 <= Math.PI - _f * Math.PI)) {  	// Geodesic runs along equator  	calp1 = calp2 = 0;  	salp1 = salp2 = 1;  	s12x = _a * lam12;  	sig12 = omg12 = lam12 / _f1;  	m12x = _b * Math.Sin (sig12);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12);  	a12 = lon12 / _f1;  }  else if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && sbet1 == 0 && // and sbet3 == 0  // Mimic the way Lambda12 works with calp1 = 0  (_f <= 0 || lam12 <= Math.PI - _f * Math.PI)) {  	// Geodesic runs along equator  	calp1 = calp2 = 0;  	salp1 = salp2 = 1;  	s12x = _a * lam12;  	sig12 = omg12 = lam12 / _f1;  	m12x = _b * Math.Sin (sig12);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12);  	a12 = lon12 / _f1;  }  else if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian) {  	// Now point1 and point2 belong within a hemisphere bounded by a  	// meridian and geodesic is neither meridional or equatorial.  	// Figure a starting point for Newton's method  	double dnm;  	{  		InverseStartV v = InverseStart (sbet1' cbet1' dn1' sbet2' cbet2' dn2' lam12' C1a' C2a);  		sig12 = v.sig12;  		salp1 = v.salp1;  		calp1 = v.calp1;  		salp2 = v.salp2;  		calp2 = v.calp2;  		dnm = v.dnm;  	}  	if (sig12 >= 0) {  		// Short lines (InverseStart sets salp3' calp3' dnm)  		s12x = sig12 * _b * dnm;  		m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  			r.M12 = r.M21 = Math.Cos (sig12 / dnm);  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 / (_f1 * dnm);  	}  	else {  		// Newton's method.  This is a straightforward solution of f(alp1) =  		// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  		// root in the interval (0' pi) and its derivative is positive at the  		// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  		// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  		// maintained which brackets the root and with each evaluation of  		// f(alp) the range is shrunk' if possible.  Newton's method is  		// restarted whenever the derivative of f is negative (because the new  		// value of alp1 is then further from the solution) or if the new  		// estimate of alp1 lies outside (0'pi); in this case' the new starting  		// guess is taken to be (alp1a + alp1b) / 2.  		double ssig1' csig1' ssig2' csig2' eps;  		ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  		int numit = 0;  		// Bracketing range  		double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  		for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  			// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  			// WGS84 and random input: mean = 2.85' sd = 0.60  			double v' dv;  			{  				Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  				v = w.lam12 - lam12;  				salp2 = w.salp2;  				calp2 = w.calp2;  				sig12 = w.sig12;  				ssig1 = w.ssig1;  				csig1 = w.csig1;  				ssig2 = w.ssig2;  				csig2 = w.csig2;  				eps = w.eps;  				omg12 = w.domg12;  				dv = w.dlam12;  			// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  			// Reversed test to allow escape with NaNs  			// Update bracketing values  			// Either dv was not postive or updated value was outside legal  			// range.  Use the midpoint of the bracket as the next estimate.  			// This mechanism is not needed for the WGS84 ellipsoid' but it does  			// catch problems with more eccentric ellipsoids.  Its efficacy is  			// such for the WGS84 test set with the starting guess set to alp1 =  			// 90deg:  			// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  			// WGS84 and random input: mean = 4.74' sd = 0.99  			}  			if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  				break;  			if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  				salp1b = salp1;  				calp1b = calp1;  			}  			else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  				salp1a = salp1;  				calp1a = calp1;  			}  			if (numit < maxit1_ && dv > 0) {  				double dalp1 = -v / dv;  				double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  				if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  					calp1 = calp1 * cdalp1 - salp1 * sdalp1;  					salp1 = nsalp1;  					{  						Pair p = SinCosNorm (salp1' calp1);  						salp1 = p.First;  						calp1 = p.Second;  					// In some regimes we don't get quadratic convergence because  					// slope -> 0.  So use convergence conditions based on Epsilon  					// instead of sqrt(Epsilon).  					}  					tripn = Math.Abs (v) <= 16 * tol0_;  					continue;  				}  			}  			salp1 = (salp1a + salp1b) / 2;  			calp1 = (calp1a + calp1b) / 2;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			}  			tripn = false;  			tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  		}  		{  			LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  			s12x = v.s12b;  			m12x = v.m12b;  			if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  				r.M12 = v.M12;  				r.M21 = v.M21;  			}  		}  		m12x *= _b;  		s12x *= _b;  		a12 = sig12 / GeoMath.Degree;  		omg12 = lam12 - omg12;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (sig12 >= 0) {  	// Short lines (InverseStart sets salp3' calp3' dnm)  	s12x = sig12 * _b * dnm;  	m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12 / dnm);  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 / (_f1 * dnm);  }  else {  	// Newton's method.  This is a straightforward solution of f(alp1) =  	// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  	// root in the interval (0' pi) and its derivative is positive at the  	// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  	// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  	// maintained which brackets the root and with each evaluation of  	// f(alp) the range is shrunk' if possible.  Newton's method is  	// restarted whenever the derivative of f is negative (because the new  	// value of alp1 is then further from the solution) or if the new  	// estimate of alp1 lies outside (0'pi); in this case' the new starting  	// guess is taken to be (alp1a + alp1b) / 2.  	double ssig1' csig1' ssig2' csig2' eps;  	ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  	int numit = 0;  	// Bracketing range  	double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  	for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  		// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  		// WGS84 and random input: mean = 2.85' sd = 0.60  		double v' dv;  		{  			Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  			v = w.lam12 - lam12;  			salp2 = w.salp2;  			calp2 = w.calp2;  			sig12 = w.sig12;  			ssig1 = w.ssig1;  			csig1 = w.csig1;  			ssig2 = w.ssig2;  			csig2 = w.csig2;  			eps = w.eps;  			omg12 = w.domg12;  			dv = w.dlam12;  		// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  		// Reversed test to allow escape with NaNs  		// Update bracketing values  		// Either dv was not postive or updated value was outside legal  		// range.  Use the midpoint of the bracket as the next estimate.  		// This mechanism is not needed for the WGS84 ellipsoid' but it does  		// catch problems with more eccentric ellipsoids.  Its efficacy is  		// such for the WGS84 test set with the starting guess set to alp1 =  		// 90deg:  		// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  		// WGS84 and random input: mean = 4.74' sd = 0.99  		}  		if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  			break;  		if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  			salp1b = salp1;  			calp1b = calp1;  		}  		else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  			salp1a = salp1;  			calp1a = calp1;  		}  		if (numit < maxit1_ && dv > 0) {  			double dalp1 = -v / dv;  			double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  			if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  				calp1 = calp1 * cdalp1 - salp1 * sdalp1;  				salp1 = nsalp1;  				{  					Pair p = SinCosNorm (salp1' calp1);  					salp1 = p.First;  					calp1 = p.Second;  				// In some regimes we don't get quadratic convergence because  				// slope -> 0.  So use convergence conditions based on Epsilon  				// instead of sqrt(Epsilon).  				}  				tripn = Math.Abs (v) <= 16 * tol0_;  				continue;  			}  		}  		salp1 = (salp1a + salp1b) / 2;  		calp1 = (calp1a + calp1b) / 2;  		{  			Pair p = SinCosNorm (salp1' calp1);  			salp1 = p.First;  			calp1 = p.Second;  		}  		tripn = false;  		tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  	}  	{  		LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  		s12x = v.s12b;  		m12x = v.m12b;  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  			r.M12 = v.M12;  			r.M21 = v.M21;  		}  	}  	m12x *= _b;  	s12x *= _b;  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 - omg12;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (sig12 >= 0) {  	// Short lines (InverseStart sets salp3' calp3' dnm)  	s12x = sig12 * _b * dnm;  	m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12 / dnm);  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 / (_f1 * dnm);  }  else {  	// Newton's method.  This is a straightforward solution of f(alp1) =  	// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  	// root in the interval (0' pi) and its derivative is positive at the  	// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  	// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  	// maintained which brackets the root and with each evaluation of  	// f(alp) the range is shrunk' if possible.  Newton's method is  	// restarted whenever the derivative of f is negative (because the new  	// value of alp1 is then further from the solution) or if the new  	// estimate of alp1 lies outside (0'pi); in this case' the new starting  	// guess is taken to be (alp1a + alp1b) / 2.  	double ssig1' csig1' ssig2' csig2' eps;  	ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  	int numit = 0;  	// Bracketing range  	double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  	for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  		// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  		// WGS84 and random input: mean = 2.85' sd = 0.60  		double v' dv;  		{  			Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  			v = w.lam12 - lam12;  			salp2 = w.salp2;  			calp2 = w.calp2;  			sig12 = w.sig12;  			ssig1 = w.ssig1;  			csig1 = w.csig1;  			ssig2 = w.ssig2;  			csig2 = w.csig2;  			eps = w.eps;  			omg12 = w.domg12;  			dv = w.dlam12;  		// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  		// Reversed test to allow escape with NaNs  		// Update bracketing values  		// Either dv was not postive or updated value was outside legal  		// range.  Use the midpoint of the bracket as the next estimate.  		// This mechanism is not needed for the WGS84 ellipsoid' but it does  		// catch problems with more eccentric ellipsoids.  Its efficacy is  		// such for the WGS84 test set with the starting guess set to alp1 =  		// 90deg:  		// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  		// WGS84 and random input: mean = 4.74' sd = 0.99  		}  		if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  			break;  		if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  			salp1b = salp1;  			calp1b = calp1;  		}  		else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  			salp1a = salp1;  			calp1a = calp1;  		}  		if (numit < maxit1_ && dv > 0) {  			double dalp1 = -v / dv;  			double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  			if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  				calp1 = calp1 * cdalp1 - salp1 * sdalp1;  				salp1 = nsalp1;  				{  					Pair p = SinCosNorm (salp1' calp1);  					salp1 = p.First;  					calp1 = p.Second;  				// In some regimes we don't get quadratic convergence because  				// slope -> 0.  So use convergence conditions based on Epsilon  				// instead of sqrt(Epsilon).  				}  				tripn = Math.Abs (v) <= 16 * tol0_;  				continue;  			}  		}  		salp1 = (salp1a + salp1b) / 2;  		calp1 = (calp1a + calp1b) / 2;  		{  			Pair p = SinCosNorm (salp1' calp1);  			salp1 = p.First;  			calp1 = p.Second;  		}  		tripn = false;  		tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  	}  	{  		LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  		s12x = v.s12b;  		m12x = v.m12b;  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  			r.M12 = v.M12;  			r.M21 = v.M21;  		}  	}  	m12x *= _b;  	s12x *= _b;  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 - omg12;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (sig12 >= 0) {  	// Short lines (InverseStart sets salp3' calp3' dnm)  	s12x = sig12 * _b * dnm;  	m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12 / dnm);  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 / (_f1 * dnm);  }  else {  	// Newton's method.  This is a straightforward solution of f(alp1) =  	// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  	// root in the interval (0' pi) and its derivative is positive at the  	// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  	// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  	// maintained which brackets the root and with each evaluation of  	// f(alp) the range is shrunk' if possible.  Newton's method is  	// restarted whenever the derivative of f is negative (because the new  	// value of alp1 is then further from the solution) or if the new  	// estimate of alp1 lies outside (0'pi); in this case' the new starting  	// guess is taken to be (alp1a + alp1b) / 2.  	double ssig1' csig1' ssig2' csig2' eps;  	ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  	int numit = 0;  	// Bracketing range  	double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  	for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  		// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  		// WGS84 and random input: mean = 2.85' sd = 0.60  		double v' dv;  		{  			Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  			v = w.lam12 - lam12;  			salp2 = w.salp2;  			calp2 = w.calp2;  			sig12 = w.sig12;  			ssig1 = w.ssig1;  			csig1 = w.csig1;  			ssig2 = w.ssig2;  			csig2 = w.csig2;  			eps = w.eps;  			omg12 = w.domg12;  			dv = w.dlam12;  		// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  		// Reversed test to allow escape with NaNs  		// Update bracketing values  		// Either dv was not postive or updated value was outside legal  		// range.  Use the midpoint of the bracket as the next estimate.  		// This mechanism is not needed for the WGS84 ellipsoid' but it does  		// catch problems with more eccentric ellipsoids.  Its efficacy is  		// such for the WGS84 test set with the starting guess set to alp1 =  		// 90deg:  		// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  		// WGS84 and random input: mean = 4.74' sd = 0.99  		}  		if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  			break;  		if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  			salp1b = salp1;  			calp1b = calp1;  		}  		else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  			salp1a = salp1;  			calp1a = calp1;  		}  		if (numit < maxit1_ && dv > 0) {  			double dalp1 = -v / dv;  			double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  			if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  				calp1 = calp1 * cdalp1 - salp1 * sdalp1;  				salp1 = nsalp1;  				{  					Pair p = SinCosNorm (salp1' calp1);  					salp1 = p.First;  					calp1 = p.Second;  				// In some regimes we don't get quadratic convergence because  				// slope -> 0.  So use convergence conditions based on Epsilon  				// instead of sqrt(Epsilon).  				}  				tripn = Math.Abs (v) <= 16 * tol0_;  				continue;  			}  		}  		salp1 = (salp1a + salp1b) / 2;  		calp1 = (calp1a + calp1b) / 2;  		{  			Pair p = SinCosNorm (salp1' calp1);  			salp1 = p.First;  			calp1 = p.Second;  		}  		tripn = false;  		tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  	}  	{  		LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  		s12x = v.s12b;  		m12x = v.m12b;  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  			r.M12 = v.M12;  			r.M21 = v.M21;  		}  	}  	m12x *= _b;  	s12x *= _b;  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 - omg12;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (sig12 >= 0) {  	// Short lines (InverseStart sets salp3' calp3' dnm)  	s12x = sig12 * _b * dnm;  	m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12 / dnm);  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 / (_f1 * dnm);  }  else {  	// Newton's method.  This is a straightforward solution of f(alp1) =  	// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  	// root in the interval (0' pi) and its derivative is positive at the  	// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  	// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  	// maintained which brackets the root and with each evaluation of  	// f(alp) the range is shrunk' if possible.  Newton's method is  	// restarted whenever the derivative of f is negative (because the new  	// value of alp1 is then further from the solution) or if the new  	// estimate of alp1 lies outside (0'pi); in this case' the new starting  	// guess is taken to be (alp1a + alp1b) / 2.  	double ssig1' csig1' ssig2' csig2' eps;  	ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  	int numit = 0;  	// Bracketing range  	double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  	for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  		// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  		// WGS84 and random input: mean = 2.85' sd = 0.60  		double v' dv;  		{  			Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  			v = w.lam12 - lam12;  			salp2 = w.salp2;  			calp2 = w.calp2;  			sig12 = w.sig12;  			ssig1 = w.ssig1;  			csig1 = w.csig1;  			ssig2 = w.ssig2;  			csig2 = w.csig2;  			eps = w.eps;  			omg12 = w.domg12;  			dv = w.dlam12;  		// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  		// Reversed test to allow escape with NaNs  		// Update bracketing values  		// Either dv was not postive or updated value was outside legal  		// range.  Use the midpoint of the bracket as the next estimate.  		// This mechanism is not needed for the WGS84 ellipsoid' but it does  		// catch problems with more eccentric ellipsoids.  Its efficacy is  		// such for the WGS84 test set with the starting guess set to alp1 =  		// 90deg:  		// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  		// WGS84 and random input: mean = 4.74' sd = 0.99  		}  		if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  			break;  		if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  			salp1b = salp1;  			calp1b = calp1;  		}  		else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  			salp1a = salp1;  			calp1a = calp1;  		}  		if (numit < maxit1_ && dv > 0) {  			double dalp1 = -v / dv;  			double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  			if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  				calp1 = calp1 * cdalp1 - salp1 * sdalp1;  				salp1 = nsalp1;  				{  					Pair p = SinCosNorm (salp1' calp1);  					salp1 = p.First;  					calp1 = p.Second;  				// In some regimes we don't get quadratic convergence because  				// slope -> 0.  So use convergence conditions based on Epsilon  				// instead of sqrt(Epsilon).  				}  				tripn = Math.Abs (v) <= 16 * tol0_;  				continue;  			}  		}  		salp1 = (salp1a + salp1b) / 2;  		calp1 = (calp1a + calp1b) / 2;  		{  			Pair p = SinCosNorm (salp1' calp1);  			salp1 = p.First;  			calp1 = p.Second;  		}  		tripn = false;  		tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  	}  	{  		LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  		s12x = v.s12b;  		m12x = v.m12b;  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  			r.M12 = v.M12;  			r.M21 = v.M21;  		}  	}  	m12x *= _b;  	s12x *= _b;  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 - omg12;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (sig12 >= 0) {  	// Short lines (InverseStart sets salp3' calp3' dnm)  	s12x = sig12 * _b * dnm;  	m12x = GeoMath.Sq (dnm) * _b * Math.Sin (sig12 / dnm);  	if ((outmask & GeodesicMask.GEODESICSCALE) != 0)  		r.M12 = r.M21 = Math.Cos (sig12 / dnm);  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 / (_f1 * dnm);  }  else {  	// Newton's method.  This is a straightforward solution of f(alp1) =  	// lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one  	// root in the interval (0' pi) and its derivative is positive at the  	// root.  Thus f(alp) is positive for alp > alp1 and negative for alp <  	// alp1.  During the course of the iteration' a range (alp1a' alp1b) is  	// maintained which brackets the root and with each evaluation of  	// f(alp) the range is shrunk' if possible.  Newton's method is  	// restarted whenever the derivative of f is negative (because the new  	// value of alp1 is then further from the solution) or if the new  	// estimate of alp1 lies outside (0'pi); in this case' the new starting  	// guess is taken to be (alp1a + alp1b) / 2.  	double ssig1' csig1' ssig2' csig2' eps;  	ssig1 = csig1 = ssig2 = csig2 = eps = Double.NaN;  	int numit = 0;  	// Bracketing range  	double salp1a = tiny_' calp1a = 1' salp1b = tiny_' calp1b = -1;  	for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  		// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  		// WGS84 and random input: mean = 2.85' sd = 0.60  		double v' dv;  		{  			Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  			v = w.lam12 - lam12;  			salp2 = w.salp2;  			calp2 = w.calp2;  			sig12 = w.sig12;  			ssig1 = w.ssig1;  			csig1 = w.csig1;  			ssig2 = w.ssig2;  			csig2 = w.csig2;  			eps = w.eps;  			omg12 = w.domg12;  			dv = w.dlam12;  		// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  		// Reversed test to allow escape with NaNs  		// Update bracketing values  		// Either dv was not postive or updated value was outside legal  		// range.  Use the midpoint of the bracket as the next estimate.  		// This mechanism is not needed for the WGS84 ellipsoid' but it does  		// catch problems with more eccentric ellipsoids.  Its efficacy is  		// such for the WGS84 test set with the starting guess set to alp1 =  		// 90deg:  		// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  		// WGS84 and random input: mean = 4.74' sd = 0.99  		}  		if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  			break;  		if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  			salp1b = salp1;  			calp1b = calp1;  		}  		else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  			salp1a = salp1;  			calp1a = calp1;  		}  		if (numit < maxit1_ && dv > 0) {  			double dalp1 = -v / dv;  			double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  			if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  				calp1 = calp1 * cdalp1 - salp1 * sdalp1;  				salp1 = nsalp1;  				{  					Pair p = SinCosNorm (salp1' calp1);  					salp1 = p.First;  					calp1 = p.Second;  				// In some regimes we don't get quadratic convergence because  				// slope -> 0.  So use convergence conditions based on Epsilon  				// instead of sqrt(Epsilon).  				}  				tripn = Math.Abs (v) <= 16 * tol0_;  				continue;  			}  		}  		salp1 = (salp1a + salp1b) / 2;  		calp1 = (calp1a + calp1b) / 2;  		{  			Pair p = SinCosNorm (salp1' calp1);  			salp1 = p.First;  			calp1 = p.Second;  		}  		tripn = false;  		tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  	}  	{  		LengthsV v = Lengths (eps' sig12' ssig1' csig1' dn1' ssig2' csig2' dn2' cbet1' cbet2' (outmask & GeodesicMask.GEODESICSCALE) != 0' C1a' C2a);  		s12x = v.s12b;  		m12x = v.m12b;  		if ((outmask & GeodesicMask.GEODESICSCALE) != 0) {  			r.M12 = v.M12;  			r.M21 = v.M21;  		}  	}  	m12x *= _b;  	s12x *= _b;  	a12 = sig12 / GeoMath.Degree;  	omg12 = lam12 - omg12;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  	// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  	// WGS84 and random input: mean = 2.85' sd = 0.60  	double v' dv;  	{  		Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  		v = w.lam12 - lam12;  		salp2 = w.salp2;  		calp2 = w.calp2;  		sig12 = w.sig12;  		ssig1 = w.ssig1;  		csig1 = w.csig1;  		ssig2 = w.ssig2;  		csig2 = w.csig2;  		eps = w.eps;  		omg12 = w.domg12;  		dv = w.dlam12;  	// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  	// Reversed test to allow escape with NaNs  	// Update bracketing values  	// Either dv was not postive or updated value was outside legal  	// range.  Use the midpoint of the bracket as the next estimate.  	// This mechanism is not needed for the WGS84 ellipsoid' but it does  	// catch problems with more eccentric ellipsoids.  Its efficacy is  	// such for the WGS84 test set with the starting guess set to alp1 =  	// 90deg:  	// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  	// WGS84 and random input: mean = 4.74' sd = 0.99  	}  	if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  		break;  	if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  		salp1b = salp1;  		calp1b = calp1;  	}  	else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  		salp1a = salp1;  		calp1a = calp1;  	}  	if (numit < maxit1_ && dv > 0) {  		double dalp1 = -v / dv;  		double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  		if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  			calp1 = calp1 * cdalp1 - salp1 * sdalp1;  			salp1 = nsalp1;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			// In some regimes we don't get quadratic convergence because  			// slope -> 0.  So use convergence conditions based on Epsilon  			// instead of sqrt(Epsilon).  			}  			tripn = Math.Abs (v) <= 16 * tol0_;  			continue;  		}  	}  	salp1 = (salp1a + salp1b) / 2;  	calp1 = (calp1a + calp1b) / 2;  	{  		Pair p = SinCosNorm (salp1' calp1);  		salp1 = p.First;  		calp1 = p.Second;  	}  	tripn = false;  	tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  	// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  	// WGS84 and random input: mean = 2.85' sd = 0.60  	double v' dv;  	{  		Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  		v = w.lam12 - lam12;  		salp2 = w.salp2;  		calp2 = w.calp2;  		sig12 = w.sig12;  		ssig1 = w.ssig1;  		csig1 = w.csig1;  		ssig2 = w.ssig2;  		csig2 = w.csig2;  		eps = w.eps;  		omg12 = w.domg12;  		dv = w.dlam12;  	// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  	// Reversed test to allow escape with NaNs  	// Update bracketing values  	// Either dv was not postive or updated value was outside legal  	// range.  Use the midpoint of the bracket as the next estimate.  	// This mechanism is not needed for the WGS84 ellipsoid' but it does  	// catch problems with more eccentric ellipsoids.  Its efficacy is  	// such for the WGS84 test set with the starting guess set to alp1 =  	// 90deg:  	// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  	// WGS84 and random input: mean = 4.74' sd = 0.99  	}  	if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  		break;  	if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  		salp1b = salp1;  		calp1b = calp1;  	}  	else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  		salp1a = salp1;  		calp1a = calp1;  	}  	if (numit < maxit1_ && dv > 0) {  		double dalp1 = -v / dv;  		double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  		if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  			calp1 = calp1 * cdalp1 - salp1 * sdalp1;  			salp1 = nsalp1;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			// In some regimes we don't get quadratic convergence because  			// slope -> 0.  So use convergence conditions based on Epsilon  			// instead of sqrt(Epsilon).  			}  			tripn = Math.Abs (v) <= 16 * tol0_;  			continue;  		}  	}  	salp1 = (salp1a + salp1b) / 2;  	calp1 = (calp1a + calp1b) / 2;  	{  		Pair p = SinCosNorm (salp1' calp1);  		salp1 = p.First;  		calp1 = p.Second;  	}  	tripn = false;  	tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  	// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  	// WGS84 and random input: mean = 2.85' sd = 0.60  	double v' dv;  	{  		Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  		v = w.lam12 - lam12;  		salp2 = w.salp2;  		calp2 = w.calp2;  		sig12 = w.sig12;  		ssig1 = w.ssig1;  		csig1 = w.csig1;  		ssig2 = w.ssig2;  		csig2 = w.csig2;  		eps = w.eps;  		omg12 = w.domg12;  		dv = w.dlam12;  	// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  	// Reversed test to allow escape with NaNs  	// Update bracketing values  	// Either dv was not postive or updated value was outside legal  	// range.  Use the midpoint of the bracket as the next estimate.  	// This mechanism is not needed for the WGS84 ellipsoid' but it does  	// catch problems with more eccentric ellipsoids.  Its efficacy is  	// such for the WGS84 test set with the starting guess set to alp1 =  	// 90deg:  	// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  	// WGS84 and random input: mean = 4.74' sd = 0.99  	}  	if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  		break;  	if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  		salp1b = salp1;  		calp1b = calp1;  	}  	else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  		salp1a = salp1;  		calp1a = calp1;  	}  	if (numit < maxit1_ && dv > 0) {  		double dalp1 = -v / dv;  		double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  		if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  			calp1 = calp1 * cdalp1 - salp1 * sdalp1;  			salp1 = nsalp1;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			// In some regimes we don't get quadratic convergence because  			// slope -> 0.  So use convergence conditions based on Epsilon  			// instead of sqrt(Epsilon).  			}  			tripn = Math.Abs (v) <= 16 * tol0_;  			continue;  		}  	}  	salp1 = (salp1a + salp1b) / 2;  	calp1 = (calp1a + calp1b) / 2;  	{  		Pair p = SinCosNorm (salp1' calp1);  		salp1 = p.First;  		calp1 = p.Second;  	}  	tripn = false;  	tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  	// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  	// WGS84 and random input: mean = 2.85' sd = 0.60  	double v' dv;  	{  		Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  		v = w.lam12 - lam12;  		salp2 = w.salp2;  		calp2 = w.calp2;  		sig12 = w.sig12;  		ssig1 = w.ssig1;  		csig1 = w.csig1;  		ssig2 = w.ssig2;  		csig2 = w.csig2;  		eps = w.eps;  		omg12 = w.domg12;  		dv = w.dlam12;  	// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  	// Reversed test to allow escape with NaNs  	// Update bracketing values  	// Either dv was not postive or updated value was outside legal  	// range.  Use the midpoint of the bracket as the next estimate.  	// This mechanism is not needed for the WGS84 ellipsoid' but it does  	// catch problems with more eccentric ellipsoids.  Its efficacy is  	// such for the WGS84 test set with the starting guess set to alp1 =  	// 90deg:  	// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  	// WGS84 and random input: mean = 4.74' sd = 0.99  	}  	if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  		break;  	if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  		salp1b = salp1;  		calp1b = calp1;  	}  	else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  		salp1a = salp1;  		calp1a = calp1;  	}  	if (numit < maxit1_ && dv > 0) {  		double dalp1 = -v / dv;  		double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  		if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  			calp1 = calp1 * cdalp1 - salp1 * sdalp1;  			salp1 = nsalp1;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			// In some regimes we don't get quadratic convergence because  			// slope -> 0.  So use convergence conditions based on Epsilon  			// instead of sqrt(Epsilon).  			}  			tripn = Math.Abs (v) <= 16 * tol0_;  			continue;  		}  	}  	salp1 = (salp1a + salp1b) / 2;  	calp1 = (calp1a + calp1b) / 2;  	{  		Pair p = SinCosNorm (salp1' calp1);  		salp1 = p.First;  		calp1 = p.Second;  	}  	tripn = false;  	tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: for (bool tripn = false' tripb = false; numit < maxit2_; ++numit) {  	// the WGS84 test set: mean = 1.47' sd = 1.25' max = 16  	// WGS84 and random input: mean = 2.85' sd = 0.60  	double v' dv;  	{  		Lambda12V w = Lambda12 (sbet1' cbet1' dn1' sbet2' cbet2' dn2' salp1' calp1' numit < maxit1_' C1a' C2a' C3a);  		v = w.lam12 - lam12;  		salp2 = w.salp2;  		calp2 = w.calp2;  		sig12 = w.sig12;  		ssig1 = w.ssig1;  		csig1 = w.csig1;  		ssig2 = w.ssig2;  		csig2 = w.csig2;  		eps = w.eps;  		omg12 = w.domg12;  		dv = w.dlam12;  	// 2 * tol0 is approximately 1 ulp for a number in [0' pi].  	// Reversed test to allow escape with NaNs  	// Update bracketing values  	// Either dv was not postive or updated value was outside legal  	// range.  Use the midpoint of the bracket as the next estimate.  	// This mechanism is not needed for the WGS84 ellipsoid' but it does  	// catch problems with more eccentric ellipsoids.  Its efficacy is  	// such for the WGS84 test set with the starting guess set to alp1 =  	// 90deg:  	// the WGS84 test set: mean = 5.21' sd = 3.93' max = 24  	// WGS84 and random input: mean = 4.74' sd = 0.99  	}  	if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  		break;  	if (v > 0 && (numit > maxit1_ || calp1 / salp1 > calp1b / salp1b)) {  		salp1b = salp1;  		calp1b = calp1;  	}  	else if (v < 0 && (numit > maxit1_ || calp1 / salp1 < calp1a / salp1a)) {  		salp1a = salp1;  		calp1a = calp1;  	}  	if (numit < maxit1_ && dv > 0) {  		double dalp1 = -v / dv;  		double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  		if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  			calp1 = calp1 * cdalp1 - salp1 * sdalp1;  			salp1 = nsalp1;  			{  				Pair p = SinCosNorm (salp1' calp1);  				salp1 = p.First;  				calp1 = p.Second;  			// In some regimes we don't get quadratic convergence because  			// slope -> 0.  So use convergence conditions based on Epsilon  			// instead of sqrt(Epsilon).  			}  			tripn = Math.Abs (v) <= 16 * tol0_;  			continue;  		}  	}  	salp1 = (salp1a + salp1b) / 2;  	calp1 = (calp1a + calp1b) / 2;  	{  		Pair p = SinCosNorm (salp1' calp1);  		salp1 = p.First;  		calp1 = p.Second;  	}  	tripn = false;  	tripb = (Math.Abs (salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.Abs (salp1 - salp1b) + (calp1 - calp1b) < tolb_);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  	break;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (tripb || !(Math.Abs (v) >= (tripn ? 8 : 2) * tol0_))  	break;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (numit < maxit1_ && dv > 0) {  	double dalp1 = -v / dv;  	double sdalp1 = Math.Sin (dalp1)' cdalp1 = Math.Cos (dalp1)' nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;  	if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  		calp1 = calp1 * cdalp1 - salp1 * sdalp1;  		salp1 = nsalp1;  		{  			Pair p = SinCosNorm (salp1' calp1);  			salp1 = p.First;  			calp1 = p.Second;  		// In some regimes we don't get quadratic convergence because  		// slope -> 0.  So use convergence conditions based on Epsilon  		// instead of sqrt(Epsilon).  		}  		tripn = Math.Abs (v) <= 16 * tol0_;  		continue;  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (nsalp1 > 0 && Math.Abs (dalp1) < Math.PI) {  	calp1 = calp1 * cdalp1 - salp1 * sdalp1;  	salp1 = nsalp1;  	{  		Pair p = SinCosNorm (salp1' calp1);  		salp1 = p.First;  		calp1 = p.Second;  	// In some regimes we don't get quadratic convergence because  	// slope -> 0.  So use convergence conditions based on Epsilon  	// instead of sqrt(Epsilon).  	}  	tripn = Math.Abs (v) <= 16 * tol0_;  	continue;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: tripn = Math.Abs (v) <= 16 * tol0_;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: salp1 = (salp1a + salp1b) / 2;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: calp1 = (calp1a + calp1b) / 2;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if ((outmask & GeodesicMask.AREA) != 0) {  	double // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)  	salp0 = salp1 * cbet1' calp0 = GeoMath.Hypot (calp1' salp1 * sbet1);  	// calp0 > 0  	double alp12;  	if (calp0 != 0 && salp0 != 0) {  		double // From Lambda12: tan(bet) = tan(sig) * cos(alp)  		ssig1 = sbet1' csig1 = calp1 * cbet1' ssig2 = sbet2' csig2 = calp2 * cbet2' k2 = GeoMath.Sq (calp0) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2)' // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).  		A4 = GeoMath.Sq (_a) * calp0 * salp0 * _e2;  		{  			Pair p = SinCosNorm (ssig1' csig1);  			ssig1 = p.First;  			csig1 = p.Second;  		}  		{  			Pair p = SinCosNorm (ssig2' csig2);  			ssig2 = p.First;  			csig2 = p.Second;  		}  		double[] C4a = new double[nC4_];  		C4f (eps' C4a);  		double B41 = SinCosSeries (false' ssig1' csig1' C4a)' B42 = SinCosSeries (false' ssig2' csig2' C4a);  		r.S12 = A4 * (B42 - B41);  	}  	else  		// Avoid problems with indeterminate sig1' sig2 on equator  		r.S12 = 0;  	if (!meridian && omg12 < 0.75 * Math.PI && // Long difference too big  	sbet2 - sbet1 < 1.75) {  		// Lat difference too big  		// Use tan(Gamma/2) = tan(omg12/2)  		// * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))  		// with tan(x/2) = sin(x)/(1+cos(x))  		double somg12 = Math.Sin (omg12)' domg12 = 1 + Math.Cos (omg12)' dbet1 = 1 + cbet1' dbet2 = 1 + cbet2;  		alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  	}  	else {  		// alp12 = alp2 - alp1' used in atan2 so no need to normalize  		double salp12 = salp2 * calp1 - calp2 * salp1' calp12 = calp2 * calp1 + salp2 * salp1;  		// The right thing appears to happen if alp1 = +/-180 and alp2 = 0' viz  		// salp12 = -0 and alp12 = -180.  However this depends on the sign  		// being attached to 0 correctly.  The following ensures the correct  		// behavior.  		if (salp12 == 0 && calp12 < 0) {  			salp12 = tiny_ * calp1;  			calp12 = -1;  		}  		alp12 = Math.Atan2 (salp12' calp12);  	}  	r.S12 += _c2 * alp12;  	r.S12 *= swapp * lonsign * latsign;  	// Convert -0 to 0  	r.S12 += 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if ((outmask & GeodesicMask.AREA) != 0) {  	double // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)  	salp0 = salp1 * cbet1' calp0 = GeoMath.Hypot (calp1' salp1 * sbet1);  	// calp0 > 0  	double alp12;  	if (calp0 != 0 && salp0 != 0) {  		double // From Lambda12: tan(bet) = tan(sig) * cos(alp)  		ssig1 = sbet1' csig1 = calp1 * cbet1' ssig2 = sbet2' csig2 = calp2 * cbet2' k2 = GeoMath.Sq (calp0) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2)' // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).  		A4 = GeoMath.Sq (_a) * calp0 * salp0 * _e2;  		{  			Pair p = SinCosNorm (ssig1' csig1);  			ssig1 = p.First;  			csig1 = p.Second;  		}  		{  			Pair p = SinCosNorm (ssig2' csig2);  			ssig2 = p.First;  			csig2 = p.Second;  		}  		double[] C4a = new double[nC4_];  		C4f (eps' C4a);  		double B41 = SinCosSeries (false' ssig1' csig1' C4a)' B42 = SinCosSeries (false' ssig2' csig2' C4a);  		r.S12 = A4 * (B42 - B41);  	}  	else  		// Avoid problems with indeterminate sig1' sig2 on equator  		r.S12 = 0;  	if (!meridian && omg12 < 0.75 * Math.PI && // Long difference too big  	sbet2 - sbet1 < 1.75) {  		// Lat difference too big  		// Use tan(Gamma/2) = tan(omg12/2)  		// * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))  		// with tan(x/2) = sin(x)/(1+cos(x))  		double somg12 = Math.Sin (omg12)' domg12 = 1 + Math.Cos (omg12)' dbet1 = 1 + cbet1' dbet2 = 1 + cbet2;  		alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  	}  	else {  		// alp12 = alp2 - alp1' used in atan2 so no need to normalize  		double salp12 = salp2 * calp1 - calp2 * salp1' calp12 = calp2 * calp1 + salp2 * salp1;  		// The right thing appears to happen if alp1 = +/-180 and alp2 = 0' viz  		// salp12 = -0 and alp12 = -180.  However this depends on the sign  		// being attached to 0 correctly.  The following ensures the correct  		// behavior.  		if (salp12 == 0 && calp12 < 0) {  			salp12 = tiny_ * calp1;  			calp12 = -1;  		}  		alp12 = Math.Atan2 (salp12' calp12);  	}  	r.S12 += _c2 * alp12;  	r.S12 *= swapp * lonsign * latsign;  	// Convert -0 to 0  	r.S12 += 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if ((outmask & GeodesicMask.AREA) != 0) {  	double // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)  	salp0 = salp1 * cbet1' calp0 = GeoMath.Hypot (calp1' salp1 * sbet1);  	// calp0 > 0  	double alp12;  	if (calp0 != 0 && salp0 != 0) {  		double // From Lambda12: tan(bet) = tan(sig) * cos(alp)  		ssig1 = sbet1' csig1 = calp1 * cbet1' ssig2 = sbet2' csig2 = calp2 * cbet2' k2 = GeoMath.Sq (calp0) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2)' // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).  		A4 = GeoMath.Sq (_a) * calp0 * salp0 * _e2;  		{  			Pair p = SinCosNorm (ssig1' csig1);  			ssig1 = p.First;  			csig1 = p.Second;  		}  		{  			Pair p = SinCosNorm (ssig2' csig2);  			ssig2 = p.First;  			csig2 = p.Second;  		}  		double[] C4a = new double[nC4_];  		C4f (eps' C4a);  		double B41 = SinCosSeries (false' ssig1' csig1' C4a)' B42 = SinCosSeries (false' ssig2' csig2' C4a);  		r.S12 = A4 * (B42 - B41);  	}  	else  		// Avoid problems with indeterminate sig1' sig2 on equator  		r.S12 = 0;  	if (!meridian && omg12 < 0.75 * Math.PI && // Long difference too big  	sbet2 - sbet1 < 1.75) {  		// Lat difference too big  		// Use tan(Gamma/2) = tan(omg12/2)  		// * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))  		// with tan(x/2) = sin(x)/(1+cos(x))  		double somg12 = Math.Sin (omg12)' domg12 = 1 + Math.Cos (omg12)' dbet1 = 1 + cbet1' dbet2 = 1 + cbet2;  		alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  	}  	else {  		// alp12 = alp2 - alp1' used in atan2 so no need to normalize  		double salp12 = salp2 * calp1 - calp2 * salp1' calp12 = calp2 * calp1 + salp2 * salp1;  		// The right thing appears to happen if alp1 = +/-180 and alp2 = 0' viz  		// salp12 = -0 and alp12 = -180.  However this depends on the sign  		// being attached to 0 correctly.  The following ensures the correct  		// behavior.  		if (salp12 == 0 && calp12 < 0) {  			salp12 = tiny_ * calp1;  			calp12 = -1;  		}  		alp12 = Math.Atan2 (salp12' calp12);  	}  	r.S12 += _c2 * alp12;  	r.S12 *= swapp * lonsign * latsign;  	// Convert -0 to 0  	r.S12 += 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if ((outmask & GeodesicMask.AREA) != 0) {  	double // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)  	salp0 = salp1 * cbet1' calp0 = GeoMath.Hypot (calp1' salp1 * sbet1);  	// calp0 > 0  	double alp12;  	if (calp0 != 0 && salp0 != 0) {  		double // From Lambda12: tan(bet) = tan(sig) * cos(alp)  		ssig1 = sbet1' csig1 = calp1 * cbet1' ssig2 = sbet2' csig2 = calp2 * cbet2' k2 = GeoMath.Sq (calp0) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2)' // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).  		A4 = GeoMath.Sq (_a) * calp0 * salp0 * _e2;  		{  			Pair p = SinCosNorm (ssig1' csig1);  			ssig1 = p.First;  			csig1 = p.Second;  		}  		{  			Pair p = SinCosNorm (ssig2' csig2);  			ssig2 = p.First;  			csig2 = p.Second;  		}  		double[] C4a = new double[nC4_];  		C4f (eps' C4a);  		double B41 = SinCosSeries (false' ssig1' csig1' C4a)' B42 = SinCosSeries (false' ssig2' csig2' C4a);  		r.S12 = A4 * (B42 - B41);  	}  	else  		// Avoid problems with indeterminate sig1' sig2 on equator  		r.S12 = 0;  	if (!meridian && omg12 < 0.75 * Math.PI && // Long difference too big  	sbet2 - sbet1 < 1.75) {  		// Lat difference too big  		// Use tan(Gamma/2) = tan(omg12/2)  		// * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))  		// with tan(x/2) = sin(x)/(1+cos(x))  		double somg12 = Math.Sin (omg12)' domg12 = 1 + Math.Cos (omg12)' dbet1 = 1 + cbet1' dbet2 = 1 + cbet2;  		alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  	}  	else {  		// alp12 = alp2 - alp1' used in atan2 so no need to normalize  		double salp12 = salp2 * calp1 - calp2 * salp1' calp12 = calp2 * calp1 + salp2 * salp1;  		// The right thing appears to happen if alp1 = +/-180 and alp2 = 0' viz  		// salp12 = -0 and alp12 = -180.  However this depends on the sign  		// being attached to 0 correctly.  The following ensures the correct  		// behavior.  		if (salp12 == 0 && calp12 < 0) {  			salp12 = tiny_ * calp1;  			calp12 = -1;  		}  		alp12 = Math.Atan2 (salp12' calp12);  	}  	r.S12 += _c2 * alp12;  	r.S12 *= swapp * lonsign * latsign;  	// Convert -0 to 0  	r.S12 += 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (calp0 != 0 && salp0 != 0) {  	double // From Lambda12: tan(bet) = tan(sig) * cos(alp)  	ssig1 = sbet1' csig1 = calp1 * cbet1' ssig2 = sbet2' csig2 = calp2 * cbet2' k2 = GeoMath.Sq (calp0) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2)' // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).  	A4 = GeoMath.Sq (_a) * calp0 * salp0 * _e2;  	{  		Pair p = SinCosNorm (ssig1' csig1);  		ssig1 = p.First;  		csig1 = p.Second;  	}  	{  		Pair p = SinCosNorm (ssig2' csig2);  		ssig2 = p.First;  		csig2 = p.Second;  	}  	double[] C4a = new double[nC4_];  	C4f (eps' C4a);  	double B41 = SinCosSeries (false' ssig1' csig1' C4a)' B42 = SinCosSeries (false' ssig2' csig2' C4a);  	r.S12 = A4 * (B42 - B41);  }  else  	// Avoid problems with indeterminate sig1' sig2 on equator  	r.S12 = 0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && omg12 < 0.75 * Math.PI && // Long difference too big  sbet2 - sbet1 < 1.75) {  	// Lat difference too big  	// Use tan(Gamma/2) = tan(omg12/2)  	// * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))  	// with tan(x/2) = sin(x)/(1+cos(x))  	double somg12 = Math.Sin (omg12)' domg12 = 1 + Math.Cos (omg12)' dbet1 = 1 + cbet1' dbet2 = 1 + cbet2;  	alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  }  else {  	// alp12 = alp2 - alp1' used in atan2 so no need to normalize  	double salp12 = salp2 * calp1 - calp2 * salp1' calp12 = calp2 * calp1 + salp2 * salp1;  	// The right thing appears to happen if alp1 = +/-180 and alp2 = 0' viz  	// salp12 = -0 and alp12 = -180.  However this depends on the sign  	// being attached to 0 correctly.  The following ensures the correct  	// behavior.  	if (salp12 == 0 && calp12 < 0) {  		salp12 = tiny_ * calp1;  		calp12 = -1;  	}  	alp12 = Math.Atan2 (salp12' calp12);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && omg12 < 0.75 * Math.PI && // Long difference too big  sbet2 - sbet1 < 1.75) {  	// Lat difference too big  	// Use tan(Gamma/2) = tan(omg12/2)  	// * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))  	// with tan(x/2) = sin(x)/(1+cos(x))  	double somg12 = Math.Sin (omg12)' domg12 = 1 + Math.Cos (omg12)' dbet1 = 1 + cbet1' dbet2 = 1 + cbet2;  	alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  }  else {  	// alp12 = alp2 - alp1' used in atan2 so no need to normalize  	double salp12 = salp2 * calp1 - calp2 * salp1' calp12 = calp2 * calp1 + salp2 * salp1;  	// The right thing appears to happen if alp1 = +/-180 and alp2 = 0' viz  	// salp12 = -0 and alp12 = -180.  However this depends on the sign  	// being attached to 0 correctly.  The following ensures the correct  	// behavior.  	if (salp12 == 0 && calp12 < 0) {  		salp12 = tiny_ * calp1;  		calp12 = -1;  	}  	alp12 = Math.Atan2 (salp12' calp12);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: if (!meridian && omg12 < 0.75 * Math.PI && // Long difference too big  sbet2 - sbet1 < 1.75) {  	// Lat difference too big  	// Use tan(Gamma/2) = tan(omg12/2)  	// * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))  	// with tan(x/2) = sin(x)/(1+cos(x))  	double somg12 = Math.Sin (omg12)' domg12 = 1 + Math.Cos (omg12)' dbet1 = 1 + cbet1' dbet2 = 1 + cbet2;  	alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  }  else {  	// alp12 = alp2 - alp1' used in atan2 so no need to normalize  	double salp12 = salp2 * calp1 - calp2 * salp1' calp12 = calp2 * calp1 + salp2 * salp1;  	// The right thing appears to happen if alp1 = +/-180 and alp2 = 0' viz  	// salp12 = -0 and alp12 = -180.  However this depends on the sign  	// being attached to 0 correctly.  The following ensures the correct  	// behavior.  	if (salp12 == 0 && calp12 < 0) {  		salp12 = tiny_ * calp1;  		calp12 = -1;  	}  	alp12 = Math.Atan2 (salp12' calp12);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Inverse,The following statement contains a magic number: alp12 = 2 * Math.Atan2 (somg12 * (sbet1 * dbet2 + sbet2 * dbet1)' domg12 * (sbet1 * sbet2 + dbet1 * dbet2));  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,EllipsoidArea,The following statement contains a magic number: return 4 * Math.PI * _c2;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,SinCosSeries,The following statement contains a magic number: n /= 2;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,SinCosSeries,The following statement contains a magic number: return sinp ? 2 * sinx * cosx * y0 // sin(2 * x) * y0  : cosx * (y0 - y1);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: if (!(q == 0 && r <= 0)) {  	double // Avoid possible division by zero when r = 0 by multiplying equations  	// for s and t by r^3 and r' resp.  	S = p * q / 4' // S = r^3 * s  	r2 = GeoMath.Sq (r)' r3 = r * r2' // The discrimant of the quadratic equation for T3.  This is zero on  	// the evolute curve p^(1/3)+q^(1/3) = 1  	disc = S * (S + 2 * r3);  	double u = r;  	if (disc >= 0) {  		double T3 = S + r3;  		// Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss  		// of precision due to cancellation.  The result is unchanged because  		// of the way the T is used in definition of u.  		T3 += T3 < 0 ? -Math.Sqrt (disc) : Math.Sqrt (disc);  		// T3 = (r * t)^3  		// N.B. cbrt always returns the double root.  cbrt(-8) = -2.  		double T = GeoMath.cbrt (T3);  		// T = r * t  		// T can be zero; but then r2 / T -> 0.  		u += T + (T != 0 ? r2 / T : 0);  	}  	else {  		// T is complex' but the way u is defined the result is double.  		double ang = Math.Atan2 (Math.Sqrt (-disc)' -(S + r3));  		// There are three possible cube roots.  We choose the root which  		// avoids cancellation.  Note that disc < 0 implies that r < 0.  		u += 2 * r * Math.Cos (ang / 3);  	}  	double v = Math.Sqrt (GeoMath.Sq (u) + q)' // guaranteed positive  	// Avoid loss of accuracy when u < 0.  	uv = u < 0 ? q / (v - u) : u + v' // u+v' guaranteed positive  	w = (uv - q) / (2 * v);  	// positive?  	// Rearrange expression for k to avoid loss of accuracy due to  	// subtraction.  Division by 0 not possible because uv > 0' w >= 0.  	k = uv / (Math.Sqrt (uv + GeoMath.Sq (w)) + w);  	// guaranteed positive  }  else {  	// q == 0 && r <= 0  	// y = 0 with |x| <= 1.  Handle this case directly.  	// for y small' positive root is k = abs(y)/sqrt(1-x^2)  	k = 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: if (!(q == 0 && r <= 0)) {  	double // Avoid possible division by zero when r = 0 by multiplying equations  	// for s and t by r^3 and r' resp.  	S = p * q / 4' // S = r^3 * s  	r2 = GeoMath.Sq (r)' r3 = r * r2' // The discrimant of the quadratic equation for T3.  This is zero on  	// the evolute curve p^(1/3)+q^(1/3) = 1  	disc = S * (S + 2 * r3);  	double u = r;  	if (disc >= 0) {  		double T3 = S + r3;  		// Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss  		// of precision due to cancellation.  The result is unchanged because  		// of the way the T is used in definition of u.  		T3 += T3 < 0 ? -Math.Sqrt (disc) : Math.Sqrt (disc);  		// T3 = (r * t)^3  		// N.B. cbrt always returns the double root.  cbrt(-8) = -2.  		double T = GeoMath.cbrt (T3);  		// T = r * t  		// T can be zero; but then r2 / T -> 0.  		u += T + (T != 0 ? r2 / T : 0);  	}  	else {  		// T is complex' but the way u is defined the result is double.  		double ang = Math.Atan2 (Math.Sqrt (-disc)' -(S + r3));  		// There are three possible cube roots.  We choose the root which  		// avoids cancellation.  Note that disc < 0 implies that r < 0.  		u += 2 * r * Math.Cos (ang / 3);  	}  	double v = Math.Sqrt (GeoMath.Sq (u) + q)' // guaranteed positive  	// Avoid loss of accuracy when u < 0.  	uv = u < 0 ? q / (v - u) : u + v' // u+v' guaranteed positive  	w = (uv - q) / (2 * v);  	// positive?  	// Rearrange expression for k to avoid loss of accuracy due to  	// subtraction.  Division by 0 not possible because uv > 0' w >= 0.  	k = uv / (Math.Sqrt (uv + GeoMath.Sq (w)) + w);  	// guaranteed positive  }  else {  	// q == 0 && r <= 0  	// y = 0 with |x| <= 1.  Handle this case directly.  	// for y small' positive root is k = abs(y)/sqrt(1-x^2)  	k = 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: if (!(q == 0 && r <= 0)) {  	double // Avoid possible division by zero when r = 0 by multiplying equations  	// for s and t by r^3 and r' resp.  	S = p * q / 4' // S = r^3 * s  	r2 = GeoMath.Sq (r)' r3 = r * r2' // The discrimant of the quadratic equation for T3.  This is zero on  	// the evolute curve p^(1/3)+q^(1/3) = 1  	disc = S * (S + 2 * r3);  	double u = r;  	if (disc >= 0) {  		double T3 = S + r3;  		// Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss  		// of precision due to cancellation.  The result is unchanged because  		// of the way the T is used in definition of u.  		T3 += T3 < 0 ? -Math.Sqrt (disc) : Math.Sqrt (disc);  		// T3 = (r * t)^3  		// N.B. cbrt always returns the double root.  cbrt(-8) = -2.  		double T = GeoMath.cbrt (T3);  		// T = r * t  		// T can be zero; but then r2 / T -> 0.  		u += T + (T != 0 ? r2 / T : 0);  	}  	else {  		// T is complex' but the way u is defined the result is double.  		double ang = Math.Atan2 (Math.Sqrt (-disc)' -(S + r3));  		// There are three possible cube roots.  We choose the root which  		// avoids cancellation.  Note that disc < 0 implies that r < 0.  		u += 2 * r * Math.Cos (ang / 3);  	}  	double v = Math.Sqrt (GeoMath.Sq (u) + q)' // guaranteed positive  	// Avoid loss of accuracy when u < 0.  	uv = u < 0 ? q / (v - u) : u + v' // u+v' guaranteed positive  	w = (uv - q) / (2 * v);  	// positive?  	// Rearrange expression for k to avoid loss of accuracy due to  	// subtraction.  Division by 0 not possible because uv > 0' w >= 0.  	k = uv / (Math.Sqrt (uv + GeoMath.Sq (w)) + w);  	// guaranteed positive  }  else {  	// q == 0 && r <= 0  	// y = 0 with |x| <= 1.  Handle this case directly.  	// for y small' positive root is k = abs(y)/sqrt(1-x^2)  	k = 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: if (!(q == 0 && r <= 0)) {  	double // Avoid possible division by zero when r = 0 by multiplying equations  	// for s and t by r^3 and r' resp.  	S = p * q / 4' // S = r^3 * s  	r2 = GeoMath.Sq (r)' r3 = r * r2' // The discrimant of the quadratic equation for T3.  This is zero on  	// the evolute curve p^(1/3)+q^(1/3) = 1  	disc = S * (S + 2 * r3);  	double u = r;  	if (disc >= 0) {  		double T3 = S + r3;  		// Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss  		// of precision due to cancellation.  The result is unchanged because  		// of the way the T is used in definition of u.  		T3 += T3 < 0 ? -Math.Sqrt (disc) : Math.Sqrt (disc);  		// T3 = (r * t)^3  		// N.B. cbrt always returns the double root.  cbrt(-8) = -2.  		double T = GeoMath.cbrt (T3);  		// T = r * t  		// T can be zero; but then r2 / T -> 0.  		u += T + (T != 0 ? r2 / T : 0);  	}  	else {  		// T is complex' but the way u is defined the result is double.  		double ang = Math.Atan2 (Math.Sqrt (-disc)' -(S + r3));  		// There are three possible cube roots.  We choose the root which  		// avoids cancellation.  Note that disc < 0 implies that r < 0.  		u += 2 * r * Math.Cos (ang / 3);  	}  	double v = Math.Sqrt (GeoMath.Sq (u) + q)' // guaranteed positive  	// Avoid loss of accuracy when u < 0.  	uv = u < 0 ? q / (v - u) : u + v' // u+v' guaranteed positive  	w = (uv - q) / (2 * v);  	// positive?  	// Rearrange expression for k to avoid loss of accuracy due to  	// subtraction.  Division by 0 not possible because uv > 0' w >= 0.  	k = uv / (Math.Sqrt (uv + GeoMath.Sq (w)) + w);  	// guaranteed positive  }  else {  	// q == 0 && r <= 0  	// y = 0 with |x| <= 1.  Handle this case directly.  	// for y small' positive root is k = abs(y)/sqrt(1-x^2)  	k = 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: if (!(q == 0 && r <= 0)) {  	double // Avoid possible division by zero when r = 0 by multiplying equations  	// for s and t by r^3 and r' resp.  	S = p * q / 4' // S = r^3 * s  	r2 = GeoMath.Sq (r)' r3 = r * r2' // The discrimant of the quadratic equation for T3.  This is zero on  	// the evolute curve p^(1/3)+q^(1/3) = 1  	disc = S * (S + 2 * r3);  	double u = r;  	if (disc >= 0) {  		double T3 = S + r3;  		// Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss  		// of precision due to cancellation.  The result is unchanged because  		// of the way the T is used in definition of u.  		T3 += T3 < 0 ? -Math.Sqrt (disc) : Math.Sqrt (disc);  		// T3 = (r * t)^3  		// N.B. cbrt always returns the double root.  cbrt(-8) = -2.  		double T = GeoMath.cbrt (T3);  		// T = r * t  		// T can be zero; but then r2 / T -> 0.  		u += T + (T != 0 ? r2 / T : 0);  	}  	else {  		// T is complex' but the way u is defined the result is double.  		double ang = Math.Atan2 (Math.Sqrt (-disc)' -(S + r3));  		// There are three possible cube roots.  We choose the root which  		// avoids cancellation.  Note that disc < 0 implies that r < 0.  		u += 2 * r * Math.Cos (ang / 3);  	}  	double v = Math.Sqrt (GeoMath.Sq (u) + q)' // guaranteed positive  	// Avoid loss of accuracy when u < 0.  	uv = u < 0 ? q / (v - u) : u + v' // u+v' guaranteed positive  	w = (uv - q) / (2 * v);  	// positive?  	// Rearrange expression for k to avoid loss of accuracy due to  	// subtraction.  Division by 0 not possible because uv > 0' w >= 0.  	k = uv / (Math.Sqrt (uv + GeoMath.Sq (w)) + w);  	// guaranteed positive  }  else {  	// q == 0 && r <= 0  	// y = 0 with |x| <= 1.  Handle this case directly.  	// for y small' positive root is k = abs(y)/sqrt(1-x^2)  	k = 0;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: if (disc >= 0) {  	double T3 = S + r3;  	// Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss  	// of precision due to cancellation.  The result is unchanged because  	// of the way the T is used in definition of u.  	T3 += T3 < 0 ? -Math.Sqrt (disc) : Math.Sqrt (disc);  	// T3 = (r * t)^3  	// N.B. cbrt always returns the double root.  cbrt(-8) = -2.  	double T = GeoMath.cbrt (T3);  	// T = r * t  	// T can be zero; but then r2 / T -> 0.  	u += T + (T != 0 ? r2 / T : 0);  }  else {  	// T is complex' but the way u is defined the result is double.  	double ang = Math.Atan2 (Math.Sqrt (-disc)' -(S + r3));  	// There are three possible cube roots.  We choose the root which  	// avoids cancellation.  Note that disc < 0 implies that r < 0.  	u += 2 * r * Math.Cos (ang / 3);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: if (disc >= 0) {  	double T3 = S + r3;  	// Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss  	// of precision due to cancellation.  The result is unchanged because  	// of the way the T is used in definition of u.  	T3 += T3 < 0 ? -Math.Sqrt (disc) : Math.Sqrt (disc);  	// T3 = (r * t)^3  	// N.B. cbrt always returns the double root.  cbrt(-8) = -2.  	double T = GeoMath.cbrt (T3);  	// T = r * t  	// T can be zero; but then r2 / T -> 0.  	u += T + (T != 0 ? r2 / T : 0);  }  else {  	// T is complex' but the way u is defined the result is double.  	double ang = Math.Atan2 (Math.Sqrt (-disc)' -(S + r3));  	// There are three possible cube roots.  We choose the root which  	// avoids cancellation.  Note that disc < 0 implies that r < 0.  	u += 2 * r * Math.Cos (ang / 3);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: u += 2 * r * Math.Cos (ang / 3);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Astroid,The following statement contains a magic number: u += 2 * r * Math.Cos (ang / 3);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (shortline && ssig12 < _etol2) {  	// really short lines  	w.salp2 = cbet1 * somg12;  	w.calp2 = sbet12 - cbet1 * sbet2 * (comg12 >= 0 ? GeoMath.Sq (somg12) / (1 + comg12) : 1 - comg12);  	{  		Pair p = SinCosNorm (w.salp2' w.calp2);  		w.salp2 = p.First;  		w.calp2 = p.Second;  	// Set return value  	}  	w.sig12 = Math.Atan2 (ssig12' csig12);  }  else if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (shortline && ssig12 < _etol2) {  	// really short lines  	w.salp2 = cbet1 * somg12;  	w.calp2 = sbet12 - cbet1 * sbet2 * (comg12 >= 0 ? GeoMath.Sq (somg12) / (1 + comg12) : 1 - comg12);  	{  		Pair p = SinCosNorm (w.salp2' w.calp2);  		w.salp2 = p.First;  		w.calp2 = p.Second;  	// Set return value  	}  	w.sig12 = Math.Atan2 (ssig12' csig12);  }  else if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (shortline && ssig12 < _etol2) {  	// really short lines  	w.salp2 = cbet1 * somg12;  	w.calp2 = sbet12 - cbet1 * sbet2 * (comg12 >= 0 ? GeoMath.Sq (somg12) / (1 + comg12) : 1 - comg12);  	{  		Pair p = SinCosNorm (w.salp2' w.calp2);  		w.salp2 = p.First;  		w.calp2 = p.Second;  	// Set return value  	}  	w.sig12 = Math.Atan2 (ssig12' csig12);  }  else if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (shortline && ssig12 < _etol2) {  	// really short lines  	w.salp2 = cbet1 * somg12;  	w.calp2 = sbet12 - cbet1 * sbet2 * (comg12 >= 0 ? GeoMath.Sq (somg12) / (1 + comg12) : 1 - comg12);  	{  		Pair p = SinCosNorm (w.salp2' w.calp2);  		w.salp2 = p.First;  		w.calp2 = p.Second;  	// Set return value  	}  	w.sig12 = Math.Atan2 (ssig12' csig12);  }  else if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (Math.Abs (_n) > 0.1 || // Skip astroid calc if too eccentric  csig12 >= 0 || ssig12 >= 6 * Math.Abs (_n) * Math.PI * GeoMath.Sq (cbet1)) {  	// Nothing to do' zeroth order spherical approximation is OK  }  else {  	// Scale lam12 and bet2 to x' y coordinate system where antipodal point  	// is at origin and singular point is at y = 0' x = -1.  	double y' lamscale' betscale;  	// In C++ volatile declaration needed to fix inverse case  	// 56.320923501171 0 -56.320923501171 179.664747671772880215  	// which otherwise fails with g++ 4.4.4 x86 -O3  	double x;  	if (_f >= 0) {  		// In fact f == 0 does not get here  		// x = dlong' y = dlat  		{  			double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  			lamscale = _f * cbet1 * A3f (eps) * Math.PI;  		}  		betscale = lamscale * cbet1;  		x = (lam12 - Math.PI) / lamscale;  		y = sbet12a / betscale;  	}  	else {  		// _f < 0  		// x = dlat' y = dlong  		double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  		double m12b' m0;  		// In the case of lon12 = 180' this repeats a calculation made in  		// Inverse.  		LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  		m12b = v.m12b;  		m0 = v.m0;  		x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  		betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  		lamscale = betscale / cbet1;  		y = (lam12 - Math.PI) / lamscale;  	}  	if (y > -tol1_ && x > -1 - xthresh_) {  		// strip near cut  		if (_f >= 0) {  			w.salp1 = Math.Min (1.0' -x);  			w.calp1 = -Math.Sqrt (1 - GeoMath.Sq (w.salp1));  		}  		else {  			w.calp1 = Math.Max (x > -tol1_ ? 0.0 : -1.0' x);  			w.salp1 = Math.Sqrt (1 - GeoMath.Sq (w.calp1));  		}  	}  	else {  		// Estimate alp1' by solving the astroid problem.  		//  		// Could estimate alpha1 = theta + pi/2' directly' i.e.'  		//   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0  		//   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)  		//  		// However' it's better to estimate omg12 from astroid and use  		// spherical formula to compute alp1.  This reduces the mean number of  		// Newton iterations for astroid cases from 2.24 (Min 0' max 6) to 2.12  		// (Min 0 max 5).  The changes in the number of iterations are as  		// follows:  		//  		// change percent  		//    1       5  		//    0      78  		//   -1      16  		//   -2       0.6  		//   -3       0.04  		//   -4       0.002  		//  		// The histogram of iterations is (m = number of iterations estimating  		// alp1 directly' n = number of iterations estimating via omg12' total  		// number of trials = 148605):  		//  		//  iter    m      n  		//    0   148    186  		//    1 13046  13845  		//    2 93315 102225  		//    3 36189  32341  		//    4  5396      7  		//    5   455      1  		//    6    56      0  		//  		// Because omg12 is near pi' estimate work with omg12a = pi - omg12  		double k = Astroid (x' y);  		double omg12a = lamscale * (_f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);  		somg12 = Math.Sin (omg12a);  		comg12 = -Math.Cos (omg12a);  		// Update spherical estimate of alp1 using omg12 instead of lam12  		w.salp1 = cbet2 * somg12;  		w.calp1 = sbet12a - cbet2 * sbet1 * GeoMath.Sq (somg12) / (1 - comg12);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (_f >= 0) {  	// In fact f == 0 does not get here  	// x = dlong' y = dlat  	{  		double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  		lamscale = _f * cbet1 * A3f (eps) * Math.PI;  	}  	betscale = lamscale * cbet1;  	x = (lam12 - Math.PI) / lamscale;  	y = sbet12a / betscale;  }  else {  	// _f < 0  	// x = dlat' y = dlong  	double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  	double m12b' m0;  	// In the case of lon12 = 180' this repeats a calculation made in  	// Inverse.  	LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  	m12b = v.m12b;  	m0 = v.m0;  	x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  	betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  	lamscale = betscale / cbet1;  	y = (lam12 - Math.PI) / lamscale;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: if (_f >= 0) {  	// In fact f == 0 does not get here  	// x = dlong' y = dlat  	{  		double k2 = GeoMath.Sq (sbet1) * _ep2' eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  		lamscale = _f * cbet1 * A3f (eps) * Math.PI;  	}  	betscale = lamscale * cbet1;  	x = (lam12 - Math.PI) / lamscale;  	y = sbet12a / betscale;  }  else {  	// _f < 0  	// x = dlat' y = dlong  	double cbet12a = cbet2 * cbet1 - sbet2 * sbet1' bet12a = Math.Atan2 (sbet12a' cbet12a);  	double m12b' m0;  	// In the case of lon12 = 180' this repeats a calculation made in  	// Inverse.  	LengthsV v = Lengths (_n' Math.PI + bet12a' sbet1' -cbet1' dn1' sbet2' cbet2' dn2' cbet1' cbet2' false' C1a' C2a);  	m12b = v.m12b;  	m0 = v.m0;  	x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);  	betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  	lamscale = betscale / cbet1;  	y = (lam12 - Math.PI) / lamscale;  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,InverseStart,The following statement contains a magic number: betscale = x < -0.01 ? sbet12a / x : -_f * GeoMath.Sq (cbet1) * Math.PI;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lambda12,The following statement contains a magic number: w.eps = k2 / (2 * (1 + Math.Sqrt (1 + k2)) + k2);  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lambda12,The following statement contains a magic number: if (diffp) {  	if (w.calp2 == 0)  		w.dlam12 = -2 * _f1 * dn1 / sbet1;  	else {  		double dummy;  		LengthsV v = Lengths (w.eps' w.sig12' w.ssig1' w.csig1' dn1' w.ssig2' w.csig2' dn2' cbet1' cbet2' false' C1a' C2a);  		w.dlam12 = v.m12b;  		w.dlam12 *= _f1 / (w.calp2 * cbet2);  	}  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lambda12,The following statement contains a magic number: if (w.calp2 == 0)  	w.dlam12 = -2 * _f1 * dn1 / sbet1;  else {  	double dummy;  	LengthsV v = Lengths (w.eps' w.sig12' w.ssig1' w.csig1' dn1' w.ssig2' w.csig2' dn2' cbet1' cbet2' false' C1a' C2a);  	w.dlam12 = v.m12b;  	w.dlam12 *= _f1 / (w.calp2 * cbet2);  }  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,Lambda12,The following statement contains a magic number: w.dlam12 = -2 * _f1 * dn1 / sbet1;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A1m1f,The following statement contains a magic number: t = eps2 * (eps2 * (eps2 + 4) + 64) / 256;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A1m1f,The following statement contains a magic number: t = eps2 * (eps2 * (eps2 + 4) + 64) / 256;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A1m1f,The following statement contains a magic number: t = eps2 * (eps2 * (eps2 + 4) + 64) / 256;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [1] = d * ((6 - eps2) * eps2 - 16) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [1] = d * ((6 - eps2) * eps2 - 16) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [1] = d * ((6 - eps2) * eps2 - 16) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [2] = d * ((64 - 9 * eps2) * eps2 - 128) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [2] = d * ((64 - 9 * eps2) * eps2 - 128) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [2] = d * ((64 - 9 * eps2) * eps2 - 128) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [2] = d * ((64 - 9 * eps2) * eps2 - 128) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [2] = d * ((64 - 9 * eps2) * eps2 - 128) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [3] = d * (9 * eps2 - 16) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [3] = d * (9 * eps2 - 16) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [3] = d * (9 * eps2 - 16) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [3] = d * (9 * eps2 - 16) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [4] = d * (3 * eps2 - 5) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [4] = d * (3 * eps2 - 5) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [4] = d * (3 * eps2 - 5) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [4] = d * (3 * eps2 - 5) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [5] = -7 * d / 1280;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [5] = -7 * d / 1280;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [5] = -7 * d / 1280;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [6] = -7 * d / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [6] = -7 * d / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1f,The following statement contains a magic number: c [6] = -7 * d / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [1] = d * (eps2 * (205 * eps2 - 432) + 768) / 1536;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [1] = d * (eps2 * (205 * eps2 - 432) + 768) / 1536;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [1] = d * (eps2 * (205 * eps2 - 432) + 768) / 1536;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [1] = d * (eps2 * (205 * eps2 - 432) + 768) / 1536;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [2] = d * (eps2 * (4005 * eps2 - 4736) + 3840) / 12288;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [2] = d * (eps2 * (4005 * eps2 - 4736) + 3840) / 12288;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [2] = d * (eps2 * (4005 * eps2 - 4736) + 3840) / 12288;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [2] = d * (eps2 * (4005 * eps2 - 4736) + 3840) / 12288;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [2] = d * (eps2 * (4005 * eps2 - 4736) + 3840) / 12288;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [3] = d * (116 - 225 * eps2) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [3] = d * (116 - 225 * eps2) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [3] = d * (116 - 225 * eps2) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [3] = d * (116 - 225 * eps2) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [4] = d * (2695 - 7173 * eps2) / 7680;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [4] = d * (2695 - 7173 * eps2) / 7680;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [4] = d * (2695 - 7173 * eps2) / 7680;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [4] = d * (2695 - 7173 * eps2) / 7680;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [5] = 3467 * d / 7680;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [5] = 3467 * d / 7680;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [5] = 3467 * d / 7680;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [6] = 38081 * d / 61440;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [6] = 38081 * d / 61440;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C1pf,The following statement contains a magic number: c [6] = 38081 * d / 61440;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A2m1f,The following statement contains a magic number: t = eps2 * (eps2 * (25 * eps2 + 36) + 64) / 256;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A2m1f,The following statement contains a magic number: t = eps2 * (eps2 * (25 * eps2 + 36) + 64) / 256;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A2m1f,The following statement contains a magic number: t = eps2 * (eps2 * (25 * eps2 + 36) + 64) / 256;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A2m1f,The following statement contains a magic number: t = eps2 * (eps2 * (25 * eps2 + 36) + 64) / 256;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [1] = d * (eps2 * (eps2 + 2) + 16) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [1] = d * (eps2 * (eps2 + 2) + 16) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [1] = d * (eps2 * (eps2 + 2) + 16) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [2] = d * (eps2 * (35 * eps2 + 64) + 384) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [2] = d * (eps2 * (35 * eps2 + 64) + 384) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [2] = d * (eps2 * (35 * eps2 + 64) + 384) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [2] = d * (eps2 * (35 * eps2 + 64) + 384) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [2] = d * (eps2 * (35 * eps2 + 64) + 384) / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [3] = d * (15 * eps2 + 80) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [3] = d * (15 * eps2 + 80) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [3] = d * (15 * eps2 + 80) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [3] = d * (15 * eps2 + 80) / 768;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [4] = d * (7 * eps2 + 35) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [4] = d * (7 * eps2 + 35) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [4] = d * (7 * eps2 + 35) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [4] = d * (7 * eps2 + 35) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [5] = 63 * d / 1280;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [5] = 63 * d / 1280;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [5] = 63 * d / 1280;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [6] = 77 * d / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [6] = 77 * d / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C2f,The following statement contains a magic number: c [6] = 77 * d / 2048;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [1] = (_n - 1) / 2;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [2] = (_n * (3 * _n - 1) - 2) / 8;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [2] = (_n * (3 * _n - 1) - 2) / 8;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [2] = (_n * (3 * _n - 1) - 2) / 8;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [2] = (_n * (3 * _n - 1) - 2) / 8;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [3] = ((-_n - 3) * _n - 1) / 16;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [3] = ((-_n - 3) * _n - 1) / 16;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [3] = ((-_n - 3) * _n - 1) / 16;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [4] = (-2 * _n - 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [4] = (-2 * _n - 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [4] = (-2 * _n - 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [4] = (-2 * _n - 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [5] = -3 / 128.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [5] = -3 / 128.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,A3coeff,The following statement contains a magic number: _A3x [5] = -3 / 128.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [0] = (1 - _n) / 4;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [1] = (1 - _n * _n) / 8;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [2] = ((3 - _n) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [2] = ((3 - _n) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [2] = ((3 - _n) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [2] = ((3 - _n) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [3] = (2 * _n + 5) / 128;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [3] = (2 * _n + 5) / 128;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [3] = (2 * _n + 5) / 128;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [3] = (2 * _n + 5) / 128;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [4] = 3 / 128.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [4] = 3 / 128.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [4] = 3 / 128.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [5] = ((_n - 3) * _n + 2) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [5] = ((_n - 3) * _n + 2) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [5] = ((_n - 3) * _n + 2) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [5] = ((_n - 3) * _n + 2) / 32;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [6] = ((-3 * _n - 2) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [6] = ((-3 * _n - 2) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [6] = ((-3 * _n - 2) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [6] = ((-3 * _n - 2) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [6] = ((-3 * _n - 2) * _n + 3) / 64;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [7] = (_n + 3) / 128;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [7] = (_n + 3) / 128;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [7] = (_n + 3) / 128;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [8] = 5 / 256.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [8] = 5 / 256.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [8] = 5 / 256.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [9] = (_n * (5 * _n - 9) + 5) / 192;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [9] = (_n * (5 * _n - 9) + 5) / 192;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [9] = (_n * (5 * _n - 9) + 5) / 192;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [9] = (_n * (5 * _n - 9) + 5) / 192;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [9] = (_n * (5 * _n - 9) + 5) / 192;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [10] = (9 - 10 * _n) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [10] = (9 - 10 * _n) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [10] = (9 - 10 * _n) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [10] = (9 - 10 * _n) / 384;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [11] = 7 / 512.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [11] = 7 / 512.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [11] = 7 / 512.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [12] = (7 - 14 * _n) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [12] = (7 - 14 * _n) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [12] = (7 - 14 * _n) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [12] = (7 - 14 * _n) / 512;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [13] = 7 / 512.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [13] = 7 / 512.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [13] = 7 / 512.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [14] = 21 / 2560.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [14] = 21 / 2560.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C3coeff,The following statement contains a magic number: _C3x [14] = 21 / 2560.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [0] = (_n * (_n * (_n * (_n * (100 * _n + 208) + 572) + 3432) - 12012) + 30030) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [0] = (_n * (_n * (_n * (_n * (100 * _n + 208) + 572) + 3432) - 12012) + 30030) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [0] = (_n * (_n * (_n * (_n * (100 * _n + 208) + 572) + 3432) - 12012) + 30030) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [0] = (_n * (_n * (_n * (_n * (100 * _n + 208) + 572) + 3432) - 12012) + 30030) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [0] = (_n * (_n * (_n * (_n * (100 * _n + 208) + 572) + 3432) - 12012) + 30030) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [0] = (_n * (_n * (_n * (_n * (100 * _n + 208) + 572) + 3432) - 12012) + 30030) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [0] = (_n * (_n * (_n * (_n * (100 * _n + 208) + 572) + 3432) - 12012) + 30030) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [1] = (_n * (_n * (_n * (64 * _n + 624) - 4576) + 6864) - 3003) / 15015;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [1] = (_n * (_n * (_n * (64 * _n + 624) - 4576) + 6864) - 3003) / 15015;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [1] = (_n * (_n * (_n * (64 * _n + 624) - 4576) + 6864) - 3003) / 15015;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [1] = (_n * (_n * (_n * (64 * _n + 624) - 4576) + 6864) - 3003) / 15015;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [1] = (_n * (_n * (_n * (64 * _n + 624) - 4576) + 6864) - 3003) / 15015;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [1] = (_n * (_n * (_n * (64 * _n + 624) - 4576) + 6864) - 3003) / 15015;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [2] = (_n * ((14144 - 10656 * _n) * _n - 4576) - 858) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [2] = (_n * ((14144 - 10656 * _n) * _n - 4576) - 858) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [2] = (_n * ((14144 - 10656 * _n) * _n - 4576) - 858) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [2] = (_n * ((14144 - 10656 * _n) * _n - 4576) - 858) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [2] = (_n * ((14144 - 10656 * _n) * _n - 4576) - 858) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [2] = (_n * ((14144 - 10656 * _n) * _n - 4576) - 858) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [3] = ((-224 * _n - 4784) * _n + 1573) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [3] = ((-224 * _n - 4784) * _n + 1573) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [3] = ((-224 * _n - 4784) * _n + 1573) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [3] = ((-224 * _n - 4784) * _n + 1573) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [3] = ((-224 * _n - 4784) * _n + 1573) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [4] = (1088 * _n + 156) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [4] = (1088 * _n + 156) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [4] = (1088 * _n + 156) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [4] = (1088 * _n + 156) / 45045;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [5] = 97 / 15015.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [5] = 97 / 15015.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [5] = 97 / 15015.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [6] = (_n * (_n * ((-64 * _n - 624) * _n + 4576) - 6864) + 3003) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [6] = (_n * (_n * ((-64 * _n - 624) * _n + 4576) - 6864) + 3003) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [6] = (_n * (_n * ((-64 * _n - 624) * _n + 4576) - 6864) + 3003) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [6] = (_n * (_n * ((-64 * _n - 624) * _n + 4576) - 6864) + 3003) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [6] = (_n * (_n * ((-64 * _n - 624) * _n + 4576) - 6864) + 3003) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [6] = (_n * (_n * ((-64 * _n - 624) * _n + 4576) - 6864) + 3003) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [6] = (_n * (_n * ((-64 * _n - 624) * _n + 4576) - 6864) + 3003) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [7] = (_n * (_n * (5952 * _n - 11648) + 9152) - 2574) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [7] = (_n * (_n * (5952 * _n - 11648) + 9152) - 2574) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [7] = (_n * (_n * (5952 * _n - 11648) + 9152) - 2574) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [7] = (_n * (_n * (5952 * _n - 11648) + 9152) - 2574) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [7] = (_n * (_n * (5952 * _n - 11648) + 9152) - 2574) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [7] = (_n * (_n * (5952 * _n - 11648) + 9152) - 2574) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [8] = (_n * (5792 * _n + 1040) - 1287) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [8] = (_n * (5792 * _n + 1040) - 1287) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [8] = (_n * (5792 * _n + 1040) - 1287) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [8] = (_n * (5792 * _n + 1040) - 1287) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [8] = (_n * (5792 * _n + 1040) - 1287) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [9] = (468 - 2944 * _n) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [9] = (468 - 2944 * _n) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [9] = (468 - 2944 * _n) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [9] = (468 - 2944 * _n) / 135135;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [10] = 1 / 9009.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [10] = 1 / 9009.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [11] = (_n * ((4160 - 1440 * _n) * _n - 4576) + 1716) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [11] = (_n * ((4160 - 1440 * _n) * _n - 4576) + 1716) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [11] = (_n * ((4160 - 1440 * _n) * _n - 4576) + 1716) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [11] = (_n * ((4160 - 1440 * _n) * _n - 4576) + 1716) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [11] = (_n * ((4160 - 1440 * _n) * _n - 4576) + 1716) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [11] = (_n * ((4160 - 1440 * _n) * _n - 4576) + 1716) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [12] = ((4992 - 8448 * _n) * _n - 1144) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [12] = ((4992 - 8448 * _n) * _n - 1144) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [12] = ((4992 - 8448 * _n) * _n - 1144) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [12] = ((4992 - 8448 * _n) * _n - 1144) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [12] = ((4992 - 8448 * _n) * _n - 1144) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [13] = (1856 * _n - 936) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [13] = (1856 * _n - 936) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [13] = (1856 * _n - 936) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [13] = (1856 * _n - 936) / 225225;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [14] = 8 / 10725.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [14] = 8 / 10725.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [14] = 8 / 10725.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [15] = (_n * (3584 * _n - 3328) + 1144) / 315315;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [15] = (_n * (3584 * _n - 3328) + 1144) / 315315;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [15] = (_n * (3584 * _n - 3328) + 1144) / 315315;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [15] = (_n * (3584 * _n - 3328) + 1144) / 315315;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [15] = (_n * (3584 * _n - 3328) + 1144) / 315315;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [16] = (1024 * _n - 208) / 105105;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [16] = (1024 * _n - 208) / 105105;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [16] = (1024 * _n - 208) / 105105;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [16] = (1024 * _n - 208) / 105105;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [17] = -136 / 63063.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [17] = -136 / 63063.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [17] = -136 / 63063.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [18] = (832 - 2560 * _n) / 405405;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [18] = (832 - 2560 * _n) / 405405;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [18] = (832 - 2560 * _n) / 405405;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [18] = (832 - 2560 * _n) / 405405;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [19] = -128 / 135135.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [19] = -128 / 135135.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [19] = -128 / 135135.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [20] = 128 / 99099.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [20] = 128 / 99099.0;  
Magic Number,GeographicLib,Geodesic,C:\repos\suryapratap_GeographicLib\GeographicLib\Geodesic.cs,C4coeff,The following statement contains a magic number: _C4x [20] = 128 / 99099.0;  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,GeodesicLine,The following statement contains a magic number: _salp1 = azi1 == -180 ? 0 : Math.Sin (alp1);  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,GeodesicLine,The following statement contains a magic number: _calp1 = Math.Abs (azi1) == 90 ? 0 : Math.Cos (alp1);  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,GeodesicLine,The following statement contains a magic number: cbet1 = Math.Abs (lat1) == 90 ? Geodesic.tiny_ : Math.Cos (phi);  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: if (arcmode) {  	// Interpret s12_a12 as spherical arc length  	r.a12 = s12_a12;  	sig12 = s12_a12 * GeoMath.Degree;  	double s12a = Math.Abs (s12_a12);  	s12a -= 180 * Math.Floor (s12a / 180);  	ssig12 = s12a == 0 ? 0 : Math.Sin (sig12);  	csig12 = s12a == 90 ? 0 : Math.Cos (sig12);  }  else {  	// Interpret s12_a12 as distance  	r.s12 = s12_a12;  	double tau12 = s12_a12 / (_b * (1 + _A1m1))' s = Math.Sin (tau12)' c = Math.Cos (tau12);  	// tau2 = tau1 + tau12  	B12 = -Geodesic.SinCosSeries (true' _stau1 * c + _ctau1 * s' _ctau1 * c - _stau1 * s' _C1pa);  	sig12 = tau12 - (B12 - _B11);  	r.a12 = sig12 / GeoMath.Degree;  	ssig12 = Math.Sin (sig12);  	csig12 = Math.Cos (sig12);  	if (Math.Abs (_f) > 0.01) {  		// Reverted distance series is inaccurate for |f| > 1/100' so correct  		// sig12 with 1 Newton iteration.  The following table shows the  		// approximate maximum error for a = WGS_a() and various f relative to  		// GeodesicExact.  		//     erri = the error in the inverse solution (nm)  		//     errd = the error in the direct solution (series only) (nm)  		//     errda = the error in the direct solution (series + 1 Newton) (nm)  		//  		//       f     erri  errd errda  		//     -1/5    12e6 1.2e9  69e6  		//     -1/10  123e3  12e6 765e3  		//     -1/20   1110 108e3  7155  		//     -1/50  18.63 200.9 27.12  		//     -1/100 18.63 23.78 23.37  		//     -1/150 18.63 21.05 20.26  		//      1/150 22.35 24.73 25.83  		//      1/100 22.35 25.03 25.31  		//      1/50  29.80 231.9 30.44  		//      1/20   5376 146e3  10e3  		//      1/10  829e3  22e6 1.5e6  		//      1/5   157e6 3.8e9 280e6  		double ssig2 = _ssig1 * csig12 + _csig1 * ssig12' csig2 = _csig1 * csig12 - _ssig1 * ssig12;  		B12 = Geodesic.SinCosSeries (true' ssig2' csig2' _C1a);  		double serr = (1 + _A1m1) * (sig12 + (B12 - _B11)) - s12_a12 / _b;  		sig12 = sig12 - serr / Math.Sqrt (1 + _k2 * GeoMath.Sq (ssig2));  		ssig12 = Math.Sin (sig12);  		csig12 = Math.Cos (sig12);  		// Update B12 below  	}  }  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: if (arcmode) {  	// Interpret s12_a12 as spherical arc length  	r.a12 = s12_a12;  	sig12 = s12_a12 * GeoMath.Degree;  	double s12a = Math.Abs (s12_a12);  	s12a -= 180 * Math.Floor (s12a / 180);  	ssig12 = s12a == 0 ? 0 : Math.Sin (sig12);  	csig12 = s12a == 90 ? 0 : Math.Cos (sig12);  }  else {  	// Interpret s12_a12 as distance  	r.s12 = s12_a12;  	double tau12 = s12_a12 / (_b * (1 + _A1m1))' s = Math.Sin (tau12)' c = Math.Cos (tau12);  	// tau2 = tau1 + tau12  	B12 = -Geodesic.SinCosSeries (true' _stau1 * c + _ctau1 * s' _ctau1 * c - _stau1 * s' _C1pa);  	sig12 = tau12 - (B12 - _B11);  	r.a12 = sig12 / GeoMath.Degree;  	ssig12 = Math.Sin (sig12);  	csig12 = Math.Cos (sig12);  	if (Math.Abs (_f) > 0.01) {  		// Reverted distance series is inaccurate for |f| > 1/100' so correct  		// sig12 with 1 Newton iteration.  The following table shows the  		// approximate maximum error for a = WGS_a() and various f relative to  		// GeodesicExact.  		//     erri = the error in the inverse solution (nm)  		//     errd = the error in the direct solution (series only) (nm)  		//     errda = the error in the direct solution (series + 1 Newton) (nm)  		//  		//       f     erri  errd errda  		//     -1/5    12e6 1.2e9  69e6  		//     -1/10  123e3  12e6 765e3  		//     -1/20   1110 108e3  7155  		//     -1/50  18.63 200.9 27.12  		//     -1/100 18.63 23.78 23.37  		//     -1/150 18.63 21.05 20.26  		//      1/150 22.35 24.73 25.83  		//      1/100 22.35 25.03 25.31  		//      1/50  29.80 231.9 30.44  		//      1/20   5376 146e3  10e3  		//      1/10  829e3  22e6 1.5e6  		//      1/5   157e6 3.8e9 280e6  		double ssig2 = _ssig1 * csig12 + _csig1 * ssig12' csig2 = _csig1 * csig12 - _ssig1 * ssig12;  		B12 = Geodesic.SinCosSeries (true' ssig2' csig2' _C1a);  		double serr = (1 + _A1m1) * (sig12 + (B12 - _B11)) - s12_a12 / _b;  		sig12 = sig12 - serr / Math.Sqrt (1 + _k2 * GeoMath.Sq (ssig2));  		ssig12 = Math.Sin (sig12);  		csig12 = Math.Cos (sig12);  		// Update B12 below  	}  }  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: if (arcmode) {  	// Interpret s12_a12 as spherical arc length  	r.a12 = s12_a12;  	sig12 = s12_a12 * GeoMath.Degree;  	double s12a = Math.Abs (s12_a12);  	s12a -= 180 * Math.Floor (s12a / 180);  	ssig12 = s12a == 0 ? 0 : Math.Sin (sig12);  	csig12 = s12a == 90 ? 0 : Math.Cos (sig12);  }  else {  	// Interpret s12_a12 as distance  	r.s12 = s12_a12;  	double tau12 = s12_a12 / (_b * (1 + _A1m1))' s = Math.Sin (tau12)' c = Math.Cos (tau12);  	// tau2 = tau1 + tau12  	B12 = -Geodesic.SinCosSeries (true' _stau1 * c + _ctau1 * s' _ctau1 * c - _stau1 * s' _C1pa);  	sig12 = tau12 - (B12 - _B11);  	r.a12 = sig12 / GeoMath.Degree;  	ssig12 = Math.Sin (sig12);  	csig12 = Math.Cos (sig12);  	if (Math.Abs (_f) > 0.01) {  		// Reverted distance series is inaccurate for |f| > 1/100' so correct  		// sig12 with 1 Newton iteration.  The following table shows the  		// approximate maximum error for a = WGS_a() and various f relative to  		// GeodesicExact.  		//     erri = the error in the inverse solution (nm)  		//     errd = the error in the direct solution (series only) (nm)  		//     errda = the error in the direct solution (series + 1 Newton) (nm)  		//  		//       f     erri  errd errda  		//     -1/5    12e6 1.2e9  69e6  		//     -1/10  123e3  12e6 765e3  		//     -1/20   1110 108e3  7155  		//     -1/50  18.63 200.9 27.12  		//     -1/100 18.63 23.78 23.37  		//     -1/150 18.63 21.05 20.26  		//      1/150 22.35 24.73 25.83  		//      1/100 22.35 25.03 25.31  		//      1/50  29.80 231.9 30.44  		//      1/20   5376 146e3  10e3  		//      1/10  829e3  22e6 1.5e6  		//      1/5   157e6 3.8e9 280e6  		double ssig2 = _ssig1 * csig12 + _csig1 * ssig12' csig2 = _csig1 * csig12 - _ssig1 * ssig12;  		B12 = Geodesic.SinCosSeries (true' ssig2' csig2' _C1a);  		double serr = (1 + _A1m1) * (sig12 + (B12 - _B11)) - s12_a12 / _b;  		sig12 = sig12 - serr / Math.Sqrt (1 + _k2 * GeoMath.Sq (ssig2));  		ssig12 = Math.Sin (sig12);  		csig12 = Math.Cos (sig12);  		// Update B12 below  	}  }  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: if (arcmode) {  	// Interpret s12_a12 as spherical arc length  	r.a12 = s12_a12;  	sig12 = s12_a12 * GeoMath.Degree;  	double s12a = Math.Abs (s12_a12);  	s12a -= 180 * Math.Floor (s12a / 180);  	ssig12 = s12a == 0 ? 0 : Math.Sin (sig12);  	csig12 = s12a == 90 ? 0 : Math.Cos (sig12);  }  else {  	// Interpret s12_a12 as distance  	r.s12 = s12_a12;  	double tau12 = s12_a12 / (_b * (1 + _A1m1))' s = Math.Sin (tau12)' c = Math.Cos (tau12);  	// tau2 = tau1 + tau12  	B12 = -Geodesic.SinCosSeries (true' _stau1 * c + _ctau1 * s' _ctau1 * c - _stau1 * s' _C1pa);  	sig12 = tau12 - (B12 - _B11);  	r.a12 = sig12 / GeoMath.Degree;  	ssig12 = Math.Sin (sig12);  	csig12 = Math.Cos (sig12);  	if (Math.Abs (_f) > 0.01) {  		// Reverted distance series is inaccurate for |f| > 1/100' so correct  		// sig12 with 1 Newton iteration.  The following table shows the  		// approximate maximum error for a = WGS_a() and various f relative to  		// GeodesicExact.  		//     erri = the error in the inverse solution (nm)  		//     errd = the error in the direct solution (series only) (nm)  		//     errda = the error in the direct solution (series + 1 Newton) (nm)  		//  		//       f     erri  errd errda  		//     -1/5    12e6 1.2e9  69e6  		//     -1/10  123e3  12e6 765e3  		//     -1/20   1110 108e3  7155  		//     -1/50  18.63 200.9 27.12  		//     -1/100 18.63 23.78 23.37  		//     -1/150 18.63 21.05 20.26  		//      1/150 22.35 24.73 25.83  		//      1/100 22.35 25.03 25.31  		//      1/50  29.80 231.9 30.44  		//      1/20   5376 146e3  10e3  		//      1/10  829e3  22e6 1.5e6  		//      1/5   157e6 3.8e9 280e6  		double ssig2 = _ssig1 * csig12 + _csig1 * ssig12' csig2 = _csig1 * csig12 - _ssig1 * ssig12;  		B12 = Geodesic.SinCosSeries (true' ssig2' csig2' _C1a);  		double serr = (1 + _A1m1) * (sig12 + (B12 - _B11)) - s12_a12 / _b;  		sig12 = sig12 - serr / Math.Sqrt (1 + _k2 * GeoMath.Sq (ssig2));  		ssig12 = Math.Sin (sig12);  		csig12 = Math.Cos (sig12);  		// Update B12 below  	}  }  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: s12a -= 180 * Math.Floor (s12a / 180);  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: s12a -= 180 * Math.Floor (s12a / 180);  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: csig12 = s12a == 90 ? 0 : Math.Cos (sig12);  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: if (Math.Abs (_f) > 0.01) {  	// Reverted distance series is inaccurate for |f| > 1/100' so correct  	// sig12 with 1 Newton iteration.  The following table shows the  	// approximate maximum error for a = WGS_a() and various f relative to  	// GeodesicExact.  	//     erri = the error in the inverse solution (nm)  	//     errd = the error in the direct solution (series only) (nm)  	//     errda = the error in the direct solution (series + 1 Newton) (nm)  	//  	//       f     erri  errd errda  	//     -1/5    12e6 1.2e9  69e6  	//     -1/10  123e3  12e6 765e3  	//     -1/20   1110 108e3  7155  	//     -1/50  18.63 200.9 27.12  	//     -1/100 18.63 23.78 23.37  	//     -1/150 18.63 21.05 20.26  	//      1/150 22.35 24.73 25.83  	//      1/100 22.35 25.03 25.31  	//      1/50  29.80 231.9 30.44  	//      1/20   5376 146e3  10e3  	//      1/10  829e3  22e6 1.5e6  	//      1/5   157e6 3.8e9 280e6  	double ssig2 = _ssig1 * csig12 + _csig1 * ssig12' csig2 = _csig1 * csig12 - _ssig1 * ssig12;  	B12 = Geodesic.SinCosSeries (true' ssig2' csig2' _C1a);  	double serr = (1 + _A1m1) * (sig12 + (B12 - _B11)) - s12_a12 / _b;  	sig12 = sig12 - serr / Math.Sqrt (1 + _k2 * GeoMath.Sq (ssig2));  	ssig12 = Math.Sin (sig12);  	csig12 = Math.Cos (sig12);  	// Update B12 below  }  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: if ((outmask & (GeodesicMask.DISTANCE | GeodesicMask.REDUCEDLENGTH | GeodesicMask.GEODESICSCALE)) != 0) {  	if (arcmode || Math.Abs (_f) > 0.01)  		B12 = Geodesic.SinCosSeries (true' ssig3' csig3' _C1a);  	AB1 = (1 + _A1m1) * (B12 - _B11);  }  
Magic Number,GeographicLib,GeodesicLine,C:\repos\suryapratap_GeographicLib\GeographicLib\GeodesicLine.cs,Position,The following statement contains a magic number: if (arcmode || Math.Abs (_f) > 0.01)  	B12 = Geodesic.SinCosSeries (true' ssig3' csig3' _C1a);  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,Atanh,The following statement contains a magic number: y = Math.Log (2 * y / (1 - y)) / 2;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,Atanh,The following statement contains a magic number: y = Math.Log (2 * y / (1 - y)) / 2;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngNormalize,The following statement contains a magic number: return x >= 180 ? x - 360 : (x < -180 ? x + 360 : x);  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngNormalize,The following statement contains a magic number: return x >= 180 ? x - 360 : (x < -180 ? x + 360 : x);  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngNormalize,The following statement contains a magic number: return x >= 180 ? x - 360 : (x < -180 ? x + 360 : x);  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngNormalize,The following statement contains a magic number: return x >= 180 ? x - 360 : (x < -180 ? x + 360 : x);  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngNormalize2,The following statement contains a magic number: return AngNormalize (x % 360.0);  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: if ((d - 180.0) + t > 0.0)  	// y - x > 180  	d -= 360.0;  // exact  else if ((d + 180.0) + t <= 0.0)  	// y - x <= -180  	d += 360.0;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: if ((d - 180.0) + t > 0.0)  	// y - x > 180  	d -= 360.0;  // exact  else if ((d + 180.0) + t <= 0.0)  	// y - x <= -180  	d += 360.0;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: if ((d - 180.0) + t > 0.0)  	// y - x > 180  	d -= 360.0;  // exact  else if ((d + 180.0) + t <= 0.0)  	// y - x <= -180  	d += 360.0;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: if ((d - 180.0) + t > 0.0)  	// y - x > 180  	d -= 360.0;  // exact  else if ((d + 180.0) + t <= 0.0)  	// y - x <= -180  	d += 360.0;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: d -= 360.0;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: if ((d + 180.0) + t <= 0.0)  	// y - x <= -180  	d += 360.0;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: if ((d + 180.0) + t <= 0.0)  	// y - x <= -180  	d += 360.0;  
Magic Number,GeographicLib,GeoMath,C:\repos\suryapratap_GeographicLib\GeographicLib\GeoMath.cs,AngDiff,The following statement contains a magic number: d += 360.0;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: if (_num < 2)  	return new PolygonResult (_num' 0' _polyline ? Double.NaN : 0);  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: if ((crossings & 1) != 0)  	tempsum.Add ((tempsum.Sum () < 0 ? 1 : -1) * _area0 / 2);  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: tempsum.Add ((tempsum.Sum () < 0 ? 1 : -1) * _area0 / 2);  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: if (sign) {  	if (tempsum.Sum () > _area0 / 2)  		tempsum.Add (-_area0);  	else if (tempsum.Sum () <= -_area0 / 2)  		tempsum.Add (+_area0);  }  else {  	if (tempsum.Sum () >= _area0)  		tempsum.Add (-_area0);  	else if (tempsum.Sum () < 0)  		tempsum.Add (+_area0);  }  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: if (sign) {  	if (tempsum.Sum () > _area0 / 2)  		tempsum.Add (-_area0);  	else if (tempsum.Sum () <= -_area0 / 2)  		tempsum.Add (+_area0);  }  else {  	if (tempsum.Sum () >= _area0)  		tempsum.Add (-_area0);  	else if (tempsum.Sum () < 0)  		tempsum.Add (+_area0);  }  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: if (tempsum.Sum () > _area0 / 2)  	tempsum.Add (-_area0);  else if (tempsum.Sum () <= -_area0 / 2)  	tempsum.Add (+_area0);  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: if (tempsum.Sum () > _area0 / 2)  	tempsum.Add (-_area0);  else if (tempsum.Sum () <= -_area0 / 2)  	tempsum.Add (+_area0);  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,Compute,The following statement contains a magic number: if (tempsum.Sum () <= -_area0 / 2)  	tempsum.Add (+_area0);  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: for (int i = 0; i < (_polyline ? 1 : 2); ++i) {  	GeodesicData g = _earth.Inverse (i == 0 ? _lat1 : lat' i == 0 ? _lon1 : lon' i != 0 ? _lat0 : lat' i != 0 ? _lon0 : lon' _mask);  	perimeter += g.s12;  	if (!_polyline) {  		tempsum += g.S12;  		crossings += transit (i == 0 ? _lon1 : lon' i != 0 ? _lon0 : lon);  	}  }  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: if ((crossings & 1) != 0)  	tempsum += (tempsum < 0 ? 1 : -1) * _area0 / 2;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: tempsum += (tempsum < 0 ? 1 : -1) * _area0 / 2;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: if (sign) {  	if (tempsum > _area0 / 2)  		tempsum -= _area0;  	else if (tempsum <= -_area0 / 2)  		tempsum += _area0;  }  else {  	if (tempsum >= _area0)  		tempsum -= _area0;  	else if (tempsum < 0)  		tempsum += _area0;  }  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: if (sign) {  	if (tempsum > _area0 / 2)  		tempsum -= _area0;  	else if (tempsum <= -_area0 / 2)  		tempsum += _area0;  }  else {  	if (tempsum >= _area0)  		tempsum -= _area0;  	else if (tempsum < 0)  		tempsum += _area0;  }  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: if (tempsum > _area0 / 2)  	tempsum -= _area0;  else if (tempsum <= -_area0 / 2)  	tempsum += _area0;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: if (tempsum > _area0 / 2)  	tempsum -= _area0;  else if (tempsum <= -_area0 / 2)  	tempsum += _area0;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestPoint,The following statement contains a magic number: if (tempsum <= -_area0 / 2)  	tempsum += _area0;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,The following statement contains a magic number: if ((crossings & 1) != 0)  	tempsum += (tempsum < 0 ? 1 : -1) * _area0 / 2;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,The following statement contains a magic number: tempsum += (tempsum < 0 ? 1 : -1) * _area0 / 2;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,The following statement contains a magic number: if (sign) {  	if (tempsum > _area0 / 2)  		tempsum -= _area0;  	else if (tempsum <= -_area0 / 2)  		tempsum += _area0;  }  else {  	if (tempsum >= _area0)  		tempsum -= _area0;  	else if (tempsum < 0)  		tempsum += _area0;  }  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,The following statement contains a magic number: if (sign) {  	if (tempsum > _area0 / 2)  		tempsum -= _area0;  	else if (tempsum <= -_area0 / 2)  		tempsum += _area0;  }  else {  	if (tempsum >= _area0)  		tempsum -= _area0;  	else if (tempsum < 0)  		tempsum += _area0;  }  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,The following statement contains a magic number: if (tempsum > _area0 / 2)  	tempsum -= _area0;  else if (tempsum <= -_area0 / 2)  	tempsum += _area0;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,The following statement contains a magic number: if (tempsum > _area0 / 2)  	tempsum -= _area0;  else if (tempsum <= -_area0 / 2)  	tempsum += _area0;  
Magic Number,GeographicLib,PolygonArea,C:\repos\suryapratap_GeographicLib\GeographicLib\PolygonArea.cs,TestEdge,The following statement contains a magic number: if (tempsum <= -_area0 / 2)  	tempsum += _area0;  
