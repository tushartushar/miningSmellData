Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The method has 260 lines of code.
Complex Method,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,HandleKey,Cyclomatic complexity of the method is 29
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OnKeyDown,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetCharacterClass,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FindOverlappingSegments,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateAugmentedData,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,HandleTextChange,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,DoReplace,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Editing,Caret,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetUpDownCaretPosition,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,TransformSelectedLines,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,TransformSelectedSegments,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnTab,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnPaste,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,ExpandToEnclosingUnit,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,MoveEndpointByUnit,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,StartDrag,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.AvalonEdit.Editing,SimpleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,ReplaceSelectionWithText,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Editing,TextAreaInputHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextAreaInputHandler.cs,Detach,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingElementGenerator,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingElementGenerator.cs,ConstructElement,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingManager.cs,UpdateFoldings,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,CalculateFoldLinesForFoldingsActiveAtStart,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,CalculateFoldLinesForMarkers,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateNewFoldings,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,MergeWith,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,WriteTo,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,HighlightLineInternal,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,CreateHtmlFragment,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HtmlRichTextWriter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlRichTextWriter.cs,WriteChar,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRuleSet,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRegex,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,ParseElements,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,ParseSpan,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,Cyclomatic complexity of the method is 107
Complex Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,IsSingleStatementKeyword,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,GetRectsForSegmentImpl,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.AvalonEdit.Rendering,ColorizingTransformer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\ColorizingTransformer.cs,ChangeVisualElements,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,InsertAfter,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,MergeCollapsedSectionsIfPossible,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AddRemoveCollapsedSection,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,GetFirstInterestedOffset,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ArrangeOverride,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetTextRun,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Search,SearchPanel,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchPanel.cs,SearchLayerKeyDown,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Search,SearchStrategyFactory,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchStrategyFactory.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Search,SearchStrategyFactory,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchStrategyFactory.cs,ConvertWildcardsToRegex,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Snippets,InsertionContext,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,RaiseInsertionCompleted,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,InsertRange,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,RemoveRange,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.AvalonEdit.Utils,Rope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,FindNodeUsingCache,Cyclomatic complexity of the method is 10
Long Parameter List,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNextCaretPosition,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetPrevCaretPosition,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetUpDownCaretPosition,The method has 7 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,ImeSupport,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\ImeSupport.cs,WndProc,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,Insert,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The method has 6 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CharRope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CharRope.cs,IndexOf,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CharRope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CharRope.cs,LastIndexOf,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The method has 5 parameters.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter removalNeverCausesAnchorDeletion is 32.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,InsertText,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,PerformInsertText,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,Colorize,The length of the parameter currentDocumentLineTotalEndOffset is 33.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,Redraw,The length of the parameter changedSomethingBeforeOrInLine is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the parameter relativeSplitRelativeTextOffset is 31.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,OnLineNumbersForegroundChanged,The length of the statement  "	var lineNumberMargin = editor.TextArea.LeftMargins.FirstOrDefault (margin => margin is LineNumberMargin) as LineNumberMargin; " is 125.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The length of the statement  "		Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle); " is 126.
Long Statement,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "[TextViewPosition Line={0} Column={1} VisualColumn={2} IsAtEndOfLine={3}]"' this.line' this.column' this.visualColumn' this.isAtEndOfLine); " is 192.
Long Statement,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,Equals,The length of the statement  "	return this.Line == other.Line && this.Column == other.Column && this.VisualColumn == other.VisualColumn && this.IsAtEndOfLine == other.IsAtEndOfLine; " is 150.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindowBase,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindowBase.cs,TextViewScrollOffsetChanged,The length of the statement  "	Rect visibleRect = new Rect (scrollInfo.HorizontalOffset' scrollInfo.VerticalOffset' scrollInfo.ViewportWidth' scrollInfo.ViewportHeight); " is 138.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,OnMouseDoubleClick,The length of the statement  "		if (ExtensionMethods.VisualAncestorsAndSelf (e.OriginalSource as DependencyObject).TakeWhile (obj => obj != this).Any (obj => obj is ListBoxItem)) { " is 148.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "	var listToFilter = (this.currentList != null && (!string.IsNullOrEmpty (this.currentText)) && (!string.IsNullOrEmpty (query)) && query.StartsWith (this.currentText' StringComparison.Ordinal)) ? this.currentList : this.completionData; " is 233.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "	ICompletionData suggestedItem = listBox.SelectedIndex != -1 ? (ICompletionData)(listBox.Items [listBox.SelectedIndex]) : null; " is 126.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,completionList_InsertionRequested,The length of the statement  "		item.Complete (this.TextArea' new AnchorSegment (this.TextArea.Document' this.StartOffset' this.EndOffset - this.StartOffset)' e); " is 130.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,textArea_PreviewTextInput,The length of the statement  "	e.Handled = RaiseEventPair (this' PreviewTextInputEvent' TextInputEvent' new TextCompositionEventArgs (e.Device' e.TextComposition)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,textArea_MouseWheel,The length of the statement  "	e.Handled = RaiseEventPair (GetScrollEventTarget ()' PreviewMouseWheelEvent' MouseWheelEvent' new MouseWheelEventArgs (e.MouseDevice' e.Timestamp' e.Delta)); " is 157.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The length of the statement  "	Rect workingArea = System.Windows.Forms.Screen.FromPoint (pointOnScreen.ToSystemDrawing ()).WorkingArea.ToWpf ().TransformFromDevice (this); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Document,SimpleSegment,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\SimpleSegment.cs,ToString,The length of the statement  "	return "[Offset=" + Offset.ToString (CultureInfo.InvariantCulture) + "' Length=" + Length.ToString (CultureInfo.InvariantCulture) + "]"; " is 136.
Long Statement,ICSharpCode.AvalonEdit.Document,AnchorSegment,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\SimpleSegment.cs,ToString,The length of the statement  "	return "[Offset=" + Offset.ToString (CultureInfo.InvariantCulture) + "' EndOffset=" + EndOffset.ToString (CultureInfo.InvariantCulture) + "]"; " is 142.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineNode.cs,ToString,The length of the statement  "		return string.Format (CultureInfo.InvariantCulture' "[DocumentLine Number={0} Offset={1} Length={2}]"' LineNumber' Offset' Length); " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,StopBetweenCharacters,The length of the statement  "		if (charBefore == CharacterClass.Other && (mode == CaretPositioningMode.WordBorderOrSymbol || mode == CaretPositioningMode.WordStartOrSymbol)) { " is 144.
Long Statement,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,StopBetweenCharacters,The length of the statement  "		if (!((mode == CaretPositioningMode.WordStart || mode == CaretPositioningMode.WordStartOrSymbol) && (charAfter == CharacterClass.Whitespace || charAfter == CharacterClass.LineTerminator))) { " is 190.
Long Statement,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,Equals,The length of the statement  "	return offset == other.offset && insertionLengthWithMovementFlag == other.insertionLengthWithMovementFlag && removalLengthWithDeletionFlag == other.removalLengthWithDeletionFlag; " is 178.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "		throw new InvalidOperationException ("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "		throw new InvalidOperationException ("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsetsInternal,The length of the statement  "	// Special case pure insertions' because they don't always cause a text segment to increase in size when the replaced region " is 124.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CheckProperties,The length of the statement  "		distanceToMaxEnd = Math.Max (distanceToMaxEnd' node.right.distanceToMaxEnd + node.right.StartOffset - node.StartOffset); " is 120.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - count)); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,PerformInsertText,The length of the statement  "		} else if (defaultAnchorMovementIsBeforeInsertion ? anchor.MovementType != AnchorMovementType.AfterInsertion : anchor.MovementType == AnchorMovementType.BeforeInsertion) { " is 171.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegment,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegment.cs,ToDebugString,The length of the statement  "	return "[nodeLength=" + nodeLength + " totalNodeLength=" + totalNodeLength + " distanceToMaxEnd=" + distanceToMaxEnd + " MaxEndOffset=" + (StartOffset + distanceToMaxEnd) + "]"; " is 177.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - LineCount)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "		throw new ArgumentOutOfRangeException ("offset"' offset' "0 <= offset <= " + rope.Length.ToString (CultureInfo.InvariantCulture)); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "		throw new ArgumentOutOfRangeException ("length"' length' "0 <= length' offset(" + offset + ")+length <= " + rope.Length.ToString (CultureInfo.InvariantCulture)); " is 161.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The length of the statement  "		Replace (offset' length' text' OffsetChangeMap.FromSingleElement (new OffsetChangeMapEntry (offset' length' text.TextLength' false' true))); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The length of the statement  "			OffsetChangeMapEntry entry = new OffsetChangeMapEntry (offset + text.TextLength' length - text.TextLength' 0' true' false); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,CreateAnchor,The length of the statement  "		throw new ArgumentOutOfRangeException ("offset"' offset' "0 <= offset <= " + rope.Length.ToString (CultureInfo.InvariantCulture)); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "	int newVisualColumnForwards = visualLine.GetNextCaretPosition (position.VisualColumn - 1' LogicalDirection.Forward' CaretPositioningMode.Normal' textArea.Selection.EnableVirtualSpace); " is 184.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "		int newVisualColumnBackwards = visualLine.GetNextCaretPosition (position.VisualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.Normal' textArea.Selection.EnableVirtualSpace); " is 186.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,CalcCaretOverstrikeRectangle,The length of the statement  "	int nextPos = visualLine.GetNextCaretPosition (currentPos' LogicalDirection.Forward' CaretPositioningMode.Normal' true); " is 120.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,ShowInternal,The length of the statement  "			Rect caretRect = this.textArea.OverstrikeMode ? CalcCaretOverstrikeRectangle (visualLine) : CalcCaretRectangle (visualLine); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretLayer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretLayer.cs,OnRender,The length of the statement  "		Rect r = new Rect (caretRectangle.X - textView.HorizontalOffset' caretRectangle.Y - textView.VerticalOffset' caretRectangle.Width' caretRectangle.Height); " is 154.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaret,The length of the statement  "	textArea.Caret.Position = GetNewCaretPosition (textArea.TextView' textArea.Caret.Position' direction' textArea.Selection.EnableVirtualSpace' ref desiredXPos); " is 158.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The length of the statement  "		return GetPrevCaretPosition (textView' caretPosition' visualLine' CaretPositioningMode.EveryCodepoint' enableVirtualSpace); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The length of the statement  "		return GetUpDownCaretPosition (textView' caretPosition' direction' visualLine' textLine' enableVirtualSpace' ref desiredXPos); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetStartOfLineCaretPosition,The length of the statement  "		newVC = visualLine.GetNextCaretPosition (newVC - 1' LogicalDirection.Forward' CaretPositioningMode.WordStart' enableVirtualSpace); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNextCaretPosition,The length of the statement  "	int pos = visualLine.GetNextCaretPosition (caretPosition.VisualColumn' LogicalDirection.Forward' mode' enableVirtualSpace); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNextCaretPosition,The length of the statement  "			Debug.Assert (visualLine.LastDocumentLine.Offset + visualLine.LastDocumentLine.TotalLength == textView.Document.TextLength); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetPrevCaretPosition,The length of the statement  "	int pos = visualLine.GetNextCaretPosition (caretPosition.VisualColumn' LogicalDirection.Backward' mode' enableVirtualSpace); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetPrevCaretPosition,The length of the statement  "			pos = previousLine.GetNextCaretPosition (previousLine.VisualLength + 1' LogicalDirection.Backward' mode' enableVirtualSpace); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnTab,The length of the statement  "						textArea.Document.Replace (offset' 0' textArea.Options.IndentationString' OffsetChangeMappingType.KeepAnchorBeforeInsertion); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnDelete,The length of the statement  "				TextViewPosition endPos = CaretNavigationCommandHandler.GetNewCaretPosition (textArea.TextView' startPos' caretMovement' enableVirtualSpace' ref desiredXPos); " is 158.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnCut,The length of the statement  "				ISegment[] segmentsToDelete = textArea.GetDeletableSegments (new SimpleSegment (currentLine.Offset' currentLine.TotalLength)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,CopyWholeLine,The length of the statement  "		HtmlClipboard.SetHtml (data' HtmlClipboard.CreateHtmlFragment (textArea.Document' highlighter' wholeLine' new HtmlOptions (textArea.Options))); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,GetTextToPaste,The length of the statement  "		else if (pastingEventArgs.FormatToApply != DataFormats.UnicodeText && dataObject.GetDataPresent (DataFormats.UnicodeText)) " is 122.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,GetTextToPaste,The length of the statement  "		text = textArea.Options.ConvertTabsToSpaces ? text.Replace ("\t"' new String (' '' textArea.Options.IndentationSize)) : text; " is 125.
Long Statement,ICSharpCode.AvalonEdit.Editing,ImeNativeWrapper,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\ImeNativeWrapper.cs,GetCharacterBounds,The length of the statement  "		displayRect = new Rect (vl.GetVisualPosition (pos.VisualColumn' VisualYPosition.TextTop)' new Size (textView.WideSpaceWidth' textView.DefaultLineHeight)); " is 154.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionSegment,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionSegment.cs,ToString,The length of the statement  "	return string.Format ("[SelectionSegment StartOffset={0}' EndOffset={1}' StartVC={2}' EndVC={3}]"' startOffset' endOffset' startVC' endVC); " is 139.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,Compare,The length of the statement  "	bool result = doc == other.doc && segment.Offset == other.segment.Offset && segment.EndOffset == other.segment.EndOffset; " is 121.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,Select,The length of the statement  "	textArea.Selection = new SimpleSelection (textArea' new TextViewPosition (doc.GetLocation (segment.Offset))' new TextViewPosition (doc.GetLocation (segment.EndOffset))); " is 169.
Long Statement,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,MeasureOverride,The length of the statement  "	FormattedText text = TextFormatterFactory.CreateFormattedText (this' new string ('9'' maxLineNumberLength)' typeface' emSize' (Brush)GetValue (Control.ForegroundProperty)); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnRender,The length of the statement  "			FormattedText text = TextFormatterFactory.CreateFormattedText (this' lineNumber.ToString (CultureInfo.CurrentCulture)' typeface' emSize' foreground); " is 149.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,Equals,The length of the statement  "	return r != null && r.textArea == this.textArea && r.topLeftOffset == this.topLeftOffset && r.bottomRightOffset == this.bottomRightOffset && r.startLine == this.startLine && r.endLine == this.endLine && r.startXPos == this.startXPos && r.endXPos == this.endXPos; " is 262.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "	TextLocation newStartLocation = textArea.Document.GetLocation (e.GetNewOffset (topLeftOffset' AnchorMovementType.AfterInsertion)); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "	TextLocation newEndLocation = textArea.Document.GetLocation (e.GetNewOffset (bottomRightOffset' AnchorMovementType.BeforeInsertion)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "	return new RectangleSelection (textArea' new TextViewPosition (newStartLocation' GetVisualColumnFromXPos (newStartLocation.Line' startXPos))' new TextViewPosition (newEndLocation' GetVisualColumnFromXPos (newEndLocation.Line' endXPos))); " is 237.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "		TextViewPosition start = new TextViewPosition (document.GetLocation (topLeftOffset)' GetVisualColumnFromXPos (startLine' startXPos)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "		TextViewPosition end = new TextViewPosition (document.GetLocation (bottomRightOffset)' GetVisualColumnFromXPos (endLine' endXPos)); " is 131.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "		textArea.Caret.Position = textArea.TextView.GetPosition (new Point (GetXPos (textArea' pos)' textArea.TextView.GetVisualTopByDocumentLine (Math.Max (startLine' endLine)))).GetValueOrDefault (); " is 193.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "			newText = AddSpacesIfRequired (newText' new TextViewPosition (document.GetLocation (lineSegment.StartOffset)' lineSegment.StartVisualColumn)' new TextViewPosition (document.GetLocation (lineSegment.EndOffset)' lineSegment.EndVisualColumn)); " is 240.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "				if (segmentsToDelete [i].Offset == SurroundingSegment.Offset && segmentsToDelete [i].Length == SurroundingSegment.Length) { " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "					newText = AddSpacesIfRequired (newText' new TextViewPosition (document.GetLocation (lineSegment.StartOffset)' lineSegment.StartVisualColumn)' new TextViewPosition (document.GetLocation (lineSegment.EndOffset)' lineSegment.EndVisualColumn)); " is 240.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,PerformRectangularPaste,The length of the statement  "			RectangleSelection rsel = new RectangleSelection (textArea' startPosition' endLocation.Line' GetXPos (textArea' startPosition)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ToString,The length of the statement  "	return string.Format ("[RectangleSelection {0} {1} {2} to {3} {4} {5}]"' startLine' topLeftOffset' startXPos' endLine' bottomRightOffset' endXPos); " is 147.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,Create,The length of the statement  "		return new SimpleSelection (textArea' new TextViewPosition (textArea.Document.GetLocation (startOffset))' new TextViewPosition (textArea.Document.GetLocation (endOffset))); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,Create,The length of the statement  "	if (textArea.Document.GetOffset (start.Location) == textArea.Document.GetOffset (end.Location) && start.VisualColumn == end.VisualColumn) " is 137.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,InsertVirtualSpaces,The length of the statement  "	return (!string.IsNullOrEmpty (newText) || !(IsInVirtualSpace (start) && IsInVirtualSpace (end))) && newText != "\r\n" && newText != "\n" && newText != "\r"; " is 157.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,IsInVirtualSpace,The length of the statement  "	return pos.VisualColumn > textArea.TextView.GetOrConstructVisualLine (textArea.Document.GetLineByNumber (pos.Line)).VisualLength; " is 129.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionColorizer.cs,Colorize,The length of the statement  "			startColumn = context.VisualLine.ValidateVisualColumn (segment.StartOffset' segment.StartVisualColumn' textArea.Selection.EnableVirtualSpace); " is 142.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionColorizer.cs,Colorize,The length of the statement  "			endColumn = context.VisualLine.ValidateVisualColumn (segment.EndOffset' segment.EndVisualColumn' textArea.Selection.EnableVirtualSpace); " is 136.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionLayer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionLayer.cs,ReceiveWeakEvent,The length of the statement  "	if (managerType == typeof(TextViewWeakEventManager.VisualLinesChanged) || managerType == typeof(TextViewWeakEventManager.ScrollOffsetChanged)) { " is 144.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetEffect,The length of the statement  "				if ((e.AllowedEffects & DragDropEffects.Move) == DragDropEffects.Move && (e.KeyStates & DragDropKeyStates.ControlKey) != DragDropKeyStates.ControlKey) { " is 152.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,StartDrag,The length of the statement  "	if (deleteOnMove != null && resultEffect == DragDropEffects.Move && (allowedEffects & DragDropEffects.Move) == DragDropEffects.Move) { " is 134.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The length of the statement  "						textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.Offset))); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The length of the statement  "						textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.EndOffset))); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "		int wordStartVC = line.GetNextCaretPosition (visualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.WordStartOrSymbol' textArea.Selection.EnableVirtualSpace); " is 169.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "		int wordEndVC = line.GetNextCaretPosition (wordStartVC' LogicalDirection.Forward' CaretPositioningMode.WordBorderOrSymbol' textArea.Selection.EnableVirtualSpace); " is 162.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The length of the statement  "	if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 142.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The length of the statement  "		if (Math.Abs (mouseMovement.X) > SystemParameters.MinimumHorizontalDragDistance || Math.Abs (mouseMovement.Y) > SystemParameters.MinimumVerticalDragDistance) { " is 159.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,ExtendSelectionToMouse,The length of the statement  "			textArea.Selection = Selection.Create (textArea' Math.Min (newWord.Offset' startWord.Offset)' Math.Max (newWord.EndOffset' startWord.EndOffset)); " is 145.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The length of the statement  "	} else if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 149.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,ReplaceSelectionWithText,The length of the statement  "				if (segmentsToDelete [i].Offset == SurroundingSegment.Offset && segmentsToDelete [i].Length == SurroundingSegment.Length) { " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,UpdateOnDocumentChange,The length of the statement  "	return Selection.Create (textArea' new TextViewPosition (textArea.Document.GetLocation (newStartOffset)' start.VisualColumn)' new TextViewPosition (textArea.Document.GetLocation (newEndOffset)' end.VisualColumn)); " is 213.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,Equals,The length of the statement  "	return this.start.Equals (other.start) && this.end.Equals (other.end) && this.startOffset == other.startOffset && this.endOffset == other.endOffset && this.textArea == other.textArea; " is 183.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnTextInput,The length of the statement  "	//Debug.WriteLine("TextInput: Text='" + e.Text + "' SystemText='" + e.SystemText + "' ControlText='" + e.ControlText + "'"); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "			throw new InvalidOperationException ("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "		throw new InvalidOperationException ("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,AttachTypingEvents,The length of the statement  "	// Use the PreviewMouseMove event in case some other editor layer consumes the MouseMove event (e.g. SD's InsertionCursorLayer) " is 127.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnPropertyChanged,The length of the statement  "	if (e.Property == SelectionBrushProperty || e.Property == SelectionBorderProperty || e.Property == SelectionForegroundProperty || e.Property == SelectionCornerRadiusProperty) { " is 176.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "				drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos)); " is 145.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "					drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2)); " is 150.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "		drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' RenderSize.Height)); " is 135.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The length of the statement  "	Rect rect = new Rect (pixelSize.Width / 2' pixelSize.Height / 2' this.RenderSize.Width - pixelSize.Width' this.RenderSize.Height - pixelSize.Height); " is 149.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The length of the statement  "	drawingContext.DrawRectangle (IsMouseDirectlyOver ? margin.SelectedFoldingMarkerBackgroundBrush : margin.FoldingMarkerBackgroundBrush' IsMouseDirectlyOver ? activePen : inactivePen' rect); " is 188.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingSection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingSection.cs,ValidateCollapsedLineSections,The length of the statement  "					Debug.WriteLine ("CollapsedLineSection validation - recreate collapsed section from " + startLinePlusOne + " to " + endLine); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateElementFoldStart,The length of the statement  "	//XmlFoldStart newFoldStart = new XmlFoldStart(reader.Prefix' reader.LocalName' reader.LineNumber - 1' reader.LinePosition - 2); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,UpdateTreeList,The length of the statement  "		//Debug.WriteLine("Span stack in line " + lineNumber + " changed from " + storedSpanStacks[lineNumber] + " to " + spanStack); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedInlineBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedInlineBuilder.cs,SetHighlighting,The length of the statement  "	if (color.Foreground == null && color.Background == null && color.FontStyle == null && color.FontWeight == null && color.Underline == null) { " is 141.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedInlineBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedInlineBuilder.cs,ToRichText,The length of the statement  "	return new RichText (text' stateChangeOffsets.ToArray ()' stateChanges.Select (FreezableHelper.GetFrozenClone).ToArray ()); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedInlineBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedInlineBuilder.cs,Clone,The length of the statement  "	return new HighlightedInlineBuilder (this.text' stateChangeOffsets.ToList ()' stateChanges.Select (sc => sc.Clone ()).ToList ()); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,WriteTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("startOffset"' startOffset' "Value must be between " + documentLineStartOffset + " and " + documentLineEndOffset); " is 153.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,WriteTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("endOffset"' endOffset' "Value must be between startOffset and " + documentLineEndOffset); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,Equals,The length of the statement  "	return this.name == other.name && this.fontWeight == other.fontWeight && this.fontStyle == other.fontStyle && this.underline == other.underline && object.Equals (this.foreground' other.foreground) && object.Equals (this.background' other.background); " is 250.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,CreateHighlighter,The length of the statement  "		throw new NotSupportedException ("Cannot create a highlighter because no IHighlightingDefinition was specified' and the CreateHighlighter() method was not overridden."); " is 169.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnAddToTextView,The length of the statement  "		throw new InvalidOperationException ("Cannot use a HighlightingColorizer instance in multiple text views. Please create a separate instance for each text view."); " is 162.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,textView_VisualLineConstructionStarting,The length of the statement  "		// This is necessary in case the document gets modified above the FirstLineInView so that the highlighting state changes. " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,ColorizeLine,The length of the statement  "			ChangeLinePart (section.Offset' section.Offset + section.Length' visualLineElement => ApplyColorToElement (visualLineElement' section.Color)); " is 142.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,IsEmptyColor,The length of the statement  "	return color.Background == null && color.Foreground == null && color.FontStyle == null && color.FontWeight == null && color.Underline == null; " is 142.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,ApplyColorToElement,The length of the statement  "		element.TextRunProperties.SetTypeface (new Typeface (tf.FontFamily' color.FontStyle ?? tf.Style' color.FontWeight ?? tf.Weight' tf.Stretch)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnHighlightStateChanged,The length of the statement  "	Debug.WriteLine (string.Format ("OnHighlightStateChanged forces redraw of lines {0} to {1}"' fromLineNumber' toLineNumber)); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnHighlightStateChanged,The length of the statement  "			 * But doing it too early means it doesn't have the information necessary to re-highlight and redraw only the desired parts." is 123.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,HighlightLineInternal,The length of the statement  "					throw new InvalidOperationException ("A highlighting span matched 0 characters' which would cause an endless loop.\n" + "Change the highlighting definition so that either the start or the end regex matches at least one character.\n" + "Start regex: " + poppedSpan.StartExpression + "\n" + "End regex: " + poppedSpan.EndExpression); " is 331.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,HighlightNonSpans,The length of the statement  "				throw new InvalidOperationException ("A highlighting rule matched 0 characters' which would cause an endless loop.\n" + "Change the highlighting definition so that the rule matches at least one character.\n" + "Regex: " + rules [ruleIndex].Regex); " is 247.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,PushColor,The length of the statement  "	} else if (lastPoppedSection != null && lastPoppedSection.Color == color && lastPoppedSection.Offset + lastPoppedSection.Length == position + lineStartOffset) { " is 160.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,SetHtml,The length of the statement  "	string htmlStart = @"<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0 Transitional//EN"">" + Environment.NewLine + "<HTML>" + Environment.NewLine + "<BODY>" + Environment.NewLine + "<!--StartFragment-->" + Environment.NewLine; " is 222.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,SetHtml,The length of the statement  "	string htmlEnd = "<!--EndFragment-->" + Environment.NewLine + "</BODY>" + Environment.NewLine + "</HTML>" + Environment.NewLine; " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,Resources,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Resources\Resources.cs,RegisterBuiltInHighlightings,The length of the statement  "	hlm.RegisterHighlighting ("XML"' (".xml;.xsl;.xslt;.xsd;.manifest;.config;.addin;" + ".xshd;.wxs;.wxi;.wxl;.proj;.csproj;.vbproj;.ilproj;" + ".booproj;.build;.xfrm;.targets;.xaml;.xpt;" + ".xft;.map;.wsdl;.disco;.ps1xml;.nuspec").Split (';')' "XML-Mode.xshd"); " is 260.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,RichTextColorizer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\RichTextColorizer.cs,ColorizeLine,The length of the statement  "		ChangeLinePart (section.Offset' section.Offset + section.Length' visualLineElement => HighlightingColorizer.ApplyColorToElement (visualLineElement' section.Color' CurrentContext)); " is 180.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,RichTextModelWriter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\RichTextModelWriter.cs,AfterWrite,The length of the statement  "	richTextModel.SetHighlighting (currentColorBegin' documentTextWriter.InsertionOffset - currentColorBegin' currentColor); " is 120.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteRuleSetReference,The length of the statement  "			writer.WriteAttributeString ("ruleSet"' ruleSetReference.ReferencedDefinition + "/" + ruleSetReference.ReferencedElement); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "		writer.WriteAttributeString ("fontWeight"' V2Loader.FontWeightConverter.ConvertToInvariantString (color.FontWeight.Value).ToLowerInvariant ()); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "		writer.WriteAttributeString ("fontStyle"' V2Loader.FontStyleConverter.ConvertToInvariantString (color.FontStyle.Value).ToLowerInvariant ()); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseDefinition,The length of the statement  "				Regex = @"\b0[xX][0-9a-fA-F]+" + @"|" + @"(\b\d+(" + floatingPoint + ")?" + @"|" + floatingPoint + ")" + optionalExponent " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The length of the statement  "	if (!element.HasAttribute ("bold") && !element.HasAttribute ("italic") && !element.HasAttribute ("color") && !element.HasAttribute ("bgcolor")) " is 143.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportSpan,The length of the statement  "	span.BeginRegex = ImportRegex (element ["Begin"].InnerText' element ["Begin"].GetBoolAttribute ("singleword") ?? false' element ["Begin"].GetBoolAttribute ("startofline")); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,Error,The length of the statement  "		return new HighlightingDefinitionInvalidException (HighlightingLoader.FormatExceptionMessage (message' lineInfo.LineNumber' lineInfo.LinePosition)); " is 148.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,XshdReference,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\XshdReference.cs,Equals,The length of the statement  "	return this.referencedDefinition == other.referencedDefinition && this.referencedElement == other.referencedElement && this.inlineElement == other.inlineElement; " is 161.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "			block.Indent (Repeat (set.IndentString' oldBlock.OneLineBlock) + (oldBlock.Continuation ? set.IndentString : "") + (i == line.Length - 1 ? set.IndentString : new String (' '' i + 1))); " is 184.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "			if (block.LastWord == "case" || line.StartsWith ("case "' StringComparison.Ordinal) || line.StartsWith (block.LastWord + ":"' StringComparison.Ordinal)) { " is 154.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "		if (block.LastWord == "case" || line.StartsWith ("case "' StringComparison.Ordinal) || line.StartsWith (block.LastWord + ":"' StringComparison.Ordinal)) " is 152.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "		if (!oldBlock.Continuation && oldBlock.OneLineBlock == 0 && oldBlock.StartLine == block.StartLine && block.StartLine < doc.LineNumber && lastRealChar != ':') { " is 159.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "	if (indent.Length != (doc.Text.Length - line.Length) || !doc.Text.StartsWith (indent.ToString ()' StringComparison.Ordinal) || Char.IsWhiteSpace (doc.Text [indent.Length])) { " is 174.
Long Statement,ICSharpCode.AvalonEdit.Indentation,DefaultIndentationStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\DefaultIndentationStrategy.cs,IndentLine,The length of the statement  "		document.Replace (indentationSegment.Offset' indentationSegment.Length' indentation' OffsetChangeMappingType.RemoveAndInsert); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddRectangle,The length of the statement  "		AddRectangle (PixelSnapHelpers.Round (r.Left - halfBorder' pixelSize.Width) + halfBorder' PixelSnapHelpers.Round (r.Top - halfBorder' pixelSize.Height) + halfBorder' PixelSnapHelpers.Round (r.Right + halfBorder' pixelSize.Width) - halfBorder' PixelSnapHelpers.Round (r.Bottom + halfBorder' pixelSize.Height) - halfBorder); " is 322.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddRectangle,The length of the statement  "		//Debug.WriteLine(r.ToString() + " -> " + new Rect(lastLeft' lastTop' lastRight-lastLeft' lastBottom-lastTop).ToString()); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddRectangle,The length of the statement  "		AddRectangle (PixelSnapHelpers.PixelAlign (r.Left' pixelSize.Width)' PixelSnapHelpers.PixelAlign (r.Top' pixelSize.Height)' PixelSnapHelpers.PixelAlign (r.Right' pixelSize.Width)' PixelSnapHelpers.PixelAlign (r.Bottom' pixelSize.Height)); " is 238.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "			// The following special cases are necessary to get rid of empty rectangles at the end of a TextLine if "Show Spaces" is active. " is 128.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "			// If not excluded once' the same rectangle is calculated (and added) twice (since the offset could be mapped to two visual positions; end/start of line)' if there is no trailing whitespace. " is 190.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "			// Skip this TextLine segment' if it is at the end of this line and this line is not the last line of the VisualLine and the selection continues and there is no trailing whitespace. " is 181.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "			if (segmentEndVCInLine == visualEndCol && i < visualLine.TextLines.Count - 1 && segmentEndVC > segmentEndVCInLine && line.TrailingWhitespaceLength == 0) " is 152.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "			if (segmentStartVCInLine == visualStartCol && i > 0 && segmentStartVC < segmentStartVCInLine && visualLine.TextLines [i - 1].TrailingWhitespaceLength == 0) " is 155.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "		// Also' when word-wrap is enabled and the segment continues into the next line' extend lastRect up to the end of the line. " is 123.
Long Statement,ICSharpCode.AvalonEdit.Rendering,CollapsedLineSection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\CollapsedLineSection.cs,ToString,The length of the statement  "	return "[CollapsedSection" + ID + " Start=" + (start != null ? start.LineNumber.ToString () : "null") + " End=" + (end != null ? end.LineNumber.ToString () : "null") + "]"; " is 172.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "		throw new ArgumentOutOfRangeException ("startOffset"' startOffset' "Value must be between " + currentDocumentLineStartOffset + " and " + currentDocumentLineEndOffset); " is 167.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "		throw new ArgumentOutOfRangeException ("endOffset"' endOffset' "Value must be between " + startOffset + " and " + currentDocumentLineEndOffset); " is 144.
Long Statement,ICSharpCode.AvalonEdit.Rendering,FormattedTextRun,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,Format,The length of the statement  "		return new TextEmbeddedObjectMetrics (formattedText.WidthIncludingTrailingWhitespace' formattedText.Height' formattedText.Baseline); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,UpdateAugmentedData,The length of the statement  "	if (totalCount != node.totalCount || !totalHeight.IsClose (node.totalHeight) || mode == UpdateAfterChildrenChangeRecursionMode.WholeBranch) { " is 141.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,GetAllCollapsedSections,The length of the statement  "	return System.Linq.Enumerable.Distinct (System.Linq.Enumerable.SelectMany (AllNodes' node => System.Linq.Enumerable.Concat (node.lineNode.collapsedSections ?? emptyCSList' node.collapsedSections ?? emptyCSList))); " is 213.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTreeNode,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTreeNode.cs,ToString,The length of the statement  "	return "[HeightTreeNode " + documentLine.LineNumber + " CS=" + GetCollapsedSections (collapsedSections) + " Line.CS=" + GetCollapsedSections (lineNode.collapsedSections) + " Line.Height=" + lineNode.height + " TotalHeight=" + totalHeight + "]"; " is 244.
Long Statement,ICSharpCode.AvalonEdit.Rendering,MouseHoverLogic,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\MouseHoverLogic.cs,MouseHoverLogicMouseMove,The length of the statement  "	if (Math.Abs (mouseMovement.X) > SystemParameters.MouseHoverWidth || Math.Abs (mouseMovement.Y) > SystemParameters.MouseHoverHeight) { " is 134.
Long Statement,ICSharpCode.AvalonEdit.Rendering,MouseHoverLogic,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\MouseHoverLogic.cs,StartHovering,The length of the statement  "	mouseHoverTimer = new DispatcherTimer (SystemParameters.MouseHoverTime' DispatcherPriority.Background' OnMouseHoverTimerElapsed' this.target.Dispatcher); " is 153.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "		return new SpaceTextElement (CurrentContext.TextView.cachedElements.GetTextForNonPrintableCharacter ("\u00B7"' CurrentContext)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "		return new TabTextElement (CurrentContext.TextView.cachedElements.GetTextForNonPrintableCharacter ("\u00BB"' CurrentContext)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "		// Unfortunately the "easy" approach (just use DispatcherPriority.Background) here makes the editor twice as slow because " is 121.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "		// When fixing this' make sure performance on the SharpDevelop "type text in C# comment" stress test doesn't get significantly worse. " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,UpdateBuiltinElementGeneratorsFromOptions,The length of the statement  "	AddRemoveDefaultElementGeneratorOnDemand (ref singleCharacterElementGenerator' options.ShowBoxForControlCharacters || options.ShowSpaces || options.ShowTabs); " is 158.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,The length of the statement  "			} else if (p.KnownLayer == referencedLayer && p.Position == LayerInsertionPosition.Above || p.KnownLayer > referencedLayer) { " is 125.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,GetOrConstructVisualLine,The length of the statement  "		l = BuildVisualLine (documentLine' globalTextRunProperties' paragraphProperties' elementGenerators.ToArray ()' lineTransformers.ToArray ()' lastAvailableSize); " is 159.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,EnsureVisualLines,The length of the statement  "		throw new InvalidOperationException ("The visual line build process is already running! Cannot EnsureVisualLines() during Measure!"); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "			// HACK: we need to keep at least Caret.MinimumDistanceToViewBorder visible so that we don't scroll back up when the user types after " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "			// scrollViewportBottom: bottom of scroll view port' but clamped so that at least minVisibleDocumentHeight of the document stays visible. " is 137.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "			double scrollViewportBottom = Math.Min (heightTreeHeight - minVisibleDocumentHeight' scrollOffset.Y) + scrollViewport.Height; " is 125.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,The length of the statement  "			visualLine = BuildVisualLine (nextLine' globalTextRunProperties' paragraphProperties' elementGeneratorsArray' lineTransformersArray' availableSize); " is 148.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,The length of the statement  "		throw new InvalidOperationException ("A visual line was disposed even though it is still in use.\n" + "This can happen when Redraw() is called during measure for lines " + "that are already constructed."); " is 205.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "		double lastLinePos = heightTree.GetVisualPosition (visualLine.LastDocumentLine.NextLine ?? visualLine.LastDocumentLine); " is 120.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "					throw new InvalidOperationException ("Line " + i + " was skipped by a VisualLineElementGenerator' but it is not collapsed."); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "		TextLine textLine = formatter.FormatLine (textSource' textOffset' availableSize.Width' paragraphProperties' lastLineBreak); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,SetScrollData,The length of the statement  "	if (!(viewport.IsClose (this.scrollViewport) && extent.IsClose (this.scrollExtent) && offset.IsClose (this.scrollOffset))) { " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The length of the statement  "		using (var line = formatter.FormatLine (new SimpleTextSource ("x"' textRunProperties)' 0' 32000' new VisualLineTextParagraphProperties { " is 136.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The length of the statement  "	} else if (e.Property == Control.ForegroundProperty || e.Property == TextView.NonPrintableCharacterBrushProperty || e.Property == TextView.LinkTextBackgroundBrushProperty || e.Property == TextView.LinkTextForegroundBrushProperty || e.Property == TextView.LinkTextUnderlineProperty) { " is 283.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The length of the statement  "	if (e.Property == Control.FontFamilyProperty || e.Property == Control.FontSizeProperty || e.Property == Control.FontStretchProperty || e.Property == Control.FontStyleProperty || e.Property == Control.FontWeightProperty) { " is 221.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,The length of the statement  "					throw new ArgumentOutOfRangeException (g.GetType ().Name + ".GetFirstInterestedOffset"' g.cachedInterest' "GetFirstInterestedOffset must not return an offset less than startOffset. Return -1 to signal no interest."); " is 216.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,The length of the statement  "								throw new InvalidOperationException ("The VisualLineElementGenerator " + g.GetType ().Name + " produced an element which ends within the line delimiter"); " is 154.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,ReplaceElement,The length of the statement  "		throw new InvalidOperationException ("Old elements have document length " + oldDocumentLength + "' but new elements have length " + newDocumentLength); " is 151.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetVisualColumn,The length of the statement  "		if (element.RelativeTextOffset <= relativeTextOffset && element.RelativeTextOffset + element.DocumentLength >= relativeTextOffset) { " is 132.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualXPosition,The length of the statement  "	double xPos = textLine.GetDistanceFromCharacterHit (new CharacterHit (Math.Min (visualColumn' VisualLengthWithEndOfLineMarker)' 0)); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetVisualColumn,The length of the statement  "			int virtualX = (int)Math.Round ((xPos - textLine.WidthIncludingTrailingWhitespace) / textView.WideSpaceWidth' MidpointRounding.AwayFromZero); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "		if (visualColumn > this.VisualLength && !elements [elements.Count - 1].HandlesLineBorders && HasImplicitStopAtLineEnd (mode)) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "			int pos = elements [i].GetNextCaretPosition (Math.Min (visualColumn' elements [i].VisualColumn + elements [i].VisualLength + 1)' direction' mode); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "		throw new ArgumentOutOfRangeException ("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "		throw new ArgumentOutOfRangeException ("splitRelativeTextOffset"' splitRelativeTextOffset' "Value must be between " + (RelativeTextOffset) + " and " + (RelativeTextOffset + DocumentLength)); " is 190.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,GetNextCaretPosition,The length of the statement  "		else if (visualColumn < stop2 && mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) " is 122.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,CreateTextRun,The length of the statement  "	StringSegment text = context.GetText (context.VisualLine.FirstDocumentLine.Offset + RelativeTextOffset + relativeOffset' DocumentLength - relativeOffset); " is 154.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetPrecedingText,The length of the statement  "	StringSegment text = context.GetText (context.VisualLine.FirstDocumentLine.Offset + RelativeTextOffset' relativeOffset); " is 120.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetPrecedingText,The length of the statement  "	return new TextSpan<CultureSpecificCharacterBufferRange> (range.Length' new CultureSpecificCharacterBufferRange (this.TextRunProperties.CultureInfo' range)); " is 157.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,Split,The length of the statement  "		throw new ArgumentOutOfRangeException ("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetNextCaretPosition,The length of the statement  "	int pos = TextUtilities.GetNextCaretPosition (parentVisualLine.Document' textOffset + visualColumn - this.VisualColumn' direction' mode); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetTextRun,The length of the statement  "			if (textSourceCharacterIndex >= element.VisualColumn && textSourceCharacterIndex < element.VisualColumn + element.VisualLength) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,CreateTextRunForNewLine,The length of the statement  "	return new FormattedTextRun (new FormattedTextElement (TextView.cachedElements.GetTextForNonPrintableCharacter (newlineText' this)' 0)' GlobalTextRunProperties); " is 161.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetPrecedingText,The length of the statement  "			if (textSourceCharacterIndexLimit > element.VisualColumn && textSourceCharacterIndexLimit <= element.VisualColumn + element.VisualLength) { " is 139.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetPrecedingText,The length of the statement  "		return new TextSpan<CultureSpecificCharacterBufferRange> (empty.Length' new CultureSpecificCharacterBufferRange (null' empty)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Search,RegexSearchStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\RegexSearchStrategy.cs,IsWordBorder,The length of the statement  "	return TextUtilities.GetNextCaretPosition (document' offset - 1' LogicalDirection.Forward' CaretPositioningMode.WordBorder) == offset; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Search,RegexSearchStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\RegexSearchStrategy.cs,Equals,The length of the statement  "	return strategy != null && strategy.searchPattern.ToString () == searchPattern.ToString () && strategy.searchPattern.Options == searchPattern.Options && strategy.searchPattern.RightToLeft == searchPattern.RightToLeft; " is 217.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchInputHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchCommands.cs,RegisterGlobalCommands,The length of the statement  "	commandBindings.Add (new CommandBinding (SearchCommands.FindPrevious' ExecuteFindPrevious' CanExecuteWithOpenSearchPanel)); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchInputHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchCommands.cs,RegisterCommands,The length of the statement  "	commandBindings.Add (new CommandBinding (SearchCommands.FindPrevious' ExecuteFindPrevious' CanExecuteWithOpenSearchPanel)); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchInputHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchCommands.cs,RegisterCommands,The length of the statement  "	commandBindings.Add (new CommandBinding (SearchCommands.CloseSearchPanel' ExecuteCloseSearchPanel' CanExecuteWithOpenSearchPanel)); " is 131.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchPanel,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchPanel.cs,UpdateSearch,The length of the statement  "	strategy = SearchStrategyFactory.Create (SearchPattern ?? ""' !MatchCase' WholeWords' UseRegex ? SearchMode.RegEx : SearchMode.Normal); " is 135.
Long Statement,ICSharpCode.AvalonEdit.Snippets,InsertionContext,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,InsertText,The length of the statement  "			string insertString = text.Substring (textOffset' segment.Offset - textOffset) + this.LineTerminator + this.Indentation; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,CharRope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CharRope.cs,InsertText,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + rope.Length.ToString(CultureInfo.InvariantCulture));" is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - this.Count)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Utils,ExtensionMethods,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\ExtensionMethods.cs,CreateTypeface,The length of the statement  "	return new Typeface ((FontFamily)fe.GetValue (TextBlock.FontFamilyProperty)' (FontStyle)fe.GetValue (TextBlock.FontStyleProperty)' (FontWeight)fe.GetValue (TextBlock.FontWeightProperty)' (FontStretch)fe.GetValue (TextBlock.FontStretchProperty)); " is 245.
Long Statement,ICSharpCode.AvalonEdit.Utils,ExtensionMethods,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\ExtensionMethods.cs,Log,The length of the statement  "		string output = DateTime.Now.ToString ("hh:MM:ss") + ": " + string.Format (format' args) + Environment.NewLine + Environment.StackTrace; " is 136.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("index"' index' "0 <= index <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("index"' index' "0 <= index <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("startIndex"' startIndex' "0 <= startIndex <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 142.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("length"' length' "0 <= length' startIndex(" + startIndex + ")+length <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 169.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("startIndex"' arrayIndex' "0 <= arrayIndex <= " + array.Length.ToString (CultureInfo.InvariantCulture)); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("count"' count' "0 <= length' arrayIndex(" + arrayIndex + ")+count <= " + array.Length.ToString (CultureInfo.InvariantCulture)); " is 167.
Long Statement,ICSharpCode.AvalonEdit.Utils,RopeNode,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,ToString,The length of the statement  "			return "[Leaf length=" + length + "' isShared=" + isShared + "' text=\"" + new string (charContents' 0' length) + "\"]"; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,RopeNode,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,ToString,The length of the statement  "		return "[Concat length=" + length + "' isShared=" + isShared + "' height=" + height + "' Balance=" + this.Balance + "]"; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,FunctionNode,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,GetContentNode,The length of the statement  "				throw new InvalidOperationException ("Trying to load this node recursively; or: a previous call to a rope initializer failed."); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The length of the statement  "	return new FormattedText (text' CultureInfo.CurrentCulture' FlowDirection.LeftToRight' typeface' emSize.Value' foreground' null' TextOptions.GetTextFormattingMode (element)); " is 174.
Long Statement,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,Round,The length of the statement  "	return new Rect (Round (rect.X' pixelSize.Width)' Round (rect.Y' pixelSize.Height)' Round (rect.Width' pixelSize.Width)' Round (rect.Height' pixelSize.Height)); " is 160.
Long Statement,ICSharpCode.AvalonEdit.Utils,ThrowUtil,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\ThrowUtil.cs,CheckInRangeInclusive,The length of the statement  "		throw new ArgumentOutOfRangeException (parameterName' val' "Expected: " + lower.ToString (CultureInfo.InvariantCulture) + " <= " + parameterName + " <= " + upper.ToString (CultureInfo.InvariantCulture)); " is 203.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,StopBetweenCharacters,The conditional expression  "!((mode == CaretPositioningMode.WordStart || mode == CaretPositioningMode.WordStartOrSymbol) && (charAfter == CharacterClass.Whitespace || charAfter == CharacterClass.LineTerminator))"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_QueryCursor,The conditional expression  "p.X >= 0 && p.Y >= 0 && p.X <= textArea.TextView.ActualWidth && p.Y <= textArea.TextView.ActualHeight"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,TextArea,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnPropertyChanged,The conditional expression  "e.Property == SelectionBrushProperty || e.Property == SelectionBorderProperty || e.Property == SelectionForegroundProperty || e.Property == SelectionCornerRadiusProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting,HighlightedInlineBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedInlineBuilder.cs,SetHighlighting,The conditional expression  "color.Foreground == null && color.Background == null && color.FontStyle == null && color.FontWeight == null && color.Underline == null"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,Minimum,The conditional expression  "endSpanMatch != null && endSpanMatch.Success && (min == null || endSpanMatch.Index < min.Index)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The conditional expression  "!element.HasAttribute ("bold") && !element.HasAttribute ("italic") && !element.HasAttribute ("color") && !element.HasAttribute ("bgcolor")"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "lineComment || blockComment || inString || inChar"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "!oldBlock.Continuation && oldBlock.OneLineBlock == 0 && oldBlock.StartLine == block.StartLine && block.StartLine < doc.LineNumber && lastRealChar != ':'"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The conditional expression  "segmentEndVCInLine == visualEndCol && i < visualLine.TextLines.Count - 1 && segmentEndVC > segmentEndVCInLine && line.TrailingWhitespaceLength == 0"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The conditional expression  "segmentStartVCInLine == visualStartCol && i > 0 && segmentStartVC < segmentStartVCInLine && visualLine.TextLines [i - 1].TrailingWhitespaceLength == 0"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The conditional expression  "rectangle.IsEmpty || visual == null || visual == this || !this.IsAncestorOf (visual)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.ForegroundProperty || e.Property == TextView.NonPrintableCharacterBrushProperty || e.Property == TextView.LinkTextBackgroundBrushProperty || e.Property == TextView.LinkTextForegroundBrushProperty || e.Property == TextView.LinkTextUnderlineProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.FontFamilyProperty || e.Property == Control.FontSizeProperty || e.Property == Control.FontStretchProperty || e.Property == Control.FontStyleProperty || e.Property == Control.FontWeightProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Virtual Method Call from Constructor,ICSharpCode.AvalonEdit.Snippets,InsertionContext,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,InsertionContext,The constructor "InsertionContext" calls a virtual method "GetText".
Empty Catch Block,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,CopySelectedText,The method has an empty catch block.
Empty Catch Block,ICSharpCode.AvalonEdit.Rendering,VisualLineLinkText,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineLinkText.cs,OnMouseDown,The method has an empty catch block.
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  	if (line < 1)  		line = 1;  	if (line > document.LineCount)  		line = document.LineCount;  	IScrollInfo scrollInfo = textView;  	if (!scrollInfo.CanHorizontallyScroll) {  		// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  		// to the correct position.  		// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  		VisualLine vl = textView.GetOrConstructVisualLine (document.GetLineByNumber (line));  		double remainingHeight = scrollViewer.ViewportHeight / 2;  		while (remainingHeight > 0) {  			DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  			if (prevLine == null)  				break;  			vl = textView.GetOrConstructVisualLine (prevLine);  			remainingHeight -= vl.Height;  		}  	}  	Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle);  	double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  	if (Math.Abs (verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  		scrollViewer.ScrollToVerticalOffset (Math.Max (0' verticalPos));  	}  	if (column > 0) {  		if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  			double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  			if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  				scrollViewer.ScrollToHorizontalOffset (horizontalPos);  			}  		} else {  			scrollViewer.ScrollToHorizontalOffset (0);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  	if (line < 1)  		line = 1;  	if (line > document.LineCount)  		line = document.LineCount;  	IScrollInfo scrollInfo = textView;  	if (!scrollInfo.CanHorizontallyScroll) {  		// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  		// to the correct position.  		// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  		VisualLine vl = textView.GetOrConstructVisualLine (document.GetLineByNumber (line));  		double remainingHeight = scrollViewer.ViewportHeight / 2;  		while (remainingHeight > 0) {  			DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  			if (prevLine == null)  				break;  			vl = textView.GetOrConstructVisualLine (prevLine);  			remainingHeight -= vl.Height;  		}  	}  	Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle);  	double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  	if (Math.Abs (verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  		scrollViewer.ScrollToVerticalOffset (Math.Max (0' verticalPos));  	}  	if (column > 0) {  		if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  			double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  			if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  				scrollViewer.ScrollToHorizontalOffset (horizontalPos);  			}  		} else {  			scrollViewer.ScrollToHorizontalOffset (0);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  	if (line < 1)  		line = 1;  	if (line > document.LineCount)  		line = document.LineCount;  	IScrollInfo scrollInfo = textView;  	if (!scrollInfo.CanHorizontallyScroll) {  		// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  		// to the correct position.  		// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  		VisualLine vl = textView.GetOrConstructVisualLine (document.GetLineByNumber (line));  		double remainingHeight = scrollViewer.ViewportHeight / 2;  		while (remainingHeight > 0) {  			DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  			if (prevLine == null)  				break;  			vl = textView.GetOrConstructVisualLine (prevLine);  			remainingHeight -= vl.Height;  		}  	}  	Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle);  	double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  	if (Math.Abs (verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  		scrollViewer.ScrollToVerticalOffset (Math.Max (0' verticalPos));  	}  	if (column > 0) {  		if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  			double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  			if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  				scrollViewer.ScrollToHorizontalOffset (horizontalPos);  			}  		} else {  			scrollViewer.ScrollToHorizontalOffset (0);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  	if (line < 1)  		line = 1;  	if (line > document.LineCount)  		line = document.LineCount;  	IScrollInfo scrollInfo = textView;  	if (!scrollInfo.CanHorizontallyScroll) {  		// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  		// to the correct position.  		// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  		VisualLine vl = textView.GetOrConstructVisualLine (document.GetLineByNumber (line));  		double remainingHeight = scrollViewer.ViewportHeight / 2;  		while (remainingHeight > 0) {  			DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  			if (prevLine == null)  				break;  			vl = textView.GetOrConstructVisualLine (prevLine);  			remainingHeight -= vl.Height;  		}  	}  	Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle);  	double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  	if (Math.Abs (verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  		scrollViewer.ScrollToVerticalOffset (Math.Max (0' verticalPos));  	}  	if (column > 0) {  		if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  			double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  			if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  				scrollViewer.ScrollToHorizontalOffset (horizontalPos);  			}  		} else {  			scrollViewer.ScrollToHorizontalOffset (0);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (!scrollInfo.CanHorizontallyScroll) {  	// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  	// to the correct position.  	// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  	VisualLine vl = textView.GetOrConstructVisualLine (document.GetLineByNumber (line));  	double remainingHeight = scrollViewer.ViewportHeight / 2;  	while (remainingHeight > 0) {  		DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  		if (prevLine == null)  			break;  		vl = textView.GetOrConstructVisualLine (prevLine);  		remainingHeight -= vl.Height;  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (column > 0) {  	if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  		double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  		if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  			scrollViewer.ScrollToHorizontalOffset (horizontalPos);  		}  	} else {  		scrollViewer.ScrollToHorizontalOffset (0);  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (column > 0) {  	if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  		double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  		if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  			scrollViewer.ScrollToHorizontalOffset (horizontalPos);  		}  	} else {  		scrollViewer.ScrollToHorizontalOffset (0);  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  	double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  	if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  		scrollViewer.ScrollToHorizontalOffset (horizontalPos);  	}  } else {  	scrollViewer.ScrollToHorizontalOffset (0);  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  	double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  	if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  		scrollViewer.ScrollToHorizontalOffset (horizontalPos);  	}  } else {  	scrollViewer.ScrollToHorizontalOffset (0);  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	hashCode += 1000000007 * Line.GetHashCode ();  	hashCode += 1000000009 * Column.GetHashCode ();  	hashCode += 1000000021 * VisualColumn.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	hashCode += 1000000007 * Line.GetHashCode ();  	hashCode += 1000000009 * Column.GetHashCode ();  	hashCode += 1000000021 * VisualColumn.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	hashCode += 1000000007 * Line.GetHashCode ();  	hashCode += 1000000009 * Column.GetHashCode ();  	hashCode += 1000000021 * VisualColumn.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000007 * Line.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000009 * Column.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000021 * VisualColumn.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionListBox,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionListBox.cs,CenterViewOn,The following statement contains a magic number: this.FirstVisibleItem = index - VisibleItemCount / 2;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query == itemText)  	return 8;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 8;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (string.Equals (itemText' query' StringComparison.InvariantCultureIgnoreCase))  	return 7;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 7;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith (query' StringComparison.InvariantCulture))  	return 6;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 6;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith (query' StringComparison.InvariantCultureIgnoreCase))  	return 5;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 5;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  	camelCaseMatch = CamelCaseMatch (itemText' query);  	if (camelCaseMatch == true)  		return 4;  }  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  	camelCaseMatch = CamelCaseMatch (itemText' query);  	if (camelCaseMatch == true)  		return 4;  }  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (camelCaseMatch == true)  	return 4;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 4;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering) {  	if (itemText.IndexOf (query' StringComparison.InvariantCulture) >= 0)  		return 3;  	if (itemText.IndexOf (query' StringComparison.InvariantCultureIgnoreCase) >= 0)  		return 2;  }  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering) {  	if (itemText.IndexOf (query' StringComparison.InvariantCulture) >= 0)  		return 3;  	if (itemText.IndexOf (query' StringComparison.InvariantCultureIgnoreCase) >= 0)  		return 2;  }  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.IndexOf (query' StringComparison.InvariantCulture) >= 0)  	return 3;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 3;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.IndexOf (query' StringComparison.InvariantCultureIgnoreCase) >= 0)  	return 2;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 2;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MaxHeight = 300;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.Width = 175;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinHeight = 15;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinWidth = 30;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The following statement contains a magic number: MaxWidth = Math.Min (workingArea.Width' Math.Max (1000' workingArea.Width * 0.6));  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The following statement contains a magic number: MaxWidth = Math.Min (workingArea.Width' Math.Max (1000' workingArea.Width * 0.6));  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OverloadInsightWindow,The following statement contains a magic number: overloadViewer.Margin = new Thickness (2' 0' 0' 0);  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CollapseIfSingleOverloadConverter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadViewer.cs,Convert,The following statement contains a magic number: return ((int)value < 2) ? Visibility.Collapsed : Visibility.Visible;  
Magic Number,ICSharpCode.AvalonEdit.Document,SimpleSegment,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\SimpleSegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return Offset + 10301 * Length;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,SimpleSegment,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\SimpleSegment.cs,GetHashCode,The following statement contains a magic number: return Offset + 10301 * Length;  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos >= 0) {  	if (text [pos] == '\r') {  		if (pos + 1 < text.Length && text [pos + 1] == '\n')  			return new SimpleSegment (pos' 2);  	}  	return new SimpleSegment (pos' 1);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (text [pos] == '\r') {  	if (pos + 1 < text.Length && text [pos + 1] == '\n')  		return new SimpleSegment (pos' 2);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos + 1 < text.Length && text [pos + 1] == '\n')  	return new SimpleSegment (pos' 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: return new SimpleSegment (pos' 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos >= 0) {  	if (text.GetCharAt (pos) == '\r') {  		if (pos + 1 < textLength && text.GetCharAt (pos + 1) == '\n')  			return new SimpleSegment (pos' 2);  	}  	return new SimpleSegment (pos' 1);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (text.GetCharAt (pos) == '\r') {  	if (pos + 1 < textLength && text.GetCharAt (pos + 1) == '\n')  		return new SimpleSegment (pos' 2);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos + 1 < textLength && text.GetCharAt (pos + 1) == '\n')  	return new SimpleSegment (pos' 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: return new SimpleSegment (pos' 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,FindNextNewLine,The following statement contains a magic number: if (s == SimpleSegment.Invalid) {  	newLineType = null;  	return -1;  } else {  	if (s.Length == 2) {  		newLineType = "\r\n";  	} else if (text.GetCharAt (s.Offset) == '\n') {  		newLineType = "\n";  	} else {  		newLineType = "\r";  	}  	return s.Offset;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,FindNextNewLine,The following statement contains a magic number: if (s.Length == 2) {  	newLineType = "\r\n";  } else if (text.GetCharAt (s.Offset) == '\n') {  	newLineType = "\n";  } else {  	newLineType = "\r";  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  	return c0Table [num];  else if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  	return c0Table [num];  else if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  	return c0Table [num];  else if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: return delAndC1Table [num - 127];  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: while (true) {  	int nextPos = (direction == LogicalDirection.Backward) ? offset - 1 : offset + 1;  	// return -1 if there is no further caret position in the text source  	// we also need this to handle offset values outside the valid range  	if (nextPos < 0 || nextPos > textLength)  		return -1;  	// check if we've run against the textSource borders.  	// a 'textSource' usually isn't the whole document' but a single VisualLineElement.  	if (nextPos == 0) {  		// at the document start' there's only a word border  		// if the first character is not whitespace  		if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (0)))  			return nextPos;  	} else if (nextPos == textLength) {  		// at the document end' there's never a word start  		if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  			// at the document end' there's only a word border  			// if the last character is not whitespace  			if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (textLength - 1)))  				return nextPos;  		}  	} else {  		char charBefore = textSource.GetCharAt (nextPos - 1);  		char charAfter = textSource.GetCharAt (nextPos);  		// Don't stop in the middle of a surrogate pair  		if (!char.IsSurrogatePair (charBefore' charAfter)) {  			CharacterClass classBefore = GetCharacterClass (charBefore);  			CharacterClass classAfter = GetCharacterClass (charAfter);  			// get correct class for characters outside BMP:  			if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  				classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  			}  			if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  				classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  			}  			if (StopBetweenCharacters (mode' classBefore' classAfter)) {  				return nextPos;  			}  		}  	}  	// we'll have to continue searching...  	offset = nextPos;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: while (true) {  	int nextPos = (direction == LogicalDirection.Backward) ? offset - 1 : offset + 1;  	// return -1 if there is no further caret position in the text source  	// we also need this to handle offset values outside the valid range  	if (nextPos < 0 || nextPos > textLength)  		return -1;  	// check if we've run against the textSource borders.  	// a 'textSource' usually isn't the whole document' but a single VisualLineElement.  	if (nextPos == 0) {  		// at the document start' there's only a word border  		// if the first character is not whitespace  		if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (0)))  			return nextPos;  	} else if (nextPos == textLength) {  		// at the document end' there's never a word start  		if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  			// at the document end' there's only a word border  			// if the last character is not whitespace  			if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (textLength - 1)))  				return nextPos;  		}  	} else {  		char charBefore = textSource.GetCharAt (nextPos - 1);  		char charAfter = textSource.GetCharAt (nextPos);  		// Don't stop in the middle of a surrogate pair  		if (!char.IsSurrogatePair (charBefore' charAfter)) {  			CharacterClass classBefore = GetCharacterClass (charBefore);  			CharacterClass classAfter = GetCharacterClass (charAfter);  			// get correct class for characters outside BMP:  			if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  				classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  			}  			if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  				classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  			}  			if (StopBetweenCharacters (mode' classBefore' classAfter)) {  				return nextPos;  			}  		}  	}  	// we'll have to continue searching...  	offset = nextPos;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (nextPos == 0) {  	// at the document start' there's only a word border  	// if the first character is not whitespace  	if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (0)))  		return nextPos;  } else if (nextPos == textLength) {  	// at the document end' there's never a word start  	if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  		// at the document end' there's only a word border  		// if the last character is not whitespace  		if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (textLength - 1)))  			return nextPos;  	}  } else {  	char charBefore = textSource.GetCharAt (nextPos - 1);  	char charAfter = textSource.GetCharAt (nextPos);  	// Don't stop in the middle of a surrogate pair  	if (!char.IsSurrogatePair (charBefore' charAfter)) {  		CharacterClass classBefore = GetCharacterClass (charBefore);  		CharacterClass classAfter = GetCharacterClass (charAfter);  		// get correct class for characters outside BMP:  		if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  			classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  		}  		if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  			classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  		}  		if (StopBetweenCharacters (mode' classBefore' classAfter)) {  			return nextPos;  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (nextPos == 0) {  	// at the document start' there's only a word border  	// if the first character is not whitespace  	if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (0)))  		return nextPos;  } else if (nextPos == textLength) {  	// at the document end' there's never a word start  	if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  		// at the document end' there's only a word border  		// if the last character is not whitespace  		if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (textLength - 1)))  			return nextPos;  	}  } else {  	char charBefore = textSource.GetCharAt (nextPos - 1);  	char charAfter = textSource.GetCharAt (nextPos);  	// Don't stop in the middle of a surrogate pair  	if (!char.IsSurrogatePair (charBefore' charAfter)) {  		CharacterClass classBefore = GetCharacterClass (charBefore);  		CharacterClass classAfter = GetCharacterClass (charAfter);  		// get correct class for characters outside BMP:  		if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  			classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  		}  		if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  			classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  		}  		if (StopBetweenCharacters (mode' classBefore' classAfter)) {  			return nextPos;  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (nextPos == textLength) {  	// at the document end' there's never a word start  	if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  		// at the document end' there's only a word border  		// if the last character is not whitespace  		if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (textLength - 1)))  			return nextPos;  	}  } else {  	char charBefore = textSource.GetCharAt (nextPos - 1);  	char charAfter = textSource.GetCharAt (nextPos);  	// Don't stop in the middle of a surrogate pair  	if (!char.IsSurrogatePair (charBefore' charAfter)) {  		CharacterClass classBefore = GetCharacterClass (charBefore);  		CharacterClass classAfter = GetCharacterClass (charAfter);  		// get correct class for characters outside BMP:  		if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  			classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  		}  		if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  			classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  		}  		if (StopBetweenCharacters (mode' classBefore' classAfter)) {  			return nextPos;  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (nextPos == textLength) {  	// at the document end' there's never a word start  	if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  		// at the document end' there's only a word border  		// if the last character is not whitespace  		if (IsNormal (mode) || !char.IsWhiteSpace (textSource.GetCharAt (textLength - 1)))  			return nextPos;  	}  } else {  	char charBefore = textSource.GetCharAt (nextPos - 1);  	char charAfter = textSource.GetCharAt (nextPos);  	// Don't stop in the middle of a surrogate pair  	if (!char.IsSurrogatePair (charBefore' charAfter)) {  		CharacterClass classBefore = GetCharacterClass (charBefore);  		CharacterClass classAfter = GetCharacterClass (charAfter);  		// get correct class for characters outside BMP:  		if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  			classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  		}  		if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  			classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  		}  		if (StopBetweenCharacters (mode' classBefore' classAfter)) {  			return nextPos;  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (!char.IsSurrogatePair (charBefore' charAfter)) {  	CharacterClass classBefore = GetCharacterClass (charBefore);  	CharacterClass classAfter = GetCharacterClass (charAfter);  	// get correct class for characters outside BMP:  	if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  		classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  	}  	if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  		classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  	}  	if (StopBetweenCharacters (mode' classBefore' classAfter)) {  		return nextPos;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (!char.IsSurrogatePair (charBefore' charAfter)) {  	CharacterClass classBefore = GetCharacterClass (charBefore);  	CharacterClass classAfter = GetCharacterClass (charAfter);  	// get correct class for characters outside BMP:  	if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  		classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  	}  	if (char.IsHighSurrogate (charAfter) && nextPos + 1 < textLength) {  		classAfter = GetCharacterClass (charAfter' textSource.GetCharAt (nextPos + 1));  	}  	if (StopBetweenCharacters (mode' classBefore' classAfter)) {  		return nextPos;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  	classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: if (char.IsLowSurrogate (charBefore) && nextPos >= 2) {  	classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: classBefore = GetCharacterClass (textSource.GetCharAt (nextPos - 2)' charBefore);  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocation,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked(191 * column.GetHashCode () ^ line.GetHashCode ());  
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocationConverter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextLocation.cs,ConvertFrom,The following statement contains a magic number: if (value is string) {  	string[] parts = ((string)value).Split (';'' ''');  	if (parts.Length == 2) {  		return new TextLocation (int.Parse (parts [0]' culture)' int.Parse (parts [1]' culture));  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocationConverter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextLocation.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 2) {  	return new TextLocation (int.Parse (parts [0]' culture)' int.Parse (parts [1]' culture));  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,TextAnchorTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Remove,The following statement contains a magic number: if (offset > startLineOffset + startLine.Length) {  	Debug.Assert (startLine.DelimiterLength == 2);  	// we are deleting starting in the middle of a delimiter  	// remove last delimiter part  	SetLineLength (startLine' startLine.TotalLength - 1);  	// remove remaining text  	Remove (offset' length - 1);  	return;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Remove,The following statement contains a magic number: Debug.Assert (startLine.DelimiterLength == 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Insert,The following statement contains a magic number: if (offset > lineOffset + line.Length) {  	Debug.Assert (line.DelimiterLength == 2);  	// we are inserting in the middle of a delimiter  	// shorten line  	SetLineLength (line' line.TotalLength - 1);  	// add new line  	line = InsertLineAfter (line' 1);  	line = SetLineLength (line' 1);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Insert,The following statement contains a magic number: Debug.Assert (line.DelimiterLength == 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  	line.DelimiterLength = 0;  } else {  	int lineOffset = line.Offset;  	char lastChar = document.GetCharAt (lineOffset + newTotalLength - 1);  	if (lastChar == '\r') {  		line.DelimiterLength = 1;  	} else if (lastChar == '\n') {  		if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  			line.DelimiterLength = 2;  		} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  			// we need to join this line with the previous line  			DocumentLine previousLine = line.PreviousLine;  			RemoveLine (line);  			return SetLineLength (previousLine' previousLine.TotalLength + 1);  		} else {  			line.DelimiterLength = 1;  		}  	} else {  		line.DelimiterLength = 0;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  	line.DelimiterLength = 0;  } else {  	int lineOffset = line.Offset;  	char lastChar = document.GetCharAt (lineOffset + newTotalLength - 1);  	if (lastChar == '\r') {  		line.DelimiterLength = 1;  	} else if (lastChar == '\n') {  		if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  			line.DelimiterLength = 2;  		} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  			// we need to join this line with the previous line  			DocumentLine previousLine = line.PreviousLine;  			RemoveLine (line);  			return SetLineLength (previousLine' previousLine.TotalLength + 1);  		} else {  			line.DelimiterLength = 1;  		}  	} else {  		line.DelimiterLength = 0;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  	line.DelimiterLength = 0;  } else {  	int lineOffset = line.Offset;  	char lastChar = document.GetCharAt (lineOffset + newTotalLength - 1);  	if (lastChar == '\r') {  		line.DelimiterLength = 1;  	} else if (lastChar == '\n') {  		if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  			line.DelimiterLength = 2;  		} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  			// we need to join this line with the previous line  			DocumentLine previousLine = line.PreviousLine;  			RemoveLine (line);  			return SetLineLength (previousLine' previousLine.TotalLength + 1);  		} else {  			line.DelimiterLength = 1;  		}  	} else {  		line.DelimiterLength = 0;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\r') {  	line.DelimiterLength = 1;  } else if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\r') {  	line.DelimiterLength = 1;  } else if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\r') {  	line.DelimiterLength = 1;  } else if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  	line.DelimiterLength = 2;  } else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  	// we need to join this line with the previous line  	DocumentLine previousLine = line.PreviousLine;  	RemoveLine (line);  	return SetLineLength (previousLine' previousLine.TotalLength + 1);  } else {  	line.DelimiterLength = 1;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  	line.DelimiterLength = 2;  } else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  	// we need to join this line with the previous line  	DocumentLine previousLine = line.PreviousLine;  	RemoveLine (line);  	return SetLineLength (previousLine' previousLine.TotalLength + 1);  } else {  	line.DelimiterLength = 1;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  	line.DelimiterLength = 2;  } else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  	// we need to join this line with the previous line  	DocumentLine previousLine = line.PreviousLine;  	RemoveLine (line);  	return SetLineLength (previousLine' previousLine.TotalLength + 1);  } else {  	line.DelimiterLength = 1;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: line.DelimiterLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,GetTreeHeight,The following statement contains a magic number: if (size == 0)  	return 0;  else  	return GetTreeHeight (size / 2) + 1;  
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,GetTreeHeight,The following statement contains a magic number: return GetTreeHeight (size / 2) + 1;  
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The following statement contains a magic number: switch (offsetChangeMappingType) {  case OffsetChangeMappingType.Normal:  	Replace (offset' length' text' null);  	break;  case OffsetChangeMappingType.KeepAnchorBeforeInsertion:  	Replace (offset' length' text' OffsetChangeMap.FromSingleElement (new OffsetChangeMapEntry (offset' length' text.TextLength' false' true)));  	break;  case OffsetChangeMappingType.RemoveAndInsert:  	if (length == 0 || text.TextLength == 0) {  		// only insertion or only removal?  		// OffsetChangeMappingType doesn't matter' just use Normal.  		Replace (offset' length' text' null);  	} else {  		OffsetChangeMap map = new OffsetChangeMap (2);  		map.Add (new OffsetChangeMapEntry (offset' length' 0));  		map.Add (new OffsetChangeMapEntry (offset' 0' text.TextLength));  		map.Freeze ();  		Replace (offset' length' text' map);  	}  	break;  case OffsetChangeMappingType.CharacterReplace:  	if (length == 0 || text.TextLength == 0) {  		// only insertion or only removal?  		// OffsetChangeMappingType doesn't matter' just use Normal.  		Replace (offset' length' text' null);  	} else if (text.TextLength > length) {  		// look at OffsetChangeMappingType.CharacterReplace XML comments on why we need to replace  		// the last character  		OffsetChangeMapEntry entry = new OffsetChangeMapEntry (offset + length - 1' 1' 1 + text.TextLength - length);  		Replace (offset' length' text' OffsetChangeMap.FromSingleElement (entry));  	} else if (text.TextLength < length) {  		OffsetChangeMapEntry entry = new OffsetChangeMapEntry (offset + text.TextLength' length - text.TextLength' 0' true' false);  		Replace (offset' length' text' OffsetChangeMap.FromSingleElement (entry));  	} else {  		Replace (offset' length' text' OffsetChangeMap.Empty);  	}  	break;  default:  	throw new ArgumentOutOfRangeException ("offsetChangeMappingType"' offsetChangeMappingType' "Invalid enum value");  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The following statement contains a magic number: if (length == 0 || text.TextLength == 0) {  	// only insertion or only removal?  	// OffsetChangeMappingType doesn't matter' just use Normal.  	Replace (offset' length' text' null);  } else {  	OffsetChangeMap map = new OffsetChangeMap (2);  	map.Add (new OffsetChangeMapEntry (offset' length' 0));  	map.Add (new OffsetChangeMapEntry (offset' 0' text.TextLength));  	map.Freeze ();  	Replace (offset' length' text' map);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,DoReplace,The following statement contains a magic number: if (length == 0) {  	removedText = StringTextSource.Empty;  } else if (length < 100) {  	removedText = new StringTextSource (rope.ToString (offset' length));  } else {  	// use a rope if the removed string is long  	removedText = new RopeTextSource (rope.GetRange (offset' length));  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,DoReplace,The following statement contains a magic number: if (length < 100) {  	removedText = new StringTextSource (rope.ToString (offset' length));  } else {  	// use a rope if the removed string is long  	removedText = new RopeTextSource (rope.GetRange (offset' length));  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,CaretLayer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretLayer.cs,OnRender,The following statement contains a magic number: if (isVisible && blink) {  	Brush caretBrush = this.CaretBrush;  	if (caretBrush == null)  		caretBrush = (Brush)textView.GetValue (TextBlock.ForegroundProperty);  	if (this.textArea.OverstrikeMode) {  		SolidColorBrush scBrush = caretBrush as SolidColorBrush;  		if (scBrush != null) {  			Color brushColor = scBrush.Color;  			Color newColor = Color.FromArgb (100' brushColor.R' brushColor.G' brushColor.B);  			caretBrush = new SolidColorBrush (newColor);  			caretBrush.Freeze ();  		}  	}  	Rect r = new Rect (caretRectangle.X - textView.HorizontalOffset' caretRectangle.Y - textView.VerticalOffset' caretRectangle.Width' caretRectangle.Height);  	drawingContext.DrawRectangle (caretBrush' null' PixelSnapHelpers.Round (r' PixelSnapHelpers.GetPixelSize (this)));  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,CaretLayer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretLayer.cs,OnRender,The following statement contains a magic number: if (this.textArea.OverstrikeMode) {  	SolidColorBrush scBrush = caretBrush as SolidColorBrush;  	if (scBrush != null) {  		Color brushColor = scBrush.Color;  		Color newColor = Color.FromArgb (100' brushColor.R' brushColor.G' brushColor.B);  		caretBrush = new SolidColorBrush (newColor);  		caretBrush.Freeze ();  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,CaretLayer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretLayer.cs,OnRender,The following statement contains a magic number: if (scBrush != null) {  	Color brushColor = scBrush.Color;  	Color newColor = Color.FromArgb (100' brushColor.R' brushColor.G' brushColor.B);  	caretBrush = new SolidColorBrush (newColor);  	caretBrush.Freeze ();  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  	newLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  	newLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: newLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnMouseLeftButtonDown,The following statement contains a magic number: if (!e.Handled && TextView != null && textArea != null) {  	e.Handled = true;  	textArea.Focus ();  	SimpleSegment currentSeg = GetTextLineSegment (e);  	if (currentSeg == SimpleSegment.Invalid)  		return;  	textArea.Caret.Offset = currentSeg.Offset + currentSeg.Length;  	if (CaptureMouse ()) {  		selecting = true;  		selectionStart = new AnchorSegment (Document' currentSeg.Offset' currentSeg.Length);  		if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift) {  			SimpleSelection simpleSelection = textArea.Selection as SimpleSelection;  			if (simpleSelection != null)  				selectionStart = new AnchorSegment (Document' simpleSelection.SurroundingSegment);  		}  		textArea.Selection = Selection.Create (textArea' selectionStart);  		if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift) {  			ExtendSelection (currentSeg);  		}  		textArea.Caret.BringCaretToView (5.0);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnMouseLeftButtonDown,The following statement contains a magic number: if (CaptureMouse ()) {  	selecting = true;  	selectionStart = new AnchorSegment (Document' currentSeg.Offset' currentSeg.Length);  	if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift) {  		SimpleSelection simpleSelection = textArea.Selection as SimpleSelection;  		if (simpleSelection != null)  			selectionStart = new AnchorSegment (Document' simpleSelection.SurroundingSegment);  	}  	textArea.Selection = Selection.Create (textArea' selectionStart);  	if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift) {  		ExtendSelection (currentSeg);  	}  	textArea.Caret.BringCaretToView (5.0);  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnMouseLeftButtonDown,The following statement contains a magic number: textArea.Caret.BringCaretToView (5.0);  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnMouseMove,The following statement contains a magic number: if (selecting && textArea != null && TextView != null) {  	e.Handled = true;  	SimpleSegment currentSeg = GetTextLineSegment (e);  	if (currentSeg == SimpleSegment.Invalid)  		return;  	ExtendSelection (currentSeg);  	textArea.Caret.BringCaretToView (5.0);  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnMouseMove,The following statement contains a magic number: textArea.Caret.BringCaretToView (5.0);  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (!e.Handled && e.ChangedButton == MouseButton.Left) {  	ModifierKeys modifiers = Keyboard.Modifiers;  	bool shift = (modifiers & ModifierKeys.Shift) == ModifierKeys.Shift;  	if (enableTextDragDrop && e.ClickCount == 1 && !shift) {  		int visualColumn;  		bool isAtEndOfLine;  		int offset = GetOffsetFromMousePosition (e' out visualColumn' out isAtEndOfLine);  		if (textArea.Selection.Contains (offset)) {  			if (textArea.CaptureMouse ()) {  				mode = SelectionMode.PossibleDragStart;  				possibleDragStartMousePos = e.GetPosition (textArea);  			}  			e.Handled = true;  			return;  		}  	}  	var oldPosition = textArea.Caret.Position;  	SetCaretOffsetToMousePosition (e);  	if (!shift) {  		textArea.ClearSelection ();  	}  	if (textArea.CaptureMouse ()) {  		if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt && textArea.Options.EnableRectangularSelection) {  			mode = SelectionMode.Rectangular;  			if (shift && textArea.Selection is RectangleSelection) {  				textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldPosition' textArea.Caret.Position);  			}  		} else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  			mode = SelectionMode.Normal;  			if (shift && !(textArea.Selection is RectangleSelection)) {  				textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldPosition' textArea.Caret.Position);  			}  		} else {  			SimpleSegment startWord;  			if (e.ClickCount == 3) {  				mode = SelectionMode.WholeLine;  				startWord = GetLineAtMousePosition (e);  			} else {  				mode = SelectionMode.WholeWord;  				startWord = GetWordAtMousePosition (e);  			}  			if (startWord == SimpleSegment.Invalid) {  				mode = SelectionMode.None;  				textArea.ReleaseMouseCapture ();  				return;  			}  			if (shift && !textArea.Selection.IsEmpty) {  				if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  					textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.Offset)));  				} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  					textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.EndOffset)));  				}  				this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  			} else {  				textArea.Selection = Selection.Create (textArea' startWord.Offset' startWord.EndOffset);  				this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  			}  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (textArea.CaptureMouse ()) {  	if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt && textArea.Options.EnableRectangularSelection) {  		mode = SelectionMode.Rectangular;  		if (shift && textArea.Selection is RectangleSelection) {  			textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldPosition' textArea.Caret.Position);  		}  	} else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  		mode = SelectionMode.Normal;  		if (shift && !(textArea.Selection is RectangleSelection)) {  			textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldPosition' textArea.Caret.Position);  		}  	} else {  		SimpleSegment startWord;  		if (e.ClickCount == 3) {  			mode = SelectionMode.WholeLine;  			startWord = GetLineAtMousePosition (e);  		} else {  			mode = SelectionMode.WholeWord;  			startWord = GetWordAtMousePosition (e);  		}  		if (startWord == SimpleSegment.Invalid) {  			mode = SelectionMode.None;  			textArea.ReleaseMouseCapture ();  			return;  		}  		if (shift && !textArea.Selection.IsEmpty) {  			if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  				textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.Offset)));  			} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  				textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.EndOffset)));  			}  			this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  		} else {  			textArea.Selection = Selection.Create (textArea' startWord.Offset' startWord.EndOffset);  			this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt && textArea.Options.EnableRectangularSelection) {  	mode = SelectionMode.Rectangular;  	if (shift && textArea.Selection is RectangleSelection) {  		textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldPosition' textArea.Caret.Position);  	}  } else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  	mode = SelectionMode.Normal;  	if (shift && !(textArea.Selection is RectangleSelection)) {  		textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldPosition' textArea.Caret.Position);  	}  } else {  	SimpleSegment startWord;  	if (e.ClickCount == 3) {  		mode = SelectionMode.WholeLine;  		startWord = GetLineAtMousePosition (e);  	} else {  		mode = SelectionMode.WholeWord;  		startWord = GetWordAtMousePosition (e);  	}  	if (startWord == SimpleSegment.Invalid) {  		mode = SelectionMode.None;  		textArea.ReleaseMouseCapture ();  		return;  	}  	if (shift && !textArea.Selection.IsEmpty) {  		if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  			textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.Offset)));  		} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  			textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.EndOffset)));  		}  		this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  	} else {  		textArea.Selection = Selection.Create (textArea' startWord.Offset' startWord.EndOffset);  		this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  	mode = SelectionMode.Normal;  	if (shift && !(textArea.Selection is RectangleSelection)) {  		textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldPosition' textArea.Caret.Position);  	}  } else {  	SimpleSegment startWord;  	if (e.ClickCount == 3) {  		mode = SelectionMode.WholeLine;  		startWord = GetLineAtMousePosition (e);  	} else {  		mode = SelectionMode.WholeWord;  		startWord = GetWordAtMousePosition (e);  	}  	if (startWord == SimpleSegment.Invalid) {  		mode = SelectionMode.None;  		textArea.ReleaseMouseCapture ();  		return;  	}  	if (shift && !textArea.Selection.IsEmpty) {  		if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  			textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.Offset)));  		} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  			textArea.Selection = textArea.Selection.SetEndpoint (new TextViewPosition (textArea.Document.GetLocation (startWord.EndOffset)));  		}  		this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  	} else {  		textArea.Selection = Selection.Create (textArea' startWord.Offset' startWord.EndOffset);  		this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (e.ClickCount == 3) {  	mode = SelectionMode.WholeLine;  	startWord = GetLineAtMousePosition (e);  } else {  	mode = SelectionMode.WholeWord;  	startWord = GetWordAtMousePosition (e);  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,ExtendSelectionToMouse,The following statement contains a magic number: textArea.Caret.BringCaretToView (5.0);  
Magic Number,ICSharpCode.AvalonEdit.Editing,SimpleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return startOffset * 27811 + endOffset + textArea.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SimpleSelection,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,GetHashCode,The following statement contains a magic number: return startOffset * 27811 + endOffset + textArea.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  	int visualColumn = m.VisualLine.GetVisualColumn (m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  	TextLine textLine = m.VisualLine.GetTextLine (visualColumn);  	double yPos = m.VisualLine.GetTextLineVisualYPosition (textLine' VisualYPosition.TextMiddle) - TextView.VerticalOffset;  	yPos -= m.DesiredSize.Height / 2;  	double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  	m.Arrange (new Rect (PixelSnapHelpers.Round (new Point (xPos' yPos)' pixelSize)' m.DesiredSize));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  	int visualColumn = m.VisualLine.GetVisualColumn (m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  	TextLine textLine = m.VisualLine.GetTextLine (visualColumn);  	double yPos = m.VisualLine.GetTextLineVisualYPosition (textLine' VisualYPosition.TextMiddle) - TextView.VerticalOffset;  	yPos -= m.DesiredSize.Height / 2;  	double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  	m.Arrange (new Rect (PixelSnapHelpers.Round (new Point (xPos' yPos)' pixelSize)' m.DesiredSize));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: yPos -= m.DesiredSize.Height / 2;  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  	foreach (TextLine tl in vl.TextLines) {  		if (endMarker [tlNumber] != null) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  		}  		if (colors [tlNumber + 1] != currentPen) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			if (currentPen != null) {  				drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  			}  			currentPen = colors [tlNumber + 1];  			startY = visualPos;  		}  		tlNumber++;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  	foreach (TextLine tl in vl.TextLines) {  		if (endMarker [tlNumber] != null) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  		}  		if (colors [tlNumber + 1] != currentPen) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			if (currentPen != null) {  				drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  			}  			currentPen = colors [tlNumber + 1];  			startY = visualPos;  		}  		tlNumber++;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  	foreach (TextLine tl in vl.TextLines) {  		if (endMarker [tlNumber] != null) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  		}  		if (colors [tlNumber + 1] != currentPen) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			if (currentPen != null) {  				drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  			}  			currentPen = colors [tlNumber + 1];  			startY = visualPos;  		}  		tlNumber++;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (TextLine tl in vl.TextLines) {  	if (endMarker [tlNumber] != null) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  	}  	if (colors [tlNumber + 1] != currentPen) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		if (currentPen != null) {  			drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  		}  		currentPen = colors [tlNumber + 1];  		startY = visualPos;  	}  	tlNumber++;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (TextLine tl in vl.TextLines) {  	if (endMarker [tlNumber] != null) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  	}  	if (colors [tlNumber + 1] != currentPen) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		if (currentPen != null) {  			drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  		}  		currentPen = colors [tlNumber + 1];  		startY = visualPos;  	}  	tlNumber++;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (TextLine tl in vl.TextLines) {  	if (endMarker [tlNumber] != null) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  	}  	if (colors [tlNumber + 1] != currentPen) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		if (currentPen != null) {  			drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  		}  		currentPen = colors [tlNumber + 1];  		startY = visualPos;  	}  	tlNumber++;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (endMarker [tlNumber] != null) {  	double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  	drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (colors [tlNumber + 1] != currentPen) {  	double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  	if (currentPen != null) {  		drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  	}  	currentPen = colors [tlNumber + 1];  	startY = visualPos;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (colors [tlNumber + 1] != currentPen) {  	double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  	if (currentPen != null) {  		drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  	}  	currentPen = colors [tlNumber + 1];  	startY = visualPos;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  	drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  	drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  	drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' RenderSize.Height));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' RenderSize.Height));  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  	int firstNewLine = comment.IndexOf ('\n');  	if (firstNewLine >= 0) {  		// Take off 4 chars to get the actual comment start (takes  		// into account the <!-- chars.  		int startOffset = GetOffset (document' reader) - 4;  		int endOffset = startOffset + comment.Length + 7;  		string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  		foldMarkers.Add (new NewFolding (startOffset' endOffset) {  			Name = foldText  		});  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  	int firstNewLine = comment.IndexOf ('\n');  	if (firstNewLine >= 0) {  		// Take off 4 chars to get the actual comment start (takes  		// into account the <!-- chars.  		int startOffset = GetOffset (document' reader) - 4;  		int endOffset = startOffset + comment.Length + 7;  		string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  		foldMarkers.Add (new NewFolding (startOffset' endOffset) {  			Name = foldText  		});  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (firstNewLine >= 0) {  	// Take off 4 chars to get the actual comment start (takes  	// into account the <!-- chars.  	int startOffset = GetOffset (document' reader) - 4;  	int endOffset = startOffset + comment.Length + 7;  	string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  	foldMarkers.Add (new NewFolding (startOffset' endOffset) {  		Name = foldText  	});  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (firstNewLine >= 0) {  	// Take off 4 chars to get the actual comment start (takes  	// into account the <!-- chars.  	int startOffset = GetOffset (document' reader) - 4;  	int endOffset = startOffset + comment.Length + 7;  	string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  	foldMarkers.Add (new NewFolding (startOffset' endOffset) {  		Name = foldText  	});  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	if (name != null)  		hashCode += 1000000007 * name.GetHashCode ();  	hashCode += 1000000009 * fontWeight.GetHashCode ();  	hashCode += 1000000021 * fontStyle.GetHashCode ();  	if (foreground != null)  		hashCode += 1000000033 * foreground.GetHashCode ();  	if (background != null)  		hashCode += 1000000087 * background.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	if (name != null)  		hashCode += 1000000007 * name.GetHashCode ();  	hashCode += 1000000009 * fontWeight.GetHashCode ();  	hashCode += 1000000021 * fontStyle.GetHashCode ();  	if (foreground != null)  		hashCode += 1000000033 * foreground.GetHashCode ();  	if (background != null)  		hashCode += 1000000087 * background.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	if (name != null)  		hashCode += 1000000007 * name.GetHashCode ();  	hashCode += 1000000009 * fontWeight.GetHashCode ();  	hashCode += 1000000021 * fontStyle.GetHashCode ();  	if (foreground != null)  		hashCode += 1000000033 * foreground.GetHashCode ();  	if (background != null)  		hashCode += 1000000087 * background.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	if (name != null)  		hashCode += 1000000007 * name.GetHashCode ();  	hashCode += 1000000009 * fontWeight.GetHashCode ();  	hashCode += 1000000021 * fontStyle.GetHashCode ();  	if (foreground != null)  		hashCode += 1000000033 * foreground.GetHashCode ();  	if (background != null)  		hashCode += 1000000087 * background.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	if (name != null)  		hashCode += 1000000007 * name.GetHashCode ();  	hashCode += 1000000009 * fontWeight.GetHashCode ();  	hashCode += 1000000021 * fontStyle.GetHashCode ();  	if (foreground != null)  		hashCode += 1000000033 * foreground.GetHashCode ();  	if (background != null)  		hashCode += 1000000087 * background.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: if (name != null)  	hashCode += 1000000007 * name.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000007 * name.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000009 * fontWeight.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000021 * fontStyle.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: if (foreground != null)  	hashCode += 1000000033 * foreground.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000033 * foreground.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: if (background != null)  	hashCode += 1000000087 * background.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000087 * background.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HtmlOptions,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlOptions.cs,HtmlOptions,The following statement contains a magic number: this.TabSize = 4;  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) {  	offset = 2;  	a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) {  	offset = 2;  	a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) {  	offset = 2;  	a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: offset = 2;  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddRectangle,The following statement contains a magic number: if (AlignToWholePixels) {  	double halfBorder = 0.5 * BorderThickness;  	AddRectangle (PixelSnapHelpers.Round (r.Left - halfBorder' pixelSize.Width) + halfBorder' PixelSnapHelpers.Round (r.Top - halfBorder' pixelSize.Height) + halfBorder' PixelSnapHelpers.Round (r.Right + halfBorder' pixelSize.Width) - halfBorder' PixelSnapHelpers.Round (r.Bottom + halfBorder' pixelSize.Height) - halfBorder);  	//Debug.WriteLine(r.ToString() + " -> " + new Rect(lastLeft' lastTop' lastRight-lastLeft' lastBottom-lastTop).ToString());  } else if (alignToMiddleOfPixels) {  	AddRectangle (PixelSnapHelpers.PixelAlign (r.Left' pixelSize.Width)' PixelSnapHelpers.PixelAlign (r.Top' pixelSize.Height)' PixelSnapHelpers.PixelAlign (r.Right' pixelSize.Width)' PixelSnapHelpers.PixelAlign (r.Bottom' pixelSize.Height));  } else {  	AddRectangle (r.Left' r.Top' r.Right' r.Bottom);  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,FormattedTextElement,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,PrepareText,The following statement contains a magic number: return formatter.FormatLine (new SimpleTextSource (text' properties)' 0' 32000' new VisualLineTextParagraphProperties {  	defaultTextRunProperties = properties'  	textWrapping = TextWrapping.NoWrap'  	tabSize = 40  }' null);  
Magic Number,ICSharpCode.AvalonEdit.Rendering,FormattedTextElement,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,PrepareText,The following statement contains a magic number: return formatter.FormatLine (new SimpleTextSource (text' properties)' 0' 32000' new VisualLineTextParagraphProperties {  	defaultTextRunProperties = properties'  	textWrapping = TextWrapping.NoWrap'  	tabSize = 40  }' null);  
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  	availableSize.Width = 32000;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  	availableSize.Width = 32000;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: availableSize.Width = 32000;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The following statement contains a magic number: while (textOffset <= visualLine.VisualLengthWithEndOfLineMarker) {  	TextLine textLine = formatter.FormatLine (textSource' textOffset' availableSize.Width' paragraphProperties' lastLineBreak);  	textLines.Add (textLine);  	textOffset += textLine.Length;  	// exit loop so that we don't do the indentation calculation if there's only a single line  	if (textOffset >= visualLine.VisualLengthWithEndOfLineMarker)  		break;  	if (paragraphProperties.firstLineInParagraph) {  		paragraphProperties.firstLineInParagraph = false;  		TextEditorOptions options = this.Options;  		double indentation = 0;  		if (options.InheritWordWrapIndentation) {  			// determine indentation for next line:  			int indentVisualColumn = GetIndentationVisualColumn (visualLine);  			if (indentVisualColumn > 0 && indentVisualColumn < textOffset) {  				indentation = textLine.GetDistanceFromCharacterHit (new CharacterHit (indentVisualColumn' 0));  			}  		}  		indentation += options.WordWrapIndentation;  		// apply the calculated indentation unless it's more than half of the text editor size:  		if (indentation > 0 && indentation * 2 < availableSize.Width)  			paragraphProperties.indent = indentation;  	}  	lastLineBreak = textLine.GetTextLineBreak ();  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The following statement contains a magic number: if (paragraphProperties.firstLineInParagraph) {  	paragraphProperties.firstLineInParagraph = false;  	TextEditorOptions options = this.Options;  	double indentation = 0;  	if (options.InheritWordWrapIndentation) {  		// determine indentation for next line:  		int indentVisualColumn = GetIndentationVisualColumn (visualLine);  		if (indentVisualColumn > 0 && indentVisualColumn < textOffset) {  			indentation = textLine.GetDistanceFromCharacterHit (new CharacterHit (indentVisualColumn' 0));  		}  	}  	indentation += options.WordWrapIndentation;  	// apply the calculated indentation unless it's more than half of the text editor size:  	if (indentation > 0 && indentation * 2 < availableSize.Width)  		paragraphProperties.indent = indentation;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The following statement contains a magic number: if (indentation > 0 && indentation * 2 < availableSize.Width)  	paragraphProperties.indent = indentation;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: foreach (var line in visibleVisualLines) {  	Brush currentBrush = null;  	int startVC = 0;  	int length = 0;  	foreach (var element in line.Elements) {  		if (currentBrush == null || !currentBrush.Equals (element.BackgroundBrush)) {  			if (currentBrush != null) {  				BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  				builder.AlignToWholePixels = true;  				builder.CornerRadius = 3;  				foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  					builder.AddRectangle (this' rect);  				Geometry geometry = builder.CreateGeometry ();  				if (geometry != null) {  					drawingContext.DrawGeometry (currentBrush' null' geometry);  				}  			}  			startVC = element.VisualColumn;  			length = element.DocumentLength;  			currentBrush = element.BackgroundBrush;  		} else {  			length += element.VisualLength;  		}  	}  	if (currentBrush != null) {  		BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  		builder.AlignToWholePixels = true;  		builder.CornerRadius = 3;  		foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  			builder.AddRectangle (this' rect);  		Geometry geometry = builder.CreateGeometry ();  		if (geometry != null) {  			drawingContext.DrawGeometry (currentBrush' null' geometry);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: foreach (var line in visibleVisualLines) {  	Brush currentBrush = null;  	int startVC = 0;  	int length = 0;  	foreach (var element in line.Elements) {  		if (currentBrush == null || !currentBrush.Equals (element.BackgroundBrush)) {  			if (currentBrush != null) {  				BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  				builder.AlignToWholePixels = true;  				builder.CornerRadius = 3;  				foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  					builder.AddRectangle (this' rect);  				Geometry geometry = builder.CreateGeometry ();  				if (geometry != null) {  					drawingContext.DrawGeometry (currentBrush' null' geometry);  				}  			}  			startVC = element.VisualColumn;  			length = element.DocumentLength;  			currentBrush = element.BackgroundBrush;  		} else {  			length += element.VisualLength;  		}  	}  	if (currentBrush != null) {  		BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  		builder.AlignToWholePixels = true;  		builder.CornerRadius = 3;  		foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  			builder.AddRectangle (this' rect);  		Geometry geometry = builder.CreateGeometry ();  		if (geometry != null) {  			drawingContext.DrawGeometry (currentBrush' null' geometry);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: foreach (var element in line.Elements) {  	if (currentBrush == null || !currentBrush.Equals (element.BackgroundBrush)) {  		if (currentBrush != null) {  			BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  			builder.AlignToWholePixels = true;  			builder.CornerRadius = 3;  			foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  				builder.AddRectangle (this' rect);  			Geometry geometry = builder.CreateGeometry ();  			if (geometry != null) {  				drawingContext.DrawGeometry (currentBrush' null' geometry);  			}  		}  		startVC = element.VisualColumn;  		length = element.DocumentLength;  		currentBrush = element.BackgroundBrush;  	} else {  		length += element.VisualLength;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: if (currentBrush == null || !currentBrush.Equals (element.BackgroundBrush)) {  	if (currentBrush != null) {  		BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  		builder.AlignToWholePixels = true;  		builder.CornerRadius = 3;  		foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  			builder.AddRectangle (this' rect);  		Geometry geometry = builder.CreateGeometry ();  		if (geometry != null) {  			drawingContext.DrawGeometry (currentBrush' null' geometry);  		}  	}  	startVC = element.VisualColumn;  	length = element.DocumentLength;  	currentBrush = element.BackgroundBrush;  } else {  	length += element.VisualLength;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: if (currentBrush != null) {  	BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  	builder.AlignToWholePixels = true;  	builder.CornerRadius = 3;  	foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  		builder.AddRectangle (this' rect);  	Geometry geometry = builder.CreateGeometry ();  	if (geometry != null) {  		drawingContext.DrawGeometry (currentBrush' null' geometry);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: builder.CornerRadius = 3;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: if (currentBrush != null) {  	BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder ();  	builder.AlignToWholePixels = true;  	builder.CornerRadius = 3;  	foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment (this' line' startVC' startVC + length))  		builder.AddRectangle (this' rect);  	Geometry geometry = builder.CreateGeometry ();  	if (geometry != null) {  		drawingContext.DrawGeometry (currentBrush' null' geometry);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: builder.CornerRadius = 3;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  	var textRunProperties = CreateGlobalTextRunProperties ();  	using (var line = formatter.FormatLine (new SimpleTextSource ("x"' textRunProperties)' 0' 32000' new VisualLineTextParagraphProperties {  		defaultTextRunProperties = textRunProperties  	}' null)) {  		wideSpaceWidth = Math.Max (1' line.WidthIncludingTrailingWhitespace);  		defaultBaseline = Math.Max (1' line.Baseline);  		defaultLineHeight = Math.Max (1' line.Height);  	}  } else {  	wideSpaceWidth = FontSize / 2;  	defaultBaseline = FontSize;  	defaultLineHeight = FontSize + 3;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  	var textRunProperties = CreateGlobalTextRunProperties ();  	using (var line = formatter.FormatLine (new SimpleTextSource ("x"' textRunProperties)' 0' 32000' new VisualLineTextParagraphProperties {  		defaultTextRunProperties = textRunProperties  	}' null)) {  		wideSpaceWidth = Math.Max (1' line.WidthIncludingTrailingWhitespace);  		defaultBaseline = Math.Max (1' line.Baseline);  		defaultLineHeight = Math.Max (1' line.Height);  	}  } else {  	wideSpaceWidth = FontSize / 2;  	defaultBaseline = FontSize;  	defaultLineHeight = FontSize + 3;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  	var textRunProperties = CreateGlobalTextRunProperties ();  	using (var line = formatter.FormatLine (new SimpleTextSource ("x"' textRunProperties)' 0' 32000' new VisualLineTextParagraphProperties {  		defaultTextRunProperties = textRunProperties  	}' null)) {  		wideSpaceWidth = Math.Max (1' line.WidthIncludingTrailingWhitespace);  		defaultBaseline = Math.Max (1' line.Baseline);  		defaultLineHeight = Math.Max (1' line.Height);  	}  } else {  	wideSpaceWidth = FontSize / 2;  	defaultBaseline = FontSize;  	defaultLineHeight = FontSize + 3;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: using (var line = formatter.FormatLine (new SimpleTextSource ("x"' textRunProperties)' 0' 32000' new VisualLineTextParagraphProperties {  	defaultTextRunProperties = textRunProperties  }' null)) {  	wideSpaceWidth = Math.Max (1' line.WidthIncludingTrailingWhitespace);  	defaultBaseline = Math.Max (1' line.Baseline);  	defaultLineHeight = Math.Max (1' line.Height);  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: wideSpaceWidth = FontSize / 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: defaultLineHeight = FontSize + 3;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Left < visibleRectangle.Left) {  	if (rectangle.Right > visibleRectangle.Right) {  		newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  	} else {  		newScrollOffset.X = rectangle.Left;  	}  } else if (rectangle.Right > visibleRectangle.Right) {  	newScrollOffset.X = rectangle.Right - scrollViewport.Width;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Right > visibleRectangle.Right) {  	newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  } else {  	newScrollOffset.X = rectangle.Left;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Top < visibleRectangle.Top) {  	if (rectangle.Bottom > visibleRectangle.Bottom) {  		newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  	} else {  		newScrollOffset.Y = rectangle.Top;  	}  } else if (rectangle.Bottom > visibleRectangle.Bottom) {  	newScrollOffset.Y = rectangle.Bottom - scrollViewport.Height;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Bottom > visibleRectangle.Bottom) {  	newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  } else {  	newScrollOffset.Y = rectangle.Top;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  	if (tl == textLine) {  		switch (yPositionMode) {  		case VisualYPosition.LineTop:  			return pos;  		case VisualYPosition.LineMiddle:  			return pos + tl.Height / 2;  		case VisualYPosition.LineBottom:  			return pos + tl.Height;  		case VisualYPosition.TextTop:  			return pos + tl.Baseline - textView.DefaultBaseline;  		case VisualYPosition.TextBottom:  			return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  		case VisualYPosition.TextMiddle:  			return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  		case VisualYPosition.Baseline:  			return pos + tl.Baseline;  		default:  			throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  		}  	} else {  		pos += tl.Height;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  	if (tl == textLine) {  		switch (yPositionMode) {  		case VisualYPosition.LineTop:  			return pos;  		case VisualYPosition.LineMiddle:  			return pos + tl.Height / 2;  		case VisualYPosition.LineBottom:  			return pos + tl.Height;  		case VisualYPosition.TextTop:  			return pos + tl.Baseline - textView.DefaultBaseline;  		case VisualYPosition.TextBottom:  			return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  		case VisualYPosition.TextMiddle:  			return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  		case VisualYPosition.Baseline:  			return pos + tl.Baseline;  		default:  			throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  		}  	} else {  		pos += tl.Height;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: if (tl == textLine) {  	switch (yPositionMode) {  	case VisualYPosition.LineTop:  		return pos;  	case VisualYPosition.LineMiddle:  		return pos + tl.Height / 2;  	case VisualYPosition.LineBottom:  		return pos + tl.Height;  	case VisualYPosition.TextTop:  		return pos + tl.Baseline - textView.DefaultBaseline;  	case VisualYPosition.TextBottom:  		return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  	case VisualYPosition.TextMiddle:  		return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  	case VisualYPosition.Baseline:  		return pos + tl.Baseline;  	default:  		throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  	}  } else {  	pos += tl.Height;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: if (tl == textLine) {  	switch (yPositionMode) {  	case VisualYPosition.LineTop:  		return pos;  	case VisualYPosition.LineMiddle:  		return pos + tl.Height / 2;  	case VisualYPosition.LineBottom:  		return pos + tl.Height;  	case VisualYPosition.TextTop:  		return pos + tl.Baseline - textView.DefaultBaseline;  	case VisualYPosition.TextBottom:  		return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  	case VisualYPosition.TextMiddle:  		return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  	case VisualYPosition.Baseline:  		return pos + tl.Baseline;  	default:  		throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  	}  } else {  	pos += tl.Height;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: switch (yPositionMode) {  case VisualYPosition.LineTop:  	return pos;  case VisualYPosition.LineMiddle:  	return pos + tl.Height / 2;  case VisualYPosition.LineBottom:  	return pos + tl.Height;  case VisualYPosition.TextTop:  	return pos + tl.Baseline - textView.DefaultBaseline;  case VisualYPosition.TextBottom:  	return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  case VisualYPosition.TextMiddle:  	return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  case VisualYPosition.Baseline:  	return pos + tl.Baseline;  default:  	throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: switch (yPositionMode) {  case VisualYPosition.LineTop:  	return pos;  case VisualYPosition.LineMiddle:  	return pos + tl.Height / 2;  case VisualYPosition.LineBottom:  	return pos + tl.Height;  case VisualYPosition.TextTop:  	return pos + tl.Baseline - textView.DefaultBaseline;  case VisualYPosition.TextBottom:  	return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  case VisualYPosition.TextMiddle:  	return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  case VisualYPosition.Baseline:  	return pos + tl.Baseline;  default:  	throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: return pos + tl.Height / 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,CreateTextRunForNewLine,The following statement contains a magic number: if (lastDocumentLine.DelimiterLength == 2) {  	newlineText = "¶";  } else if (lastDocumentLine.DelimiterLength == 1) {  	char newlineChar = Document.GetCharAt (lastDocumentLine.Offset + lastDocumentLine.Length);  	if (newlineChar == '\r')  		newlineText = "\\r";  	else if (newlineChar == '\n')  		newlineText = "\\n";  	else  		newlineText = "?";  }  
Magic Number,ICSharpCode.AvalonEdit.Search,SearchResultBackgroundRenderer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchResultBackgroundRenderer.cs,Draw,The following statement contains a magic number: foreach (SearchResult result in currentResults.FindOverlappingSegments (viewStart' viewEnd - viewStart)) {  	BackgroundGeometryBuilder geoBuilder = new BackgroundGeometryBuilder ();  	geoBuilder.AlignToWholePixels = true;  	geoBuilder.BorderThickness = markerPen != null ? markerPen.Thickness : 0;  	geoBuilder.CornerRadius = 3;  	geoBuilder.AddSegment (textView' result);  	Geometry geometry = geoBuilder.CreateGeometry ();  	if (geometry != null) {  		drawingContext.DrawGeometry (markerBrush' markerPen' geometry);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Search,SearchResultBackgroundRenderer,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchResultBackgroundRenderer.cs,Draw,The following statement contains a magic number: geoBuilder.CornerRadius = 3;  
Magic Number,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,DocumentPrinter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\DocumentPrinter.cs,ConvertTextDocumentToRichText,The following statement contains a magic number: for (int lineNumber = 1; lineNumber <= document.LineCount; lineNumber++) {  	var line = document.GetLineByNumber (lineNumber);  	if (lineNumber > 1)  		texts.Add (line.PreviousLine.DelimiterLength == 2 ? "\r\n" : "\n");  	if (highlighter != null) {  		HighlightedLine highlightedLine = highlighter.HighlightLine (lineNumber);  		texts.Add (highlightedLine.ToRichText ());  	} else {  		texts.Add (document.GetText (line));  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,DocumentPrinter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\DocumentPrinter.cs,ConvertTextDocumentToRichText,The following statement contains a magic number: if (lineNumber > 1)  	texts.Add (line.PreviousLine.DelimiterLength == 2 ? "\r\n" : "\n");  
Magic Number,ICSharpCode.AvalonEdit.Utils,DocumentPrinter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\DocumentPrinter.cs,ConvertTextDocumentToRichText,The following statement contains a magic number: texts.Add (line.PreviousLine.DelimiterLength == 2 ? "\r\n" : "\n");  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsASCIICompatible,The following statement contains a magic number: return bytes.Length == 2 && bytes [0] == 'A' && bytes [1] == 'z';  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,RemoveBOM,The following statement contains a magic number: switch (encoding.CodePage) {  case 65001:  	// UTF-8  	return UTF8NoBOM;  default:  	return encoding;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  	// the autodetection of StreamReader is not capable of detecting the difference  	// between ISO-8859-1 and UTF-8 without BOM.  	int firstByte = stream.ReadByte ();  	int secondByte = stream.ReadByte ();  	switch ((firstByte << 8) | secondByte) {  	case 0x0000:  	// either UTF-32 Big Endian or a binary file; use StreamReader  	case 0xfffe:  	// Unicode BOM (UTF-16 LE or UTF-32 LE)  	case 0xfeff:  	// UTF-16 BE BOM  	case 0xefbb:  		// start of UTF-8 BOM  		// StreamReader autodetection works  		stream.Position = 0;  		return new StreamReader (stream);  	default:  		return AutoDetect (stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  	}  } else {  	if (defaultEncoding != null) {  		return new StreamReader (stream' defaultEncoding);  	} else {  		return new StreamReader (stream);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  	// the autodetection of StreamReader is not capable of detecting the difference  	// between ISO-8859-1 and UTF-8 without BOM.  	int firstByte = stream.ReadByte ();  	int secondByte = stream.ReadByte ();  	switch ((firstByte << 8) | secondByte) {  	case 0x0000:  	// either UTF-32 Big Endian or a binary file; use StreamReader  	case 0xfffe:  	// Unicode BOM (UTF-16 LE or UTF-32 LE)  	case 0xfeff:  	// UTF-16 BE BOM  	case 0xefbb:  		// start of UTF-8 BOM  		// StreamReader autodetection works  		stream.Position = 0;  		return new StreamReader (stream);  	default:  		return AutoDetect (stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  	}  } else {  	if (defaultEncoding != null) {  		return new StreamReader (stream' defaultEncoding);  	} else {  		return new StreamReader (stream);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: switch ((firstByte << 8) | secondByte) {  case 0x0000:  // either UTF-32 Big Endian or a binary file; use StreamReader  case 0xfffe:  // Unicode BOM (UTF-16 LE or UTF-32 LE)  case 0xfeff:  // UTF-16 BE BOM  case 0xefbb:  	// start of UTF-8 BOM  	// StreamReader autodetection works  	stream.Position = 0;  	return new StreamReader (stream);  default:  	return AutoDetect (stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	if (i == 0) {  		b = firstByte;  	} else if (i == 1) {  		b = secondByte;  	} else {  		b = (byte)fs.ReadByte ();  	}  	if (b < 0x80) {  		// normal ASCII character  		if (state == UTF8Sequence) {  			state = Error;  			break;  		}  	} else if (b < 0xc0) {  		// 10xxxxxx : continues UTF8 byte sequence  		if (state == UTF8Sequence) {  			--sequenceLength;  			if (sequenceLength < 0) {  				state = Error;  				break;  			} else if (sequenceLength == 0) {  				state = UTF8;  			}  		} else {  			state = Error;  			break;  		}  	} else if (b >= 0xc2 && b < 0xf5) {  		// beginning of byte sequence  		if (state == UTF8 || state == ASCII) {  			state = UTF8Sequence;  			if (b < 0xe0) {  				sequenceLength = 1;  				// one more byte following  			} else if (b < 0xf0) {  				sequenceLength = 2;  				// two more bytes following  			} else {  				sequenceLength = 3;  				// three more bytes following  			}  		} else {  			state = Error;  			break;  		}  	} else {  		// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  		state = Error;  		break;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	if (i == 0) {  		b = firstByte;  	} else if (i == 1) {  		b = secondByte;  	} else {  		b = (byte)fs.ReadByte ();  	}  	if (b < 0x80) {  		// normal ASCII character  		if (state == UTF8Sequence) {  			state = Error;  			break;  		}  	} else if (b < 0xc0) {  		// 10xxxxxx : continues UTF8 byte sequence  		if (state == UTF8Sequence) {  			--sequenceLength;  			if (sequenceLength < 0) {  				state = Error;  				break;  			} else if (sequenceLength == 0) {  				state = UTF8;  			}  		} else {  			state = Error;  			break;  		}  	} else if (b >= 0xc2 && b < 0xf5) {  		// beginning of byte sequence  		if (state == UTF8 || state == ASCII) {  			state = UTF8Sequence;  			if (b < 0xe0) {  				sequenceLength = 1;  				// one more byte following  			} else if (b < 0xf0) {  				sequenceLength = 2;  				// two more bytes following  			} else {  				sequenceLength = 3;  				// three more bytes following  			}  		} else {  			state = Error;  			break;  		}  	} else {  		// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  		state = Error;  		break;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0x80) {  	// normal ASCII character  	if (state == UTF8Sequence) {  		state = Error;  		break;  	}  } else if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0x80) {  	// normal ASCII character  	if (state == UTF8Sequence) {  		state = Error;  		break;  	}  } else if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (state == UTF8 || state == ASCII) {  	state = UTF8Sequence;  	if (b < 0xe0) {  		sequenceLength = 1;  		// one more byte following  	} else if (b < 0xf0) {  		sequenceLength = 2;  		// two more bytes following  	} else {  		sequenceLength = 3;  		// three more bytes following  	}  } else {  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (state == UTF8 || state == ASCII) {  	state = UTF8Sequence;  	if (b < 0xe0) {  		sequenceLength = 1;  		// one more byte following  	} else if (b < 0xf0) {  		sequenceLength = 2;  		// two more bytes following  	} else {  		sequenceLength = 3;  		// three more bytes following  	}  } else {  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xe0) {  	sequenceLength = 1;  	// one more byte following  } else if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xe0) {  	sequenceLength = 1;  	// one more byte following  } else if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: sequenceLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: sequenceLength = 3;  
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,CreateNodes,The following statement contains a magic number: if (leafCount == 1) {  	result.contents = new T[NodeSize];  } else {  	int rightSide = leafCount / 2;  	int leftSide = leafCount - rightSide;  	int leftLength = leftSide * NodeSize;  	result.left = CreateNodes (leftSide' leftLength);  	result.right = CreateNodes (rightSide' totalLength - leftLength);  	result.height = (byte)(1 + Math.Max (result.left.height' result.right.height));  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,FunctionNode,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round ((value / pixelSize) + 0.5' MidpointRounding.AwayFromZero) - 0.5);  
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round ((value / pixelSize) + 0.5' MidpointRounding.AwayFromZero) - 0.5);  
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,RoundToOdd,The following statement contains a magic number: return Round (value - pixelSize' pixelSize * 2) + pixelSize;  
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,HandleKey,The following switch statement is missing a default case: switch (e.Key) {  case Key.Down:  	e.Handled = true;  	listBox.SelectIndex (listBox.SelectedIndex + 1);  	break;  case Key.Up:  	e.Handled = true;  	listBox.SelectIndex (listBox.SelectedIndex - 1);  	break;  case Key.PageDown:  	e.Handled = true;  	listBox.SelectIndex (listBox.SelectedIndex + listBox.VisibleItemCount);  	break;  case Key.PageUp:  	e.Handled = true;  	listBox.SelectIndex (listBox.SelectedIndex - listBox.VisibleItemCount);  	break;  case Key.Home:  	e.Handled = true;  	listBox.SelectIndex (0);  	break;  case Key.End:  	e.Handled = true;  	listBox.SelectIndex (listBox.Items.Count - 1);  	break;  case Key.Tab:  case Key.Enter:  	e.Handled = true;  	RequestInsertion (e);  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Up:  	e.Handled = true;  	overloadViewer.ChangeIndex (-1);  	break;  case Key.Down:  	e.Handled = true;  	overloadViewer.ChangeIndex (+1);  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The following switch statement is missing a default case: switch (direction) {  case CaretMovementType.None:  	return caretPosition;  case CaretMovementType.DocumentStart:  	desiredXPos = double.NaN;  	return new TextViewPosition (0' 0);  case CaretMovementType.DocumentEnd:  	desiredXPos = double.NaN;  	return new TextViewPosition (textView.Document.GetLocation (textView.Document.TextLength));  }  
Missing Default,ICSharpCode.AvalonEdit.Editing,ImeSupport,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\ImeSupport.cs,WndProc,The following switch statement is missing a default case: switch (msg) {  case ImeNativeWrapper.WM_INPUTLANGCHANGE:  	// Don't mark the message as handled; other windows  	// might want to handle it as well.  	// If we have a context' recreate it  	if (hwndSource != null) {  		ClearContext ();  		CreateContext ();  	}  	break;  case ImeNativeWrapper.WM_IME_COMPOSITION:  	UpdateCompositionWindow ();  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,ExpandToEnclosingUnit,The following switch statement is missing a default case: switch (unit) {  case TextUnit.Character:  	ExpandToEnclosingUnit (CaretPositioningMode.Normal);  	break;  case TextUnit.Format:  case TextUnit.Word:  	ExpandToEnclosingUnit (CaretPositioningMode.WordStartOrSymbol);  	break;  case TextUnit.Line:  case TextUnit.Paragraph:  	segment = doc.GetLineByOffset (segment.Offset);  	break;  case TextUnit.Document:  	segment = new AnchorSegment (doc' 0' doc.TextLength);  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,MoveEndpointByUnit,The following switch statement is missing a default case: switch (unit) {  case TextUnit.Character:  	offset = MoveOffset (offset' CaretPositioningMode.Normal' count);  	break;  case TextUnit.Format:  case TextUnit.Word:  	offset = MoveOffset (offset' CaretPositioningMode.WordStart' count);  	break;  case TextUnit.Line:  case TextUnit.Paragraph:  	int line = doc.GetLineByOffset (offset).LineNumber;  	int newLine = Math.Max (1' Math.Min (doc.LineCount' line + count));  	offset = doc.GetLineByNumber (newLine).Offset;  	break;  case TextUnit.Document:  	offset = count < 0 ? 0 : doc.TextLength;  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateNewFoldings,The following switch statement is missing a default case: switch (reader.NodeType) {  case XmlNodeType.Element:  	if (!reader.IsEmptyElement) {  		XmlFoldStart newFoldStart = CreateElementFoldStart (document' reader);  		stack.Push (newFoldStart);  	}  	break;  case XmlNodeType.EndElement:  	XmlFoldStart foldStart = stack.Pop ();  	CreateElementFold (document' foldMarkers' reader' foldStart);  	break;  case XmlNodeType.Comment:  	CreateCommentFold (document' foldMarkers' reader);  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  case '/':  	if (blockComment && lastchar == '*')  		blockComment = false;  	if (!inString && !inChar) {  		if (!blockComment && nextchar == '/')  			lineComment = true;  		if (!lineComment && nextchar == '*')  			blockComment = true;  	}  	break;  case '#':  	if (!(inChar || blockComment || inString))  		lineComment = true;  	break;  case '"':  	if (!(inChar || lineComment || blockComment)) {  		inString = !inString;  		if (!inString && verbatim) {  			if (nextchar == '"') {  				escape = true;  				// skip escaped quote  				inString = true;  			} else {  				verbatim = false;  			}  		} else if (inString && lastchar == '@') {  			verbatim = true;  		}  	}  	break;  case '\'':  	if (!(inString || lineComment || blockComment)) {  		inChar = !inChar;  	}  	break;  case '\\':  	if ((inString && !verbatim) || inChar)  		escape = true;  	// skip next character  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  case '{':  	block.ResetOneLineBlock ();  	blocks.Push (block);  	block.StartLine = doc.LineNumber;  	if (block.LastWord == "switch") {  		block.Indent (set.IndentString + set.IndentString);  		/* oldBlock refers to the previous line' not the previous block 							 * The block we want is not available anymore because it was never pushed. 							 * } else if (oldBlock.OneLineBlock) { 							// Inside a one-line-block is another statement 							// with a full block: indent the inner full block 							// by one additional level 							block.Indent(set' set.IndentString + set.IndentString); 							block.OuterIndent += set.IndentString; 							// Indent current line if it starts with the '{' character 							if (i == 0) { 								oldBlock.InnerIndent += set.IndentString; 							}*/} else {  		block.Indent (set);  	}  	block.Bracket = '{';  	break;  case '}':  	while (block.Bracket != '{') {  		if (blocks.Count == 0)  			break;  		block = blocks.Pop ();  	}  	if (blocks.Count == 0)  		break;  	block = blocks.Pop ();  	block.Continuation = false;  	block.ResetOneLineBlock ();  	break;  case '(':  case '[':  	blocks.Push (block);  	if (block.StartLine == doc.LineNumber)  		block.InnerIndent = block.OuterIndent;  	else  		block.StartLine = doc.LineNumber;  	block.Indent (Repeat (set.IndentString' oldBlock.OneLineBlock) + (oldBlock.Continuation ? set.IndentString : "") + (i == line.Length - 1 ? set.IndentString : new String (' '' i + 1)));  	block.Bracket = c;  	break;  case ')':  	if (blocks.Count == 0)  		break;  	if (block.Bracket == '(') {  		block = blocks.Pop ();  		if (IsSingleStatementKeyword (block.LastWord))  			block.Continuation = false;  	}  	break;  case ']':  	if (blocks.Count == 0)  		break;  	if (block.Bracket == '[')  		block = blocks.Pop ();  	break;  case ';':  case ''':  	block.Continuation = false;  	block.ResetOneLineBlock ();  	break;  case ':':  	if (block.LastWord == "case" || line.StartsWith ("case "' StringComparison.Ordinal) || line.StartsWith (block.LastWord + ":"' StringComparison.Ordinal)) {  		block.Continuation = false;  		block.ResetOneLineBlock ();  	}  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Rendering,TextView,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,The following switch statement is missing a default case: switch (position) {  case LayerInsertionPosition.Below:  	layers.Insert (i' layer);  	return;  case LayerInsertionPosition.Above:  	layers.Insert (i + 1' layer);  	return;  case LayerInsertionPosition.Replace:  	layers [i] = layer;  	return;  }  
Missing Default,ICSharpCode.AvalonEdit.Search,SearchPanel,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchPanel.cs,SearchLayerKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Enter:  	e.Handled = true;  	if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift)  		FindPrevious ();  	else  		FindNext ();  	if (searchTextBox != null) {  		var error = Validation.GetErrors (searchTextBox).FirstOrDefault ();  		if (error != null) {  			messageView.Content = Localization.ErrorText + " " + error.ErrorContent;  			messageView.PlacementTarget = searchTextBox;  			messageView.IsOpen = true;  		}  	}  	break;  case Key.Escape:  	e.Handled = true;  	Close ();  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Search,SearchStrategyFactory,F:\newReposMay17\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchStrategyFactory.cs,Create,The following switch statement is missing a default case: switch (mode) {  case SearchMode.Normal:  	searchPattern = Regex.Escape (searchPattern);  	break;  case SearchMode.Wildcard:  	searchPattern = ConvertWildcardsToRegex (searchPattern);  	break;  }  
