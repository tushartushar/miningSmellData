Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The method has 281 lines of code.
Complex Method,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FindOverlappingSegments,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateAugmentedData,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,HandleTextChange,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,DoReplace,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingManager,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingManager.cs,UpdateFoldings,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,CalculateFoldLinesForFoldingsActiveAtStart,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,MergeWith,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,WriteTo,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,HighlightLineInternal,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,HighlightNonSpans,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,CreateHtmlFragment,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRuleSet,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRegex,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,Cyclomatic complexity of the method is 36
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,GetRectsForSegmentImpl,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Rendering,ColorizingTransformer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\ColorizingTransformer.cs,ChangeVisualElements,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,MergeCollapsedSectionsIfPossible,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AddRemoveCollapsedSection,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ArrangeOverride,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetTextRun,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,FindNodeUsingCache,Cyclomatic complexity of the method is 9
Long Parameter List,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The method has 5 parameters. Parameters: offset' removalLength' insertionLength' removalNeverCausesAnchorDeletion' defaultAnchorMovementIsBeforeInsertion
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The method has 5 parameters. Parameters: textView' caretPosition' direction' enableVirtualSpace' desiredXPos
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNextCaretPosition,The method has 5 parameters. Parameters: textView' caretPosition' visualLine' mode' enableVirtualSpace
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetPrevCaretPosition,The method has 5 parameters. Parameters: textView' caretPosition' visualLine' mode' enableVirtualSpace
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetUpDownCaretPosition,The method has 7 parameters. Parameters: textView' caretPosition' direction' visualLine' textLine' enableVirtualSpace' xPos
Long Parameter List,ICSharpCode.AvalonEdit.Editing,ImeSupport,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\ImeSupport.cs,WndProc,The method has 5 parameters. Parameters: hWnd' msg' wParam' lParam' handled
Long Parameter List,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,Insert,The method has 5 parameters. Parameters: pos' newSectionStart' insertionEndPos' color' insertionStack
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The method has 6 parameters. Parameters: documentLine' globalTextRunProperties' paragraphProperties' elementGeneratorsArray' lineTransformersArray' availableSize
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CharRope,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CharRope.cs,IndexOf,The method has 5 parameters. Parameters: rope' searchText' startIndex' length' comparisonType
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CharRope,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CharRope.cs,LastIndexOf,The method has 5 parameters. Parameters: rope' searchText' startIndex' length' comparisonType
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The method has 5 parameters. Parameters: element' text' typeface' emSize' foreground
Long Identifier,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,,The length of the parameter HorizontalScrollBarVisibilityProperty is 37.
Long Identifier,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,,The length of the parameter VerticalScrollBarVisibilityProperty is 35.
Long Identifier,ICSharpCode.AvalonEdit,TextEditorOptions,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditorOptions.cs,,The length of the parameter requireControlModifierForHyperlinkClick is 39.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter removalNeverCausesAnchorDeletion is 32.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,,The length of the parameter insertionLengthWithMovementFlag is 31.
Long Identifier,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,InsertText,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,PerformInsertText,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,UndoStack,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\UndoStack.cs,,The length of the parameter elementsOnUndoUntilOriginalFile is 31.
Long Identifier,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,,The length of the parameter raisePositionChangedOnUpdateFinished is 36.
Long Identifier,ICSharpCode.AvalonEdit.Editing,ImeNativeWrapper,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\ImeNativeWrapper.cs,,The length of the parameter textFrameworkThreadMgrInitialized is 33.
Long Identifier,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,,The length of the parameter FoldingMarkerBackgroundBrushProperty is 36.
Long Identifier,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,,The length of the parameter SelectedFoldingMarkerBrushProperty is 34.
Long Identifier,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,,The length of the parameter SelectedFoldingMarkerBackgroundBrushProperty is 44.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,Colorize,The length of the parameter currentDocumentLineTotalEndOffset is 33.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,,The length of the parameter currentDocumentLineStartOffset is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,Redraw,The length of the parameter changedSomethingBeforeOrInLine is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter singleCharacterElementGenerator is 31.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter visualLinesWithOutstandingInlineObjects is 39.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter NonPrintableCharacterBrushProperty is 34.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter LinkTextForegroundBrushProperty is 31.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter LinkTextBackgroundBrushProperty is 31.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter AdditionalHorizontalScrollAmount is 32.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the parameter relativeSplitRelativeTextOffset is 31.
Long Identifier,ICSharpCode.AvalonEdit.Search,DropDownButton,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\DropDownButton.cs,,The length of the parameter IsDropDownContentOpenPropertyKey is 32.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,OnLineNumbersForegroundChanged,The length of the statement  "			var lineNumberMargin = editor.TextArea.LeftMargins.FirstOrDefault(margin => margin is LineNumberMargin) as LineNumberMargin;; " is 125.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,Load,The length of the statement  "				SetCurrentValue(EncodingProperty' reader.CurrentEncoding); // assign encoding after ReadToEnd() so that the StreamReader can autodetect the encoding " is 148.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The length of the statement  "				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle); " is 123.
Long Statement,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,Equals,The length of the statement  "			return this.Line == other.Line && this.Column == other.Column && this.VisualColumn == other.VisualColumn && this.IsAtEndOfLine == other.IsAtEndOfLine; " is 150.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindowBase,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindowBase.cs,TextViewScrollOffsetChanged,The length of the statement  "			Rect visibleRect = new Rect(scrollInfo.HorizontalOffset' scrollInfo.VerticalOffset' scrollInfo.ViewportWidth' scrollInfo.ViewportHeight); " is 137.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,OnMouseDoubleClick,The length of the statement  "				if (ExtensionMethods.VisualAncestorsAndSelf(e.OriginalSource as DependencyObject).TakeWhile(obj => obj != this).Any(obj => obj is ListBoxItem)) { " is 145.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "			var listToFilter = (this.currentList != null && (!string.IsNullOrEmpty(this.currentText)) && (!string.IsNullOrEmpty(query)) && " is 126.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "			ICompletionData suggestedItem = listBox.SelectedIndex != -1 ? (ICompletionData)(listBox.Items[listBox.SelectedIndex]) : null; " is 125.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,completionList_InsertionRequested,The length of the statement  "				item.Complete(this.TextArea' new AnchorSegment(this.TextArea.Document' this.StartOffset' this.EndOffset - this.StartOffset)' e); " is 128.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The length of the statement  "			Rect workingArea = System.Windows.Forms.Screen.FromPoint(pointOnScreen.ToSystemDrawing()).WorkingArea.ToWpf().TransformFromDevice(this); " is 136.
Long Statement,ICSharpCode.AvalonEdit.Document,SimpleSegment,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\SimpleSegment.cs,ToString,The length of the statement  "			return "[Offset=" + Offset.ToString(CultureInfo.InvariantCulture) + "' Length=" + Length.ToString(CultureInfo.InvariantCulture) + "]"; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Document,AnchorSegment,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\SimpleSegment.cs,ToString,The length of the statement  "			return "[Offset=" + Offset.ToString(CultureInfo.InvariantCulture) + "' EndOffset=" + EndOffset.ToString(CultureInfo.InvariantCulture) + "]"; " is 140.
Long Statement,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,Equals,The length of the statement  "			return offset == other.offset && insertionLengthWithMovementFlag == other.insertionLengthWithMovementFlag && removalLengthWithDeletionFlag == other.removalLengthWithDeletionFlag; " is 178.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "				throw new InvalidOperationException("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "				throw new InvalidOperationException("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsetsInternal,The length of the statement  "			// Special case pure insertions' because they don't always cause a text segment to increase in size when the replaced region " is 124.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - count)); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - LineCount)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "				throw new ArgumentOutOfRangeException("offset"' offset' "0 <= offset <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' length' "0 <= length' offset(" + offset + ")+length <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 159.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The length of the statement  "						OffsetChangeMapEntry entry = new OffsetChangeMapEntry(offset + text.TextLength' length - text.TextLength' 0' true' false); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,CreateAnchor,The length of the statement  "				throw new ArgumentOutOfRangeException("offset"' offset' "0 <= offset <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "			int newVisualColumnForwards = visualLine.GetNextCaretPosition(position.VisualColumn - 1' LogicalDirection.Forward' CaretPositioningMode.Normal' textArea.Selection.EnableVirtualSpace); " is 183.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "				int newVisualColumnBackwards = visualLine.GetNextCaretPosition(position.VisualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.Normal' textArea.Selection.EnableVirtualSpace); " is 185.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,ShowInternal,The length of the statement  "					Rect caretRect = this.textArea.OverstrikeMode ? CalcCaretOverstrikeRectangle(visualLine) : CalcCaretRectangle(visualLine); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaret,The length of the statement  "			textArea.Caret.Position = GetNewCaretPosition(textArea.TextView' textArea.Caret.Position' direction' textArea.Selection.EnableVirtualSpace' ref desiredXPos); " is 157.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The length of the statement  "					return GetPrevCaretPosition(textView' caretPosition' visualLine' CaretPositioningMode.EveryCodepoint' enableVirtualSpace); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The length of the statement  "					return GetUpDownCaretPosition(textView' caretPosition' direction' visualLine' textLine' enableVirtualSpace' ref desiredXPos); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetStartOfLineCaretPosition,The length of the statement  "				newVC = visualLine.GetNextCaretPosition(newVC - 1' LogicalDirection.Forward' CaretPositioningMode.WordStart' enableVirtualSpace); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNextCaretPosition,The length of the statement  "			int pos = visualLine.GetNextCaretPosition(caretPosition.VisualColumn' LogicalDirection.Forward' mode' enableVirtualSpace); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNextCaretPosition,The length of the statement  "					Debug.Assert(visualLine.LastDocumentLine.Offset + visualLine.LastDocumentLine.TotalLength == textView.Document.TextLength); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetPrevCaretPosition,The length of the statement  "			int pos = visualLine.GetNextCaretPosition(caretPosition.VisualColumn' LogicalDirection.Backward' mode' enableVirtualSpace); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetPrevCaretPosition,The length of the statement  "					pos = previousLine.GetNextCaretPosition(previousLine.VisualLength + 1' LogicalDirection.Backward' mode' enableVirtualSpace); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnTab,The length of the statement  "								textArea.Document.Replace(offset' 0' textArea.Options.IndentationString' OffsetChangeMappingType.KeepAnchorBeforeInsertion); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnCut,The length of the statement  "						ISegment[] segmentsToDelete = textArea.GetDeletableSegments(new SimpleSegment(currentLine.Offset' currentLine.TotalLength)); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,CopyWholeLine,The length of the statement  "				HtmlClipboard.SetHtml(data' HtmlClipboard.CreateHtmlFragment(textArea.Document' highlighter' wholeLine' new HtmlOptions(textArea.Options))); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,GetTextToPaste,The length of the statement  "				else if (pastingEventArgs.FormatToApply != DataFormats.UnicodeText && dataObject.GetDataPresent(DataFormats.UnicodeText)) " is 121.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,GetTextToPaste,The length of the statement  "				text = textArea.Options.ConvertTabsToSpaces ? text.Replace("\t"' new String(' '' textArea.Options.IndentationSize)) : text; " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionSegment,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionSegment.cs,ToString,The length of the statement  "			return string.Format("[SelectionSegment StartOffset={0}' EndOffset={1}' StartVC={2}' EndVC={3}]"' startOffset' endOffset' startVC' endVC); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextAreaAutomationPeer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextAreaAutomationPeer.cs,GetSelection,The length of the statement  "				return new ITextRangeProvider[] { new TextRangeProvider(TextArea' TextArea.Document' new AnchorSegment(anchor' anchor))}; " is 121.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "			TextLocation newStartLocation = textArea.Document.GetLocation(e.GetNewOffset(topLeftOffset' AnchorMovementType.AfterInsertion)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "			TextLocation newEndLocation = textArea.Document.GetLocation(e.GetNewOffset(bottomRightOffset' AnchorMovementType.BeforeInsertion)); " is 131.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "				TextViewPosition start = new TextViewPosition(document.GetLocation(topLeftOffset)' GetVisualColumnFromXPos(startLine' startXPos)); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "				TextViewPosition end = new TextViewPosition(document.GetLocation(bottomRightOffset)' GetVisualColumnFromXPos(endLine' endXPos)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "				textArea.Caret.Position = textArea.TextView.GetPosition(new Point(GetXPos(textArea' pos)' textArea.TextView.GetVisualTopByDocumentLine(Math.Max(startLine' endLine)))).GetValueOrDefault(); " is 187.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "					newText = AddSpacesIfRequired(newText' new TextViewPosition(document.GetLocation(lineSegment.StartOffset)' lineSegment.StartVisualColumn)' new TextViewPosition(document.GetLocation(lineSegment.EndOffset)' lineSegment.EndVisualColumn)); " is 235.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "						if (segmentsToDelete[i].Offset == SurroundingSegment.Offset && segmentsToDelete[i].Length == SurroundingSegment.Length) { " is 121.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "							newText = AddSpacesIfRequired(newText' new TextViewPosition(document.GetLocation(lineSegment.StartOffset)' lineSegment.StartVisualColumn)' new TextViewPosition(document.GetLocation(lineSegment.EndOffset)' lineSegment.EndVisualColumn)); " is 235.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,PerformRectangularPaste,The length of the statement  "			int newLineCount = text.Count(c => c == '\n'); // TODO might not work in all cases' but single \r line endings are really rare today. " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,PerformRectangularPaste,The length of the statement  "					RectangleSelection rsel = new RectangleSelection(textArea' startPosition' endLocation.Line' GetXPos(textArea' startPosition)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ToString,The length of the statement  "			return string.Format("[RectangleSelection {0} {1} {2} to {3} {4} {5}]"' startLine' topLeftOffset' startXPos' endLine' bottomRightOffset' endXPos); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,Create,The length of the statement  "			if (textArea.Document.GetOffset(start.Location) == textArea.Document.GetOffset(end.Location) && start.VisualColumn == end.VisualColumn) " is 135.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,IsInVirtualSpace,The length of the statement  "			return pos.VisualColumn > textArea.TextView.GetOrConstructVisualLine(textArea.Document.GetLineByNumber(pos.Line)).VisualLength; " is 127.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionColorizer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionColorizer.cs,Colorize,The length of the statement  "					startColumn = context.VisualLine.ValidateVisualColumn(segment.StartOffset' segment.StartVisualColumn' textArea.Selection.EnableVirtualSpace); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionColorizer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionColorizer.cs,Colorize,The length of the statement  "					endColumn = context.VisualLine.ValidateVisualColumn(segment.EndOffset' segment.EndVisualColumn' textArea.Selection.EnableVirtualSpace); " is 135.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetEffect,The length of the statement  "					textArea.Caret.Position = new TextViewPosition(textArea.Document.GetLocation(offset)' visualColumn) { IsAtEndOfLine = isAtEndOfLine }; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,StartDrag,The length of the statement  "			if (deleteOnMove != null && resultEffect == DragDropEffects.Move && (allowedEffects & DragDropEffects.Move) == DragDropEffects.Move) { " is 134.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The length of the statement  "								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.Offset))); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The length of the statement  "								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.EndOffset))); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "				int wordStartVC = line.GetNextCaretPosition(visualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.WordStartOrSymbol' textArea.Selection.EnableVirtualSpace); " is 168.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "				int wordEndVC = line.GetNextCaretPosition(wordStartVC' LogicalDirection.Forward' CaretPositioningMode.WordBorderOrSymbol' textArea.Selection.EnableVirtualSpace); " is 161.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The length of the statement  "			if (mode == MouseSelectionMode.Normal || mode == MouseSelectionMode.WholeWord || mode == MouseSelectionMode.WholeLine || mode == MouseSelectionMode.Rectangular) { " is 162.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,SetCaretOffsetToMousePosition,The length of the statement  "				textArea.Caret.Position = new TextViewPosition(textArea.Document.GetLocation(offset)' visualColumn) { IsAtEndOfLine = isAtEndOfLine }; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The length of the statement  "			} else if (mode == MouseSelectionMode.Normal || mode == MouseSelectionMode.WholeWord || mode == MouseSelectionMode.WholeLine || mode == MouseSelectionMode.Rectangular) { " is 169.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,ReplaceSelectionWithText,The length of the statement  "						if (segmentsToDelete[i].Offset == SurroundingSegment.Offset && segmentsToDelete[i].Length == SurroundingSegment.Length) { " is 121.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnTextInput,The length of the statement  "			//Debug.WriteLine("TextInput: Text='" + e.Text + "' SystemText='" + e.SystemText + "' ControlText='" + e.ControlText + "'"); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "					throw new InvalidOperationException("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "				throw new InvalidOperationException("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,AttachTypingEvents,The length of the statement  "			// Use the PreviewMouseMove event in case some other editor layer consumes the MouseMove event (e.g. SD's InsertionCursorLayer) " is 127.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2)); " is 147.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "				drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' RenderSize.Height)); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingSection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingSection.cs,ValidateCollapsedLineSections,The length of the statement  "							Debug.WriteLine("CollapsedLineSection validation - recreate collapsed section from " + startLinePlusOne + " to " + endLine); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateElementFoldStart,The length of the statement  "			//XmlFoldStart newFoldStart = new XmlFoldStart(reader.Prefix' reader.LocalName' reader.LineNumber - 1' reader.LinePosition - 2); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,UpdateTreeList,The length of the statement  "				//Debug.WriteLine("Span stack in line " + lineNumber + " changed from " + storedSpanStacks[lineNumber] + " to " + spanStack); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedInlineBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedInlineBuilder.cs,SetHighlighting,The length of the statement  "			if (color.Foreground == null && color.Background == null && color.FontStyle == null && color.FontWeight == null && color.Underline == null) { " is 141.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,WriteTo,The length of the statement  "				throw new ArgumentOutOfRangeException("startOffset"' startOffset' "Value must be between " + documentLineStartOffset + " and " + documentLineEndOffset); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,WriteTo,The length of the statement  "				throw new ArgumentOutOfRangeException("endOffset"' endOffset' "Value must be between startOffset and " + documentLineEndOffset); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,CreateHighlighter,The length of the statement  "				throw new NotSupportedException("Cannot create a highlighter because no IHighlightingDefinition was specified' and the CreateHighlighter() method was not overridden."); " is 168.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnAddToTextView,The length of the statement  "				throw new InvalidOperationException("Cannot use a HighlightingColorizer instance in multiple text views. Please create a separate instance for each text view."); " is 161.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,textView_VisualLineConstructionStarting,The length of the statement  "				// This is necessary in case the document gets modified above the FirstLineInView so that the highlighting state changes. " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnHighlightStateChanged,The length of the statement  "			Debug.WriteLine(string.Format("OnHighlightStateChanged forces redraw of lines {0} to {1}"' fromLineNumber' toLineNumber)); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnHighlightStateChanged,The length of the statement  "			 * But doing it too early means it doesn't have the information necessary to re-highlight and redraw only the desired parts. " is 123.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DelayLoadedHighlightingDefinition,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingManager.cs,GetDefinition,The length of the statement  "							throw new InvalidOperationException("Tried to create delay-loaded highlighting definition recursively. Make sure the are no cyclic references between the highlighting definitions."); " is 182.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DefaultHighlightingManager,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingManager.cs,RegisterHighlighting,The length of the statement  "//						new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter().Serialize(fs' Xshd.HighlightingLoader.Load(xshd' this)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,SetHtml,The length of the statement  "			string htmlEnd = "<!--EndFragment-->" + Environment.NewLine + "</BODY>" + Environment.NewLine + "</HTML>" + Environment.NewLine; " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteRuleSetReference,The length of the statement  "					writer.WriteAttributeString("ruleSet"' ruleSetReference.ReferencedDefinition + "/" + ruleSetReference.ReferencedElement); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "				writer.WriteAttributeString("fontWeight"' V2Loader.FontWeightConverter.ConvertToInvariantString(color.FontWeight.Value).ToLowerInvariant()); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "				writer.WriteAttributeString("fontStyle"' V2Loader.FontStyleConverter.ConvertToInvariantString(color.FontStyle.Value).ToLowerInvariant()); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The length of the statement  "			if (!element.HasAttribute("bold") && !element.HasAttribute("italic") && !element.HasAttribute("color") && !element.HasAttribute("bgcolor")) " is 139.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,Error,The length of the statement  "				return new HighlightingDefinitionInvalidException(HighlightingLoader.FormatExceptionMessage(message' lineInfo.LineNumber' lineInfo.LinePosition)); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,TranslateElementVisitor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\XmlHighlightingDefinition.cs,GetDefinition,The length of the statement  "					throw Error(position' "Resolving references to other syntax definitions is not possible because the IHighlightingDefinitionReferenceResolver is null."); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "				if (block.LastWord == "case" || line.StartsWith("case "' StringComparison.Ordinal) || line.StartsWith(block.LastWord + ":"' StringComparison.Ordinal)) " is 150.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddRectangle,The length of the statement  "				//Debug.WriteLine(r.ToString() + " -> " + new Rect(lastLeft' lastTop' lastRight-lastLeft' lastBottom-lastTop).ToString()); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					// The following special cases are necessary to get rid of empty rectangles at the end of a TextLine if "Show Spaces" is active. " is 128.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					// If not excluded once' the same rectangle is calculated (and added) twice (since the offset could be mapped to two visual positions; end/start of line)' if there is no trailing whitespace. " is 190.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					// Skip this TextLine segment' if it is at the end of this line and this line is not the last line of the VisualLine and the selection continues and there is no trailing whitespace. " is 181.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					if (segmentEndVCInLine == visualEndCol && i < visualLine.TextLines.Count - 1 && segmentEndVC > segmentEndVCInLine && line.TrailingWhitespaceLength == 0) " is 152.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					if (segmentStartVCInLine == visualStartCol && i > 0 && segmentStartVC < segmentStartVCInLine && visualLine.TextLines[i - 1].TrailingWhitespaceLength == 0) " is 154.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "				// Also' when word-wrap is enabled and the segment continues into the next line' extend lastRect up to the end of the line. " is 123.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "				throw new ArgumentOutOfRangeException("startOffset"' startOffset' "Value must be between " + currentDocumentLineStartOffset + " and " + currentDocumentLineEndOffset); " is 166.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "				throw new ArgumentOutOfRangeException("endOffset"' endOffset' "Value must be between " + startOffset + " and " + currentDocumentLineEndOffset); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Rendering,MouseHoverLogic,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\MouseHoverLogic.cs,StartHovering,The length of the statement  "			mouseHoverTimer = new DispatcherTimer(SystemParameters.MouseHoverTime' DispatcherPriority.Background' OnMouseHoverTimerElapsed' this.target.Dispatcher); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "				return new SpaceTextElement(CurrentContext.TextView.cachedElements.GetTextForNonPrintableCharacter("\u00B7"' CurrentContext)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "				return new TabTextElement(CurrentContext.TextView.cachedElements.GetTextForNonPrintableCharacter("\u00BB"' CurrentContext)); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "				// Unfortunately the "easy" approach (just use DispatcherPriority.Background) here makes the editor twice as slow because " is 121.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "				// When fixing this' make sure performance on the SharpDevelop "type text in C# comment" stress test doesn't get significantly worse. " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,UpdateBuiltinElementGeneratorsFromOptions,The length of the statement  "			AddRemoveDefaultElementGeneratorOnDemand(ref singleCharacterElementGenerator' options.ShowBoxForControlCharacters || options.ShowSpaces || options.ShowTabs); " is 157.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,EnsureVisualLines,The length of the statement  "				throw new InvalidOperationException("The visual line build process is already running! Cannot EnsureVisualLines() during Measure!"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "					// HACK: we need to keep at least Caret.MinimumDistanceToViewBorder visible so that we don't scroll back up when the user types after " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "					// scrollViewportBottom: bottom of scroll view port' but clamped so that at least minVisibleDocumentHeight of the document stays visible. " is 137.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "					double scrollViewportBottom = Math.Min(heightTreeHeight - minVisibleDocumentHeight' scrollOffset.Y) + scrollViewport.Height; " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "							throw new InvalidOperationException("Line " + i + " was skipped by a VisualLineElementGenerator' but it is not collapsed."); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,ReplaceElement,The length of the statement  "				throw new InvalidOperationException("Old elements have document length " + oldDocumentLength + "' but new elements have length " + newDocumentLength); " is 150.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetVisualColumn,The length of the statement  "					int virtualX = (int)Math.Round((xPos - textLine.WidthIncludingTrailingWhitespace) / textView.WideSpaceWidth' MidpointRounding.AwayFromZero); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "				if (visualColumn > this.VisualLength && !elements[elements.Count-1].HandlesLineBorders && HasImplicitStopAtLineEnd(mode)) { " is 123.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "				throw new ArgumentOutOfRangeException("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 171.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "				throw new ArgumentOutOfRangeException("splitRelativeTextOffset"' splitRelativeTextOffset' "Value must be between " + (RelativeTextOffset) + " and " + (RelativeTextOffset + DocumentLength)); " is 189.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,GetNextCaretPosition,The length of the statement  "				else if (visualColumn < stop2 && mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) " is 122.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,CreateTextRun,The length of the statement  "			StringSegment text = context.GetText(context.VisualLine.FirstDocumentLine.Offset + RelativeTextOffset + relativeOffset' DocumentLength - relativeOffset); " is 153.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetPrecedingText,The length of the statement  "			return new TextSpan<CultureSpecificCharacterBufferRange>(range.Length' new CultureSpecificCharacterBufferRange(this.TextRunProperties.CultureInfo' range)); " is 155.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,Split,The length of the statement  "				throw new ArgumentOutOfRangeException("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 171.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetNextCaretPosition,The length of the statement  "			int pos = TextUtilities.GetNextCaretPosition(parentVisualLine.Document' textOffset + visualColumn - this.VisualColumn' direction' mode); " is 136.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,CreateTextRunForNewLine,The length of the statement  "			return new FormattedTextRun(new FormattedTextElement(TextView.cachedElements.GetTextForNonPrintableCharacter(newlineText' this)' 0)' GlobalTextRunProperties); " is 158.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetPrecedingText,The length of the statement  "				return new TextSpan<CultureSpecificCharacterBufferRange>(empty.Length' new CultureSpecificCharacterBufferRange(null' empty)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Search,RegexSearchStrategy,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\RegexSearchStrategy.cs,IsWordBorder,The length of the statement  "			return TextUtilities.GetNextCaretPosition(document' offset - 1' LogicalDirection.Forward' CaretPositioningMode.WordBorder) == offset; " is 133.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchInputHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchCommands.cs,RegisterGlobalCommands,The length of the statement  "			commandBindings.Add(new CommandBinding(SearchCommands.FindPrevious' ExecuteFindPrevious' CanExecuteWithOpenSearchPanel)); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchInputHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchCommands.cs,RegisterCommands,The length of the statement  "			commandBindings.Add(new CommandBinding(SearchCommands.FindPrevious' ExecuteFindPrevious' CanExecuteWithOpenSearchPanel)); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchInputHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchCommands.cs,RegisterCommands,The length of the statement  "			commandBindings.Add(new CommandBinding(SearchCommands.CloseSearchPanel' ExecuteCloseSearchPanel' CanExecuteWithOpenSearchPanel)); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchPanel,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchPanel.cs,UpdateSearch,The length of the statement  "			strategy = SearchStrategyFactory.Create(SearchPattern ?? ""' !MatchCase' WholeWords' UseRegex ? SearchMode.RegEx : SearchMode.Normal); " is 134.
Long Statement,ICSharpCode.AvalonEdit.Utils,CharRope,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CharRope.cs,InsertText,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - this.Count)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Utils,ExtensionMethods,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\ExtensionMethods.cs,Log,The length of the statement  "				string output = DateTime.Now.ToString("hh:MM:ss") + ": " + string.Format(format' args) + Environment.NewLine + Environment.StackTrace; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "				throw new ArgumentOutOfRangeException("startIndex"' startIndex' "0 <= startIndex <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' length' "0 <= length' startIndex(" + startIndex + ")+length <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 167.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "				throw new ArgumentOutOfRangeException("startIndex"' arrayIndex' "0 <= arrayIndex <= " + array.Length.ToString(CultureInfo.InvariantCulture)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "				throw new ArgumentOutOfRangeException("count"' count' "0 <= length' arrayIndex(" + arrayIndex + ")+count <= " + array.Length.ToString(CultureInfo.InvariantCulture)); " is 165.
Long Statement,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,ToString,The length of the statement  "				return "[Concat length=" + length + "' isShared=" + isShared + "' height=" + height + "' Balance=" + this.Balance + "]"; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,FunctionNode<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,GetContentNode,The length of the statement  "						throw new InvalidOperationException("Trying to load this node recursively; or: a previous call to a rope initializer failed."); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,ThrowUtil,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\ThrowUtil.cs,CheckInRangeInclusive,The length of the statement  "				throw new ArgumentOutOfRangeException(parameterName' val' "Expected: " + lower.ToString(CultureInfo.InvariantCulture) + " <= " + parameterName + " <= " + upper.ToString(CultureInfo.InvariantCulture)); " is 200.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,StopBetweenCharacters,The conditional expression  "!((mode == CaretPositioningMode.WordStart || mode == CaretPositioningMode.WordStartOrSymbol)  				      && (charAfter == CharacterClass.Whitespace || charAfter == CharacterClass.LineTerminator))"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_QueryCursor,The conditional expression  "p.X >= 0 && p.Y >= 0 && p.X <= textArea.TextView.ActualWidth && p.Y <= textArea.TextView.ActualHeight"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The conditional expression  "mode == MouseSelectionMode.Normal || mode == MouseSelectionMode.WholeWord || mode == MouseSelectionMode.WholeLine || mode == MouseSelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The conditional expression  "mode == MouseSelectionMode.Normal || mode == MouseSelectionMode.WholeWord || mode == MouseSelectionMode.WholeLine || mode == MouseSelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnPropertyChanged,The conditional expression  "e.Property == SelectionBrushProperty  			    || e.Property == SelectionBorderProperty  			    || e.Property == SelectionForegroundProperty  			    || e.Property == SelectionCornerRadiusProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting,HighlightedInlineBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedInlineBuilder.cs,SetHighlighting,The conditional expression  "color.Foreground == null && color.Background == null && color.FontStyle == null && color.FontWeight == null && color.Underline == null"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting,HighlightingEngine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingEngine.cs,Minimum,The conditional expression  "endSpanMatch != null && endSpanMatch.Success && (min == null || endSpanMatch.Index < min.Index)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The conditional expression  "!element.HasAttribute("bold") && !element.HasAttribute("italic") && !element.HasAttribute("color") && !element.HasAttribute("bgcolor")"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "lineComment || blockComment || inString || inChar"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "!oldBlock.Continuation && oldBlock.OneLineBlock == 0 &&  				    oldBlock.StartLine == block.StartLine &&  				    block.StartLine < doc.LineNumber && lastRealChar != ':'"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The conditional expression  "segmentEndVCInLine == visualEndCol && i < visualLine.TextLines.Count - 1 && segmentEndVC > segmentEndVCInLine && line.TrailingWhitespaceLength == 0"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The conditional expression  "segmentStartVCInLine == visualStartCol && i > 0 && segmentStartVC < segmentStartVCInLine && visualLine.TextLines[i - 1].TrailingWhitespaceLength == 0"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The conditional expression  "rectangle.IsEmpty || visual == null || visual == this || !this.IsAncestorOf(visual)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.ForegroundProperty  			           || e.Property == TextView.NonPrintableCharacterBrushProperty  			           || e.Property == TextView.LinkTextBackgroundBrushProperty  			           || e.Property == TextView.LinkTextForegroundBrushProperty  			           || e.Property == TextView.LinkTextUnderlineProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.FontFamilyProperty  			    || e.Property == Control.FontSizeProperty  			    || e.Property == Control.FontStretchProperty  			    || e.Property == Control.FontStyleProperty  			    || e.Property == Control.FontWeightProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Virtual Method Call from Constructor,ICSharpCode.AvalonEdit.Snippets,InsertionContext,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,InsertionContext,The constructor "InsertionContext" calls a virtual method "GetText".
Empty Catch Block,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,CopySelectedText,The method has an empty catch block.
Empty Catch Block,ICSharpCode.AvalonEdit.Rendering,VisualLineLinkText,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineLinkText.cs,OnMouseDown,The method has an empty catch block.
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: const double MinimumScrollPercentage = 0.3;
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: int hashCode = isAtEndOfLine ? 115817 : 0;
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionListBox,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionListBox.cs,CenterViewOn,The following statement contains a magic number: this.FirstVisibleItem = index - VisibleItemCount / 2;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query == itemText)  				return 8;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (string.Equals(itemText' query' StringComparison.InvariantCultureIgnoreCase))  				return 7;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith(query' StringComparison.InvariantCulture))  				return 6;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith(query' StringComparison.InvariantCultureIgnoreCase))  				return 5;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  				camelCaseMatch = CamelCaseMatch(itemText' query);  				if (camelCaseMatch == true) return 4;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  				camelCaseMatch = CamelCaseMatch(itemText' query);  				if (camelCaseMatch == true) return 4;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering) {  				if (itemText.IndexOf(query' StringComparison.InvariantCulture) >= 0)  					return 3;  				if (itemText.IndexOf(query' StringComparison.InvariantCultureIgnoreCase) >= 0)  					return 2;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering) {  				if (itemText.IndexOf(query' StringComparison.InvariantCulture) >= 0)  					return 3;  				if (itemText.IndexOf(query' StringComparison.InvariantCultureIgnoreCase) >= 0)  					return 2;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MaxHeight = 300;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.Width = 175;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinHeight = 15;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinWidth = 30;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The following statement contains a magic number: MaxWidth = Math.Min(workingArea.Width' Math.Max(1000' workingArea.Width * 0.6));
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The following statement contains a magic number: MaxWidth = Math.Min(workingArea.Width' Math.Max(1000' workingArea.Width * 0.6));
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OverloadInsightWindow,The following statement contains a magic number: overloadViewer.Margin = new Thickness(2'0'0'0);
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CollapseIfSingleOverloadConverter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadViewer.cs,Convert,The following statement contains a magic number: return ((int)value < 2) ? Visibility.Collapsed : Visibility.Visible;
Magic Number,ICSharpCode.AvalonEdit.Document,SimpleSegment,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\SimpleSegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return Offset + 10301 * Length;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos >= 0) {  				if (text[pos] == '\r') {  					if (pos + 1 < text.Length && text[pos + 1] == '\n')  						return new SimpleSegment(pos' 2);  				}  				return new SimpleSegment(pos' 1);  			}
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos >= 0) {  				if (text.GetCharAt(pos) == '\r') {  					if (pos + 1 < textLength && text.GetCharAt(pos + 1) == '\n')  						return new SimpleSegment(pos' 2);  				}  				return new SimpleSegment(pos' 1);  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,FindNextNewLine,The following statement contains a magic number: if (s == SimpleSegment.Invalid) {  				newLineType = null;  				return -1;  			} else {  				if (s.Length == 2) {  					newLineType = "\r\n";  				} else if (text.GetCharAt(s.Offset) == '\n') {  					newLineType = "\n";  				} else {  					newLineType = "\r";  				}  				return s.Offset;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: while (true) {  				int nextPos = (direction == LogicalDirection.Backward) ? offset - 1 : offset + 1;  				  				// return -1 if there is no further caret position in the text source  				// we also need this to handle offset values outside the valid range  				if (nextPos < 0 || nextPos > textLength)  					return -1;  				  				// check if we've run against the textSource borders.  				// a 'textSource' usually isn't the whole document' but a single VisualLineElement.  				if (nextPos == 0) {  					// at the document start' there's only a word border  					// if the first character is not whitespace  					if (IsNormal(mode) || !char.IsWhiteSpace(textSource.GetCharAt(0)))  						return nextPos;  				} else if (nextPos == textLength) {  					// at the document end' there's never a word start  					if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  						// at the document end' there's only a word border  						// if the last character is not whitespace  						if (IsNormal(mode) || !char.IsWhiteSpace(textSource.GetCharAt(textLength - 1)))  							return nextPos;  					}  				} else {  					char charBefore = textSource.GetCharAt(nextPos - 1);  					char charAfter = textSource.GetCharAt(nextPos);  					// Don't stop in the middle of a surrogate pair  					if (!char.IsSurrogatePair(charBefore' charAfter)) {  						CharacterClass classBefore = GetCharacterClass(charBefore);  						CharacterClass classAfter = GetCharacterClass(charAfter);  						// get correct class for characters outside BMP:  						if (char.IsLowSurrogate(charBefore) && nextPos >= 2) {  							classBefore = GetCharacterClass(textSource.GetCharAt(nextPos - 2)' charBefore);  						}  						if (char.IsHighSurrogate(charAfter) && nextPos + 1 < textLength) {  							classAfter = GetCharacterClass(charAfter' textSource.GetCharAt(nextPos + 1));  						}  						if (StopBetweenCharacters(mode' classBefore' classAfter)) {  							return nextPos;  						}  					}  				}  				// we'll have to continue searching...  				offset = nextPos;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The following statement contains a magic number: while (true) {  				int nextPos = (direction == LogicalDirection.Backward) ? offset - 1 : offset + 1;  				  				// return -1 if there is no further caret position in the text source  				// we also need this to handle offset values outside the valid range  				if (nextPos < 0 || nextPos > textLength)  					return -1;  				  				// check if we've run against the textSource borders.  				// a 'textSource' usually isn't the whole document' but a single VisualLineElement.  				if (nextPos == 0) {  					// at the document start' there's only a word border  					// if the first character is not whitespace  					if (IsNormal(mode) || !char.IsWhiteSpace(textSource.GetCharAt(0)))  						return nextPos;  				} else if (nextPos == textLength) {  					// at the document end' there's never a word start  					if (mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) {  						// at the document end' there's only a word border  						// if the last character is not whitespace  						if (IsNormal(mode) || !char.IsWhiteSpace(textSource.GetCharAt(textLength - 1)))  							return nextPos;  					}  				} else {  					char charBefore = textSource.GetCharAt(nextPos - 1);  					char charAfter = textSource.GetCharAt(nextPos);  					// Don't stop in the middle of a surrogate pair  					if (!char.IsSurrogatePair(charBefore' charAfter)) {  						CharacterClass classBefore = GetCharacterClass(charBefore);  						CharacterClass classAfter = GetCharacterClass(charAfter);  						// get correct class for characters outside BMP:  						if (char.IsLowSurrogate(charBefore) && nextPos >= 2) {  							classBefore = GetCharacterClass(textSource.GetCharAt(nextPos - 2)' charBefore);  						}  						if (char.IsHighSurrogate(charAfter) && nextPos + 1 < textLength) {  							classAfter = GetCharacterClass(charAfter' textSource.GetCharAt(nextPos + 1));  						}  						if (StopBetweenCharacters(mode' classBefore' classAfter)) {  							return nextPos;  						}  					}  				}  				// we'll have to continue searching...  				offset = nextPos;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocation,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked (191 * column.GetHashCode() ^ line.GetHashCode());
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocationConverter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextLocation.cs,ConvertFrom,The following statement contains a magic number: if (value is string) {  				string[] parts = ((string)value).Split(';'' ''');  				if (parts.Length == 2) {  					return new TextLocation(int.Parse(parts[0]' culture)' int.Parse(parts[1]' culture));  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Remove,The following statement contains a magic number: if (offset > startLineOffset + startLine.Length) {  				Debug.Assert(startLine.DelimiterLength == 2);  				// we are deleting starting in the middle of a delimiter  				  				// remove last delimiter part  				SetLineLength(startLine' startLine.TotalLength - 1);  				// remove remaining text  				Remove(offset' length - 1);  				return;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Insert,The following statement contains a magic number: if (offset > lineOffset + line.Length) {  				Debug.Assert(line.DelimiterLength == 2);  				// we are inserting in the middle of a delimiter  				  				// shorten line  				SetLineLength(line' line.TotalLength - 1);  				// add new line  				line = InsertLineAfter(line' 1);  				line = SetLineLength(line' 1);  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,GetTreeHeight,The following statement contains a magic number: if (size == 0)  				return 0;  			else  				return GetTreeHeight(size / 2) + 1;
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,BuildTree,The following statement contains a magic number: int middle = (start + end) / 2;
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The following statement contains a magic number: switch (offsetChangeMappingType) {  				case OffsetChangeMappingType.Normal:  					Replace(offset' length' text' null);  					break;  				case OffsetChangeMappingType.KeepAnchorBeforeInsertion:  					Replace(offset' length' text' OffsetChangeMap.FromSingleElement(  						new OffsetChangeMapEntry(offset' length' text.TextLength' false' true)));  					break;  				case OffsetChangeMappingType.RemoveAndInsert:  					if (length == 0 || text.TextLength == 0) {  						// only insertion or only removal?  						// OffsetChangeMappingType doesn't matter' just use Normal.  						Replace(offset' length' text' null);  					} else {  						OffsetChangeMap map = new OffsetChangeMap(2);  						map.Add(new OffsetChangeMapEntry(offset' length' 0));  						map.Add(new OffsetChangeMapEntry(offset' 0' text.TextLength));  						map.Freeze();  						Replace(offset' length' text' map);  					}  					break;  				case OffsetChangeMappingType.CharacterReplace:  					if (length == 0 || text.TextLength == 0) {  						// only insertion or only removal?  						// OffsetChangeMappingType doesn't matter' just use Normal.  						Replace(offset' length' text' null);  					} else if (text.TextLength > length) {  						// look at OffsetChangeMappingType.CharacterReplace XML comments on why we need to replace  						// the last character  						OffsetChangeMapEntry entry = new OffsetChangeMapEntry(offset + length - 1' 1' 1 + text.TextLength - length);  						Replace(offset' length' text' OffsetChangeMap.FromSingleElement(entry));  					} else if (text.TextLength < length) {  						OffsetChangeMapEntry entry = new OffsetChangeMapEntry(offset + text.TextLength' length - text.TextLength' 0' true' false);  						Replace(offset' length' text' OffsetChangeMap.FromSingleElement(entry));  					} else {  						Replace(offset' length' text' OffsetChangeMap.Empty);  					}  					break;  				default:  					throw new ArgumentOutOfRangeException("offsetChangeMappingType"' offsetChangeMappingType' "Invalid enum value");  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,DoReplace,The following statement contains a magic number: if (length == 0) {  				removedText = StringTextSource.Empty;  			} else if (length < 100) {  				removedText = new StringTextSource(rope.ToString(offset' length));  			} else {  				// use a rope if the removed string is long  				removedText = new RopeTextSource(rope.GetRange(offset' length));  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,CaretLayer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretLayer.cs,OnRender,The following statement contains a magic number: if (isVisible && blink) {  				Brush caretBrush = this.CaretBrush;  				if (caretBrush == null)  					caretBrush = (Brush)textView.GetValue(TextBlock.ForegroundProperty);  				  				if (this.textArea.OverstrikeMode) {  					SolidColorBrush scBrush = caretBrush as SolidColorBrush;  					if (scBrush != null) {  						Color brushColor = scBrush.Color;  						Color newColor = Color.FromArgb(100' brushColor.R' brushColor.G' brushColor.B);  						caretBrush = new SolidColorBrush(newColor);  						caretBrush.Freeze();  					}  				}  				  				Rect r = new Rect(caretRectangle.X - textView.HorizontalOffset'  				                  caretRectangle.Y - textView.VerticalOffset'  				                  caretRectangle.Width'  				                  caretRectangle.Height);  				drawingContext.DrawRectangle(caretBrush' null' PixelSnapHelpers.Round(r' PixelSnapHelpers.GetPixelSize(this)));  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: Line line = new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: Line line = new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: Line line = new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  				newLength = 2;
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  				newLength = 2;
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnMouseLeftButtonDown,The following statement contains a magic number: if (!e.Handled && TextView != null && textArea != null) {  				e.Handled = true;  				textArea.Focus();  				  				SimpleSegment currentSeg = GetTextLineSegment(e);  				if (currentSeg == SimpleSegment.Invalid)  					return;  				textArea.Caret.Offset = currentSeg.Offset + currentSeg.Length;  				if (CaptureMouse()) {  					selecting = true;  					selectionStart = new AnchorSegment(Document' currentSeg.Offset' currentSeg.Length);  					if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift) {  						SimpleSelection simpleSelection = textArea.Selection as SimpleSelection;  						if (simpleSelection != null)  							selectionStart = new AnchorSegment(Document' simpleSelection.SurroundingSegment);  					}  					textArea.Selection = Selection.Create(textArea' selectionStart);  					if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift) {  						ExtendSelection(currentSeg);  					}  					textArea.Caret.BringCaretToView(5.0);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnMouseMove,The following statement contains a magic number: if (selecting && textArea != null && TextView != null) {  				e.Handled = true;  				SimpleSegment currentSeg = GetTextLineSegment(e);  				if (currentSeg == SimpleSegment.Invalid)  					return;  				ExtendSelection(currentSeg);  				textArea.Caret.BringCaretToView(5.0);  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (!e.Handled && e.ChangedButton == MouseButton.Left) {  				ModifierKeys modifiers = Keyboard.Modifiers;  				bool shift = (modifiers & ModifierKeys.Shift) == ModifierKeys.Shift;  				if (enableTextDragDrop && e.ClickCount == 1 && !shift) {  					int visualColumn;  					bool isAtEndOfLine;  					int offset = GetOffsetFromMousePosition(e' out visualColumn' out isAtEndOfLine);  					if (textArea.Selection.Contains(offset)) {  						if (textArea.CaptureMouse()) {  							mode = MouseSelectionMode.PossibleDragStart;  							possibleDragStartMousePos = e.GetPosition(textArea);  						}  						e.Handled = true;  						return;  					}  				}  				  				var oldPosition = textArea.Caret.Position;  				SetCaretOffsetToMousePosition(e);  				  				  				if (!shift) {  					textArea.ClearSelection();  				}  				if (textArea.CaptureMouse()) {  					if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt && textArea.Options.EnableRectangularSelection) {  						mode = MouseSelectionMode.Rectangular;  						if (shift && textArea.Selection is RectangleSelection) {  							textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint(oldPosition' textArea.Caret.Position);  						}  					} else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  						mode = MouseSelectionMode.Normal;  						if (shift && !(textArea.Selection is RectangleSelection)) {  							textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint(oldPosition' textArea.Caret.Position);  						}  					} else {  						SimpleSegment startWord;  						if (e.ClickCount == 3) {  							mode = MouseSelectionMode.WholeLine;  							startWord = GetLineAtMousePosition(e);  						} else {  							mode = MouseSelectionMode.WholeWord;  							startWord = GetWordAtMousePosition(e);  						}  						if (startWord == SimpleSegment.Invalid) {  							mode = MouseSelectionMode.None;  							textArea.ReleaseMouseCapture();  							return;  						}  						if (shift && !textArea.Selection.IsEmpty) {  							if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.Offset)));  							} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.EndOffset)));  							}  							this.startWord = new AnchorSegment(textArea.Document' textArea.Selection.SurroundingSegment);  						} else {  							textArea.Selection = Selection.Create(textArea' startWord.Offset' startWord.EndOffset);  							this.startWord = new AnchorSegment(textArea.Document' startWord.Offset' startWord.Length);  						}  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,ExtendSelectionToMouse,The following statement contains a magic number: textArea.Caret.BringCaretToView(5.0);
Magic Number,ICSharpCode.AvalonEdit.Editing,SimpleSelection,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return startOffset * 27811 + endOffset + textArea.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingLineElement,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingElementGenerator.cs,OnMouseDown,The following statement contains a magic number: if (e.ClickCount == 2 && e.ChangedButton == MouseButton.Left) {  					fs.IsFolded = false;  					e.Handled = true;  				} else {  					base.OnMouseDown(e);  				}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  				int visualColumn = m.VisualLine.GetVisualColumn(m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  				TextLine textLine = m.VisualLine.GetTextLine(visualColumn);  				double yPos = m.VisualLine.GetTextLineVisualYPosition(textLine' VisualYPosition.TextMiddle) - TextView.VerticalOffset;  				yPos -= m.DesiredSize.Height / 2;  				double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  				m.Arrange(new Rect(PixelSnapHelpers.Round(new Point(xPos' yPos)' pixelSize)' m.DesiredSize));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  				int visualColumn = m.VisualLine.GetVisualColumn(m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  				TextLine textLine = m.VisualLine.GetTextLine(visualColumn);  				double yPos = m.VisualLine.GetTextLineVisualYPosition(textLine' VisualYPosition.TextMiddle) - TextView.VerticalOffset;  				yPos -= m.DesiredSize.Height / 2;  				double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  				m.Arrange(new Rect(PixelSnapHelpers.Round(new Point(xPos' yPos)' pixelSize)' m.DesiredSize));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: double markerXPos = PixelSnapHelpers.PixelAlign(RenderSize.Width / 2' pixelSize.Width);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  				drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' RenderSize.Height));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: Rect rect = new Rect(pixelSize.Width / 2'  			                     pixelSize.Height / 2'  			                     this.RenderSize.Width - pixelSize.Width'  			                     this.RenderSize.Height - pixelSize.Height);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: Rect rect = new Rect(pixelSize.Width / 2'  			                     pixelSize.Height / 2'  			                     this.RenderSize.Width - pixelSize.Width'  			                     this.RenderSize.Height - pixelSize.Height);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double middleX = rect.Left + rect.Width / 2;
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double middleY = rect.Top + rect.Height / 2;
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double space = PixelSnapHelpers.Round(rect.Width / 8' pixelSize.Width) + pixelSize.Width;
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  				int firstNewLine = comment.IndexOf('\n');  				if (firstNewLine >= 0) {  					  					// Take off 4 chars to get the actual comment start (takes  					// into account the <!-- chars.  					  					int startOffset = GetOffset(document' reader) - 4;  					int endOffset = startOffset + comment.Length + 7;  					  					string foldText = String.Concat("<!--"' comment.Substring(0' firstNewLine).TrimEnd('\r') ' "-->");  					foldMarkers.Add(new NewFolding(startOffset' endOffset) { Name = foldText } );  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  				int firstNewLine = comment.IndexOf('\n');  				if (firstNewLine >= 0) {  					  					// Take off 4 chars to get the actual comment start (takes  					// into account the <!-- chars.  					  					int startOffset = GetOffset(document' reader) - 4;  					int endOffset = startOffset + comment.Length + 7;  					  					string foldText = String.Concat("<!--"' comment.Substring(0' firstNewLine).TrimEnd('\r') ' "-->");  					foldMarkers.Add(new NewFolding(startOffset' endOffset) { Name = foldText } );  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (name != null)  					hashCode += 1000000007 * name.GetHashCode();  				hashCode += 1000000009 * fontWeight.GetHashCode();  				hashCode += 1000000021 * fontStyle.GetHashCode();  				if (foreground != null)  					hashCode += 1000000033 * foreground.GetHashCode();  				if (background != null)  					hashCode += 1000000087 * background.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (name != null)  					hashCode += 1000000007 * name.GetHashCode();  				hashCode += 1000000009 * fontWeight.GetHashCode();  				hashCode += 1000000021 * fontStyle.GetHashCode();  				if (foreground != null)  					hashCode += 1000000033 * foreground.GetHashCode();  				if (background != null)  					hashCode += 1000000087 * background.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (name != null)  					hashCode += 1000000007 * name.GetHashCode();  				hashCode += 1000000009 * fontWeight.GetHashCode();  				hashCode += 1000000021 * fontStyle.GetHashCode();  				if (foreground != null)  					hashCode += 1000000033 * foreground.GetHashCode();  				if (background != null)  					hashCode += 1000000087 * background.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (name != null)  					hashCode += 1000000007 * name.GetHashCode();  				hashCode += 1000000009 * fontWeight.GetHashCode();  				hashCode += 1000000021 * fontStyle.GetHashCode();  				if (foreground != null)  					hashCode += 1000000033 * foreground.GetHashCode();  				if (background != null)  					hashCode += 1000000087 * background.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HighlightingColor,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (name != null)  					hashCode += 1000000007 * name.GetHashCode();  				hashCode += 1000000009 * fontWeight.GetHashCode();  				hashCode += 1000000021 * fontStyle.GetHashCode();  				if (foreground != null)  					hashCode += 1000000033 * foreground.GetHashCode();  				if (background != null)  					hashCode += 1000000087 * background.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HtmlOptions,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlOptions.cs,HtmlOptions,The following statement contains a magic number: this.TabSize = 4;
Magic Number,ICSharpCode.AvalonEdit.Highlighting,RichText,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\RichText.cs,Substring,The following statement contains a magic number: OffsetChangeMap map = new OffsetChangeMap(2);
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,GetSystemColorBrush,The following statement contains a magic number: string shortName = name.Substring(13);
Magic Number,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddRectangle,The following statement contains a magic number: if (AlignToWholePixels) {  				double halfBorder = 0.5 * BorderThickness;  				AddRectangle(PixelSnapHelpers.Round(r.Left - halfBorder' pixelSize.Width) + halfBorder'  				             PixelSnapHelpers.Round(r.Top - halfBorder' pixelSize.Height) + halfBorder'  				             PixelSnapHelpers.Round(r.Right + halfBorder' pixelSize.Width) - halfBorder'  				             PixelSnapHelpers.Round(r.Bottom + halfBorder' pixelSize.Height) - halfBorder);  				//Debug.WriteLine(r.ToString() + " -> " + new Rect(lastLeft' lastTop' lastRight-lastLeft' lastBottom-lastTop).ToString());  			} else if (alignToMiddleOfPixels) {  				AddRectangle(PixelSnapHelpers.PixelAlign(r.Left' pixelSize.Width)'  				             PixelSnapHelpers.PixelAlign(r.Top' pixelSize.Height)'  				             PixelSnapHelpers.PixelAlign(r.Right' pixelSize.Width)'  				             PixelSnapHelpers.PixelAlign(r.Bottom' pixelSize.Height));  			} else {  				AddRectangle(r.Left' r.Top' r.Right' r.Bottom);  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,FormattedTextElement,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,PrepareText,The following statement contains a magic number: return formatter.FormatLine(  				new SimpleTextSource(text' properties)'  				0'  				32000'  				new VisualLineTextParagraphProperties {  					defaultTextRunProperties = properties'  					textWrapping = TextWrapping.NoWrap'  					tabSize = 40  				}'  				null);
Magic Number,ICSharpCode.AvalonEdit.Rendering,FormattedTextElement,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,PrepareText,The following statement contains a magic number: return formatter.FormatLine(  				new SimpleTextSource(text' properties)'  				0'  				32000'  				new VisualLineTextParagraphProperties {  					defaultTextRunProperties = properties'  					textWrapping = TextWrapping.NoWrap'  					tabSize = 40  				}'  				null);
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,BuildTree,The following statement contains a magic number: int middle = (start + end) / 2;
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: Point newOrigin = new Point(origin.X + 1.5' origin.Y);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: Rect r = new Rect(newOrigin.X - 0.5' newOrigin.Y - metrics.Baseline' metrics.Width + 2' metrics.Height);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: Rect r = new Rect(newOrigin.X - 0.5' newOrigin.Y - metrics.Baseline' metrics.Width + 2' metrics.Height);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: drawingContext.DrawRoundedRectangle(darkGrayBrush' null' r' 2.5' 2.5);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: drawingContext.DrawRoundedRectangle(darkGrayBrush' null' r' 2.5' 2.5);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Format,The following statement contains a magic number: return new TextEmbeddedObjectMetrics(metrics.Width + 3'  				                                     metrics.Height' metrics.Baseline);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ComputeBoundingBox,The following statement contains a magic number: r.Width += 3;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  				availableSize.Width = 32000;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  				availableSize.Width = 32000;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The following statement contains a magic number: while (textOffset <= visualLine.VisualLengthWithEndOfLineMarker) {  				TextLine textLine = formatter.FormatLine(  					textSource'  					textOffset'  					availableSize.Width'  					paragraphProperties'  					lastLineBreak  				);  				textLines.Add(textLine);  				textOffset += textLine.Length;  				  				// exit loop so that we don't do the indentation calculation if there's only a single line  				if (textOffset >= visualLine.VisualLengthWithEndOfLineMarker)  					break;  				  				if (paragraphProperties.firstLineInParagraph) {  					paragraphProperties.firstLineInParagraph = false;  					  					TextEditorOptions options = this.Options;  					double indentation = 0;  					if (options.InheritWordWrapIndentation) {  						// determine indentation for next line:  						int indentVisualColumn = GetIndentationVisualColumn(visualLine);  						if (indentVisualColumn > 0 && indentVisualColumn < textOffset) {  							indentation = textLine.GetDistanceFromCharacterHit(new CharacterHit(indentVisualColumn' 0));  						}  					}  					indentation += options.WordWrapIndentation;  					// apply the calculated indentation unless it's more than half of the text editor size:  					if (indentation > 0 && indentation * 2 < availableSize.Width)  						paragraphProperties.indent = indentation;  				}  				lastLineBreak = textLine.GetTextLineBreak();  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: foreach (var line in visibleVisualLines) {  				Brush currentBrush = null;  				int startVC = 0;  				int length = 0;  				foreach (var element in line.Elements) {  					if (currentBrush == null || !currentBrush.Equals(element.BackgroundBrush)) {  						if (currentBrush != null) {  							BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  							builder.AlignToWholePixels = true;  							builder.CornerRadius = 3;  							foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  								builder.AddRectangle(this' rect);  							Geometry geometry = builder.CreateGeometry();  							if (geometry != null) {  								drawingContext.DrawGeometry(currentBrush' null' geometry);  							}  						}  						startVC = element.VisualColumn;  						length = element.DocumentLength;  						currentBrush = element.BackgroundBrush;  					} else {  						length += element.VisualLength;  					}  				}  				if (currentBrush != null) {  					BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  					builder.AlignToWholePixels = true;  					builder.CornerRadius = 3;  					foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  						builder.AddRectangle(this' rect);  					Geometry geometry = builder.CreateGeometry();  					if (geometry != null) {  						drawingContext.DrawGeometry(currentBrush' null' geometry);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: foreach (var line in visibleVisualLines) {  				Brush currentBrush = null;  				int startVC = 0;  				int length = 0;  				foreach (var element in line.Elements) {  					if (currentBrush == null || !currentBrush.Equals(element.BackgroundBrush)) {  						if (currentBrush != null) {  							BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  							builder.AlignToWholePixels = true;  							builder.CornerRadius = 3;  							foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  								builder.AddRectangle(this' rect);  							Geometry geometry = builder.CreateGeometry();  							if (geometry != null) {  								drawingContext.DrawGeometry(currentBrush' null' geometry);  							}  						}  						startVC = element.VisualColumn;  						length = element.DocumentLength;  						currentBrush = element.BackgroundBrush;  					} else {  						length += element.VisualLength;  					}  				}  				if (currentBrush != null) {  					BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  					builder.AlignToWholePixels = true;  					builder.CornerRadius = 3;  					foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  						builder.AddRectangle(this' rect);  					Geometry geometry = builder.CreateGeometry();  					if (geometry != null) {  						drawingContext.DrawGeometry(currentBrush' null' geometry);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  				var textRunProperties = CreateGlobalTextRunProperties();  				using (var line = formatter.FormatLine(  					new SimpleTextSource("x"' textRunProperties)'  					0' 32000'  					new VisualLineTextParagraphProperties { defaultTextRunProperties = textRunProperties }'  					null))  				{  					wideSpaceWidth = Math.Max(1' line.WidthIncludingTrailingWhitespace);  					defaultBaseline = Math.Max(1' line.Baseline);  					defaultLineHeight = Math.Max(1' line.Height);  				}  			} else {  				wideSpaceWidth = FontSize / 2;  				defaultBaseline = FontSize;  				defaultLineHeight = FontSize + 3;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  				var textRunProperties = CreateGlobalTextRunProperties();  				using (var line = formatter.FormatLine(  					new SimpleTextSource("x"' textRunProperties)'  					0' 32000'  					new VisualLineTextParagraphProperties { defaultTextRunProperties = textRunProperties }'  					null))  				{  					wideSpaceWidth = Math.Max(1' line.WidthIncludingTrailingWhitespace);  					defaultBaseline = Math.Max(1' line.Baseline);  					defaultLineHeight = Math.Max(1' line.Height);  				}  			} else {  				wideSpaceWidth = FontSize / 2;  				defaultBaseline = FontSize;  				defaultLineHeight = FontSize + 3;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  				var textRunProperties = CreateGlobalTextRunProperties();  				using (var line = formatter.FormatLine(  					new SimpleTextSource("x"' textRunProperties)'  					0' 32000'  					new VisualLineTextParagraphProperties { defaultTextRunProperties = textRunProperties }'  					null))  				{  					wideSpaceWidth = Math.Max(1' line.WidthIncludingTrailingWhitespace);  					defaultBaseline = Math.Max(1' line.Baseline);  					defaultLineHeight = Math.Max(1' line.Height);  				}  			} else {  				wideSpaceWidth = FontSize / 2;  				defaultBaseline = FontSize;  				defaultLineHeight = FontSize + 3;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Left < visibleRectangle.Left) {  				if (rectangle.Right > visibleRectangle.Right) {  					newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  				} else {  					newScrollOffset.X = rectangle.Left;  				}  			} else if (rectangle.Right > visibleRectangle.Right) {  				newScrollOffset.X = rectangle.Right - scrollViewport.Width;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Top < visibleRectangle.Top) {  				if (rectangle.Bottom > visibleRectangle.Bottom) {  					newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  				} else {  					newScrollOffset.Y = rectangle.Top;  				}  			} else if (rectangle.Bottom > visibleRectangle.Bottom) {  				newScrollOffset.Y = rectangle.Bottom - scrollViewport.Height;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  				if (tl == textLine) {  					switch (yPositionMode) {  						case VisualYPosition.LineTop:  							return pos;  						case VisualYPosition.LineMiddle:  							return pos + tl.Height / 2;  						case VisualYPosition.LineBottom:  							return pos + tl.Height;  						case VisualYPosition.TextTop:  							return pos + tl.Baseline - textView.DefaultBaseline;  						case VisualYPosition.TextBottom:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  						case VisualYPosition.TextMiddle:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  						case VisualYPosition.Baseline:  							return pos + tl.Baseline;  						default:  							throw new ArgumentException("Invalid yPositionMode:" + yPositionMode);  					}  				} else {  					pos += tl.Height;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  				if (tl == textLine) {  					switch (yPositionMode) {  						case VisualYPosition.LineTop:  							return pos;  						case VisualYPosition.LineMiddle:  							return pos + tl.Height / 2;  						case VisualYPosition.LineBottom:  							return pos + tl.Height;  						case VisualYPosition.TextTop:  							return pos + tl.Baseline - textView.DefaultBaseline;  						case VisualYPosition.TextBottom:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  						case VisualYPosition.TextMiddle:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  						case VisualYPosition.Baseline:  							return pos + tl.Baseline;  						default:  							throw new ArgumentException("Invalid yPositionMode:" + yPositionMode);  					}  				} else {  					pos += tl.Height;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineByVisualYPosition,The following statement contains a magic number: const double epsilon = 0.0001;
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,CreateTextRunForNewLine,The following statement contains a magic number: if (lastDocumentLine.DelimiterLength == 2) {  				newlineText = "¶";  			} else if (lastDocumentLine.DelimiterLength == 1) {  				char newlineChar = Document.GetCharAt(lastDocumentLine.Offset + lastDocumentLine.Length);  				if (newlineChar == '\r')  					newlineText = "\\r";  				else if (newlineChar == '\n')  					newlineText = "\\n";  				else  					newlineText = "?";  			}
Magic Number,ICSharpCode.AvalonEdit.Search,SearchResultBackgroundRenderer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchResultBackgroundRenderer.cs,Draw,The following statement contains a magic number: foreach (SearchResult result in currentResults.FindOverlappingSegments(viewStart' viewEnd - viewStart)) {  				BackgroundGeometryBuilder geoBuilder = new BackgroundGeometryBuilder();  				geoBuilder.AlignToWholePixels = true;  				geoBuilder.BorderThickness = markerPen != null ? markerPen.Thickness : 0;  				geoBuilder.CornerRadius = 3;  				geoBuilder.AddSegment(textView' result);  				Geometry geometry = geoBuilder.CreateGeometry();  				if (geometry != null) {  					drawingContext.DrawGeometry(markerBrush' markerPen' geometry);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Snippets,Renderer,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Snippets\SnippetReplaceableTextElement.cs,CreateBackgroundBrush,The following statement contains a magic number: b.Opacity = 0.4;
Magic Number,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,DocumentPrinter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\DocumentPrinter.cs,ConvertTextDocumentToRichText,The following statement contains a magic number: for (int lineNumber = 1; lineNumber <= document.LineCount; lineNumber++) {  				var line = document.GetLineByNumber(lineNumber);  				if (lineNumber > 1)  					texts.Add(line.PreviousLine.DelimiterLength == 2 ? "\r\n" : "\n");  				if (highlighter != null) {  					HighlightedLine highlightedLine = highlighter.HighlightLine(lineNumber);  					texts.Add(highlightedLine.ToRichText());  				} else {  					texts.Add(document.GetText(line));  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsASCIICompatible,The following statement contains a magic number: return bytes.Length == 2 && bytes[0] == 'A' && bytes[1] == 'z';
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,RemoveBOM,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65001: // UTF-8  					return UTF8NoBOM;  				default:  					return encoding;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  				// the autodetection of StreamReader is not capable of detecting the difference  				// between ISO-8859-1 and UTF-8 without BOM.  				int firstByte = stream.ReadByte();  				int secondByte = stream.ReadByte();  				switch ((firstByte << 8) | secondByte) {  					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader  					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE)  					case 0xfeff: // UTF-16 BE BOM  					case 0xefbb: // start of UTF-8 BOM  						// StreamReader autodetection works  						stream.Position = 0;  						return new StreamReader(stream);  					default:  						return AutoDetect(stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  				}  			} else {  				if (defaultEncoding != null) {  					return new StreamReader(stream' defaultEncoding);  				} else {  					return new StreamReader(stream);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  				// the autodetection of StreamReader is not capable of detecting the difference  				// between ISO-8859-1 and UTF-8 without BOM.  				int firstByte = stream.ReadByte();  				int secondByte = stream.ReadByte();  				switch ((firstByte << 8) | secondByte) {  					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader  					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE)  					case 0xfeff: // UTF-16 BE BOM  					case 0xefbb: // start of UTF-8 BOM  						// StreamReader autodetection works  						stream.Position = 0;  						return new StreamReader(stream);  					default:  						return AutoDetect(stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  				}  			} else {  				if (defaultEncoding != null) {  					return new StreamReader(stream' defaultEncoding);  				} else {  					return new StreamReader(stream);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: int max = (int)Math.Min(fs.Length' 500000);
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8  = 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8Sequence = 3;
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  				if (i == 0) {  					b = firstByte;  				} else if (i == 1) {  					b = secondByte;  				} else {  					b = (byte)fs.ReadByte();  				}  				if (b < 0x80) {  					// normal ASCII character  					if (state == UTF8Sequence) {  						state = Error;  						break;  					}  				} else if (b < 0xc0) {  					// 10xxxxxx : continues UTF8 byte sequence  					if (state == UTF8Sequence) {  						--sequenceLength;  						if (sequenceLength < 0) {  							state = Error;  							break;  						} else if (sequenceLength == 0) {  							state = UTF8;  						}  					} else {  						state = Error;  						break;  					}  				} else if (b >= 0xc2 && b < 0xf5) {  					// beginning of byte sequence  					if (state == UTF8 || state == ASCII) {  						state = UTF8Sequence;  						if (b < 0xe0) {  							sequenceLength = 1; // one more byte following  						} else if (b < 0xf0) {  							sequenceLength = 2; // two more bytes following  						} else {  							sequenceLength = 3; // three more bytes following  						}  					} else {  						state = Error;  						break;  					}  				} else {  					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  					state = Error;  					break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  				if (i == 0) {  					b = firstByte;  				} else if (i == 1) {  					b = secondByte;  				} else {  					b = (byte)fs.ReadByte();  				}  				if (b < 0x80) {  					// normal ASCII character  					if (state == UTF8Sequence) {  						state = Error;  						break;  					}  				} else if (b < 0xc0) {  					// 10xxxxxx : continues UTF8 byte sequence  					if (state == UTF8Sequence) {  						--sequenceLength;  						if (sequenceLength < 0) {  							state = Error;  							break;  						} else if (sequenceLength == 0) {  							state = UTF8;  						}  					} else {  						state = Error;  						break;  					}  				} else if (b >= 0xc2 && b < 0xf5) {  					// beginning of byte sequence  					if (state == UTF8 || state == ASCII) {  						state = UTF8Sequence;  						if (b < 0xe0) {  							sequenceLength = 1; // one more byte following  						} else if (b < 0xf0) {  							sequenceLength = 2; // two more bytes following  						} else {  							sequenceLength = 3; // three more bytes following  						}  					} else {  						state = Error;  						break;  					}  				} else {  					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  					state = Error;  					break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,CreateNodes,The following statement contains a magic number: if (leafCount == 1) {  				result.contents = new T[NodeSize];  			} else {  				int rightSide = leafCount / 2;  				int leftSide = leafCount - rightSide;  				int leftLength = leftSide * NodeSize;  				result.left = CreateNodes(leftSide' leftLength);  				result.right = CreateNodes(rightSide' totalLength - leftLength);  				result.height = (byte)(1 + Math.Max(result.left.height' result.right.height));  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,FunctionNode<T>,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round((value / pixelSize) + 0.5' MidpointRounding.AwayFromZero) - 0.5);
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round((value / pixelSize) + 0.5' MidpointRounding.AwayFromZero) - 0.5);
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,RoundToOdd,The following statement contains a magic number: return Round(value - pixelSize' pixelSize * 2) + pixelSize;
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,HandleKey,The following switch statement is missing a default case: switch (e.Key) {  				case Key.Down:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex + 1);  					break;  				case Key.Up:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex - 1);  					break;  				case Key.PageDown:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex + listBox.VisibleItemCount);  					break;  				case Key.PageUp:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex - listBox.VisibleItemCount);  					break;  				case Key.Home:  					e.Handled = true;  					listBox.SelectIndex(0);  					break;  				case Key.End:  					e.Handled = true;  					listBox.SelectIndex(listBox.Items.Count - 1);  					break;  				case Key.Tab:  				case Key.Enter:  					e.Handled = true;  					RequestInsertion(e);  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  					case Key.Up:  						e.Handled = true;  						overloadViewer.ChangeIndex(-1);  						break;  					case Key.Down:  						e.Handled = true;  						overloadViewer.ChangeIndex(+1);  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,GetNewCaretPosition,The following switch statement is missing a default case: switch (direction) {  				case CaretMovementType.None:  					return caretPosition;  				case CaretMovementType.DocumentStart:  					desiredXPos = double.NaN;  					return new TextViewPosition(0' 0);  				case CaretMovementType.DocumentEnd:  					desiredXPos = double.NaN;  					return new TextViewPosition(textView.Document.GetLocation(textView.Document.TextLength));  			}
Missing Default,ICSharpCode.AvalonEdit.Editing,ImeSupport,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\ImeSupport.cs,WndProc,The following switch statement is missing a default case: switch (msg) {  				case ImeNativeWrapper.WM_INPUTLANGCHANGE:  					// Don't mark the message as handled; other windows  					// might want to handle it as well.  					  					// If we have a context' recreate it  					if (hwndSource != null) {  						ClearContext();  						CreateContext();  					}  					break;  				case ImeNativeWrapper.WM_IME_COMPOSITION:  					UpdateCompositionWindow();  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,ExpandToEnclosingUnit,The following switch statement is missing a default case: switch (unit) {  				case TextUnit.Character:  					ExpandToEnclosingUnit(CaretPositioningMode.Normal);  					break;  				case TextUnit.Format:  				case TextUnit.Word:  					ExpandToEnclosingUnit(CaretPositioningMode.WordStartOrSymbol);  					break;  				case TextUnit.Line:  				case TextUnit.Paragraph:  					segment = doc.GetLineByOffset(segment.Offset);  					break;  				case TextUnit.Document:  					segment = new AnchorSegment(doc' 0' doc.TextLength);  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.Editing,TextRangeProvider,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Editing\TextRangeProvider.cs,MoveEndpointByUnit,The following switch statement is missing a default case: switch (unit) {  				case TextUnit.Character:  					offset = MoveOffset(offset' CaretPositioningMode.Normal' count);  					break;  				case TextUnit.Format:  				case TextUnit.Word:  					offset = MoveOffset(offset' CaretPositioningMode.WordStart' count);  					break;  				case TextUnit.Line:  				case TextUnit.Paragraph:  					int line = doc.GetLineByOffset(offset).LineNumber;  					int newLine = Math.Max(1' Math.Min(doc.LineCount' line + count));  					offset = doc.GetLineByNumber(newLine).Offset;  					break;  				case TextUnit.Document:  					offset = count < 0 ? 0 : doc.TextLength;  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateNewFoldings,The following switch statement is missing a default case: switch (reader.NodeType) {  						case XmlNodeType.Element:  							if (!reader.IsEmptyElement) {  								XmlFoldStart newFoldStart = CreateElementFoldStart(document' reader);  								stack.Push(newFoldStart);  							}  							break;  							  						case XmlNodeType.EndElement:  							XmlFoldStart foldStart = stack.Pop();  							CreateElementFold(document' foldMarkers' reader' foldStart);  							break;  							  						case XmlNodeType.Comment:  							CreateCommentFold(document' foldMarkers' reader);  							break;  					}
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  					case '/':  						if (blockComment && lastchar == '*')  							blockComment = false;  						if (!inString && !inChar) {  							if (!blockComment && nextchar == '/')  								lineComment = true;  							if (!lineComment && nextchar == '*')  								blockComment = true;  						}  						break;  					case '#':  						if (!(inChar || blockComment || inString))  							lineComment = true;  						break;  					case '"':  						if (!(inChar || lineComment || blockComment)) {  							inString = !inString;  							if (!inString && verbatim) {  								if (nextchar == '"') {  									escape = true; // skip escaped quote  									inString = true;  								} else {  									verbatim = false;  								}  							} else if (inString && lastchar == '@') {  								verbatim = true;  							}  						}  						break;  					case '\'':  						if (!(inString || lineComment || blockComment)) {  							inChar = !inChar;  						}  						break;  					case '\\':  						if ((inString && !verbatim) || inChar)  							escape = true; // skip next character  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  					case '{':  						block.ResetOneLineBlock();  						blocks.Push(block);  						block.StartLine = doc.LineNumber;  						if (block.LastWord == "switch") {  							block.Indent(set.IndentString + set.IndentString);  							/* oldBlock refers to the previous line' not the previous block  							 * The block we want is not available anymore because it was never pushed.  							 * } else if (oldBlock.OneLineBlock) {  							// Inside a one-line-block is another statement  							// with a full block: indent the inner full block  							// by one additional level  							block.Indent(set' set.IndentString + set.IndentString);  							block.OuterIndent += set.IndentString;  							// Indent current line if it starts with the '{' character  							if (i == 0) {  								oldBlock.InnerIndent += set.IndentString;  							}*/  						} else {  							block.Indent(set);  						}  						block.Bracket = '{';  						break;  					case '}':  						while (block.Bracket != '{') {  							if (blocks.Count == 0) break;  							block = blocks.Pop();  						}  						if (blocks.Count == 0) break;  						block = blocks.Pop();  						block.Continuation = false;  						block.ResetOneLineBlock();  						break;  					case '(':  					case '[':  						blocks.Push(block);  						if (block.StartLine == doc.LineNumber)  							block.InnerIndent = block.OuterIndent;  						else  							block.StartLine = doc.LineNumber;  						block.Indent(Repeat(set.IndentString' oldBlock.OneLineBlock) +  						             (oldBlock.Continuation ? set.IndentString : "") +  						             (i == line.Length - 1 ? set.IndentString : new String(' '' i + 1)));  						block.Bracket = c;  						break;  					case ')':  						if (blocks.Count == 0) break;  						if (block.Bracket == '(') {  							block = blocks.Pop();  							if (IsSingleStatementKeyword(block.LastWord))  								block.Continuation = false;  						}  						break;  					case ']':  						if (blocks.Count == 0) break;  						if (block.Bracket == '[')  							block = blocks.Pop();  						break;  					case ';':  					case ''':  						block.Continuation = false;  						block.ResetOneLineBlock();  						break;  					case ':':  						if (block.LastWord == "case"   						    || line.StartsWith("case "' StringComparison.Ordinal)   						    || line.StartsWith(block.LastWord + ":"' StringComparison.Ordinal))   						{  							block.Continuation = false;  							block.ResetOneLineBlock();  						}  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,The following switch statement is missing a default case: switch (position) {  							case LayerInsertionPosition.Below:  								layers.Insert(i' layer);  								return;  							case LayerInsertionPosition.Above:  								layers.Insert(i + 1' layer);  								return;  							case LayerInsertionPosition.Replace:  								layers[i] = layer;  								return;  						}
Missing Default,ICSharpCode.AvalonEdit.Search,SearchPanel,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchPanel.cs,SearchLayerKeyDown,The following switch statement is missing a default case: switch (e.Key) {  				case Key.Enter:  					e.Handled = true;  					if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift)  						FindPrevious();  					else  						FindNext();  					if (searchTextBox != null) {  						var error = Validation.GetErrors(searchTextBox).FirstOrDefault();  						if (error != null) {  							messageView.Content = Localization.ErrorText + " " + error.ErrorContent;  							messageView.PlacementTarget = searchTextBox;  							messageView.IsOpen = true;  						}  					}  					break;  				case Key.Escape:  					e.Handled = true;  					Close();  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.Search,SearchStrategyFactory,C:\repos\icsharpcode_AvalonEdit\ICSharpCode.AvalonEdit\Search\SearchStrategyFactory.cs,Create,The following switch statement is missing a default case: switch (mode) {  				case SearchMode.Normal:  					searchPattern = Regex.Escape(searchPattern);  					break;  				case SearchMode.Wildcard:  					searchPattern = ConvertWildcardsToRegex(searchPattern);  					break;  			}
